Mon May 22 13:38:34 EDT 2000
Schema Migration...
Password: 
1>  
2> use mgi_release
1> 
2> dump transaction mgi_release with no_log
1> 
2> commit
1> 
2> checkpoint
1> 
2> /* MLC_Marker and MLC_Marker_Edit Changes TR148 */
3> /*
4> 3.2 MLC_Marker and MLC_Marker_edit
5> These tables are identical so the changes must be applited to both tables.
6> 1. Change the type of the tag field from varchar(30) to integer.
7> tag int not null
8> 2. Leave the new table empty. The data migration script will load this table.
9> */
10> 
11> execute sp_unbindefault "MLC_Marker.creation_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_unbindefault "MLC_Marker.modification_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_rename MLC_Marker,MLC_Marker_old
Object name has been changed.
(return status = 0) 
1> 
2> CREATE TABLE MLC_Marker (
3>        _Marker_key          int NOT NULL,
4>        tag                  int NOT NULL,
5>        _Marker_key_2        int NOT NULL,
6>        creation_date        datetime NOT NULL,
7>        modification_date    datetime NOT NULL
8> )
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Marker_tag_key ON MLC_Marker
3> (
4>        _Marker_key,
5>        _Marker_key_2,
6>        tag
7> )
1> 
2> CREATE INDEX index_modification_date ON MLC_Marker
3> (
4>        modification_date
5> )
1> 
2> CREATE INDEX index_Marker_key_2 ON MLC_Marker
3> (
4>        _Marker_key_2
5> )
1> 
2> CREATE INDEX index_Marker_key ON MLC_Marker
3> (
4>        _Marker_key
5> )
1> 
2> exec sp_primarykey MLC_Marker, _Marker_key, _Marker_key_2
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MLC_Marker.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MLC_Marker.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> DROP TABLE MLC_Marker_old
1> 
2> 
3> /* MLC_Marker_edit */
4> 
5> execute sp_unbindefault "MLC_Marker_edit.creation_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_unbindefault "MLC_Marker_edit.modification_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_rename MLC_Marker_edit,MLC_Marker_Old
Object name has been changed.
(return status = 0) 
1> 
2> 
3> CREATE TABLE MLC_Marker_edit (
4>        _Marker_key          int NOT NULL,
5>        tag                  int NOT NULL,
6>        _Marker_key_2        int NOT NULL,
7>        creation_date        datetime NOT NULL,
8>        modification_date    datetime NOT NULL
9> )
1> 
2> CREATE INDEX index_Marker_key ON MLC_Marker_edit
3> (
4>        _Marker_key
5> )
1> 
2> CREATE INDEX index_modification_date ON MLC_Marker_edit
3> (
4>        modification_date
5> )
1> 
2> CREATE INDEX index_Marker_key_2 ON MLC_Marker_edit
3> (
4>        _Marker_key_2
5> )
1> 
2> exec sp_primarykey MLC_Marker_edit, _Marker_key, _Marker_key_2
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MLC_Marker_edit.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MLC_Marker_edit.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> DROP TABLE MLC_Marker_Old
1> 
2> /* 4.12 MRK_EventReason */
3> 
4> CREATE TABLE MRK_EventReason (
5>        _Marker_EventReason_key int NOT NULL,
6>        eventReason          varchar(255) NOT NULL,
7>        creation_date        datetime NOT NULL,
8>        modification_date    datetime NOT NULL
9> ) on mgd_seg_0
1> 
2> CREATE UNIQUE CLUSTERED INDEX _MRK_EventReason_index ON MRK_EventReason
3> (
4>        _Marker_EventReason_key
5> ) on mgd_seg_0
1> 
2> CREATE INDEX index_creation_date ON MRK_EventReason
3> (
4>        creation_date
5> ) on mgd_seg_1
1> 
2> CREATE INDEX index_modification_date ON MRK_EventReason
3> (
4>        modification_date
5> ) on mgd_seg_1
1> 
2> exec sp_primarykey MRK_EventReason, _Marker_EventReason_key
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_EventReason.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_EventReason.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> grant all on MRK_EventReason to progs, tier4, ljm, rmb, djr
1> 
2> grant select on MRK_EventReason to editors
1> 
2> grant select on MRK_EventReason to public
1> 
2> 
3> insert into MRK_EventReason values (1, "to conform w/Human Nomenclature", getDate(), getDate())
(1 row affected)
1> 
2> insert into MRK_EventReason values (2, "per gene family revision", getDate(), getDate())
(1 row affected)
1> 
2> insert into MRK_EventReason values (3, "per personal comm w/Authors(s)", getDate(), getDate())
(1 row affected)
1> 
2> insert into MRK_EventReason values (4, "per personal comm w/Chromosome Committee", getDate(), getDate())
(1 row affected)
1> 
2> insert into MRK_EventReason values (-1, "Not Specified", getDate(), getDate())
(1 row affected)
1> 
2> insert into MRK_EventReason values (-2, "Not Applicable", getDate(), getDate())
(1 row affected)
1> 
2> 
3> /* 4.11 MRK_Event */
4> 
5> CREATE TABLE MRK_Event (
6>        _Marker_Event_key    int NOT NULL,
7>        event                varchar(255) NOT NULL,
8>        creation_date        datetime NOT NULL,
9>        modification_date    datetime NOT NULL
10> ) on mgd_seg_0
1> 
2> CREATE UNIQUE CLUSTERED INDEX _MRK_Event_key_index ON MRK_Event
3> (
4>        _Marker_Event_key
5> ) on mgd_seg_0
1> 
2> CREATE INDEX index_creation_date ON MRK_Event
3> (
4>        creation_date
5> ) on mgd_seg_1
1> 
2> CREATE INDEX index_modification_date ON MRK_Event
3> (
4>        modification_date
5> ) on mgd_seg_1
1> 
2> exec sp_primarykey MRK_Event, _Marker_Event_key
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_Event.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_Event.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> grant all on MRK_Event to progs
1> 
2> grant select on MRK_Event to editors
1> 
2> grant select on MRK_Event to public
1> 
2> insert into MRK_Event values (1, "assigned", getDate(), getDate())
(1 row affected)
1> 
2> insert into  MRK_Event values (2, "withdrawn", getDate(), getDate())
(1 row affected)
1> 
2> insert into MRK_Event values (3, "merged", getDate(), getDate())
(1 row affected)
1> 
2> insert into MRK_Event values (4, "allele of", getDate(), getDate())
(1 row affected)
1> 
2> insert into MRK_Event values (5, "split", getDate(), getDate())
(1 row affected)
1> 
2> insert into MRK_Event values (6, "deleted", getDate(), getDate())
(1 row affected)
1> 
2> insert into MRK_Event values (-1, "Not Specified", getDate(), getDate())
(1 row affected)
1> 
2> insert into MRK_Event values (-2, "Not Applicable", getDate(), getDate())
(1 row affected)
1> 
2> 
3> /* 4.9 MRK_Status */
4> 
5> CREATE TABLE MRK_Status (
6>        _Marker_Status_key   int NOT NULL,
7>        status               varchar(255) NOT NULL,
8>        creation_date        datetime NOT NULL,
9>        modification_date    datetime NOT NULL
10> ) on mgd_seg_0
1> 
2> CREATE UNIQUE CLUSTERED INDEX _Marker_status_index ON MRK_Status
3> (
4>        _Marker_Status_key
5> )
6>        ON mgd_seg_0
1> 
2> CREATE INDEX index_modification_date ON MRK_Status
3> (
4>        modification_date
5> )
6>        ON mgd_seg_1
1> 
2> exec sp_primarykey MRK_Status, _Marker_Status_key
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_Status.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_Status.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> grant all on MRK_Status to progs
1> 
2> grant select on MRK_Status to public
1> 
2> grant select on MRK_Status to public
1> 
2> grant select on MRK_Status to editors
1> 
2> 
3> insert MRK_Status values ( 1, "approved", getDate(), getDate())
(1 row affected)
1> 
2> insert MRK_Status values (2, "withdrawn", getDate(), getDate())
(1 row affected)
1> 
2> insert MRK_Status values (-1, "Not Specified", getDate(), getDate())
(1 row affected)
1> 
2> insert MRK_Status values (-2, "Not Applicable", getDate(), getDate())
(1 row affected)
1> 
2> 
3> 
4> 
5> /* 4.10 MRK_Marker */
6> 
7> execute sp_unbindefault "MRK_Marker.creation_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_unbindefault "MRK_Marker.modification_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_rename MRK_Marker,MRK_Marker_Old
Object name has been changed.
(return status = 0) 
1> 
2> 
3> CREATE TABLE MRK_Marker (
4>        _Marker_key          int NOT NULL,
5>        _Species_key         int NOT NULL,
6>        _Marker_Status_key   int NOT NULL,
7>        _Marker_Type_key     int NOT NULL,
8>        symbol               varchar(25) NOT NULL,
9>        name                 varchar(255) NOT NULL,
10>        chromosome           varchar(8) NOT NULL,
11>        cytogeneticOffset    varchar(20) NULL,
12>        creation_date        datetime NOT NULL,
13>        modification_date    datetime NOT NULL
14> ) on mgd_seg_0
1> 
2> 
3> INSERT INTO MRK_Marker
4> (
5> _Marker_key, 
6> _Species_key, 
7> _Marker_Status_key,
8> _Marker_Type_key, 
9> symbol, 
10> name, 
11> chromosome, 
12> cytogeneticOffset, 
13> creation_date, 
14> modification_date
15> ) 
16> SELECT 
17> _Marker_key, 
18> _Species_key,
19> -1, 
20> _Marker_Type_key, 
21> symbol, 
22> name, 
23> chromosome, 
24> cytogeneticOffset, 
25> creation_date, 
26> modification_date 
27> FROM 
28> MRK_Marker_Old
(40803 rows affected)
1> 
2> 
3> DROP TABLE MRK_Marker_Old
1> 
2> exec sp_primarykey MRK_Marker, _Marker_key
New primary key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MRK_Marker, MRK_Status, _Marker_Status_key
New foreign key added.
(return status = 0) 
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Marker_key ON MRK_Marker
3> (
4>        _Marker_key
5> )
6>        ON mgd_seg_0
1> 
2> CREATE INDEX _Marker_Status_key_index ON MRK_Marker
3> (
4>        _Marker_Status_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX index_modification_date ON MRK_Marker
3> (
4>        modification_date
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX index_chromosome ON MRK_Marker
3> (
4>        chromosome
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX index_Marker_Type_key ON MRK_Marker
3> (
4>        _Marker_Type_key
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX index_symbol ON MRK_Marker
3> (
4>        symbol
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX index_Species_key ON MRK_Marker
3> (
4>        _Species_key
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX index_Species_symbol ON MRK_Marker
3> (
4>        _Species_key,
5>        symbol
6> )
7>        ON mgd_seg_1
1> 
2> exec sp_bindefault current_date_default, 'MRK_Marker.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_Marker.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> grant delete on MRK_Marker to cgw, cml, tier3, dbradt, djr, jblake, tier4, ljm, lmm, neb, plg, progs, rmb, sr
1> 
2> grant update on MRK_Marker to cgw, cml, tier3, dbradt, djr, jblake, tier2, lglass, tier4, ljm, lmm, neb, plg, progs, rmb, sr
1> 
2> grant select on MRK_Marker to public
1> 
2> grant references on MRK_Marker to cgw, cml, tier3, dbradt, djr, jblake, tier4, ljm, lmm, neb, plg, progs, rmb, sr
1> 
2> grant insert on MRK_Marker to cgw, cml, tier3, dbradt, djr, jblake, tier4, ljm, lmm, neb, plg, progs, rmb, sr
1> 
2> 
3> /* 4.13 MRK_History */
4> 
5> execute sp_unbindefault "MRK_History.creation_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_unbindefault "MRK_History.modification_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_rename MRK_History,MRK_History_Old
Object name has been changed.
(return status = 0) 
1> 
2> CREATE TABLE MRK_History (
3>        _Marker_key          int NOT NULL,
4>        _Marker_Event_key    int NOT NULL,
5>        _Marker_EventReason_key int NOT NULL,
6>        _History_key         int NOT NULL,
7>        _Refs_key            int NULL,
8>        sequenceNum          int NOT NULL,
9>        name                 varchar(255) NULL,
10>        event_date           datetime NULL,
11>        creation_date        datetime NOT NULL,
12>        modification_date    datetime NOT NULL
13> ) on mgd_seg_0
1> 
2> INSERT INTO MRK_History (
3> _Marker_key, 
4> _Marker_Event_key,
5> _Marker_EventReason_key,
6> _History_key, 
7> _Refs_key, 
8> sequenceNum,  
9> name, 
10> event_date, 
11> creation_date, 
12> modification_date
13> ) 
14> SELECT 
15> _Marker_key, 
16> -1,
17> -1,
18> _History_key, 
19> _Refs_key, 
20> sequenceNum,  
21> name, 
22> event_date, 
23> creation_date, 
24> modification_date 
25> FROM 
26> MRK_History_Old
(37479 rows affected)
1> 
2> DROP TABLE MRK_History_Old
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_sequenceNum_Marker_key ON MRK_History
3> (
4>        sequenceNum,
5>        _Marker_key,
6>        _History_key
7> )
8>        ON mgd_seg_0
1> 
2> CREATE INDEX _Marker_Event_key_index ON MRK_History
3> (
4>        _Marker_Event_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX _Marker_EventReason_key_index ON MRK_History
3> (
4>        _Marker_EventReason_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX index_Refs_key ON MRK_History
3> (
4>        _Refs_key
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX index_modification_date ON MRK_History
3> (
4>        modification_date
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX index_Marker_key ON MRK_History
3> (
4>        _Marker_key
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX index_History_key ON MRK_History
3> (
4>        _History_key
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX MRK_EventReason_key_index ON MRK_History
3> (
4>        _Marker_EventReason_key
5> ) on mgd_seg_1
1> 
2> exec sp_primarykey MRK_History, _Marker_key, sequenceNum
New primary key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MRK_History, MRK_EventReason, _Marker_EventReason_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MRK_History, MRK_Event, _Marker_Event_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MRK_History, MRK_Marker, _History_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MRK_History, MRK_Marker, _Marker_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MRK_History, BIB_Refs, _Refs_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_History.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_History.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> /* grant all to tier4, ljm, djr, rmb, tier4 - grant all to group progs - select to public */
3> /* no one else needs permission on this table. */
4> 
5> 
6> grant delete on MRK_History to djr, tier4, ljm, rmb, progs, tier4 
1> 
2> grant update on MRK_History to djr, tier4, ljm, rmb, progs, tier4
1> 
2> grant select on MRK_History to public
1> 
2> grant references on MRK_History to djr, tier4, ljm, rmb, progs, tier4 
1> 
2> grant insert on MRK_History to djr, tier4, ljm, rmb, progs, tier4 
1> 
2> /* From CRS_tr1291 */
3> 
4> revoke  all on CRS_Cross from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke  all on CRS_Progeny from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke  all on CRS_References from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke  all on CRS_Typings from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke  all on CRS_Matrix from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke  all on CRS_Cross_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> /* From GXD_tr12921 */
3> 
4> revoke all on GXD_AntibodyType from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_AntibodyMarker from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Structure from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_StructureName from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_StructureClosure from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_TheilerStage from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_ProbePrep from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_ProbeSense from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Index from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Label from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Index_Stages from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_LabelCoverage from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_VisualizationMethod from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_GelControl from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_AntibodyPrep from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_GelLane from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Secondary from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Assay from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_AssayType from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_AssayNote from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Specimen from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_GelRNAType from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_GelLaneStructure from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_GelRow from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_GelBand from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Strength from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_GelUnits from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_EmbeddingMethod from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_FixationMethod from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_InSituResult from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_ISResultStructure from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_InSituResultImage from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Pattern from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Expression from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Genotype from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_AllelePair from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Antigen from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Antibody from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_AntibodyAlias from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_AntibodyClass from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Antigen_Acc_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Antibody_Acc_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Assay_Acc_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Antigen_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Antibody_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_AntibodyRef_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_AntibodyAntigen_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_AntibodyMarker_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_AntibodyAlias_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_AntibodyAliasRef_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Assay_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_AntibodyPrep_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_ProbePrep_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Genotype_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_AllelePair_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Antibody_Summary_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Specimen_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Antigen_Summary_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_InSituResult_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Assay_Summary_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_ISResultImage_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_GelLane_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_GelRow_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_GelBand_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_GelLaneStructure_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_ISResultStructure_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_Index_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on GXD_GelLane from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> /* IMG_tr1291 */
3> 
4> revoke all on IMG_ImageNote from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on IMG_Image from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on IMG_ImagePane from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on IMG_FieldType from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on IMG_Image_Summary_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on IMG_Image_Acc_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on IMG_Image_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on IMG_ImagePane_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on IMG_ImagePaneRef_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> /* MLD_tr1291 */
3> 
4> revoke all on MLD_Expts from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Assay_Types from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Contig from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_ContigProbe from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Distance from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Expt_Marker from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Expt_Notes from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_FISH from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_FISH_Region from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Hit from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Hybrid from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_InSitu from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_ISRegion from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Marker from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Matrix from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_MC2point from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_MCDataList from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Notes from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_PhysMap from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_RI from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_RI2Point from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_RIData from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Statistics from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Concordance from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Summary_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Acc_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Marker_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Expt_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Expt_Marker_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_FISH_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Hybrid_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Concordance_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_InSitu_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Matrix_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_MC2point_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Statistics_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Distance_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_RI_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_RIData_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_RI2Point_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> revoke all on MLD_Hit_View from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> /* RI_tr1291 */
3> 
4> revoke all on RI_RISet from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on RI_Summary from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on RI_Summary_Expt_Ref from tier4, ljm, djr, rmb
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> /* ------------------- TR 1360 Go Additions ------------------------- */
3> 
4> CREATE TABLE GO_Evidence (
5>        _Evidence_key        int NOT NULL,
6>        abbreviation         char(3) NOT NULL,
7>        evidence             varchar(255) NOT NULL,
8>        creation_date        datetime NOT NULL,
9>        modification_date    datetime NOT NULL
10> ) on mgd_seg_0
1> 
2> insert into GO_Evidence values (1, "IMP", "inferred from mutant phenotype", getDate(), getDate())
(1 row affected)
1> 
2> insert into GO_Evidence values (2, "IGI", "inferred from genetic interaction", getDate(), getDate())
(1 row affected)
1> 
2> insert into GO_Evidence values (3, "IPI", "inferred from physical interaction", getDate(), getDate())
(1 row affected)
1> 
2> insert into GO_Evidence values (4, "ISS", "inferred from sequence or structural similarity", getDate(), getDate())
(1 row affected)
1> 
2> insert into GO_Evidence values (5, "IDA", "inferred from direct assay", getDate(), getDate())
(1 row affected)
1> 
2> insert into GO_Evidence values (6, "IEP", "inferred from expression pattern", getDate(), getDate())
(1 row affected)
1> 
2> insert into GO_Evidence values (7, "SBA", "stated by author", getDate(), getDate())
(1 row affected)
1> 
2> insert into GO_Evidence values (8, "NA", "not available", getDate(), getDate())
(1 row affected)
1> 
2> insert into GO_Evidence values (9, "EA", "electronic annotation", getDate(), getDate())
(1 row affected)
1> 
2> CREATE UNIQUE CLUSTERED INDEX _Evidence_key_index ON GO_Evidence
3> (
4>        _Evidence_key
5> )
6>        ON mgd_seg_0
1> 
2> CREATE INDEX modification_date_index ON GO_Evidence
3> (
4>        modification_date
5> )
6>        ON mgd_seg_1
1> 
2> exec sp_primarykey GO_Evidence, _Evidence_key
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'GO_Evidence.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'GO_Evidence.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> grant all on GO_Evidence to progs
1> 
2> grant select on GO_Evidence to public
1> 
2> /* GO_Ontology */
3> 
4> CREATE TABLE GO_Ontology (
5>        _Ontology_key        int NOT NULL,
6>        abbreviation         char(1) NOT NULL,
7>        ontologyName         varchar(255) NOT NULL,
8>        creation_date        datetime NOT NULL,
9>        modification_date    datetime NOT NULL
10> ) on mgd_seg_0
1> 
2> insert into GO_Ontology values (1, "F", "Molecular Function", getDate(), getDate())
(1 row affected)
1> 
2> insert into GO_Ontology values (2, "P", "Biological Process", getDate(), getDate())
(1 row affected)
1> 
2> insert into GO_Ontology values (3, "C", "Cellular Component", getDate(), getDate())
(1 row affected)
1> 
2> exec sp_primarykey GO_Ontology, _Ontology_key
New primary key added.
(return status = 0) 
1> 
2> CREATE UNIQUE CLUSTERED INDEX _Ontology_key_index ON GO_Ontology
3> (
4>        _Ontology_key
5> )
6>        ON mgd_seg_0
1> 
2> CREATE INDEX modification_date_index ON GO_Ontology
3> (
4>        modification_date
5> )
6>        ON mgd_seg_1
1> 
2> exec sp_bindefault current_date_default, 'GO_Ontology.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'GO_Ontology.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> grant all on GO_Ontology to progs
1> 
2> grant select on GO_Ontology to public
1> 
2> /* GO_DataEvidence */
3> 
4> CREATE TABLE GO_DataEvidence (
5>        _MarkerGO_key        int NOT NULL,
6>        _Evidence_key        int NOT NULL,
7>        _Refs_key            int NOT NULL,
8>        creation_date        datetime NOT NULL,
9>        modifcation_date     datetime NOT NULL
10> ) on mgd_seg_0
1> 
2> exec sp_primarykey GO_DataEvidence, _MarkerGO_key, _Evidence_key
New primary key added.
(return status = 0) 
1> 
2> CREATE UNIQUE CLUSTERED INDEX _MarkerGO_key_Index ON GO_DataEvidence
3> (
4>        _MarkerGO_key,
5>        _Evidence_key
6> )
7>        ON mgd_seg_0
1> 
2> CREATE INDEX _Refs_key_index ON GO_DataEvidence
3> (
4>        _Refs_key
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX modification_date_index ON GO_DataEvidence
3> (
4>        modifcation_date
5> )
6>        ON mgd_seg_1
1> 
2> exec sp_bindefault current_date_default, 'GO_DataEvidence.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'GO_DataEvidence.modifcation_date'
Default bound to column.
(return status = 0) 
1> 
2> grant all on GO_DataEvidence to progs
1> 
2> grant select on GO_DataEvidence to public
1> 
2> 
3> /* GO_MarkerGO */
4> 
5> CREATE TABLE GO_MarkerGO (
6>        _MarkerGO_key        int NOT NULL,
7>        _Marker_key          int NOT NULL,
8>        _Term_key            int NOT NULL,
9>        creation_date        datetime NOT NULL,
10>        modification_date    datetime NOT NULL
11> ) on mgd_seg_0
1> 
2> exec sp_primarykey GO_MarkerGO, _MarkerGO_key
New primary key added.
(return status = 0) 
1> 
2> exec sp_foreignkey GO_MarkerGO, MRK_Marker, _Marker_key
New foreign key added.
(return status = 0) 
1> 
2> 
3> CREATE UNIQUE CLUSTERED INDEX _MarkerGO_key_Index ON GO_MarkerGO
4> (
5>        _MarkerGO_key
6> )
7>        ON mgd_seg_0
1> 
2> CREATE INDEX _Term_key_index ON GO_MarkerGO
3> (
4>        _Term_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX _Marker_key_index ON GO_MarkerGO
3> (
4>        _Marker_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX modification_date_index ON GO_MarkerGO
3> (
4>        modification_date
5> ) on mgd_seg_1
1> 
2> exec sp_bindefault current_date_default, 'GO_MarkerGO.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'GO_MarkerGO.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> grant all on GO_MarkerGO to progs
1> 
2> grant select on GO_MarkerGO to public
1> 
2> /* GO_Term */
3> 
4> CREATE TABLE GO_Term (
5>        _Term_key            int NOT NULL,
6>        _Ontology_key        int NOT NULL,
7>        goTerm               varchar(255) NOT NULL,
8>        creation_date        datetime NOT NULL,
9>        modification_date    datetime NOT NULL
10> ) on mgd_seg_0
1> 
2> exec sp_primarykey GO_Term, _Term_key
New primary key added.
(return status = 0) 
1> 
2> CREATE UNIQUE CLUSTERED INDEX _Go_key_index ON GO_Term
3> (
4>        _Term_key
5> )
6>        ON mgd_seg_0
1> 
2> CREATE INDEX _Ontology_key_index ON GO_Term
3> (
4>        _Ontology_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX modification_date_index ON GO_Term
3> (
4>        modification_date
5> )
6>        ON mgd_seg_1
1> 
2> exec sp_bindefault current_date_default, 'GO_Term.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'GO_Term.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> grant all on GO_Term to progs
1> 
2> grant select on GO_Term to public
1> 
2> exec sp_foreignkey GO_DataEvidence, BIB_Refs, _Refs_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey GO_MarkerGO, GO_Term, _Term_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey GO_Term, GO_Ontology, _Ontology_key
New foreign key added.
(return status = 0) 
1> 
2> /* -------------------------- tr 1177 Alleles -------------------------------------------*/
3> 
4> /* ALL_Inheritance */
5> 
6> CREATE TABLE ALL_Inheritance_Mode (
7>        _Mode_key            int NOT NULL,
8>        mode                 varchar(255) NOT NULL,
9>        creation_date        datetime NOT NULL,
10>        modification_date    datetime NOT NULL
11> )
12> ON mgd_seg_0
1> 
2> CREATE UNIQUE CLUSTERED INDEX _mode_key_index ON ALL_Inheritance_Mode
3> (
4>        _Mode_key
5> )
6>        ON mgd_seg_0
1> 
2> CREATE INDEX modification_date_index ON ALL_Inheritance_Mode
3> (
4>        modification_date
5> )
6>        ON mgd_seg_1
1> 
2> exec sp_primarykey ALL_Inheritance_Mode, _Mode_key
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Inheritance_Mode.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Inheritance_Mode.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> 
3> /* ALL_Type */
4> 
5> CREATE TABLE ALL_Type (
6>        _Allele_Type_key     int NOT NULL,
7>        alleleType           varchar(255) NOT NULL,
8>        creation_date        datetime NOT NULL,
9>        modification_date    datetime NOT NULL
10> )
11> ON mgd_seg_0
1> 
2> CREATE UNIQUE CLUSTERED INDEX _Allele_Type_key_index ON ALL_Type
3> (
4>        _Allele_Type_key
5> )
6>        ON mgd_seg_0
1> 
2> CREATE INDEX modification_date_index ON ALL_Type
3> (
4>        modification_date
5> )
6>        ON mgd_seg_1
1> 
2> exec sp_primarykey ALL_Type, _Allele_Type_key
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Type.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Type.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> 
3> /* ALL_Allele - replaces MRK_Allele */
4> 
5> execute sp_unbindefault "MRK_Allele.creation_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_unbindefault "MRK_Allele.modification_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_rename MRK_Allele,MRK_Allele_Old
Object name has been changed.
(return status = 0) 
1> 
2> CREATE TABLE ALL_Allele (
3>        _Allele_key          int NOT NULL,
4>        _Refs_key            int NULL,
5>        _Molecular_Refs_key  int NULL,
6>        _Marker_key          int NOT NULL,
7>        _Strain_key          int NOT NULL,
8>        _Mode_key            int NOT NULL,
9>        _Allele_Type_key     int NOT NULL,
10>        reviewed             bit NOT NULL,
11>        userID               varchar(30) NOT NULL,
12>        symbol               varchar(50) NOT NULL,
13>        name                 varchar(255) NOT NULL,
14>        creation_date        datetime NOT NULL,
15>        modification_date    datetime NOT NULL
16> )
17> ON mgd_seg_0
1> 
2> INSERT INTO All_Allele (
3>        _Allele_key, 
4>        _Refs_key,
5>        _Molecular_Refs_key,
6>        _Marker_key,
7>        _Strain_key,
8>        _Mode_key,
9>        _Allele_Type_key,
10>        reviewed,
11>        userID,
12>        symbol,
13>        name,
14>        creation_date,
15>        modification_date
16> ) 
17> SELECT 
18> _Allele_key, 
19> NULL,          /* Refs_key */
20> NULL,          /* Molecular_Refs_key */
21> _Marker_key, 
22> -1,            /* Strain_key */
23> -1,            /* Mode_key unspecified */
24> -1,            /* Allele_Type_key unspecified */ 
25> 0,             /* reviewed */
26> "cml",         /* user id */
27> symbol,
28> name,
29> creation_date, 
30> modification_date 
31> FROM 
32> MRK_Allele_Old
(2169 rows affected)
1> 
2> DROP TABLE MRK_Allele_Old
1> 
2> 
3> CREATE UNIQUE CLUSTERED INDEX index_Allele_key ON ALL_Allele
4> (
5>        _Allele_key
6> )
7>        ON mgd_seg_0
1> 
2> CREATE INDEX _Allele_Type_key_index ON ALL_Allele
3> (
4>        _Allele_Type_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX _Strain_key_index ON ALL_Allele
3> (
4>        _Strain_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX _Mode_key_index ON ALL_Allele
3> (
4>        _Mode_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX _Molecular_Refs_key_index ON ALL_Allele
3> (
4>        _Molecular_Refs_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX _Refs_key_index ON ALL_Allele
3> (
4>        _Refs_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX index_name ON ALL_Allele
3> (
4>        name
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX index_modification_date ON ALL_Allele
3> (
4>        modification_date
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX index_Marker_key ON ALL_Allele
3> (
4>        _Marker_key
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX index_symbol ON ALL_Allele
3> (
4>        symbol
5> )
6>        ON mgd_seg_1
1> 
2> 
3> exec sp_primarykey ALL_Allele, _Allele_key
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Allele.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Allele.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> /* ALL_Molecular_Mutation */
3> 
4> CREATE TABLE ALL_Molecular_Mutation (
5>        _Mutation_key        int NOT NULL,
6>        mutation             varchar(255) NOT NULL,
7>        creation_date        datetime NOT NULL,
8>        modification_date    datetime NOT NULL
9> )
10> ON mgd_seg_0
1> 
2> CREATE UNIQUE CLUSTERED INDEX _Mutation_key_index ON ALL_Molecular_Mutation
3> (
4>        _Mutation_key
5> )
6>        ON mgd_seg_0
1> 
2> CREATE INDEX modification_date_index ON ALL_Molecular_Mutation
3> (
4>        modification_date
5> )
6>        ON mgd_seg_1
1> 
2> exec sp_primarykey ALL_Molecular_Mutation, _Mutation_key
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Molecular_Mutation.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Molecular_Mutation.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> 
3> /* ALL_Allele_Mutation */
4> 
5> CREATE TABLE ALL_Allele_Mutation (
6>        _Allele_key          int NOT NULL,
7>        _Mutation_key        int NOT NULL,
8>        creation_date        datetime NOT NULL,
9>        modification_date    datetime NOT NULL
10> )
11> ON mgd_seg_0
1> 
2> CREATE UNIQUE CLUSTERED INDEX _Allele_Mutation_key_index ON ALL_Allele_Mutation
3> (
4>        _Allele_key,
5>        _Mutation_key
6> )
7>        ON mgd_seg_0
1> 
2> CREATE INDEX _Allele_key_index ON ALL_Allele_Mutation
3> (
4>        _Allele_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX _Mutation_key_index ON ALL_Allele_Mutation
3> (
4>        _Mutation_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX modification_date_index ON ALL_Allele_Mutation
3> (
4>        modification_date
5> )
6>        ON mgd_seg_1
1> 
2> 
3> exec sp_primarykey ALL_Allele_Mutation, _Allele_key, _Mutation_key
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Allele_Mutation.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Allele_Mutation.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> /* ALL_Molecular_Note */
3> 
4> CREATE TABLE ALL_Molecular_Note (
5>        _Allele_key          int NOT NULL,
6>        sequenceNum          int NOT NULL,
7>        note                 varchar(255) NOT NULL,
8>        creation_date        datetime NOT NULL,
9>        modification_date    datetime NOT NULL
10> )
11> ON mgd_seg_0
1> 
2> CREATE UNIQUE CLUSTERED INDEX _Allele_sequence_key_index ON ALL_Molecular_Note
3> (
4>        _Allele_key,
5>        sequenceNum
6> )
7>        ON mgd_seg_0
1> 
2> CREATE INDEX _Allele_key_index ON ALL_Molecular_Note
3> (
4>        _Allele_key
5> ) on mgd_seg_1
1> 
2> 
3> CREATE INDEX modification_date_key ON ALL_Molecular_Note
4> (
5>        modification_date
6> )
7>        ON mgd_seg_1
1> 
2> exec sp_primarykey ALL_Molecular_Note, _Allele_key, sequenceNum
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Molecular_Note.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Molecular_Note.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> /* ALL_Note */
3> 
4> CREATE TABLE ALL_Note (
5>        _Allele_key          int NOT NULL,
6>        sequenceNum          int NOT NULL,
7>        note            varchar(255) NOT NULL,
8>        creation_date        datetime NOT NULL,
9>        modification_date    datetime NOT NULL
10> )
11> ON mgd_seg_0
1> 
2> CREATE UNIQUE CLUSTERED INDEX _allele_Sequence_key_index ON ALL_Note
3> (
4>        _Allele_key,
5>        sequenceNum
6> )
7>        ON mgd_seg_0
1> 
2> CREATE INDEX _Allele_key_index ON ALL_Note
3> (
4>        _Allele_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX modification_date_index ON ALL_Note
3> (
4>        modification_date
5> )
6>        ON mgd_seg_1
1> 
2> exec sp_primarykey ALL_Note, _Allele_key, sequenceNum
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Note.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Note.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> /* ALL_Synonym */
3> 
4> CREATE TABLE ALL_Synonym (
5>        _Synonym_key         int NOT NULL,
6>        _Allele_key          int NOT NULL,
7>        _Refs_key            int NOT NULL,
8>        synonym              varchar(255) NOT NULL,       
9>        creation_date        datetime NOT NULL,
10>        modification_date    datetime NOT NULL
11> )
12> ON mgd_seg_0
1> 
2> exec sp_primarykey ALL_Synonym, _Synonym_key
New primary key added.
(return status = 0) 
1> 
2> CREATE UNIQUE CLUSTERED INDEX _Synonym_key_index ON ALL_Synonym
3> (
4>        _Synonym_key
5> )
6>        ON mgd_seg_0
1> 
2> CREATE INDEX _Allele_key_index ON ALL_Synonym
3> (
4>        _Allele_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX modification_date_index ON ALL_Synonym
3> (
4>        modification_date
5> )
6>        ON mgd_seg_1
1> 
2> exec sp_foreignkey ALL_Allele, BIB_Refs, _Refs_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey ALL_Allele, BIB_Refs, _Molecular_Refs_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey ALL_Allele, ALL_Inheritance_Mode, _Mode_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey ALL_Allele, PRB_Strain, _Strain_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey ALL_Allele, ALL_Type, _Allele_Type_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey ALL_Allele, MRK_Marker, _Marker_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MLD_Expt_Marker, ALL_Allele, _Allele_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey GXD_AllelePair, ALL_Allele, _Allele_key_1
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey GXD_AllelePair, ALL_Allele, _Allele_key_2
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey ALL_Allele_Mutation, ALL_Molecular_Mutation, _Mutation_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey ALL_Allele_Mutation, ALL_Allele, _Allele_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey ALL_Molecular_Note, ALL_Allele, _Allele_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey ALL_Note, ALL_Allele, _Allele_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey ALL_Synonym, ALL_Allele, _Allele_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Synonym.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'ALL_Synonym.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> /* data loads */
3> 
4> /* MGI type  -- requires some extra logic */
5> 
6> insert into ACC_MGIType values (11, "Allele", "ALL_Allele", "_Allele_key", getDate(), getDate(), getDate())
(1 row affected)
1> 
2> /* Allele Types */
3> 
4> insert into ALL_Type values (-2, "Not Applicable", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (-1, "Not Specified", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (1, "Spontaneous", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (2, "Transgene induced", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (3, "Transgene induced (gene targeted)", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (4, "Transgene induced (gene trapped)", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (5, "Viral induced", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (6, "Transposon induced", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (7, "Retrotransposon induced", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (8, "Radiation induced", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (9, "Chemical induced", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (10, "Chemical induced (ENU)", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (11, "Chemical induced (chlorambucil)", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (12, "Chemical induced (EMS)", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (13, "Other (see notes)", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Type values (14, "Not Curated", getDate(), getDate())
(1 row affected)
1> 
2> /* Inheritance modes */
3> 
4> insert into ALL_Inheritance_Mode values (-2, "Not Applicable", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Inheritance_Mode values (-1, "Not Specified", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Inheritance_Mode values (1, "Dominant", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Inheritance_Mode values (2, "Codominant", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Inheritance_Mode values (3, "Semidominant", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Inheritance_Mode values (4, "Recessive", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Inheritance_Mode values (5, "Other (see notes)", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Inheritance_Mode values (6, "Not Curated", getDate(), getDate())
(1 row affected)
1> 
2> /* Molecular mutations */
3> 
4> insert into ALL_Molecular_Mutation values (-2, "Not Applicable", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Molecular_Mutation values (-1, "Not Specified", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Molecular_Mutation values (1, "Deletion", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Molecular_Mutation values (2, "Inversion", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Molecular_Mutation values (3, "Insertion", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Molecular_Mutation values (4, "Nucleotide repeat expansion", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Molecular_Mutation values (5, "Translocation", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Molecular_Mutation values (6, "Nucleotide substitution", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Molecular_Mutation values (7, "Point mutation (transversion)", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Molecular_Mutation values (8, "Point mutation (transition)", getDate(), getDate())
(1 row affected)
1> 
2> insert into ALL_Molecular_Mutation values (9, "Other (see notes)", getDate(), getDate())
(1 row affected)
1> 
2> /* permissions */
3> 
4> /*
5>  1. For all CV tables (ALL_Type, ALL_Inheritance_Mode, ALL_Molecular_Mutation),
6> grant all to cml, progs; grant select to public.
7> 
8> 2. For all other tables (ALL_Allele, ALL_Allele_Mutation, ALL_Molecular_Note,
9> ALL_Note, ALL_Synonym), grant all to editors, progs.
10> */
11> 
12> grant all on ALL_Type to cml, progs
1> 
2> grant select on ALL_Type to public
1> 
2> grant all on ALL_Inheritance_Mode to cml, progs
1> 
2> grant select on ALL_Inheritance_Mode to public
1> 
2> grant all on ALL_Molecular_Mutation to cml, progs
1> 
2> grant select on ALL_Molecular_Mutation to public
1> 
2> grant all on ALL_Allele to editors, progs
1> 
2> grant all on ALL_Allele_Mutation to editors, progs
1> 
2> grant all on ALL_Molecular_Note to editors, progs
1> 
2> grant all on ALL_Note to editors, progs
1> 
2> grant all on ALL_Synonym to editors, progs
1> 
2> grant select on ALL_Type to public
1> 
2> grant select on ALL_Inheritance_Mode to public
1> 
2> grant select on ALL_Molecular_Mutation to public
1> 
2> grant select on ALL_Allele to public
1> 
2> grant select on ALL_Allele_Mutation to public
1> 
2> grant select on ALL_Molecular_Note to public
1> 
2> grant select on ALL_Note to public
1> 
2> grant select on ALL_Synonym to public
1> 
2> /* MLC permissions TR148 sec 3.0 */
3> /* all MLC tables: cgw, cml, tier3, dbradt, dph, jblake, lmm, rmb, sr, wjb */
4> 
5> /* MLC_Text_edit */
6> 
7> revoke all on MLC_Text_edit from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLC_Text_edit to progs
1> 
2> grant select on MLC_Text_edit to public
1> 
2> grant all on MLC_Text_edit to tier3, dbradt, sr, cml, rmb, jblake, wjb, lmm, cgw, dph
1> 
2> /* MLC_Reference_edit */
3> 
4> revoke all on MLC_Reference_edit from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLC_Reference_edit to progs
1> 
2> grant all on MLC_Reference_edit to tier3, dbradt, sr, cml, rmb, jblake, wjb, lmm, cgw, dph
1> 
2> grant select on MLC_Reference_edit to public
1> 
2> /* MLC_Lock_edit */
3> 
4> revoke all on MLC_Lock_edit from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLC_Lock_edit to progs
1> 
2> grant select on MLC_Lock_edit to public
1> 
2> grant all on MLC_Lock_edit to  tier3, dbradt, sr, cml, rmb, jblake, wjb, lmm, cgw, dph
1> 
2> /* MLC_Marker_edit */
3> 
4> revoke all on MLC_Marker_edit from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLC_Marker_edit to progs
1> 
2> grant select on MLC_Marker_edit to public
1> 
2> grant all on MLC_Marker_edit to  tier3, dbradt, sr, cml, rmb, jblake, wjb, lmm, cgw, dph
1> 
2> /* MLC_Text */
3> 
4> revoke all on MLC_Text from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLC_Text to progs
1> 
2> grant all on MLC_Text to tier3, dbradt, sr, cml, rmb, jblake, wjb, lmm, cgw, dph
1> 
2> grant select on MLC_Text to public
1> 
2> /* MLC_Reference */
3> 
4> revoke all on MLC_Reference from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLC_Reference to progs
1> 
2> grant all on MLC_Reference to tier3, dbradt, sr, cml, rmb, jblake, wjb, lmm, cgw, dph
1> 
2> grant select on MLC_Reference to public
1> 
2> /* MLC_Marker */
3> 
4> revoke all on MLC_Marker from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLC_Marker to progs
1> 
2> grant all on MLC_Marker to tier3, dbradt, sr, cml, rmb, jblake, wjb, lmm, cgw, dph
1> 
2> grant select on MLC_Marker to public
1> 
2> /* add tr 1404 changes */
3> 
4> CREATE RULE check_labelType
5> 	AS @col IN ('S', 'N', 'Y')
1> 
2> CREATE TABLE MRK_Label (
3>        _Marker_key          int NOT NULL,
4>        _Marker_Status_key   int NOT NULL,
5>        _Species_key         int NOT NULL,
6>        label                varchar(255) NOT NULL,
7>        labelType            char(1) NOT NULL,
8>        creation_date        datetime NOT NULL,
9>        modification_date    datetime NOT NULL
10> )
11> ON mgd_seg_0
12> 
13> CREATE UNIQUE CLUSTERED INDEX primary_key_index ON MRK_Label
14> (
15>        _Marker_key, _Marker_Status_key, labelType, label
16> )
17>        ON mgd_seg_0
1> 
2> CREATE INDEX _Marker_key_index ON MRK_Label
3> (
4>        _Marker_key
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX _Label_key_index ON MRK_Label
3> (
4>        label
5> )
6>        ON mgd_seg_1
1> 
2> CREATE INDEX  _Species_key_index ON MRK_Label
3> (
4>        _Species_key
5> ) on mgd_seg_1
1> 
2> 
3> CREATE INDEX _Marker_status_key_index ON MRK_Label
4> (
5>        _Marker_Status_key
6> )
7>        on mgd_seg_1
1> 
2> CREATE INDEX modification_index_date ON MRK_Label
3> (
4>        modification_date
5> )
6>        ON mgd_seg_1
1> 
2> Drop table MRK_Name
1> 
2> Drop table MRK_Symbol
1> 
2> exec sp_bindrule check_labelType, 'MRK_Label.labelType'
Rule bound to table column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_Label.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_Label.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> grant all on MRK_Label to progs
1> 
2> grant select on MRK_Label to public
1> 
2> grant select on MRK_Label to editors
1> 
2> sp_primarykey MRK_Label, _Marker_key, labelType, label
New primary key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MRK_Label, MRK_Status, _Marker_Status_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MRK_Label, MRK_Marker, _Marker_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MRK_Label, MRK_Species,_Species_key
New foreign key added.
(return status = 0) 
1> 
2> /* MLC Foreign keys: same as on production */
3> 
4> exec sp_foreignkey MLC_Text, MRK_Marker,
5>        _Marker_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MLC_Marker, MRK_Marker,
3>        _Marker_key_2
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MLC_Marker, MLC_Text,
3>        _Marker_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MLC_Marker_edit, MLC_Text_edit,
3>        _Marker_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MLC_Marker_edit, MRK_Marker,
3>        _Marker_key_2
New foreign key added.
(return status = 0) 
1> 
2> commit
1> 
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> dump transaction nomen with no_log
1> 
2> commit
1> 
2> checkpoint
1> 
2> /* Drop MRK_Event */
3> 
4> DROP TABLE MRK_Event
1> 
2> /* Changes to MRK_Nomen */
3> 
4> execute sp_unbindefault "MRK_Nomen.creation_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_unbindefault "MRK_Nomen.modification_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_rename MRK_Nomen,MRK_Nomen_Old
Object name has been changed.
(return status = 0) 
1> 
2> CREATE TABLE MRK_Nomen (
3>        _Nomen_key           int NOT NULL,
4>        _Marker_Type_key     int NOT NULL,
5>        _Marker_Status_key   int NOT NULL,
6>        _Marker_Event_key    int NOT NULL,
7>        _Suid_key            int NOT NULL,
8>        _Suid_broadcast_key  int NOT NULL,
9>        _Marker_EventReason_key int NOT NULL,
10>        mgiAccID             varchar(30) NULL,
11>        symbol               varchar(25) NOT NULL,
12>        name                 varchar(255) NOT NULL,
13>        chromosome           varchar(8) NOT NULL,
14>        humanSymbol          varchar(25) NULL,
15>        statusNote           varchar(255) NULL,
16>        broadcast_date       datetime NULL,
17>        creation_date        datetime NOT NULL,
18>        modification_date    datetime NOT NULL
19> )
1> 
2> INSERT INTO MRK_Nomen 
3> (
4>        _Nomen_key,
5>        _Marker_Type_key,
6>        _Marker_Status_key,
7>        _Marker_Event_key,
8>        _Suid_key,
9>        _Suid_broadcast_key,
10>        _Marker_EventReason_key,
11>        mgiAccID,
12>        symbol,
13>        name,
14>        chromosome,
15>        humanSymbol,
16>        statusNote,
17>        broadcast_date,
18>        creation_date,
19>        modification_date
20> ) SELECT 
21>       _Nomen_key,
22>       _Marker_Type_key, 
23>       _Marker_Status_key, 
24>       _Marker_Event_key, 
25>       _Suid_key, 
26>       -1,
27>       -1,
28>        NULL,
29>        approvedSymbol, 
30>        approvedName, 
31>        chromosome, 
32>        humanSymbol, 
33>        statusNote, 
34>        broadcast_date, 
35>        creation_date, 
36>        modification_date 
37> FROM 
38> MRK_Nomen_Old
(20944 rows affected)
1> 
2> DROP TABLE MRK_Nomen_Old
1> 
2> CREATE UNIQUE CLUSTERED INDEX _Nomen_key_index ON MRK_Nomen
3> (
4>        _Nomen_key
5> )
6>  
1> 
2> CREATE INDEX _Marker_Event_index ON MRK_Nomen
3> (
4>        _Marker_Event_key
5> )
1> 
2> CREATE INDEX index_modification_date ON MRK_Nomen
3> (
4>        modification_date
5> )
6>  
1> 
2> CREATE INDEX _Marker_EventReason_key_index ON MRK_Nomen
3> (
4>        _Marker_EventReason_key
5> )
1> 
2> CREATE INDEX _Marker_Status_key_Index ON MRK_Nomen
3> (
4>        _Marker_Status_key
5> )
6>  
1> 
2> CREATE INDEX _Suid_key_index ON MRK_Nomen
3> (
4>        _Suid_key
5> )
6>  
1> 
2> CREATE INDEX _Suid_Broadcast_key_index ON MRK_Nomen
3> (
4>        _Suid_broadcast_key
5> )
1> 
2> CREATE INDEX _Marker_type_Index ON MRK_Nomen
3> (
4>        _Marker_Type_key
5> )
6>  
1> 
2> CREATE INDEX index_symbol ON MRK_Nomen
3> (
4>        symbol
5> )
6>  
1> 
2> CREATE INDEX index_chromosome ON MRK_Nomen
3> (
4>        chromosome
5> )
6>  
1> 
2> CREATE INDEX index_broadcast_date ON MRK_Nomen
3> (
4>        broadcast_date
5> )
6>  
1> 
2> exec sp_primarykey MRK_Nomen,
3>        _Nomen_key
New primary key added.
(return status = 0) 
1> 
2> exec sp_foreignkey MRK_Nomen, MRK_Status,
3>        _Marker_Status_key
New foreign key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_Nomen.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_Nomen.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> revoke all on MRK_Nomen from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MRK_Nomen from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MRK_Nomen from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MRK_Nomen to tier2, lglass, lmm, cgw, tier3, dbradt, dph, sr, tier4, ljm, rmb, djr
1> 
2> grant select on MRK_Nomen to editors
1>  
2> grant select on MRK_Nomen to public
1> 
2> grant all on MRK_Nomen to progs
1> 
2> 
3> /* MRK_Nomen_Other */
4> 
5> execute sp_unbindefault "MRK_Nomen_Other.creation_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_unbindefault "MRK_Nomen_Other.modification_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_rename MRK_Nomen_Other,MRK_Nomen_Other_Old
Object name has been changed.
(return status = 0) 
1> 
2> CREATE TABLE MRK_Nomen_Other (
3>        _Other_key           int NOT NULL,
4>        _Nomen_key           int NOT NULL,
5>        _Refs_key            int NULL,
6>        name                 varchar(200) NOT NULL,
7>        isAuthor             bit NOT NULL,
8>        creation_date        datetime NOT NULL,
9>        modification_date    datetime NOT NULL
10> )
1> 
2> INSERT INTO MRK_Nomen_Other
3> (
4>        _Other_key,
5>        _Nomen_key,
6>        _Refs_key,
7>        name,
8>        isAuthor,
9>        creation_date,
10>        modification_date
11> ) SELECT 
12>        _Other_key,
13>        _Nomen_key,
14>        NULL,
15>        name,
16>        isAuthor,
17>        creation_date,
18>        modification_date      
19> FROM 
20> MRK_Nomen_Other_Old
(6545 rows affected)
1> 
2> DROP TABLE MRK_Nomen_Other_Old
1> 
2> CREATE UNIQUE CLUSTERED INDEX _Nomen_Other_Index ON MRK_Nomen_Other
3> (
4>        _Other_key
5> )
6>  
1> 
2> CREATE UNIQUE INDEX index_Nomen_key_name ON MRK_Nomen_Other
3> (
4>        name,
5>        _Nomen_key
6> )
7>  
1> 
2> CREATE INDEX _Nomen_key_Index ON MRK_Nomen_Other
3> (
4>        _Nomen_key
5> )
6>  
1> 
2> CREATE INDEX index_name ON MRK_Nomen_Other
3> (
4>        name
5> )
6>  
1> 
2> CREATE INDEX index_modification_date ON MRK_Nomen_Other
3> (
4>        modification_date
5> )
6>  
1> 
2> CREATE INDEX _Refs_key_index ON MRK_Nomen_Other
3> (
4>        _Refs_key
5> )
1> 
2> exec sp_primarykey MRK_Nomen_Other,
3>        _Other_key
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_Nomen_Other.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_Nomen_Other.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> revoke all on MRK_Nomen_Other from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MRK_Nomen_Other from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MRK_Nomen_Other from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MRK_Nomen_Other to tier2, lglass, lmm, cgw, tier3, dbradt, dph, sr, tier4, ljm, rmb, djr
1> 
2> grant select on MRK_Nomen_Other to editors
1> 
2> grant select on MRK_Nomen_Other to public
1> 
2> grant all on MRK_Nomen_Other to progs
1> 
2> /* MRK_Nomen_Reference */
3> 
4> execute sp_unbindefault "MRK_Nomen_Reference.creation_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_unbindefault "MRK_Nomen_Reference.modification_date"
Default unbound from table column.
(return status = 0) 
1> 
2> execute sp_rename MRK_Nomen_Reference,MRK_Nomen_Reference_Old
Object name has been changed.
(return status = 0) 
1> 
2> CREATE TABLE MRK_Nomen_Reference (
3>        _Nomen_key           int NOT NULL,
4>        _Refs_key            int NOT NULL,
5>        broadcastToMGD       bit NOT NULL,
6>        isPrimary            bit NOT NULL,
7>        creation_date        datetime NOT NULL,
8>        modification_date    datetime NOT NULL
9> )
1> 
2> 
3> insert into MRK_Nomen_Reference(
4>        _Nomen_key ,
5>        _Refs_key ,
6>        broadcastToMGD,
7>        isPrimary,
8>        creation_date,
9>        modification_date
10> )
11> select
12>        _Nomen_key,
13>        _Refs_key ,
14>        0,
15>        isPrimary,
16>        creation_date,
17>        modification_date
18> from 
19> MRK_Nomen_Reference_Old
(19994 rows affected)
1> 
2> DROP TABLE MRK_Nomen_Reference_Old
1> 
2> 
3> CREATE UNIQUE CLUSTERED INDEX _Refs_index ON MRK_Nomen_Reference
4> (
5>        _Refs_key,
6>        _Nomen_key
7> )
1> 
2> CREATE INDEX _Refs_key_Index ON MRK_Nomen_Reference
3> (
4>        _Refs_key
5> )
1> 
2> CREATE INDEX index_modification_date ON MRK_Nomen_Reference
3> (
4>        modification_date
5> )
1> 
2> CREATE INDEX index_nomen_key ON MRK_Nomen_Reference
3> (
4>        _Nomen_key
5> )
1> 
2> exec sp_primarykey MRK_Nomen_Reference,
3>        _Refs_key,
4>        _Nomen_key
New primary key added.
(return status = 0) 
1> 
2> exec sp_bindefault bit_default, 'MRK_Nomen_Reference.isPrimary'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault bit_default, 'MRK_Nomen_Reference.broadcastToMGD'
Default bound to column.
(return status = 0) 
1> 
2> 
3> exec sp_bindefault current_date_default, 'MRK_Nomen_Reference.creation_date'
Default bound to column.
(return status = 0) 
1> 
2> exec sp_bindefault current_date_default, 'MRK_Nomen_Reference.modification_date'
Default bound to column.
(return status = 0) 
1> 
2> revoke all on MRK_Nomen_Reference from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MRK_Nomen_Reference from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MRK_Nomen_Reference from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MRK_Nomen_Reference to progs
1> 
2> grant all on MRK_Nomen_Reference to dph, cgw, sr, tier3, dbradt, djr, tier2, lglass, tier4, ljm, lmm, rmb
1> 
2> grant all on MRK_Nomen_Reference to progs
1> 
2> grant select on MRK_Nomen_Reference to editors
1> 
2> grant select on MRK_Nomen_Reference to public
1> 
2> 
3> /* permissions MRK_Nomen_Notes */
4> 
5> revoke all on MRK_Nomen_Notes from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MRK_Nomen_Notes from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MRK_Nomen_Notes from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MRK_Nomen_Notes to tier2, lglass, lmm, cgw, tier3, dbradt, dph, sr, tier4, ljm, rmb, djr
1> 
2> grant select on MRK_Nomen_Notes to editors
1> 
2> grant all on MRK_Nomen_Notes to progs
1> 
2> grant select on  MRK_Nomen_Notes to public
1> 
2> 
3> /* permissions MRK_GeneFamily */
4> 
5> revoke all on MRK_GeneFamily from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MRK_GeneFamily from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MRK_GeneFamily from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MRK_GeneFamily to tier4, ljm, rmb, djr
1> 
2> grant select on MRK_GeneFamily to editors
1> 
2> grant select on MRK_GeneFamily to public 
1> 
2> grant all on MRK_GeneFamily to progs
1> 
2> /* permissions MRK_Nomen_GeneFamily */
3> 
4> revoke all on MRK_Nomen_GeneFamily from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MRK_Nomen_GeneFamily from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MRK_Nomen_GeneFamily from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MRK_Nomen_GeneFamily to tier2, lglass, lmm, cgw, tier3, dbradt, dph, sr, tier4, ljm, rmb, djr
1> 
2> grant select on MRK_Nomen_GeneFamily to editors
1> 
2> grant select on MRK_Nomen_GeneFamily to public 
1> 
2> grant all on MRK_Nomen_GeneFamily to progs
1> 
2> 
3> /* permissions MRK_Status */
4> 
5> revoke all on MRK_Status from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MRK_Status from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MRK_Status from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MRK_Status to tier4, ljm, rmb, djr
1> 
2> grant select on MRK_Status to editors
1> 
2> grant select on MRK_Status to public 
1> 
2> grant all on MRK_Status to progs
1> 
2> /* permissions ACC_AccessionReference */
3> 
4> revoke all on ACC_AccessionReference from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on ACC_AccessionReference from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on ACC_AccessionReference from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on ACC_AccessionReference to tier2, lglass, lmm, cgw, tier3, dbradt, dph, sr, tier4, ljm, rmb, djr
1> 
2> grant select on ACC_AccessionReference to editors
1> 
2> grant select on ACC_AccessionReference to public 
1> 
2> grant all on ACC_AccessionReference to progs
1> 
2> 
3> /* permissions ACC_Accession */
4> 
5> revoke all on ACC_Accession from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on ACC_Accession from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on ACC_Accession from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on ACC_Accession to tier2, lglass, lmm, cgw, tier3, dbradt, dph, sr, tier4, ljm, rmb, djr
1> 
2> grant select on ACC_Accession to editors
1> 
2> grant select on ACC_Accession to public 
1> 
2> grant all on ACC_Accession to progs
1> 
2> 
3> /* permissions ACC_MGIType */
4> 
5> revoke all on ACC_MGIType from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on ACC_MGIType from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on ACC_MGIType from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on ACC_Accession to tier2, lglass, lmm, rmb, djr
1> 
2> grant select on ACC_MGIType to editors
1>  
2> grant select on ACC_MGIType to public 
1> 
2> grant all on ACC_MGIType to progs
1> 
2> 
3> /* permissions system tables */
4> 
5> revoke all on sysusers from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on sysusers from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on sysusers from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on sysusers from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on sysusers from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on sysusers from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on sysobjects from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on sysobjects from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on sysobjects from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on syscolumns from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on syscolumns from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on syscolumns from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MGI_Columns from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MGI_Columns from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MGI_Columns from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MGI_Tables from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MGI_Tables from public
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on MGI_Tables from progs
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant select on sysusers to editors
1> 
2> grant select on sysusers to editors
1> 
2> grant select on syscolumns to editors
1> 
2> grant select on MGI_Columns to editors
1> 
2> grant select on MGI_Columns to public 
1> 
2> grant select on MGI_Tables to editors
1> 
2> grant select on MGI_Tables to public 
1> 
2> grant all on sysusers to progs
1> 
2> grant all on sysobjects to progs
1> 
2> grant all on syscolumns to progs
1> 
2> grant all on MGI_Columns to progs
1> 
2> grant all on MGI_Tables to progs
1> 
2> checkpoint
TR 1291...
Password: 
1>  
2> /* Nomen */
3> 
4> use nomen
1> 
2> drop trigger MRK_Nomen_Update
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Nomen_Update', because it doesn't exist in the
system catalogs.
1> 
2> /* set broadcastToMGD */
3> 
4> update MRK_Nomen_Reference
5> set broadcastToMGD = 1
6> where isPrimary = 1
(19142 rows affected)
1> 
2> /* set broadcast user to ljm */
3> 
4> update MRK_Nomen
5> set _Suid_broadcast_key = 39
6> where _Marker_Status_key = 5
(19593 rows affected)
1> 
2> /* set all non-tier 3, tier 4 users to retired_editors */
3> 
4> update MRK_Nomen
5> set _Suid_key = 86
6> where _Suid_key not in (8,17,39,47,48,81,88,91)
(17764 rows affected)
1> 
2> checkpoint
1> 
2> /* MGD */
3> 
4> use mgi_release
1> 
2> drop trigger MRK_Marker_Update
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Marker_Update', because it doesn't exist in the
system catalogs.
1> 
2> /* set non-mouse status to n/a */
3> 
4> update MRK_Marker
5> set _Marker_Status_key = -2
6> where _Species_key != 1
(8067 rows affected)
1> 
2> /* set all mouse ! W = 1 */
3> 
4> update MRK_Marker
5> set _Marker_Status_key = 1
6> where _Species_key = 1
7> and _Marker_Status_key = -1
8> and chromosome != "W"
(28142 rows affected)
1> 
2> /* set all status/chromosomes */
3> 
4> update MRK_Marker
5> set chromosome = m2.chromosome, _Marker_Status_key = 2
6> from MRK_Marker m, MRK_Current c, MRK_Marker m2
7> where m._Species_key = 1
8> and m.chromosome = "W"
9> and m._Marker_key = c._Marker_key
10> and c._Current_key = m2._Marker_key
(4593 rows affected)
1> 
2> update MRK_Marker
3> set _Marker_Status_key = 2, chromosome = "9"
4> where _Marker_key = 9992
(1 row affected)
1> 
2> update MRK_Marker
3> set _Marker_Status_key = 2, chromosome = "8"
4> where _Marker_key = 8611
(1 row affected)
1> 
2> update MRK_Marker
3> set _Marker_Status_key = 2, chromosome = "6"
4> where _Marker_key = 9117
(1 row affected)
1> 
2> update MRK_Marker
3> set _Marker_Status_key = 2, chromosome = "17"
4> where _Marker_key = 9340
(1 row affected)
1> 
2> update MRK_Marker
3> set _Marker_Status_key = 2, chromosome = "17"
4> where _Marker_key = 9341
(1 row affected)
1> 
2> update MRK_Marker
3> set _Marker_Status_key = 2, chromosome = "17"
4> where _Marker_key = 9400
(1 row affected)
1> 
2> update MRK_Marker
3> set _Marker_Status_key = 2, chromosome = "9"
4> where _Marker_key = 9996
(1 row affected)
1> 
2> update MRK_Marker
3> set _Marker_Status_key = 2, chromosome = "X"
4> where _Marker_key = 14063
(1 row affected)
1> 
2> update MRK_Marker
3> set _Marker_Status_key = 2, chromosome = "Y"
4> where _Marker_key = 14071
(1 row affected)
1> 
2> update MRK_Marker
3> set _Marker_Status_key = 2, chromosome = "UN"
4> where _Marker_key = 14868
(1 row affected)
1> 
2> /* should be no more chromosome "W" in database */
3> 
4> select symbol, _Marker_key, chromosome from MRK_Marker where chromosome = "W"
 symbol                    _Marker_key chromosome 
 ------------------------- ----------- ---------- 
 Mafk                            11121 W          

(1 row affected)
1> 
2> /* Events and Event Reasons */
3> 
4> update MRK_History
5> set _Marker_Event_key = 1
6> from MRK_History_Temp h, MRK_History h1
7> where h._Marker_key = h1._Marker_key
8> and h.sequenceNum = h1.sequenceNum
9> and h.note in ("Assigned", "Re-Assigned")
(32837 rows affected)
1> 
2> /* allele ofs */
3> 
4> update MRK_History
5> set _Marker_Event_key = 4
6> from MRK_History_Temp h, MRK_History h1
7> where h._Marker_key = h1._Marker_key
8> and h.sequenceNum = h1.sequenceNum
9> and h.note like "withdrawn, allele of%"
(209 rows affected)
1> 
2> /* splits */
3> 
4> update MRK_History
5> set _Marker_Event_key = 5
6> from MRK_History_Temp h, MRK_History h1
7> where h._Marker_key = h1._Marker_key
8> and h.sequenceNum = h1.sequenceNum
9> and h.note like "withdrawn, =%,%"
(72 rows affected)
1> 
2> /* deleted */
3> 
4> update MRK_History
5> set _Marker_Event_key = 6
6> from MRK_History_Temp h, MRK_History h1
7> where h._Marker_key = h1._Marker_key
8> and h.sequenceNum = h1.sequenceNum
9> and h.note = "withdrawn"
(10 rows affected)
1> 
2> /* all unspecified -> withdrawn */
3> 
4> update MRK_History
5> set _Marker_Event_key = 2
6> from MRK_History_Temp h, MRK_History h1
7> where h._Marker_key = h1._Marker_key
8> and h.sequenceNum = h1.sequenceNum
9> and h.note like "withdrawn%"
10> and h1._Marker_Event_key = -1
(4351 rows affected)
1> 
2> /* should be no unspecified events */
3> 
4> select * from MRK_History where _Marker_Event_key = -1
 _Marker_key _Marker_Event_key _Marker_EventReason_key _History_key _Refs_key  
	 sequenceNum
	 name                                                                                                                                                                                                                                                           
	 event_date                 creation_date             
	 modification_date          
 ----------- ----------------- ----------------------- ------------ ----------- 
	----------- 
	--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
	-------------------------- -------------------------- 
	-------------------------- 

(0 rows affected)
1> 
2> checkpoint
TR 1177...
scripts: Undefined variable
Password: 
1>  
2> use mgi_release
1> 
2> declare @typekey int
3> 
4> if not exists (select 1 from ACC_MGIType where name = "Allele")
5> begin
6>         select @typekey = max(_MGIType_key) + 1 from ACC_MGIType
7> 	insert into ACC_MGIType (_MGIType_key, name, tableName, primaryKeyName)
8> 	values (@typekey, "Allele", "ALL_Allele", "_Allele_key")
9> end
10> 
(0 rows affected)
1> 
2> /* Add MGI Accession numbers for all ALL_Allele records which don't have one... */
3> 
4> declare all_cursor cursor for
5> select _Allele_key
6> from ALL_Allele al
7> where not exists 
8> (select 1 from ACC_Accession a where al._Allele_key = a._Object_key
9> and a._MGIType_key = 11)
10> for read only
1> 
2> declare @allKey integer
3> 
4> open all_cursor
5>  
6> fetch all_cursor into @allkey
7>    
8> while (@@sqlstatus = 0)
9> begin
10> 	exec ACC_assignMGI @allKey, "Allele"
11>         fetch all_cursor into @allKey
12> end
13> 
14> close all_cursor
15> deallocate cursor all_cursor
(1 row affected)
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
(return status = 0) 
1> 
2> checkpoint
TR 148...
TR 1404...
Password: 
1>  
2> use mgi_release
1> 
2> delete from MRK_Types where _Marker_Type_key in (4,5)
(2 rows affected)
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop trigger ACC_Accession_Insert
1> 
2> create trigger ACC_Accession_Insert
3> on ACC_Accession
4> for insert
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   /* For SWISS-PROT, only allow specific users to edit Accession numbers */
10> 
11>   if (select _LogicalDB_key from inserted) = 13 and
12>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "neb", "djr", "cgw", "dph", "ljm")
13>   begin
14> 	rollback transaction
15> 	raiserror 99999 "You do not have permission to edit SWISS-PROT Accession numbers."
16> 	return
17>   end
18> 
19>   declare @accID varchar(30)
20>   select @accID = accID from inserted
21> 
22>   /* If adding Sequence ID for Molecular Segment */
23>   /* and the Sequence ID does not exist for one of the encoding Markers */
24>   if (select _LogicalDB_key from inserted) = 9 and
25>       (select _MGIType_key from inserted) = 3
26>   begin
27> 	/* test to see if any markers are specified to encode this segment
28>        (set within the Mol Probes EI's "Chr Marker Relationship" table) */
29>       if exists (select *
30>          from ACC_Accession a, PRB_Marker pm, inserted i
31>          where i._Object_key = pm._Probe_key and
32>          a._Object_key = pm._Marker_key and
33>          a._MGIType_key = 2 and
34>          a._LogicalDB_key = 9 and
35>          pm.relationship = 'E')
36>       begin
37>       /* if so, see if all of them have associated Sequence IDs entered
38>          for the encoding markers (from the Marker EI)*/
39>         if exists (select * 
40>                  from ACC_Accession a2, inserted i
41>                  where i._Object_key = a2._Object_key and
42>                  a2.accID = i.accID and
43>                  a2._MGIType_key = 3 and
44>                  a2.accID not in (select a.accID
45>                                from ACC_Accession a, PRB_Marker pm, inserted i
46>                                where i._Object_key = pm._Probe_key and 
47>                                a._Object_key = pm._Marker_key and
48> 		                       a._MGIType_key = 2 and
49>                                a._LogicalDB_key = 9 and
50>                                pm.relationship = 'E'))
51>         begin
52>            /* No. one or more encodes relationships are missing seq ids */ 
53>      	   print "Sequence IDs for Marker(s) encoding this segment do 
54> not exist for all encodes relationships specified. 
55> Some Sequence ids might need to be added."
56>         end
57>      end
58>   end
59> 
60>   /* If inserting the Sequence or SWISS-PROT ID for a Marker */
61>   /* and the same ID exists for another Marker...*/
62> 
63>   if (select _LogicalDB_key from inserted) in (9, 13) and
64>       (select _MGIType_key from inserted) = 2 and
65>       exists (select a._Accession_key
66>               from ACC_Accession a, inserted i
67>               where i.accID = a.accID and
68> 		    i._Object_key != a._Object_key and
69> 	            a._MGIType_key = 2)
70>   begin
71> 	print "The Accession ID '%1!' is associated with another Marker.", @accID
72>   end
73> 
74> end
75> 
1> 
2> drop trigger ACC_Accession_Update
1> 
2> create trigger ACC_Accession_Update
3> on ACC_Accession
4> for update
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   /* For SWISS-PROT, only allow specific users to edit Accession numbers */
10>  
11>   if (select _LogicalDB_key from inserted) = 13 and
12>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "neb", "djr", "cgw", "dph", "ljm")
13>   begin
14>         rollback transaction
15>         raiserror 99999 "You do not have permission to edit SWISS-PROT Accession numbers."
16>         return
17>   end
18>  
19>   declare @accID varchar(30)
20>   select @accID = accID from deleted
21> 
22>   /* If updating Sequence ID for Molecular Segment */
23>   /* and the same Sequence ID exists for one of the Segment's Markers... */
24> 
25>   if (select _LogicalDB_key from inserted) = 9 and
26>       (select _MGIType_key from inserted) = 3 and
27>       exists (select a._Accession_key
28>               from ACC_Accession a, PRB_Marker pm, deleted d
29>               where d.accID = a.accID and
30> 		    d._Object_key = pm._Probe_key and
31> 		    pm._Marker_key = a._Object_key and
32> 	            a._MGIType_key = 2)
33>   begin
34> 	print "Please review the relationship(s) between the Sequence ID '%1!' and the Molecular Segment's Marker(s).  These relationships may no longer be appropriate.", @accID
35>   end
36> 
37>   /* If updating the Sequence ID for a Marker */
38>   /* and the same Sequence ID exists for one of the Marker's Segments...*/
39> 
40>   if (select _LogicalDB_key from inserted) = 9 and
41>       (select _MGIType_key from inserted) = 2 and
42>       exists (select a._Accession_key
43>               from ACC_Accession a, PRB_Marker pm, deleted d
44>               where d.accID = a.accID and
45> 		    d._Object_key = pm._Marker_key and
46> 		    pm._Probe_key = a._Object_key and
47> 	            a._MGIType_key = 3)
48>   begin
49> 	print "Please review the relationship(s) between the Sequence ID '%1!' and its Molecular Segments.  These relationships may no longer be appropriate.", @accID
50>   end
51> 
52>   /* If updating the Sequence or SWISS-PROT ID for a Marker */
53>   /* and the same ID exists for another Marker...*/
54> 
55>   if (select _LogicalDB_key from inserted) in (9, 13) and
56>       (select _MGIType_key from inserted) = 2 and
57>       exists (select a._Accession_key
58>               from ACC_Accession a, inserted i
59>               where i.accID = a.accID and
60> 		    i._Object_key != a._Object_key and
61> 	            a._MGIType_key = 2)
62>   begin
63> 	print "The Accession ID '%1!' is associated with another Marker.", @accID
64>   end
65> end
66> 
67> /* If max J: in Acc table does not equal max J: in max table, then re-set max J: in max table */
68> 
69> if exists (select * from inserted where prefixPart = "J:")
70> begin
71>   declare @maxJ int
72>   select @maxJ = max(numericPart) from ACC_Accession(index index_prefixPart) where prefixPart = "J:"
73>   if @maxJ != (select maxNumericPart from ACC_AccessionMax where prefixPart = "J:")
74>   begin
75>     update ACC_AccessionMax
76>     set maxNumericPart = @maxJ
77>     where prefixPart = "J:"
78>   end
79> end
80> 
1> 
2> drop trigger ACC_Accession_Delete
1> 
2> create trigger ACC_Accession_Delete
3> on ACC_Accession
4> for delete
5> as
6> 
7> if @@rowcount = 1
8> begin
9> 
10>   /* For SWISS-PROT, only allow specific users to edit Accession numbers */
11>  
12>   if (select _LogicalDB_key from deleted) = 13 and
13>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "neb", "djr", "cgw", "dph", "ljm")
14>   begin
15>         rollback transaction
16>         raiserror 99999 "You do not have permission to edit SWISS-PROT Accession numbers."
17>         return
18>   end
19>  
20>   /* If deleting MGI Image Pixel number, then nullify X/Y Dimensions of IMG_Image record TR#134 */
21> 
22>   if (select _LogicalDB_key from deleted) = 19
23>   begin
24> 	update IMG_Image
25> 	set IMG_Image.xDim = null, 
26> 	    IMG_Image.yDim = null
27> 	from deleted, IMG_Image
28> 	where deleted._Object_key = IMG_Image._Image_key
29>   end
30> 
31>   /* If deleting Sequence ID from Molecular Segment */
32>   /* and the same Sequence ID exists for one of the Segment's Markers... */
33> 
34>   declare @accID varchar(30)
35>   select @accID = accID from deleted
36> 
37>   if (select _LogicalDB_key from deleted) = 9 and
38>       (select _MGIType_key from deleted) = 3 and
39>       exists (select a._Accession_key
40>               from ACC_Accession a, PRB_Marker pm, deleted d
41>               where d.accID = a.accID and
42> 		    d._Object_key = pm._Probe_key and
43> 		    pm._Marker_key = a._Object_key and
44> 	            a._MGIType_key = 2)
45>   begin
46> 	print "Please review the relationship(s) between the Sequence ID '%1!' and the Molecular Segment's Marker(s).  These relationships may no longer be appropriate.", @accID
47>   end
48> 
49>   /* If deleting the Sequence ID from a Marker */
50>   /* and the same Sequence ID exists for one of the Marker's Segments...*/
51> 
52>   if (select _LogicalDB_key from deleted) = 9 and
53>       (select _MGIType_key from deleted) = 2 and
54>       exists (select a._Accession_key
55>               from ACC_Accession a, PRB_Marker pm, deleted d
56>               where d.accID = a.accID and
57> 		    d._Object_key = pm._Marker_key and
58> 		    pm._Probe_key = a._Object_key and
59> 	            a._MGIType_key = 3)
60>   begin
61> 	print "Please review the relationship(s) between the Sequence ID '%1!' and its Molecular Segments.  These relationships may no longer be appropriate.", @accID
62>   end
63> end
64> 
65> /* If max J: in Acc table does not equal max J: in max table, then re-set max J: in max table */
66> 
67> if exists (select * from deleted where prefixPart = "J:")
68> begin
69>   declare @maxJ int
70>   select @maxJ = max(numericPart) from ACC_Accession(index index_prefixPart) where prefixPart = "J:"
71>   if @maxJ != (select maxNumericPart from ACC_AccessionMax where prefixPart = "J:")
72>   begin
73>     update ACC_AccessionMax
74>     set maxNumericPart = @maxJ
75>     where prefixPart = "J:"
76>   end
77> end
78> 
79> delete ACC_AccessionReference
80> from ACC_AccessionReference a, deleted d
81> where a._Accession_key = d._Accession_key
82> 
1> 
2> drop trigger ACC_AccessionReference_Insert
1> 
2> create trigger ACC_AccessionReference_Insert
3> on ACC_AccessionReference
4> for insert
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   if (select a._MGIType_key from ACC_Accession a, inserted i
10>       where a._Accession_key = i._Accession_key) = 2
11>   begin
12>         /* Insert entry in Marker Reference bucket if it doesn't already exist */
13> 
14>         if not exists (select * from MRK_Reference r, inserted i, ACC_Accession a
15>             where i._Accession_key = a._Accession_key and
16>                   a._Object_key = r._Marker_key and
17>                   r._Refs_key = i._Refs_key)
18>         begin
19>                 insert MRK_Reference (_Marker_key, _Refs_key, auto) 
20>                 select _Object_key, _Refs_key, 1 from inserted i, ACC_Accession a
21>                 where i._Accession_key = a._Accession_key
22>         end
23>   end
24> end
25> 
1> 
2> drop trigger ACC_AccessionReference_Update
1> 
2> create trigger ACC_AccessionReference_Update
3> on ACC_AccessionReference
4> for update
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   if update(_Refs_key) and
10>      (select a._MGIType_key from ACC_Accession a, inserted i
11>       where a._Accession_key = i._Accession_key) = 2
12>   begin
13>         /* Insert entry in Marker Reference bucket if it doesn't already exist */
14> 
15>         if not exists (select * from MRK_Reference r, inserted i, ACC_Accession a
16>             where i._Accession_key = a._Accession_key and
17>                   a._Object_key = r._Marker_key and
18>                   r._Refs_key = i._Refs_key)
19>         begin
20>                 insert MRK_Reference (_Marker_key, _Refs_key, auto) 
21>                 select _Object_key, _Refs_key, 1 from inserted i, ACC_Accession a
22>                 where i._Accession_key = a._Accession_key
23>         end
24>   end
25> end
26> 
1> 
2> drop trigger ACC_LogicalDB_Delete 
1> 
2> create trigger ACC_LogicalDB_Delete 
3> on ACC_LogicalDB
4> for delete
5> as
6> 
7> if exists (select * from deleted, ACC_Accession
8>         where ACC_Accession._LogicalDB_key = deleted._LogicalDB_key)
9>  
10> begin
11> 	rollback transaction
12> 	raiserror 99999 "Logical DB is referenced in Accession Record(s)"
13> 	return
14> end
15> 
16> delete ACC_ActualDB from ACC_ActualDB, deleted
17> where ACC_ActualDB._LogicalDB_key = deleted._LogicalDB_key
18> 
1>  
2>  
3> drop trigger ACC_LogicalDB_Update 
1> 
2> create trigger  ACC_LogicalDB_Update
3> on ACC_LogicalDB
4> for update
5> as
6> 
7> if update(_Species_key) and
8>    (select _Species_key from deleted) != (select _Species_key from inserted) and
9>    exists (select * from ACC_Accession, inserted
10>     where ACC_Accession._LogicalDB_key = inserted._LogicalDB_key)
11> begin
12> 	rollback transaction
13> 	raiserror 99999 "Cannot update Species because Accession numbers exist for this Logical DB."
14> 	return
15> end
16>  
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop trigger ALL_Allele_Insert
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'ALL_Allele_Insert', because it doesn't exist in the
system catalogs.
1> 
2> create trigger ALL_Allele_Insert
3> on ALL_Allele
4> for insert
5> as
6> 
7> declare @key integer
8> select @key = _Allele_key from inserted
9> exec ACC_assignMGI @key, "Allele"
10> 
11> if (@@error != 0)
12> begin
13> 	rollback transaction
14> 	return
15> end
16> 
1> 
2> drop trigger ALL_Allele_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'ALL_Allele_Delete', because it doesn't exist in the
system catalogs.
1> 
2> create trigger ALL_Allele_Delete
3> on ALL_Allele
4> for delete
5> as
6> 
7> /* Disallow deletion if Allele is currently referenced elsewhere */
8> 
9> if exists (select * from GXD_AllelePair, deleted
10> 	where GXD_AllelePair._Allele_key_1 = deleted._Allele_key)
11> begin
12> 	rollback transaction
13> 	raiserror 99999 "Allele Symbol is referenced in GXD Allele Pair Record(s)"
14> 	return
15> end
16> 
17> if exists (select * from GXD_AllelePair, deleted
18> 	where GXD_AllelePair._Allele_key_2 = deleted._Allele_key)
19> begin
20> 	rollback transaction
21> 	raiserror 99999 "Allele Symbol is referenced in GXD Allele Pair Record(s)"
22> 	return
23> end
24> 
25> if exists (select * from MLD_Expt_Marker, deleted
26> 	where MLD_Expt_Marker._Allele_key = deleted._Allele_key)
27> begin
28> 	rollback transaction
29> 	raiserror 99999 "Allele Symbol is referenced in Mapping Experiment Marker Record(s)"
30> 	return
31> end
32> 
33> delete ALL_Allele_Mutation from ALL_Allele_Mutation, deleted
34> where ALL_Allele_Mutation._Allele_key = deleted._Allele_key
35> 
36> delete ALL_Molecular_Note from ALL_Molecular_Note, deleted
37> where ALL_Molecular_Note._Allele_key = deleted._Allele_key
38> 
39> delete ALL_Note from ALL_Note, deleted
40> where ALL_Note._Allele_key = deleted._Allele_key
41> 
42> delete ALL_Synonym from ALL_Synonym, deleted
43> where ALL_Synonym._Allele_key = deleted._Allele_key
44> 
45> delete ACC_Accession
46> from ACC_Accession a, ACC_MGIType m, deleted
47> where a._Object_key = deleted._Allele_key
48> and a._MGIType_key = m._MGIType_key
49> and m.name = "Allele"
50> 
1> 
2> drop trigger ALL_Type_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'ALL_Type_Delete', because it doesn't exist in the
system catalogs.
1> 
2> create trigger ALL_Type_Delete
3> on ALL_Type
4> for delete
5> as
6> 
7> /* Disallow deletion of allele type which is referenced in Allele table */
8> 
9> if exists (select * from ALL_Allele, deleted
10>          where ALL_Allele._Allele_Type_key = deleted._Allele_Type_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Allele Type is referenced in Allele Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger ALL_Inheritance_Mode_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'ALL_Inheritance_Mode_Delete', because it doesn't exist
in the system catalogs.
1> 
2> create trigger ALL_Inheritance_Mode_Delete
3> on ALL_Inheritance_Mode
4> for delete
5> as
6> 
7> /* Disallow deletion of inheritance mode which is referenced in Allele table */
8> 
9> if exists (select * from ALL_Allele, deleted
10>          where ALL_Allele._Mode_key = deleted._Mode_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Inheritance Mode is referenced in Allele Record(s)"
14> 	return
15> end
16> 
1> 
2> checkpoint
1> 
2> drop trigger ALL_Molecular_Mutation_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'ALL_Molecular_Mutation_Delete', because it doesn't
exist in the system catalogs.
1> 
2> create trigger ALL_Molecular_Mutation_Delete
3> on ALL_Molecular_Mutation
4> for delete
5> as
6> 
7> /* Disallow deletion of molecular mutation which is referenced in Allele table */
8> 
9> if exists (select * from ALL_Allele_Mutation, deleted
10>          where ALL_Allele_Mutation._Mutation_key = deleted._Mutation_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Molecular Mutation is referenced in Allele Record(s)"
14> 	return
15> end
16> 
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop trigger BIB_Refs_Insert
1>  
2> create trigger BIB_Refs_Insert
3> on BIB_Refs
4> for insert
5> as
6>  
7> declare @pgs varchar(30)
8> select @pgs = pgs from inserted
9> 
10> /* Determine if new record constitutes a duplicate record */
11> /* within the Reference (BIB_Refs) table. */
12> /* Parameters to check are journal, year, volume and pages */
13>  
14> /* Mouse News Letter references are ignored because more than one */
15> /* reference can appear on the same page within this journal. */
16>   
17> if (select journal from inserted) != 'Mouse News Lett'
18> begin
19> 
20>   /* If pages in format "x", check for pages = x and pages like "x-%" */
21>   /* If pages in format "x-y", check for pages = x and pages like "x-%" */
22> 
23>   /* Strip off first page */
24>   if charindex("-", @pgs) > 0
25>   begin
26>     select @pgs = substring(@pgs, 1, charindex("-", @pgs) - 1)
27>   end
28> 
29>   if (select count(BIB_Refs._Refs_key) from BIB_Refs, inserted
30>       where BIB_Refs.journal = inserted.journal and
31>             BIB_Refs.year = inserted.year and
32>             BIB_Refs.vol = inserted.vol and
33>             (BIB_Refs.pgs = @pgs or BIB_Refs.pgs like @pgs + "-%")) > 1
34>   begin
35>     rollback transaction
36>     raiserror 99999 "Reference Already Exists"
37>     return
38>   end
39> end
40> 
41> declare @key integer
42> select @key = _Refs_key from inserted
43> exec ACC_assignMGI @key, "Reference"
44> 
45> if (@@error != 0)
46> begin
47>   rollback transaction
48>   return
49> end
50> 
1> 
2> drop trigger BIB_Refs_Update
1>  
2> create trigger BIB_Refs_Update
3> on BIB_Refs
4> for update
5> as
6>  
7> update BIB_Refs 
8> set modification_date = getdate()
9> from BIB_Refs, inserted
10> where BIB_Refs._Refs_key = inserted._Refs_key
11>  
1>  
2> drop trigger BIB_Refs_Delete
1> 
2> create trigger BIB_Refs_Delete
3> on BIB_Refs
4> for delete
5> as
6> 
7> /* Before deleting a record, verify that the J# is not being */
8> /* referenced elsewhere in the database. */
9> 
10> if exists (select * from deleted
11>     where deleted.dbs like "%Nomen%")
12> begin
13>         rollback transaction
14>         raiserror 99999 "J# is referenced in Nomenclature Record(s)"
15> 	return
16> end
17> 
18> if exists (select * from MRK_History, deleted
19>     where MRK_History._Refs_key = deleted._Refs_key)
20> begin
21>         rollback transaction
22>         raiserror 99999 "J# is referenced in Marker History Record(s)"
23> 	return
24> end
25> 
26> if exists (select * from MRK_Other, deleted
27>     where MRK_Other._Refs_key = deleted._Refs_key)
28> begin
29>         rollback transaction
30>         raiserror 99999 "J# is referenced in Marker Other Name Record(s)"
31> 	return
32> end
33> 
34> if exists (select * from HMD_Homology, deleted
35>          where HMD_Homology._Refs_key = deleted._Refs_key)
36> begin
37>         rollback transaction
38>         raiserror 99999 "J# is referenced in Homology Record(s)"
39> 	return
40> end
41> 
42> if exists (select * from MLC_Reference, deleted
43>          where MLC_Reference._Refs_key = deleted._Refs_key)
44> begin
45>         rollback transaction
46>         raiserror 99999 "J# is referenced in MLC Record(s)"
47> 	return
48> end
49> 
50> if exists (select * from MLC_Reference_edit, deleted
51>          where MLC_Reference_edit._Refs_key = deleted._Refs_key)
52> begin
53>         rollback transaction
54>         raiserror 99999 "J# is referenced in MLC Edit Record(s)"
55> 	return
56> end
57> 
58> if exists (select * from MLD_Expts, deleted
59>          where MLD_Expts._Refs_key = deleted._Refs_key)
60> begin
61>         rollback transaction
62>         raiserror 99999 "J# is referenced in Mapping Record(s)"
63> 	return
64> end
65> 
66> if exists (select * from PRB_Reference, deleted
67>          where PRB_Reference._Refs_key = deleted._Refs_key)
68> begin
69>         rollback transaction
70>         raiserror 99999 "J# is referenced in Probe Record(s)"
71> 	return
72> end
73> 
74> if exists (select * from PRB_Source, deleted
75>          where PRB_Source._Refs_key = deleted._Refs_key)
76> begin
77>         rollback transaction
78>         raiserror 99999 "J# is referenced in Probe Source Record(s)"
79> 	return
80> end
81> 
82> if exists (select * from GXD_Index, deleted
83>          where GXD_Index._Refs_key = deleted._Refs_key)
84> begin
85>         rollback transaction
86>         raiserror 99999 "J# is referenced in GXD Index Record(s)"
87> 	return
88> end
89> 
90> if exists (select * from GXD_Antibody, deleted
91>          where GXD_Antibody._Refs_key = deleted._Refs_key)
92> begin
93>         rollback transaction
94>         raiserror 99999 "J# is referenced in GXD Antibody Record(s)"
95> 	return
96> end
97> 
98> if exists (select * from GXD_AntibodyAlias, deleted
99>          where GXD_AntibodyAlias._Refs_key = deleted._Refs_key)
100> begin
101>         rollback transaction
102>         raiserror 99999 "J# is referenced in GXD Antibody Alias Record(s)"
103> 	return
104> end
105> 
106> if exists (select * from GXD_Assay, deleted
107>          where GXD_Assay._Refs_key = deleted._Refs_key)
108> begin
109>         rollback transaction
110>         raiserror 99999 "J# is referenced in GXD Assay Record(s)"
111> 	return
112> end
113> 
114> if exists (select * from IMG_Image, deleted
115>          where IMG_Image._Refs_key = deleted._Refs_key)
116> begin
117>         rollback transaction
118>         raiserror 99999 "J# is referenced in GXD Image Record(s)"
119> 	return
120> end
121> 
122> if exists (select * from MRK_Reference, deleted
123>     where MRK_Reference._Refs_key = deleted._Refs_key)
124> begin
125>         rollback transaction
126>         raiserror 99999 "J# is referenced in Marker Reference Record(s)"
127> 	return
128> end
129> 
130> delete BIB_Books from BIB_Books, deleted
131> where BIB_Books._Refs_key = deleted._Refs_key
132> 
133> delete BIB_Notes from BIB_Notes, deleted
134> where BIB_Notes._Refs_key = deleted._Refs_key
135> 
136> delete ACC_Accession
137> from ACC_Accession a, ACC_MGIType m, deleted
138> where a._Object_key = deleted._Refs_key
139> and a._MGIType_key = m._MGIType_key
140> and m.name = "Reference"
141> 
1> 
2> drop trigger BIB_ReviewStatus_Delete
1> 
2> create trigger BIB_ReviewStatus_Delete
3> on BIB_ReviewStatus
4> for delete
5> as
6> 
7> /* Before deleting a record, verify that the Status is not being */
8> /* referenced elsewhere in the database. */
9> 
10> if exists (select * from BIB_Refs, deleted
11>     where BIB_Refs._ReviewStatus_key = deleted._ReviewStatus_key)
12> begin
13>         rollback transaction
14>         raiserror 99999 "Review Status is referenced in Reference Record(s)"
15> 	return
16> end
17> 
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop trigger CRS_Cross_Delete
1> 
2> create trigger CRS_Cross_Delete
3> on CRS_Cross
4> for delete
5> as
6> 
7> /* Disallow removal of a record if the Cross is referenced in MLDP */
8> 
9> if (select count(*) from MLD_Matrix, deleted
10>     where MLD_Matrix._Cross_key = deleted._Cross_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Cross is referenced in MLDP Record(s)"
14> 	return
15> end
16> 
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop trigger GXD_Genotype_Delete
1> 
2> create trigger GXD_Genotype_Delete
3> on GXD_Genotype
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> /*if (select count(*) from GXD_GelLane, deleted */
10> /*    where GXD_GelLane._Genotype_key = deleted._Genotype_key) > 0 */
11> /*begin */
12> /*        rollback transaction */
13> /*        raiserror 99999 "Genotype is referenced in Gel Lane Record(s)" */
14> /*	return */
15> /*end */
16> 
17> /*if (select count(*) from GXD_Specimen, deleted */
18> /*    where GXD_Specimen._Genotype_key = deleted._Genotype_key) > 0 */
19> /*begin */
20> /*        rollback transaction */
21> /*        raiserror 99999 "Genotype is referenced in Specimen Record(s)" */
22> /*	return */
23> /*end */
24> 
25> /*if (select count(*) from GXD_Expression, deleted */
26> /*    where GXD_Expression._Genotype_key = deleted._Genotype_key) > 0 */
27> /*begin */
28> /*        rollback transaction */
29> /*        raiserror 99999 "Genotype is referenced in Expression Results (cache) Record(s)" */
30> /*	return */
31> /*end */
32> 
33> delete GXD_AllelePair from GXD_AllelePair, deleted
34> where GXD_AllelePair._Genotype_key = deleted._Genotype_key
35>  
1> 
2> drop trigger GXD_Antigen_Insert
1>  
2> create trigger GXD_Antigen_Insert
3> on GXD_Antigen
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Antigen */
8>  
9> declare @key integer
10> select @key = _Antigen_key from inserted
11> exec ACC_assignMGI @key, "Antigen"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18> 
1>  
2> drop trigger GXD_Antigen_Delete
1> 
2> create trigger GXD_Antigen_Delete
3> on GXD_Antigen
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Antibody, deleted
10>     where GXD_Antibody._Antigen_key = deleted._Antigen_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antigen is referenced in Antibody Record(s)"
14> 	return
15> end
16> 
17> /* If Probe Source Name is null, then Anonymous Source */
18> /* If Anonymous Source, delete upon deletion of Antigen */
19>  
20> if not exists (select * from GXD_Antigen, deleted
21>     where GXD_Antigen._Source_key = deleted._Source_key)
22> begin
23>         delete PRB_Source from PRB_Source, deleted
24>         where PRB_Source._Source_key = deleted._Source_key
25>               and PRB_Source.name is null
26> end
27>  
28> delete ACC_Accession 
29> from ACC_Accession a, ACC_MGIType m, deleted
30> where a._Object_key = deleted._Antigen_key
31> and a._MGIType_key = m._MGIType_key
32> and m.name = "Antigen"
33>   
1> 
2> drop trigger GXD_Antibody_Insert
1>  
2> create trigger GXD_Antibody_Insert
3> on GXD_Antibody
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Antibody */
8>  
9> declare @key integer
10> select @key = _Antibody_key from inserted
11> exec ACC_assignMGI @key, "Antibody"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1>  
2> drop trigger GXD_Antibody_Delete
1> 
2> create trigger GXD_Antibody_Delete
3> on GXD_Antibody
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_AntibodyPrep, deleted
10>     where GXD_AntibodyPrep._Antibody_key = deleted._Antibody_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody is referenced in Antibody Prep Record(s)"
14> 	return
15> end
16> 
17> delete GXD_AntibodyMarker from GXD_AntibodyMarker, deleted
18> where GXD_AntibodyMarker._Antibody_key = deleted._Antibody_key
19>  
20> delete ACC_Accession
21> from ACC_Accession a, ACC_MGIType m, deleted
22> where a._Object_key = deleted._Antibody_key
23> and a._MGIType_key = m._MGIType_key
24> and m.name = "Antibody"
25>  
1> 
2> /* GXD_Structure */
3> 
4> 
5> drop trigger GXD_Structure_Insert
1> 
2> create trigger GXD_Structure_Insert
3> on GXD_Structure
4> for insert
5> as
6> 
7> /* Ensure that _Parent_key of inserted exists as a _Structure_key and
8>    that parent has the same _Stage_key as inserted, if _Parent_key != NULL */
9> 
10> if (select _Parent_key from inserted) != NULL
11> begin
12>     if not exists (select *
13>         from GXD_Structure s, inserted
14>         where inserted._Parent_key = s._Structure_key
15>         and inserted._Stage_key = s._Stage_key)
16>     begin
17>        rollback transaction
18>        raiserror 99999 "GXD_Structure_Insert: Specified parent Structure does not exist"
19>        return
20>     end
21> end
22> 
23> declare @treeDepth integer
24> select @treeDepth = 1  /* assume that we are adding a child of a Stage node */
25> 
26> /* if the assumption doesn't hold, then the following query will set the
27>    current child's treeDepth */ 
28> 
29> 
30> /* find out the depth of the parent structure */
31> select @treeDepth = s.treeDepth + 1
32> from GXD_Structure s, inserted
33> where s._Structure_key = inserted._Parent_key 
34> 
35> /* update the inserted node */
36> update GXD_Structure
37> set treeDepth = @treeDepth
38> from GXD_Structure s, inserted
39> where s._Structure_key = inserted._Structure_key
40> 
41> if @@error != 0
42> begin
43>   rollback transaction
44>   raiserror 99999 "GXD_Structure_Insert: Update of treeDepth failed"
45>   return
46> end
47> 
48> /* incrementally modify the closure */
49> 
50> declare @inp integer  /* inserted node's parent */
51> select @inp = _Parent_key from inserted
52> 
53> /* _Parent_key will be null for an immediate child of a stage root,
54>    this node, by definition will not have any entries in the closure table,
55>    since it is a root node as far as the database is concerned */ 
56> 
57> if @inp != NULL
58> begin
59>    
60>    declare ancest_cursor cursor
61>    for select c._Structure_key
62>        from GXD_StructureClosure c
63>        where c._Descendent_key = @inp
64>    
65>    declare @sk integer
66>    declare @isk integer
67>    select @isk = _Structure_key from inserted  
68>    
69>    open ancest_cursor
70>    fetch ancest_cursor into @sk
71>    while (@@sqlstatus = 0)
72>    begin
73>       /* for each ancestor, insert ancestor's _Structure_key, inserted's 
74>          _Structure_key in GXD_StructureClosure */ 
75>       insert into GXD_StructureClosure (_Structure_key, _Descendent_key) 
76>              values (@sk, @isk)
77>       if @@error != 0
78>       begin
79>          rollback transaction
80>          raiserror 99999 "GXD_Structure_Insert: Incremental insert on closure table failed"
81>          close ancest_cursor
82>          return
83>       end
84>       fetch ancest_cursor into @sk
85>    end
86>    close ancest_cursor
87>    
88>    /* finally, insert the inserted node's _Parent_key and the inserted node's
89>       _Structure_key into the closure table */
90>    
91>    insert into GXD_StructureClosure (_Structure_key, _Descendent_key)
92>        values (@inp, @isk)
93>    if @@error != 0
94>    begin
95>       rollback transaction
96>       raiserror 99999 "GXD_Structure_Insert: Incremental insert on closure table failed"
97>       return
98>    end
99> end
100> 
101> /* Do not compute the printName for the inserted structure here!
102>    this will be taken care of by the GXD_StructureName triggers.
103>    The name records must be in place before a printName recomputation
104>    can be done. */ 
105> 
106> 
1> 
2> drop trigger GXD_Structure_Update
1> 
2> create trigger GXD_Structure_Update
3> on GXD_Structure
4> for update
5> as
6>    update GXD_Structure
7>    set s.modification_date = getdate()  
8>    from GXD_Structure s, inserted
9>    where s._Structure_key = inserted._Structure_key 
10> 
11>    /* make certain that printStop bits don't get cleared on Structures
12>       that are children of the Stage root nodes */
13> 
14>    if exists (select printStop 
15>               from inserted
16>               where printStop = 0 
17>               and _Parent_key = NULL)
18>    begin
19>         rollback transaction
20>         raiserror 99999 "GXD_Structure_Update: Cannot clear printStop on child of stage root"
21>         return
22>    end
23> 
24>    /* recalculate printnames on those structures where printStop has
25>       been changed */
26>  
27>    declare pstop_cursor cursor
28>    for select inserted._Structure_key
29>        from deleted, inserted
30>        where deleted.printStop != inserted.printStop
31>        and deleted._Structure_key = inserted._Structure_key
32>  
33>    declare @sk integer
34>    open pstop_cursor
35>    fetch pstop_cursor into @sk
36>    while (@@sqlstatus = 0)
37>    begin
38>        exec GXD_ComputePrintNamesFrom @sk
39>        if @@error != 0
40>        begin
41>            rollback transaction
42>            raiserror 99999 "GXD_Structure_Update: GXD_ComputePrintNamesFrom fail
43> ed"
44>            close pstop_cursor
45>            return
46>        end
47>        fetch pstop_cursor into @sk
48>    end
49>    close pstop_cursor
50> 
1> 
2> drop trigger GXD_Structure_Delete
1> 
2> create trigger GXD_Structure_Delete
3> on GXD_Structure
4> for delete
5> as
6> 
7> /* Disallow deletion if record is not an MGI-added record, but
8>    only if the user does not have the sa_role */
9> 
10> if exists (select * from deleted where edinburghkey != NULL)
11> begin
12> 	if (select proc_role("sa_role")) != 1
13>         begin
14>            rollback transaction
15>            raiserror 99999 "GXD_Structure_Delete: Structure is not an MGI-added record"
16> 	       return
17>         end
18> end
19> 
20> /* Disallow deletion if record is not a leaf node, i.e. it has descendents */
21> 
22> if exists (select * from GXD_StructureClosure, deleted
23>     where GXD_StructureClosure._Structure_key = deleted._Structure_key)
24> begin
25>         rollback transaction
26>         raiserror 99999 "GXD_Structure_Delete: Structure is not a leaf node; it has descendents"
27>         return
28> end
29> 
30> /* Disallow deletion if record is referenced elsewhere */
31> 
32> if exists (select * from GXD_ISResultStructure, deleted
33>     where GXD_ISResultStructure._Structure_key = deleted._Structure_key)
34> begin
35>         rollback transaction
36>         raiserror 99999 "GXD_Structure_Delete: Structure is referenced in InSitu Result Record(s)"
37>         return
38> end
39>  
40> if exists (select * from GXD_GelLaneStructure, deleted
41>     where GXD_GelLaneStructure._Structure_key = deleted._Structure_key)
42> begin
43>         rollback transaction
44>         raiserror 99999 "GXD_Structure_Delete: Structure is referenced in Gel Lane Structure Record(s)"
45>         return
46> end
47> 
48> if exists (select * from GXD_Expression, deleted
49>     where GXD_Expression._Structure_key = deleted._Structure_key)
50> begin
51>         rollback transaction
52>         raiserror 99999 "GXD_Structure_Delete: Structure is referenced in Expression Results (cache) Record(s)"
53> 	    return
54> end
55> 
56> /* incrementally modify the closure */
57> delete GXD_StructureClosure 
58> from GXD_StructureClosure sc, deleted
59> where sc._Descendent_key = deleted._Structure_key
60> 
61> if @@error != 0
62> begin
63>     rollback transaction
64>     raiserror 99999 "GXD_Structure_Delete: Delete of closure records failed"
65>     return
66> end
67> 
68> /* cascade deletes into the StructureName table */
69> delete GXD_StructureName
70> from GXD_StructureName sn, deleted
71> where sn._Structure_key = deleted._Structure_key
72> 
73> if @@error != 0
74> begin
75>     rollback transaction
76>     raiserror 99999 "GXD_Structure_Delete: Cascaded delete of StructureNames failed"
77>     return
78> end
79> 
1> 
2> /* GXD_StructureName */
3> 
4> drop trigger GXD_StructureName_Insert
1> 
2> create trigger GXD_StructureName_Insert
3> on GXD_StructureName
4> for insert
5> as
6> 
7> /* ensure that the structure specified exists */
8> if not exists(select * 
9>               from GXD_Structure s, inserted
10>               where s._Structure_key = inserted._Structure_key)
11> begin
12>     rollback transaction
13>     raiserror 99999 "GXD_StructureName_Insert: Inserted StructureName specifies a non-existent Structure"
14>     return
15> end
16> 
17> /* look for duplicate (structure key, structure) tuples */
18> 
19> if (select count(*) from 
20>    GXD_StructureName sn, inserted
21>    where sn._Structure_key = inserted._Structure_key
22>    and sn.structure = inserted.structure) >  1
23> begin
24>     rollback transaction
25>     raiserror 99999 "GXD_StructureName_Insert: Inserted StructureName has duplicate structure attribute"
26>     return
27> end
28> 
29> /* Prevent two children from having the same preferred name */
30> 
31> 
32> if (select count(*)
33>     from GXD_Structure s1, GXD_Structure s2, GXD_StructureName sn2, inserted
34>     where s1._Parent_key = s2._Parent_key
35>     and sn2._StructureName_key = s2._StructureName_key
36>     and inserted._StructureName_key = s1._StructureName_key 
37>     and inserted.structure = sn2.structure) > 1
38> begin
39>     rollback transaction
40>     raiserror 99999 "GXD_StructureName_Insert: Parent node cannot have two children with the same preferred name"
41>     return
42> end
43> 
44> /* call stored procedure that recalculates printNames, if a preferred
45>    structure name is changed.  Preferred StructureNames are those
46>    that are referred to by a record in GXD_Structure */
47> 
48> declare updatesk_cursor cursor
49> for select s._Structure_key 
50>     from GXD_Structure s, inserted
51>     where s._StructureName_key = inserted._StructureName_key
52> 
53> declare @isk integer
54> 
55> open updatesk_cursor
56> fetch updatesk_cursor into @isk
57> 
58> while (@@sqlstatus = 0)
59> begin
60>    exec GXD_ComputePrintNamesFrom @isk 
61>    if @@error != 0
62>    begin
63>         rollback transaction
64>         raiserror 99999 "GXD_StructureName_Insert: GXD_ComputePrintNamesFrom failed"
65>         close updatesk_cursor
66>         return
67>    end
68>    fetch updatesk_cursor into @isk
69> end
70> 
71> close updatesk_cursor
72> 
1> 
2> drop trigger GXD_StructureName_Update
1> 
2> create trigger GXD_StructureName_Update
3> on GXD_StructureName
4> for update
5> as
6> 
7> if (select count(*) from GXD_Structure s, inserted
8>     where s._Structure_key = inserted._Structure_key) !=
9>    (select count(*) from inserted)
10> begin
11>     rollback transaction
12>     raiserror 99999 "GXD_StructureName_Update: Non-existent Structure in StructureName record"
13>     return
14> end
15> 
16> 
17> if (select count(*) from 
18>     GXD_StructureName sn, inserted
19>     where sn._Structure_key = inserted._Structure_key
20>     and sn.structure = inserted.structure) > 
21>    (select count(*) from inserted)
22> begin
23>     rollback transaction
24>     raiserror 99999 "GXD_StructureName_Update: Inserted StructureName has duplicate structure attribute"
25>     return
26> end
27> 
28> update GXD_StructureName
29> set sn.modification_date = getdate()  
30> from GXD_StructureName sn, inserted
31> where sn._Structure_key = inserted._Structure_key 
32> 
33> /* call stored procedure that recalculates printNames, if a preferred
34>    structure name is changed.  Preferred StructureNames are those
35>    that are referred to by a record in GXD_Structure */
36> 
37> declare updatesk_cursor cursor
38> for select s._Structure_key 
39>     from GXD_Structure s, inserted
40>     where s._StructureName_key = inserted._StructureName_key
41> 
42> declare @isk integer
43> 
44> open updatesk_cursor
45> fetch updatesk_cursor into @isk
46> 
47> while (@@sqlstatus = 0)
48> begin
49>    exec GXD_ComputePrintNamesFrom @isk 
50>    if @@error != 0
51>    begin
52>         rollback transaction
53>         raiserror 99999 "GXD_StructureName_Update: GXD_ComputePrintNamesFrom failed"
54>         close updatesk_cursor
55>         return
56>    end
57>    fetch updatesk_cursor into @isk
58> end
59> 
60> close updatesk_cursor
61> 
1> 
2> drop trigger GXD_StructureName_Delete
1> 
2> create trigger GXD_StructureName_Delete
3> on GXD_StructureName
4> for delete
5> as
6> 
7> /* check to see if a Structure references the StructureNames being deleted */
8> 
9> if exists (select * from GXD_Structure, deleted
10>     where GXD_Structure._StructureName_key = deleted._StructureName_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "GXD_StructureName_Delete: Structure Name is referenced in Structure Record(s)"
14> 	return
15> end
16> 
1> 
2> /* GXD_StructureClosure */
3> 
4> drop trigger GXD_StructureClosure_Insert
1> 
2> create trigger GXD_StructureClosure_Insert
3> on GXD_StructureClosure
4> for insert
5> as
6> 
7> /* check to see if a Structure exists for the inserted structure keys */
8> if not exists(select * 
9>               from GXD_Structure s, inserted
10>               where s._Structure_key = inserted._Structure_key)
11> begin
12>     rollback transaction
13>     raiserror 99999 "GXD_StructureClosure_Insert: Non-existent Structure in StructureClosure record"
14>     return
15> end
1> 
2> drop trigger GXD_StructureClosure_Update
1> 
2> create trigger GXD_StructureClosure_Update
3> on GXD_StructureClosure
4> for update 
5> as
6> 
7> /* check to see if a Structure exists for the updated structure keys */
8> 
9> if (select count(*) 
10>     from GXD_Structure s, inserted 
11>     where s._Structure_key = inserted._Structure_key) !=
12>    (select count(*) from inserted)
13> begin
14>     rollback transaction
15>     raiserror 99999 "GXD_StructureClosure_Update: Non-existent Structure in StructureClosure record"
16>     return
17> end
1> drop trigger GXD_StructureClosure_Delete
1> 
2> create trigger GXD_StructureClosure_Delete
3> on GXD_StructureClosure
4> for delete
5> as
6> 
7> if exists (select * from GXD_Structure, deleted
8>     where GXD_Structure._Structure_key = deleted._Descendent_key)
9> begin
10>         rollback transaction
11>         raiserror 99999 "GXD_StructureClosure_Delete: Structure is referenced in GXD_Structure"
12>         return
13> end
14> 
1> 
2> /* GXD_TheilerStage */
3> 
4> drop trigger GXD_TheilerStage_Delete
1> 
2> create trigger GXD_TheilerStage_Delete
3> on GXD_TheilerStage
4> for delete
5> as
6> 
7> /* Totally disallow deletions of these records ??? */
8> 
9> rollback transaction
10> raiserror 99999 "Cannot delete Theiler Stage Record(s)"
11> return
12> 
13> if exists (select * from GXD_Structure, deleted
14>     where GXD_Structure._Stage_key = deleted._Stage_key)
15> begin
16>         rollback transaction
17>         raiserror 99999 "Theiler Stage is referenced in Structure Record(s)"
18>         return
19> end
20> 
1> 
2> drop trigger GXD_ProbePrep_Delete
1> 
2> create trigger GXD_ProbePrep_Delete
3> on GXD_ProbePrep
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Assay, deleted
10>     where GXD_Assay._ProbePrep_key = deleted._ProbePrep_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Probe Prep is referenced in Assay Record(s)"
14>         return
15> end
16> 
1> 
2> drop trigger GXD_AntibodyPrep_Delete
1> 
2> create trigger GXD_AntibodyPrep_Delete
3> on GXD_AntibodyPrep
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Assay, deleted
10>     where GXD_Assay._AntibodyPrep_key = deleted._AntibodyPrep_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody Prep is referenced in Assay Record(s)"
14>         return
15> end
16> 
1> 
2> drop trigger GXD_Assay_Insert
1>  
2> create trigger GXD_Assay_Insert
3> on GXD_Assay
4> for insert
5> as
6>  
7> declare @key integer
8> select @key = _Assay_key from inserted
9> 
10> /* Assign MGI Accession number for Assay */
11> exec ACC_assignMGI @key, "Assay"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
19> /* Insert entry in Reference bucket if it doesn't already exist */
20>  
21> if not exists (select * from MRK_Reference, inserted
22>     where MRK_Reference._Marker_key = inserted._Marker_key and
23>           MRK_Reference._Refs_key = inserted._Refs_key)
24> begin
25>   insert MRK_Reference (_Marker_key, _Refs_key, auto) 
26>   select _Marker_key, _Refs_key, 1 from inserted
27>   where _Refs_key is not null
28> end
29> 
1>  
2> drop trigger GXD_Assay_Update
1>  
2> create trigger GXD_Assay_Update
3> on GXD_Assay
4> for update
5> as
6>  
7> /* Insert entry in Reference bucket if it doesn't already exist */
8>  
9> if @@rowcount = 1
10>    and
11>    (update(_Refs_key) or update(_Marker_key))
12>    and
13>    not exists (select * from MRK_Reference, inserted
14>     where MRK_Reference._Marker_key = inserted._Marker_key and
15>           MRK_Reference._Refs_key = inserted._Refs_key)
16> begin
17>         insert MRK_Reference (_Marker_key, _Refs_key, auto) 
18>         select _Marker_key, _Refs_key, 1 from inserted
19>         where _Refs_key is not null
20> end
21>  
22> declare @key integer
23> select @key = _Assay_key from inserted
24> 
25> /* Update Expression Cache for Assay */
26> /* The update of a GXD_Assay record should be called AFTER any updates to GXD detail records */
27> 
28> exec GXD_loadCacheByAssay @key
29> 
1>  
2> drop trigger GXD_Assay_Delete
1> 
2> create trigger GXD_Assay_Delete
3> on GXD_Assay
4> for delete
5> as
6> 
7> delete GXD_Specimen from GXD_Specimen, deleted
8> where GXD_Specimen._Assay_key = deleted._Assay_key
9>  
10> delete GXD_GelLane from GXD_GelLane, deleted
11> where GXD_GelLane._Assay_key = deleted._Assay_key
12>  
13> delete GXD_GelRow from GXD_GelRow, deleted
14> where GXD_GelRow._Assay_key = deleted._Assay_key
15>  
16> delete GXD_AssayNote from GXD_AssayNote, deleted
17> where GXD_AssayNote._Assay_key = deleted._Assay_key
18>  
19> delete GXD_Expression from GXD_Expression, deleted
20> where GXD_Expression._Assay_key = deleted._Assay_key
21>  
22> delete GXD_ProbePrep from GXD_ProbePrep, deleted
23> where GXD_ProbePrep._ProbePrep_key = deleted._ProbePrep_key
24> 
25> delete GXD_AntibodyPrep from GXD_AntibodyPrep, deleted
26> where GXD_AntibodyPrep._AntibodyPrep_key = deleted._AntibodyPrep_key
27> 
28> delete ACC_Accession
29> from ACC_Accession a, ACC_MGIType m, deleted
30> where a._Object_key = deleted._Assay_key
31> and a._MGIType_key = m._MGIType_key
32> and m.name = "Assay"
33>  
1> 
2> drop trigger GXD_GelLane_Delete
1> 
2> create trigger GXD_GelLane_Delete
3> on GXD_GelLane
4> for delete
5> as
6> 
7> delete GXD_GelLaneStructure from GXD_GelLaneStructure, deleted
8> where GXD_GelLaneStructure._GelLane_key = deleted._GelLane_key
9>  
10> delete GXD_GelBand from GXD_GelBand, deleted
11> where GXD_GelBand._GelLane_key = deleted._GelLane_key
12> 
13> /* If Genotypes are specific to each specimen... */
14> 
15> if not exists (select * from GXD_GelLane, deleted
16> 	where GXD_GelLane._Genotype_key = deleted._Genotype_key)
17> begin
18> 	delete GXD_Genotype from GXD_Genotype, deleted
19> 	where GXD_Genotype._Genotype_key = deleted._Genotype_key
20> 	      and GXD_Genotype._Genotype_key >= 0
21> end
22> 
1> 
2> drop trigger GXD_GelRow_Insert
1> 
2> create trigger GXD_GelRow_Insert
3> on GXD_GelRow
4> for insert
5> as
6> 
7> if (select size from inserted) is not null and
8>    (select _GelUnits_key from inserted) < 0
9> begin
10>   rollback transaction
11>   raiserror 99999 "If Gel Row Size is entered, Gel Row Units must be specified."
12>   return
13> end
14> 
1> 
2> drop trigger GXD_GelRow_Update
1> 
2> create trigger GXD_GelRow_Update
3> on GXD_GelRow
4> for update
5> as
6> 
7> if (select size from inserted) is not null and
8>    (select _GelUnits_key from inserted) < 0
9> begin
10>   rollback transaction
11>   raiserror 99999 "If Gel Row Size is entered, Gel Row Units must be specified."
12>   return
13> end
14> 
1> 
2> drop trigger GXD_GelRow_Delete
1> 
2> create trigger GXD_GelRow_Delete
3> on GXD_GelRow
4> for delete
5> as
6> 
7> delete GXD_GelBand from GXD_GelBand, deleted
8> where GXD_GelBand._GelRow_key = deleted._GelRow_key
9> 
1> 
2> drop trigger GXD_Specimen_Delete
1> 
2> create trigger GXD_Specimen_Delete
3> on GXD_Specimen
4> for delete
5> as
6> 
7> /* If Genotypes are specific to each specimen... */
8> 
9> if not exists (select * from GXD_Specimen, deleted
10> 	where GXD_Specimen._Genotype_key = deleted._Genotype_key)
11> begin
12> 	delete GXD_Genotype from GXD_Genotype, deleted
13> 	where GXD_Genotype._Genotype_key = deleted._Genotype_key
14> 	      and GXD_Genotype._Genotype_key >= 0
15> end
16> 
17> delete GXD_InSituResult from GXD_InSituResult, deleted
18> where GXD_InSituResult._Specimen_key = deleted._Specimen_key
19> 
1> 
2> drop trigger GXD_InSituResult_Delete
1> 
2> create trigger GXD_InSituResult_Delete
3> on GXD_InSituResult
4> for delete
5> as
6> 
7> delete GXD_InSituResultImage from GXD_InSituResultImage, deleted
8> where GXD_InSituResultImage._Result_key = deleted._Result_key
9> 
10> delete GXD_ISResultStructure from GXD_ISResultStructure, deleted
11> where GXD_ISResultStructure._Result_key = deleted._Result_key
12> 
1> 
2> drop trigger GXD_Index_Delete
1> 
2> create trigger GXD_Index_Delete
3> on GXD_Index
4> for delete
5> as
6> 
7> delete GXD_Index_Stages from GXD_Index_Stages, deleted
8> where GXD_Index_Stages.index_id = deleted.index_id
9> 
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop trigger GXD_AntibodyClass_Delete
1> 
2> create trigger GXD_AntibodyClass_Delete
3> on GXD_AntibodyClass
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Antibody, deleted
10>     where GXD_Antibody._AntibodyClass_key = deleted._AntibodyClass_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody Class is referenced in Antibody Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger GXD_AntibodyType_Delete
1>  
2> create trigger GXD_AntibodyType_Delete
3> on GXD_AntibodyType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_Antibody, deleted
10>     where GXD_Antibody._AntibodyType_key = deleted._AntibodyType_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody Type is referenced in Antibody Record(s)"
14>         return
15> end
16>  
1> 
2> drop trigger GXD_AssayType_Delete
1>  
2> create trigger GXD_AssayType_Delete
3> on GXD_AssayType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_Assay, deleted
10>     where GXD_Assay._AssayType_key = deleted._AssayType_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Assay Type is referenced in Assay Record(s)"
14>         return
15> end
16>  
17> if exists (select * from GXD_Expression, deleted
18>     where GXD_Expression._AssayType_key = deleted._AssayType_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Assay Type is referenced in Expression Results (cache) Record(s)"
22>         return
23> end
24>  
1>  
2> drop trigger GXD_EmbeddingMethod_Delete
1>  
2> create trigger GXD_EmbeddingMethod_Delete
3> on GXD_EmbeddingMethod
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_Specimen, deleted
10>     where GXD_Specimen._Embedding_key = deleted._Embedding_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Embedding Method is referenced in Specimen Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_FixationMethod_Delete
1>  
2> create trigger GXD_FixationMethod_Delete
3> on GXD_FixationMethod
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_Specimen, deleted
10>     where GXD_Specimen._Fixation_key = deleted._Fixation_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Fixation Method is referenced in Specimen Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_GelRNAType_Delete
1>  
2> create trigger GXD_GelRNAType_Delete
3> on GXD_GelRNAType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_GelLane, deleted
10>     where GXD_GelLane._GelRNAType_key = deleted._GelRNAType_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Gel RNA Type is referenced in Gel Lane Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_GelUnits_Delete
1>  
2> create trigger GXD_GelUnits_Delete
3> on GXD_GelUnits
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_GelRow, deleted
10>     where GXD_GelRow._GelUnits_key = deleted._GelUnits_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Gel Unit is referenced in Gel Row Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_GelControl_Delete
1>  
2> create trigger GXD_GelControl_Delete
3> on GXD_GelControl
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_GelLane, deleted
10>     where GXD_GelLane._GelControl_key = deleted._GelControl_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Gel Control is referenced in Gel Lane Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_LabelCoverage_Delete
1>  
2> create trigger GXD_LabelCoverage_Delete
3> on GXD_LabelCoverage
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_ProbePrep, deleted
10>     where GXD_ProbePrep._Coverage_key = deleted._Coverage_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Label Coverage is referenced in Probe Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Pattern_Delete
1>  
2> create trigger GXD_Pattern_Delete
3> on GXD_Pattern
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_InSituResult, deleted
10>     where GXD_InSituResult._Pattern_key = deleted._Pattern_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Expression Pattern is referenced in InSitu Result Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Label_Delete
1>  
2> create trigger GXD_Label_Delete
3> on GXD_Label
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_AntibodyPrep, deleted
10>     where GXD_AntibodyPrep._Label_key = deleted._Label_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Label is referenced in Antibody Prep Record(s)"
14> 	return
15> end
16> 
17> if exists (select * from GXD_ProbePrep, deleted
18>     where GXD_ProbePrep._Label_key = deleted._Label_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Label is referenced in Probe Prep Record(s)"
22>         return
23> end
24>  
1>  
2> drop trigger GXD_ProbeSense_Delete
1>  
2> create trigger GXD_ProbeSense_Delete
3> on GXD_ProbeSense
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_ProbePrep, deleted
10>     where GXD_ProbePrep._Sense_key = deleted._Sense_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Probe Sense is referenced in Probe Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Secondary_Delete
1>  
2> create trigger GXD_Secondary_Delete
3> on GXD_Secondary
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_AntibodyPrep, deleted
10>     where GXD_AntibodyPrep._Secondary_key = deleted._Secondary_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Secondary is referenced in Antibody Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Strength_Delete
1>  
2> create trigger GXD_Strength_Delete
3> on GXD_Strength
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_InSituResult, deleted
10>     where GXD_InSituResult._Strength_key = deleted._Strength_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Strength is referenced in InSitu Result Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_VisualizationMethod_Delete
1>  
2> create trigger GXD_VisualizationMethod_Delete
3> on GXD_VisualizationMethod
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_ProbePrep, deleted
10>     where GXD_ProbePrep._Visualization_key = deleted._Visualization_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Visualization Method is referenced in Probe Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger IMG_FieldType_Delete
1>  
2> create trigger IMG_FieldType_Delete
3> on IMG_FieldType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from IMG_ImagePane, deleted
10>     where IMG_ImagePane._FieldType_key = deleted._FieldType_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Image Field Type is referenced in Image Pane Record(s)"
14>         return
15> end
16>  
1>  
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop trigger HMD_Class_Delete
1> 
2> create trigger HMD_Class_Delete
3> on HMD_Class
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete HMD_Homology from HMD_Homology, deleted
10> where HMD_Homology._Class_key = deleted._Class_key
11> 
1> 
2> drop trigger HMD_Homology_Delete
1> 
2> create trigger HMD_Homology_Delete
3> on HMD_Homology
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete HMD_Homology_Marker from HMD_Homology_Marker, deleted
10> where HMD_Homology_Marker._Homology_key = deleted._Homology_key
11> 
12> delete HMD_Homology_Assay from HMD_Homology_Assay, deleted
13> where HMD_Homology_Assay._Homology_key = deleted._Homology_key
14> 
15> delete HMD_Notes from HMD_Notes, deleted
16> where HMD_Notes._Homology_key = deleted._Homology_key
17> 
1> 
2> /* TR 104 - moved logic to MRK_Marker_Insert */
3> 
4> /* drop trigger HMD_Homology_Marker_Insert */
5> 
6> drop trigger HMD_Assay_Delete
1> 
2> create trigger HMD_Assay_Delete
3> on HMD_Assay
4> for delete
5> as
6> 
7> /* Disallow removal of the homology assay if it is being referenced in homology */
8> 
9> if exists (select * from HMD_Homology_Assay, deleted
10>     where HMD_Homology_Assay._Assay_key = deleted._Assay_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Assay is referenced in Homology Record(s)"
14> 	return
15> end
16>  
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop trigger IMG_Image_Insert
1>  
2> create trigger IMG_Image_Insert
3> on IMG_Image
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Image */
8>  
9> declare @key integer
10> select @key = _Image_key from inserted
11> exec ACC_assignMGI @key, "Image"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1>  
2> drop trigger IMG_Image_Delete
1> 
2> create trigger IMG_Image_Delete
3> on IMG_Image
4> for delete
5> as
6> 
7> delete IMG_ImageNote from IMG_ImageNote, deleted
8> where IMG_ImageNote._Image_key = deleted._Image_key
9>  
10> delete IMG_ImagePane from IMG_ImagePane, deleted
11> where IMG_ImagePane._Image_key = deleted._Image_key
12>  
13> delete ACC_Accession
14> from ACC_Accession a, ACC_MGIType m, deleted
15> where a._Object_key = deleted._Image_key
16> and a._MGIType_key = m._MGIType_key
17> and m.name = "Image"
18>  
1> 
2> drop trigger IMG_ImagePane_Delete
1> 
2> create trigger IMG_ImagePane_Delete
3> on IMG_ImagePane
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Assay, deleted
10>     where GXD_Assay._ImagePane_key = deleted._ImagePane_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Image Pane is referenced in Assay Record(s)"
14> 	return
15> end
16> 
17> if exists (select * from GXD_InSituResultImage, deleted
18>     where GXD_InSituResultImage._ImagePane_key = deleted._ImagePane_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Image Pane is referenced in InSitu Result Record(s)"
22> 	return
23> end
24> 
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop trigger MLD_Marker_Update
1> 
2> create trigger MLD_Marker_Update
3> on MLD_Marker
4> for update
5> as
6> 
7> /* If updating the Reference, propagate update to appropriate tables */
8> 
9> if update(_Refs_key)
10> begin
11> 	update MLD_Expts
12> 	  set _Refs_key = inserted._Refs_key
13> 	  from MLD_Expts, inserted, deleted
14> 	  where MLD_Expts._Refs_key = deleted._Refs_key
15> 
16> 	update MLD_Notes
17> 	  set _Refs_key = inserted._Refs_key
18> 	  from MLD_Notes, inserted, deleted
19> 	  where MLD_Notes._Refs_key = deleted._Refs_key
20> end
21> 
22> /* If the Marker in the Primary list is modified, then propagate */
23> /* the changes to the gene list of each experiment of the reference */
24> 
25> if update(_Marker_key)
26> begin
27> 	update MLD_Expt_Marker
28>           set _Marker_key = inserted._Marker_key
29> 	  from MLD_Expt_Marker, MLD_Expts, inserted, deleted
30> 	  where MLD_Expts._Refs_key = inserted._Refs_key and
31> 		MLD_Expts._Expt_key = MLD_Expt_Marker._Expt_key and
32> 		MLD_Expt_Marker._Marker_key = deleted._Marker_key
33> end
34> 
1> 
2> drop trigger MLD_Expts_Insert
1> 
2> create trigger MLD_Expts_Insert
3> on MLD_Expts
4> for insert
5> as
6> 
7> /* Assign MGI Accession number for each Experiment */
8> 
9> declare @key integer
10> select @key = _Expt_key from inserted
11> exec ACC_assignMGI @key, "Experiment"
12> 
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1> 
2> drop trigger MLD_Expts_Delete
1> 
2> create trigger MLD_Expts_Delete
3> on MLD_Expts
4> for delete
5> as
6> 
7> /* Re-order the tag numbers for experiments if one is deleted */
8> 
9> update MLD_Expts
10> set MLD_Expts.tag = MLD_Expts.tag - 1
11> from MLD_Expts, deleted
12> where MLD_Expts._Refs_key = deleted._Refs_key
13> and MLD_Expts.exptType = deleted.exptType
14> and MLD_Expts.tag > deleted.tag
15> 
16> /* Delete entries in all dependent experiment tables */
17> 
18> delete MLD_Expt_Marker from MLD_Expt_Marker, deleted
19> where MLD_Expt_Marker._Expt_key = deleted._Expt_key
20> 
21> delete MLD_Expt_Notes from MLD_Expt_Notes, deleted
22> where MLD_Expt_Notes._Expt_key = deleted._Expt_key
23> 
24> delete MLD_FISH from MLD_FISH, deleted
25> where MLD_FISH._Expt_key = deleted._Expt_key
26> 
27> delete MLD_FISH_Region from MLD_FISH_Region, deleted
28> where MLD_FISH_Region._Expt_key = deleted._Expt_key
29> 
30> delete MLD_Hybrid from MLD_Hybrid, deleted
31> where MLD_Hybrid._Expt_key = deleted._Expt_key
32> 
33> delete MLD_Concordance from MLD_Concordance, deleted
34> where MLD_Concordance._Expt_key = deleted._Expt_key
35> 
36> delete MLD_InSitu from MLD_InSitu, deleted
37> where MLD_InSitu._Expt_key = deleted._Expt_key
38> 
39> delete MLD_ISRegion from MLD_ISRegion, deleted
40> where MLD_ISRegion._Expt_key = deleted._Expt_key
41> 
42> delete MLD_Matrix from MLD_Matrix, deleted
43> where MLD_Matrix._Expt_key = deleted._Expt_key
44> 
45> delete MLD_MC2point from MLD_MC2point, deleted
46> where MLD_MC2point._Expt_key = deleted._Expt_key
47> 
48> delete MLD_MCDataList from MLD_MCDataList, deleted
49> where MLD_MCDataList._Expt_key = deleted._Expt_key
50> 
51> delete MLD_RI from MLD_RI, deleted
52> where MLD_RI._Expt_key = deleted._Expt_key
53> 
54> delete MLD_RIData from MLD_RIData, deleted
55> where MLD_RIData._Expt_key = deleted._Expt_key
56> 
57> delete MLD_RI2Point from MLD_RI2Point, deleted
58> where MLD_RI2Point._Expt_key = deleted._Expt_key
59> 
60> delete MLD_Hit from MLD_Hit, deleted
61> where MLD_Hit._Expt_key = deleted._Expt_key
62> 
63> delete MLD_Contig from MLD_Contig, deleted
64> where MLD_Contig._Expt_key = deleted._Expt_key
65> 
66> delete MLD_Statistics from MLD_Statistics, deleted
67> where MLD_Statistics._Expt_key = deleted._Expt_key
68> 
69> delete ACC_Accession
70> from ACC_Accession a, ACC_MGIType m, deleted
71> where a._Object_key = deleted._Expt_key
72> and a._MGIType_key = m._MGIType_key
73> and m.name = "Experiment"
74>  
1> 
2> drop trigger MLD_Expt_Marker_Insert
1>  
2> create trigger MLD_Expt_Marker_Insert
3> on MLD_Expt_Marker
4> for insert
5> as
6>  
7> /* If the chromosome in the Marker table is UN, then...  */
8>  
9> if exists (select * from MRK_Marker, MLD_Expts, inserted
10>     where MLD_Expts._Expt_key = inserted._Expt_key and
11>     MRK_Marker._Marker_key = inserted._Marker_key and
12>     MRK_Marker.chromosome = "UN")
13> begin
14>  
15>     /* Update the chromosome to the MLDP chromosome assignment */
16>  
17>     update MRK_Marker
18>     set chromosome = MLD_Expts.chromosome
19>     from MRK_Marker, MLD_Expts, inserted
20>     where MLD_Expts._Expt_key = inserted._Expt_key and
21>           MRK_Marker._Marker_key = inserted._Marker_key
22> end
23>  
1> 
2> drop trigger MLD_Expt_Marker_Update
1> 
2> create trigger MLD_Expt_Marker_Update
3> on MLD_Expt_Marker
4> for update
5> as
6> 
7> /* If modifying Assay type and this is the only instance of the */
8> /* Assay type in MGD, then remove it from the Assay table */
9> 
10> if update(_Assay_Type_key) and 
11>    not exists (select * from MLD_Expt_Marker, deleted
12>     where MLD_Expt_Marker._Assay_Type_key = deleted._Assay_Type_key)
13> begin
14>   delete MLD_Assay_Types from MLD_Assay_Types, deleted
15>   where MLD_Assay_Types._Assay_Type_key = deleted._Assay_Type_key
16> end
17> 
18> if update(_Marker_key)
19> begin
20> 	/* If the chromosome in the Marker table is UN, then...  */
21> 
22>   	if exists (select * from MRK_Marker, MLD_Expts, inserted
23>             where MLD_Expts._Expt_key = inserted._Expt_key and
24> 	    MRK_Marker._Marker_key = inserted._Marker_key and 
25> 	    MRK_Marker.chromosome = "UN")
26> 	begin
27> 
28> 	  /* Update the chromosome to the MLDP chromosome assignment */
29> 
30>   	  update MRK_Marker 
31>   	  set chromosome = MLD_Expts.chromosome
32>   	  from MRK_Marker, MLD_Expts, inserted
33>           where MLD_Expts._Expt_key = inserted._Expt_key and
34> 	        MRK_Marker._Marker_key = inserted._Marker_key
35> 	end
36> 
37> 	/* Propagate modification of Marker to experiment tables */
38> 
39> 	update MLD_Concordance 
40>           set _Marker_key = inserted._Marker_key
41> 	  from MLD_Concordance, inserted, deleted
42> 	  where MLD_Concordance._Expt_key = inserted._Expt_key and
43> 		MLD_Concordance._Marker_key = deleted._Marker_key
44> 
45> 	update MLD_MC2point 
46>           set _Marker_key_1 = inserted._Marker_key
47> 	  from MLD_MC2point, inserted, deleted
48> 	  where MLD_MC2point._Expt_key = inserted._Expt_key and
49> 		MLD_MC2point._Marker_key_1 = deleted._Marker_key
50> 
51> 	update MLD_MC2point 
52>           set _Marker_key_2 = inserted._Marker_key
53> 	  from MLD_MC2point, inserted, deleted
54> 	  where MLD_MC2point._Expt_key = inserted._Expt_key and
55> 		MLD_MC2point._Marker_key_2 = deleted._Marker_key
56> 
57> 	update MLD_RIData 
58>           set _Marker_key = inserted._Marker_key
59> 	  from MLD_RIData, inserted, deleted
60> 	  where MLD_RIData._Expt_key = inserted._Expt_key and
61> 		MLD_RIData._Marker_key = deleted._Marker_key
62> 
63> 	update MLD_RI2Point 
64>           set _Marker_key_1 = inserted._Marker_key
65> 	  from MLD_RI2Point, inserted, deleted
66> 	  where MLD_RI2Point._Expt_key = inserted._Expt_key and
67> 		MLD_RI2Point._Marker_key_1 = deleted._Marker_key
68> 
69> 	update MLD_RI2Point 
70>           set _Marker_key_2 = inserted._Marker_key
71> 	  from MLD_RI2Point, inserted, deleted
72> 	  where MLD_RI2Point._Expt_key = inserted._Expt_key and
73> 		MLD_RI2Point._Marker_key_2 = deleted._Marker_key
74> 
75>         update MLD_Statistics
76>           set _Marker_key_1 = inserted._Marker_key
77>           from MLD_Statistics, inserted, deleted
78>           where MLD_Statistics._Expt_key = inserted._Expt_key and
79>                 MLD_Statistics._Marker_key_1 = deleted._Marker_key
80> 
81>         update MLD_Statistics
82>           set _Marker_key_2 = inserted._Marker_key
83>           from MLD_Statistics, inserted, deleted
84>           where MLD_Statistics._Expt_key = inserted._Expt_key and
85>                 MLD_Statistics._Marker_key_2 = deleted._Marker_key
86> 
87>         update MLD_Distance
88>           set _Marker_key_1 = inserted._Marker_key
89>           from MLD_Distance, inserted, deleted
90>           where MLD_Distance._Expt_key = inserted._Expt_key and
91>                 MLD_Distance._Marker_key_1 = deleted._Marker_key
92> 
93>         update MLD_Distance
94>           set _Marker_key_2 = inserted._Marker_key
95>           from MLD_Distance, inserted, deleted
96>           where MLD_Distance._Expt_key = inserted._Expt_key and
97>                 MLD_Distance._Marker_key_2 = deleted._Marker_key
98> 
99> end
100> 
1> 
2> drop trigger MLD_Matrix_Delete
1> 
2> create trigger MLD_Matrix_Delete
3> on MLD_Matrix
4> for delete
5> as
6> 
7> /* Remove entries from Cross table upon deletion of Matrix */
8> /* record, if the cross is not a named (i.e. specific) Cross */
9> 
10> if exists (select * from CRS_Cross, deleted 
11>     where CRS_Cross._Cross_key = deleted._Cross_key and CRS_Cross.whoseCross is null)
12> begin
13> 	delete CRS_Cross from CRS_Cross, deleted
14> 	where CRS_Cross._Cross_key = deleted._Cross_key
15> end
16> 
1> 
2> drop trigger MLD_Contig_Delete
1> 
2> create trigger MLD_Contig_Delete
3> on MLD_Contig
4> for delete
5> as
6> 
7> /* Delete records in dependent tables */
8> 
9> delete MLD_ContigProbe from MLD_ContigProbe, deleted
10> where MLD_ContigProbe._Contig_key = deleted._Contig_key
11> 
1> 
2> drop trigger MLD_RI_Insert
1> 
2> create trigger MLD_RI_Insert
3> on MLD_RI
4> for insert
5> as
6> 
7> update MLD_RI
8> set designation = RI_RISet.designation,
9>     origin = RI_RISet.origin,
10>     abbrev1 = RI_RISet.abbrev1,
11>     abbrev2 = RI_RISet.abbrev2
12> from MLD_RI, RI_RISet, inserted
13> where MLD_RI._Expt_key = inserted._Expt_key and
14>       inserted._RISet_key = RI_RISet._RISet_key
1> 
2> drop trigger MLD_RI_Update
1> 
2> create trigger MLD_RI_Update
3> on MLD_RI
4> for update
5> as
6> 
7> /* If modifying RI key in MLDP table, then */
8> /* set appropriate column values in MLDP table */
9> /* as they appear in the RI table */
10> 
11> if update (_RISet_key)
12> begin
13>   update MLD_RI
14>   set designation = RI_RISet.designation,
15>       origin = RI_RISet.origin,
16>       abbrev1 = RI_RISet.abbrev1,
17>       abbrev2 = RI_RISet.abbrev2
18>   from MLD_RI, RI_RISet, inserted
19>   where MLD_RI._Expt_key = inserted._Expt_key and
20> 	inserted._RISet_key = RI_RISet._RISet_key
21> end
22> 
1> 
2> drop trigger MLD_Assay_Types_Delete
1> 
2> create trigger MLD_Assay_Types_Delete
3> on MLD_Assay_Types
4> for delete
5> as
6> 
7> /* Disallow removal of an Assay which is referenced in MLDP */
8> 
9> if exists (select * from MLD_Expt_Marker, deleted
10>     where MLD_Expt_Marker._Assay_Type_key = deleted._Assay_Type_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Assay is referenced in MLDP Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger MLD_InSitu_Insert
1> 
2> create trigger MLD_InSitu_Insert
3> on MLD_InSitu
4> for insert
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if (select MRK_Marker.cytogeneticOffset 
13>     from MRK_Marker, MLD_Expt_Marker, inserted
14>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key
15> 	  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
16> begin
17> 	update MRK_Marker
18> 	set cytogeneticOffset = inserted.band
19> 	from MRK_Marker, MLD_Expt_Marker, inserted
20>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
21> 	      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
22> end
23> 
1> 
2> drop trigger MLD_InSitu_Update
1> 
2> create trigger MLD_InSitu_Update
3> on MLD_InSitu
4> for update
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if update(band)
13> begin
14> 	if (select MRK_Marker.cytogeneticOffset 
15> 	    from MRK_Marker, MLD_Expt_Marker, inserted
16> 	    where inserted._Expt_key = MLD_Expt_Marker._Expt_key
17> 		  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
18> 	begin
19> 		update MRK_Marker
20> 		set cytogeneticOffset = inserted.band
21> 		from MRK_Marker, MLD_Expt_Marker, inserted
22> 	        where inserted._Expt_key = MLD_Expt_Marker._Expt_key
23> 		      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
24> 	end
25> end
26> 
1> 
2> drop trigger MLD_FISH_Insert
1> 
2> create trigger MLD_FISH_Insert
3> on MLD_FISH
4> for insert
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> /* If more than one Marker is defined in the experiment, then we can't */
13> /* assign any cytogenetic band information because we don't know which */
14> /* Marker is the relevant Marker */
15> 
16> if (select count(*) from MLD_Expt_Marker, inserted
17>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key) > 1
18> begin
19> 	return
20> end
21> 
22> if (select MRK_Marker.cytogeneticOffset 
23>     from MRK_Marker, MLD_Expt_Marker, inserted
24>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key
25> 	  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
26> begin
27> 	update MRK_Marker
28> 	set cytogeneticOffset = inserted.band
29> 	from MRK_Marker, MLD_Expt_Marker, inserted
30>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
31> 	      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
32> end
33> 
1> 
2> drop trigger MLD_FISH_Update
1> 
2> create trigger MLD_FISH_Update
3> on MLD_FISH
4> for update
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if update(band)
13> begin
14> 	/* If more than one Marker is defined in the experiment, then we can't */
15> 	/* assign any cytogenetic band information because we don't know which */
16> 	/* Marker is the relevant Marker */
17> 
18> 	if (select count(*) from MLD_Expt_Marker, inserted
19>     	    where inserted._Expt_key = MLD_Expt_Marker._Expt_key) > 1
20> 	begin
21> 		return
22> 	end
23> 
24> 	if (select MRK_Marker.cytogeneticOffset 
25> 	    from MRK_Marker, MLD_Expt_Marker, inserted
26> 	    where inserted._Expt_key = MLD_Expt_Marker._Expt_key
27> 		  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
28> 	begin
29> 		update MRK_Marker
30> 		set cytogeneticOffset = inserted.band
31> 		from MRK_Marker, MLD_Expt_Marker, inserted
32> 	        where inserted._Expt_key = MLD_Expt_Marker._Expt_key
33> 		      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
34> 	end
35> end
36> 
1> 
2> drop trigger MLD_Hybrid_Insert
1> 
2> create trigger MLD_Hybrid_Insert
3> on MLD_Hybrid
4> for insert
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if (select MRK_Marker.cytogeneticOffset 
13>     from MRK_Marker, MLD_Expt_Marker, inserted
14>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key
15> 	  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
16> begin
17> 	update MRK_Marker
18> 	set cytogeneticOffset = inserted.band
19> 	from MRK_Marker, MLD_Expt_Marker, inserted
20>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
21> 	      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
22> end
23> 
1> 
2> drop trigger MLD_Hybrid_Update
1> 
2> create trigger MLD_Hybrid_Update
3> on MLD_Hybrid
4> for update
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if update(band)
13> begin
14> 	if (select MRK_Marker.cytogeneticOffset 
15> 	    from MRK_Marker, MLD_Expt_Marker, inserted
16> 	    where inserted._Expt_key = MLD_Expt_Marker._Expt_key
17> 		  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
18> 	begin
19> 		update MRK_Marker
20> 		set cytogeneticOffset = inserted.band
21> 		from MRK_Marker, MLD_Expt_Marker, inserted
22> 	        where inserted._Expt_key = MLD_Expt_Marker._Expt_key
23> 		      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
24> 	end
25> end
26> 
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> /* obsolete triggers */
3> 
4> drop trigger MRK_Allele_Insert
Msg 3701, Level 11, State 1:
Line 4:
Cannot drop the trigger 'MRK_Allele_Insert', because it doesn't exist in the
system catalogs.
1>  
2> drop trigger MRK_Allele_Update
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Allele_Update', because it doesn't exist in the
system catalogs.
1>  
2> drop trigger MRK_Allele_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Allele_Delete', because it doesn't exist in the
system catalogs.
1>  
2> drop trigger MRK_Alias_Delete
1> 
2> drop trigger MRK_History_Insert
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_History_Insert', because it doesn't exist in the
system catalogs.
1>  
2> drop trigger MRK_History_Update
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_History_Update', because it doesn't exist in the
system catalogs.
1>  
2> drop trigger MRK_History_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_History_Delete', because it doesn't exist in the
system catalogs.
1>  
2> drop trigger MRK_Other_Insert
1>  
2> drop trigger MRK_Other_Delete
1>  
2> drop trigger MRK_Other_Update
1>  
2> /* end obsolete triggers - remove during next release */
3> 
4> drop trigger MRK_Marker_Insert
Msg 3701, Level 11, State 1:
Line 4:
Cannot drop the trigger 'MRK_Marker_Insert', because it doesn't exist in the
system catalogs.
1> 
2> create trigger MRK_Marker_Insert
3> on MRK_Marker
4> for insert
5> as
6> 
7> insert MRK_Label (_Marker_key, _Marker_Status_key, _Species_key, label, labelType) 
8> 	select _Marker_key, _Marker_Status_key, _Species_key, symbol, "S" from inserted
9> insert MRK_Label (_Marker_key, _Marker_Status_key, _Species_key, label, labelType) 
10> 	select _Marker_key, _Marker_Status_key, _Species_key, name, "N" from inserted
11> 
12> /* For Mouse Species, create Accession #, Current Symbol records */
13> 
14> if (select _Species_key from inserted) = 1
15> begin
16> 	insert MRK_Current (_Current_key, _Marker_key) 
17> 		select _Marker_key, _Marker_key from inserted
18> 
19> 	declare @key integer
20> 	select @key = _Marker_key from inserted
21> 	exec ACC_assignMGI @key, "Marker"
22> 
23> 	if (@@error != 0)
24> 	begin
25>   	  rollback transaction
26>   	  return
27> 	end
28> end
29> 
30> /* For non-mouse species, update MRK_Chromosome table */
31> 
32> if (select _Species_key from inserted) != 1
33> begin
34>         declare @speciesKey integer
35>         declare @chromosome varchar(8)
36>         select @speciesKey = _Species_key from inserted
37>         select @chromosome = chromosome from inserted
38>         exec MRK_addChromosome @speciesKey, @chromosome
39> end
40> 
1> 
2> drop trigger MRK_Marker_Update
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Marker_Update', because it doesn't exist in the
system catalogs.
1> 
2> create trigger MRK_Marker_Update
3> on MRK_Marker
4> for update
5> as
6> 
7> /* If not Mouse, disallow duplicate Species/Symbol records */
8> 
9> if (select _Species_key from inserted) != 1
10> begin
11> 	if update(symbol) and
12>            (select count(*) from MRK_Marker, inserted 
13> 	    where inserted._Species_key = MRK_Marker._Species_key and
14> 		  inserted.symbol = MRK_Marker.symbol) > 1
15> 	begin
16> 		rollback transaction
17> 		raiserror 99999 "Marker Symbol For This Species Already Exists.\nDelete Existing Row And Add A New Row For This Symbol."
18> 		return
19> 	end
20> end
21> 
22> /* If updating chromosome and changing from unknown to known, update offset to -1 */
23> 
24> if (select _Species_key from inserted) = 1 and update (chromosome)
25> begin
26>        if (select chromosome from deleted) = "UN" and
27>           (select chromosome from inserted) != "UN"
28> 	begin
29>         	update MRK_Offset set offset = -1
30>         	from inserted
31>         	where inserted._Marker_key = MRK_Offset._Marker_key and MRK_Offset.source = 0
32> 	end
33> end
34> 
35> /* For non-mouse species, update MRK_Chromosome table */
36> 
37> if (select _Species_key from inserted) != 1 and update(chromosome)
38> begin
39>         declare @speciesKey integer
40>         declare @chromosome varchar(8)
41>         select @speciesKey = _Species_key from inserted
42>         select @chromosome = chromosome from inserted
43>         exec MRK_addChromosome @speciesKey, @chromosome
44> end
45> 
1> 
2> drop trigger MRK_Marker_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Marker_Delete', because it doesn't exist in the
system catalogs.
1> 
2> create trigger MRK_Marker_Delete
3> on MRK_Marker
4> for delete
5> as
6> 
7> /* Disallow deletion if Marker is currently referenced elsewhere */
8> 
9> if exists (select * from MRK_Alias, deleted
10>     where MRK_Alias._Alias_key = deleted._Marker_key)
11> begin
12> 	rollback transaction
13> 	raiserror 99999 "Marker Symbol is referenced in Alias Record(s)"
14> 	return
15> end
16> 
17> /* Symbol is a Current Symbol of itself */
18> 
19> if exists (select * from MRK_Current, deleted
20>          where MRK_Current._Current_key = deleted._Marker_key)
21> begin
22> 	rollback transaction
23> 	raiserror 99999 "Marker Symbol is referenced in Current Symbol Record(s)"
24> 	return
25> end
26> 
27> if exists (select * from MRK_History, deleted
28>          where MRK_History._History_key = deleted._Marker_key and
29>                MRK_History._Marker_key != deleted._Marker_key)
30> begin
31> 	rollback transaction
32> 	raiserror 99999 "Marker Symbol is referenced in History Record(s)"
33> 	return
34> end
35> 
36> if exists (select * from PRB_Marker, deleted
37>          where PRB_Marker._Marker_key = deleted._Marker_key)
38> begin
39> 	rollback transaction
40> 	raiserror 99999 "Marker Symbol is referenced in Probe Marker Record(s)"
41> 	return
42> end
43> 
44> if exists (select * from PRB_RFLV, deleted
45>          where PRB_RFLV._Marker_key = deleted._Marker_key)
46> begin
47> 	rollback transaction
48> 	raiserror 99999 "Marker Symbol is referenced in Probe RFLV Record(s)"
49> 	return
50> end
51> 
52> if exists (select * from MLD_Marker, deleted
53>          where MLD_Marker._Marker_key = deleted._Marker_key)
54> begin
55> 	rollback transaction
56> 	raiserror 99999 "Marker Symbol is referenced in MLDP Marker Record(s)"
57> 	return
58> end
59> 
60> if exists (select * from MLD_Expt_Marker, deleted
61>          where MLD_Expt_Marker._Marker_key = deleted._Marker_key)
62> begin
63> 	rollback transaction
64> 	raiserror 99999 "Marker Symbol is referenced in MLDP Experiment Marker Record(s)"
65> 	return
66> end
67> 
68> if exists (select * from MLD_Concordance, deleted
69>          where MLD_Concordance._Marker_key = deleted._Marker_key)
70> begin
71> 	rollback transaction
72> 	raiserror 99999 "Marker Symbol is referenced in MLDP Hybrid Concordance Record(s)"
73> 	return
74> end
75> 
76> if exists (select * from MLD_MC2point, deleted
77>          where MLD_MC2point._Marker_key_1 = deleted._Marker_key)
78> begin
79> 	rollback transaction
80> 	raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
81> 	return
82> end
83> 
84> if exists (select * from MLD_MC2point, deleted
85>          where MLD_MC2point._Marker_key_2 = deleted._Marker_key)
86> begin
87> 	rollback transaction
88> 	raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
89> 	return
90> end
91> 
92> if exists (select * from MLD_RIData, deleted
93>          where MLD_RIData._Marker_key = deleted._Marker_key)
94> begin
95> 	rollback transaction
96> 	raiserror 99999 "Marker Symbol is referenced in MLDP RI Data Record(s)"
97> 	return
98> end
99> 
100> if exists (select * from MLD_RI2Point, deleted
101>          where MLD_RI2Point._Marker_key_1 = deleted._Marker_key)
102> begin
103> 	rollback transaction
104> 	raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
105> 	return
106> end
107> 
108> if exists (select * from MLD_RI2Point, deleted
109>          where MLD_RI2Point._Marker_key_2 = deleted._Marker_key)
110> begin
111> 	rollback transaction
112> 	raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
113> 	return
114> end
115> 
116> if exists (select * from MLD_Distance, deleted
117>          where MLD_Distance._Marker_key_1 = deleted._Marker_key)
118> begin
119> 	rollback transaction
120> 	raiserror 99999 "Marker Symbol is referenced in Physical Mapping Record(s)"
121> 	return
122> end
123> 
124> if exists (select * from MLD_Distance, deleted
125>          where MLD_Distance._Marker_key_2 = deleted._Marker_key)
126> begin
127> 	rollback transaction
128> 	raiserror 99999 "Marker Symbol is referenced in Physical Mapping Record(s)"
129> 	return
130> end
131> 
132> if exists (select * from HMD_Homology_Marker, deleted
133>          where HMD_Homology_Marker._Marker_key = deleted._Marker_key)
134> begin
135> 	rollback transaction
136> 	raiserror 99999 "Marker Symbol is referenced in Homology Record(s)"
137> 	return
138> end
139> 
140> if exists (select * from MLC_Text_edit, deleted
141>          where MLC_Text_edit._Marker_key = deleted._Marker_key)
142> begin
143> 	rollback transaction
144> 	raiserror 99999 "Marker Symbol is referenced in MLC Edit Record(s)"
145> 	return
146> end
147> 
148> if exists (select * from MLC_Marker_edit, deleted
149>          where MLC_Marker_edit._Marker_key_2 = deleted._Marker_key)
150> begin
151> 	rollback transaction
152> 	raiserror 99999 "Marker Symbol is referenced in MLC Edit Record(s)"
153> 	return
154> end
155> 
156> if exists (select * from CRS_Matrix, deleted
157>          where CRS_Matrix._Marker_key = deleted._Marker_key)
158> begin
159> 	rollback transaction
160> 	raiserror 99999 "Marker Symbol is referenced in Cross Matrix Record(s)"
161> 	return
162> end
163> 
164> if exists (select * from GXD_Index, deleted
165>          where GXD_Index._Marker_key = deleted._Marker_key)
166> begin
167> 	rollback transaction
168> 	raiserror 99999 "Marker Symbol is referenced in GXD Index Record(s)"
169> 	return
170> end
171> 
172> if exists (select * from GXD_AllelePair, deleted
173>          where GXD_AllelePair._Marker_key = deleted._Marker_key)
174> begin
175> 	rollback transaction
176> 	raiserror 99999 "Marker Symbol is referenced in GXD Allele Pair Record(s)"
177> 	return
178> end
179> 
180> if exists (select * from GXD_AntibodyMarker, deleted
181>          where GXD_AntibodyMarker._Marker_key = deleted._Marker_key)
182> begin
183> 	rollback transaction
184> 	raiserror 99999 "Marker Symbol is referenced in GXD Antibody Marker Record(s)"
185> 	return
186> end
187> 
188> if exists (select * from GXD_Assay, deleted
189>          where GXD_Assay._Marker_key = deleted._Marker_key)
190> begin
191> 	rollback transaction
192> 	raiserror 99999 "Marker Symbol is referenced in GXD Assay Record(s)"
193> 	return
194> end
195> 
196> if exists (select * from PRB_Strain_Marker, deleted
197>     where PRB_Strain_Marker._Marker_key = deleted._Marker_key)
198> begin
199> 	rollback transaction
200> 	raiserror 99999 "Marker Symbol is referenced in Strain Record(s)"
201> 	return
202> end
203> 
204> if exists (select * from GO_MarkerGO, deleted
205>     where GO_MarkerGO._Marker_key = deleted._Marker_key)
206> begin
207> 	rollback transaction
208> 	raiserror 99999 "Marker Symbol is referenced in GO Marker Record(s)"
209> 	return
210> end
211> 
212> delete MRK_Alias from MRK_Alias, deleted
213> where MRK_Alias._Marker_key = deleted._Marker_key
214> 
215> delete ALL_Allele from ALL_Allele, deleted
216> where ALL_Allele._Marker_key = deleted._Marker_key
217> 
218> delete MRK_Classes from MRK_Classes, deleted
219> where MRK_Classes._Marker_key = deleted._Marker_key
220> 
221> delete MRK_Current from MRK_Current, deleted
222> where MRK_Current._Marker_key = deleted._Marker_key
223> 
224> delete MRK_History from MRK_History, deleted
225> where MRK_History._Marker_key = deleted._Marker_key
226> 
227> delete MRK_Notes from MRK_Notes, deleted
228> where MRK_Notes._Marker_key = deleted._Marker_key
229> 
230> delete MRK_Offset from MRK_Offset, deleted
231> where MRK_Offset._Marker_key = deleted._Marker_key
232> 
233> delete MRK_Other from MRK_Other, deleted
234> where MRK_Other._Marker_key = deleted._Marker_key
235> 
236> delete MRK_Reference from MRK_Reference, deleted
237> where MRK_Reference._Marker_key = deleted._Marker_key
238> 
239> delete MRK_Label from MRK_Label, deleted
240> where MRK_Label._Marker_key = deleted._Marker_key
241> 
242> delete ACC_Accession
243> from ACC_Accession a, ACC_MGIType m, deleted
244> where a._Object_key = deleted._Marker_key
245> and a._MGIType_key = m._MGIType_key
246> and m.name = "Marker"
247> 
1> 
2> drop trigger MRK_Alias_Insert
1> 
2> create trigger MRK_Alias_Insert
3> on MRK_Alias
4> for insert
5> as
6> 
7> if exists (select * from MRK_Marker, inserted
8>          where inserted._Marker_key = inserted._Alias_key)
9> begin
10>         rollback transaction
11>         raiserror 99999 "Symbol cannot use itself as an Alias"
12> 	return
13> end
14> 
1> 
2> drop trigger MRK_Class_Delete
1>  
2> create trigger MRK_Class_Delete
3> on MRK_Class
4> for delete
5> as
6> 
7> /* Disallow deletion if Class is referenced by a Marker */
8>  
9> if exists (select * from MRK_Classes, deleted
10>     where MRK_Classes._Class_key = deleted._Class_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Class is referenced in Marker Record(s)"
14> 	return
15> end
16>  
1>  
2> drop trigger MRK_Event_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Event_Delete', because it doesn't exist in the
system catalogs.
1> 
2> create trigger MRK_Event_Delete
3> on MRK_Event
4> for delete
5> as
6> 
7> /* Disallow deletion of event which is referenced in History table */
8> 
9> if exists (select * from MRK_History, deleted
10>          where MRK_History._Marker_Event_key = deleted._Marker_Event_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Event is referenced in History Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger MRK_EventReason_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_EventReason_Delete', because it doesn't exist in
the system catalogs.
1> 
2> create trigger MRK_EventReason_Delete
3> on MRK_EventReason
4> for delete
5> as
6> 
7> /* Disallow deletion of event reason which is referenced in History table */
8> 
9> if exists (select * from MRK_History, deleted
10>          where MRK_History._Marker_EventReason_key = deleted._Marker_EventReason_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Event Reason is referenced in History Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger MRK_Species_Delete
1> 
2> create trigger MRK_Species_Delete
3> on MRK_Species
4> for delete
5> as
6> 
7> /* Disallow deletion of species which is referenced in MRK_Marker table */
8> 
9> if exists (select * from MRK_Marker, deleted
10>          where MRK_Marker._Species_key = deleted._Species_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Species is referenced in Marker Record(s)"
14> 	return
15> end
16> 
17> /* Delete records in dependent tables */
18> 
19> delete MRK_Chromosome from MRK_Chromosome, deleted
20> where MRK_Chromosome._Species_key = deleted._Species_key
21> 
1> 
2> drop trigger MRK_Status_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Status_Delete', because it doesn't exist in the
system catalogs.
1> 
2> create trigger MRK_Status_Delete
3> on MRK_Status
4> for delete
5> as
6> 
7> /* Disallow deletion of status which is referenced in Marker table */
8> 
9> if exists (select * from MRK_Marker, deleted
10>          where MRK_Marker._Marker_Status_key = deleted._Marker_Status_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Status is referenced in Marker Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger MRK_Types_Delete
1> 
2> create trigger MRK_Types_Delete
3> on MRK_Types
4> for delete
5> as
6> 
7> /* Disallow deletion of Type which is referenced in MRK_Marker table */
8> 
9> if exists (select * from MRK_Marker, deleted
10>          where MRK_Marker._Marker_Type_key = deleted._Marker_Type_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Marker Type is referenced in Marker Record(s)"
14> 	return
15> end
16> 
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop trigger PRB_Probe_Insert
1>  
2> create trigger PRB_Probe_Insert
3> on PRB_Probe
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Molecular Segment */
8> 
9> declare @key integer
10> select @key = _Probe_key from inserted
11> exec ACC_assignMGI @key, "Segment"
12> 
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1>  
2> drop trigger PRB_Probe_Update
1>  
2> create trigger PRB_Probe_Update
3> on PRB_Probe
4> for update
5> as
6>  
7> if update (_Source_key)
8> begin
9> 	/* Disallow edits to WashU data - TR 611 */
10> 
11>    	if exists (select * from PRB_Reference_View r, inserted i
12> 		where r._Probe_key = i._Probe_key and
13> 	      	      r.jnum = 57656)
14>    	    and
15>    	    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
16> 	begin
17>         	rollback transaction
18>         	raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot modify the Source information."
19> 		return
20> 	end
21> 
22> 	/* Delete orphan Anonymous _Source_keys */
23> 
24> 	if (select PRB_Source.name from PRB_Source, deleted
25> 	    where PRB_Source._Source_key = deleted._Source_key) is null
26> 	    and
27> 	   not exists (select * from PRB_Probe, deleted
28>             where PRB_Probe._Source_key = deleted._Source_key)
29> 	begin
30> 		delete PRB_Source from PRB_Source, deleted
31> 		where PRB_Source._Source_key = deleted._Source_key
32> 	end
33> 
34> 	/* Update _Source_key for all children of Parent */
35> 
36> 	update PRB_Probe set _Source_key = inserted._Source_key
37> 	from PRB_Probe, inserted
38> 	where PRB_Probe.derivedFrom = inserted._Probe_key
39> end
40> 
41> /* Disallow edits to WashU data - TR 611 */
42> 
43> if update (name)
44>    and
45>    exists (select * from PRB_Reference_View r, inserted i
46> 	where r._Probe_key = i._Probe_key and
47> 	      r.jnum = 57656)
48>    and
49>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
50> begin
51>         rollback transaction
52>         raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot modify the name."
53> 	return
54> end
55> 
1>  
2> drop trigger PRB_Probe_Delete
1> 
2> create trigger PRB_Probe_Delete
3> on PRB_Probe
4> for delete
5> as
6> 
7> /* Disallow deletion if Molecular Segment is referenced elsewhere */
8> 
9> if exists (select * from PRB_Probe, deleted
10>     where PRB_Probe.derivedFrom = deleted._Probe_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Molecular Segment is referenced as a Parent in Molecular Segment record(s)"
14> 	return
15> end
16>  
17> if exists (select * from MLD_Hit, deleted
18>          where MLD_Hit._Probe_key = deleted._Probe_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Molecular Segment is referenced in MLDP Hit record(s)"
22> 	return
23> end
24>  
25> if exists (select * from MLD_Hit, deleted
26>          where MLD_Hit._Target_key = deleted._Probe_key)
27> begin
28>         rollback transaction
29>         raiserror 99999 "Molecular Segment is referenced as a Target in MLDP Hit record(s)"
30> 	return
31> end
32>  
33> if exists (select * from MLD_ContigProbe, deleted
34>          where MLD_ContigProbe._Probe_key = deleted._Probe_key)
35> begin
36>         rollback transaction
37>         raiserror 99999 "Molecular Segment is referenced in MLDP Contig/Probe record(s)"
38> 	return
39> end
40>  
41> if exists (select * from GXD_ProbePrep, deleted
42>          where GXD_ProbePrep._Probe_key = deleted._Probe_key)
43> begin
44>         rollback transaction
45>         raiserror 99999 "Molecular Segment is referenced in GXD Probe Prep record(s)"
46> 	return
47> end
48> 
49> /* Disallow edits to WashU data - TR 611 */
50> 
51> if exists (select * from PRB_Reference_View r, deleted d
52> 	where r._Probe_key = d._Probe_key and
53> 	      r.jnum = 57656)
54>    and
55>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
56> begin
57>         rollback transaction
58>         raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot delete record."
59> 	return
60> end
61> 
62> delete PRB_Marker from PRB_Marker, deleted
63> where PRB_Marker._Probe_key = deleted._Probe_key
64> 
65> delete PRB_Notes from PRB_Notes, deleted
66> where PRB_Notes._Probe_key = deleted._Probe_key
67> 
68> delete PRB_Reference from PRB_Reference, deleted
69> where PRB_Reference._Probe_key = deleted._Probe_key
70> 
71> /* If Probe Source Name is null, then Anonymous Source */
72> /* If Anonymous Source, delete upon deletion of Probe */
73> 
74> if exists (select * from PRB_Probe, deleted
75>     where PRB_Probe._Source_key = deleted._Source_key)
76> begin
77>   	delete PRB_Source from PRB_Source, deleted
78>   	where PRB_Source._Source_key = deleted._Source_key
79> 	      and PRB_Source.name is null
80> end
81> 
82> delete ACC_AccessionReference 
83> from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m, deleted
84> where a._Object_key = deleted._Probe_key
85> and a._MGIType_key = m._MGIType_key
86> and m.name = "Segment"
87> and a._Accession_key = ar._Accession_key
88>  
89> delete ACC_Accession 
90> from ACC_Accession a, ACC_MGIType m, deleted
91> where a._Object_key = deleted._Probe_key
92> and a._MGIType_key = m._MGIType_key
93> and m.name = "Segment"
94>  
1> 
2> drop trigger PRB_Allele_Delete
1> 
2> create trigger PRB_Allele_Delete
3> on PRB_Allele
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete PRB_Allele_Strain from PRB_Allele_Strain, deleted
10> where PRB_Allele_Strain._Allele_key = deleted._Allele_key
11> 
1> 
2> drop trigger PRB_Marker_Insert
1> 
2> create trigger PRB_Marker_Insert
3> on PRB_Marker
4> for insert
5> as
6> 
7> if @@rowcount = 1
8> begin
9> 	/* Relationship must be 'H' for Probes of non-mouse source */
10> 
11> 	if exists (select * from inserted i, PRB_Probe p, PRB_Source s
12>     		where i._Probe_key = p._Probe_key
13> 	  	and p.DNAtype != 'primer'
14> 	  	and p._Source_key = s._Source_key
15> 	  	and s.species not in ('mouse, laboratory')
16> 	  	and (i.relationship != 'H' or i.relationship is null))
17> 	begin
18>         	rollback transaction
19>         	raiserror 99999 "Relationship Must be 'H'"
20> 		return
21> 	end
22> 
23> 	/* Relationship 'P' can only be used during an EST bulk load */
24> 
25> 	if (select relationship from inserted) = 'P'
26> 	begin
27>         	rollback transaction
28>         	raiserror 99999 "Relationship 'P' can only be used during EST load"
29> 		return
30> 	end
31> 
32>   	/* If adding encoding Marker to a Molecular Segment and */
33> 	/* Molecular Segment contains a Seq ID and */
34> 	/* the Marker is not associated with the Seq ID */
35> 
36> 	if (select relationship from inserted) = 'E'
37> 	begin
38> 		if exists (select a1.accID
39> 		   from ACC_Accession a1, ACC_Accession a2, inserted i
40> 		   where a1._MGIType_key = 3 and 
41> 		         a1. _LogicalDB_key = 9 and 
42> 		         a1._Object_key = i._Probe_key)
43> 		   and
44> 		   not exists (select a1.accID
45> 		   from ACC_Accession a1, ACC_Accession a2, inserted i
46> 		   where a1._MGIType_key = 3 and 
47> 		         a1. _LogicalDB_key = 9 and 
48> 		         a1._Object_key = i._Probe_key and
49> 			 a1.accID = a2.accID and
50> 			 a2._MGIType_key = 2 and
51> 			 a2._LogicalDB_key = 9 and
52> 			 a2._Object_key = i._Marker_key)
53> 
54>   		begin
55>         		print "The Sequence ID(s) for this Molecular Segment should probably be added to the encoding, updated Marker."
56>   		end
57> 
58> 	end
59> end
60> 
1> 
2> drop trigger PRB_Marker_Update
1>  
2> create trigger PRB_Marker_Update
3> on PRB_Marker
4> for update
5> as
6>  
7> if @@rowcount = 1
8> begin
9> 
10> 	/* Relationship must be 'H' for Probes of non-mouse source */
11> 
12> 	if exists (select * from inserted i, PRB_Probe p, PRB_Source s
13>     		where i._Probe_key = p._Probe_key
14> 	  	and p.DNAtype != 'primer'
15> 	  	and p._Source_key = s._Source_key
16> 	  	and s.species not in ('mouse, laboratory')
17> 	  	and (i.relationship != 'H' or i.relationship is null))
18> 	begin
19>         	rollback transaction
20>         	raiserror 99999 "Relationship Must be 'H'"
21> 		return
22> 	end
23> 
24> 	/* Allow update of 'P' to other relationship */
25> 	/* Disallow update of other relationship to 'P' */
26> 	/* Only check on individual inserts */
27> 
28> 	if ((select relationship from inserted) = 'P'
29> 	    and (select _Marker_key from inserted) = (select _Marker_key from deleted))
30> 	   or
31> 	   ((select _Marker_key from inserted) != (select _Marker_key from deleted)
32> 	    and (select relationship from inserted) = 'P'
33> 	    and (select relationship from deleted) != 'P')
34> 	begin
35>         	rollback transaction
36>         	raiserror 99999 "Relationship 'P' can only be used during EST load"
37> 		return
38> 	end
39> 
40>         /* If updating to an encoding Marker for a Molecular Segment and */
41>         /* Molecular Segment contains a Seq ID and */
42>         /* the Marker is not associated with the Seq ID */
43>  
44>         if update(relationship) and (select relationship from inserted) = 'E'
45>         begin
46>                 if not exists (select a1.accID
47>                    from ACC_Accession a1, ACC_Accession a2, inserted i
48>                    where a1._MGIType_key = 3 and
49>                          a1. _LogicalDB_key = 9 and
50>                          a1._Object_key = i._Probe_key and
51>                          a1.accID = a2.accID and
52>                          a2._MGIType_key = 2 and
53>                          a2._LogicalDB_key = 9 and
54>                          a2._Object_key = i._Marker_key)
55>  
56>                 begin
57>                         print "The Sequence ID(s) for this Molecular Segment should probably be added to the encoding, updated Marker."
58>                 end
59> 	end 
60> 
61>         /* If updating to an non-encoding Marker for a Molecular Segment and */
62>         /* Molecular Segment contains a Seq ID and */
63>         /* the Marker is associated with the Seq ID */
64>  
65>         if update(relationship) and 
66> 	   (select relationship from deleted) = 'E' and
67>            (select relationship from inserted) != 'E'
68>         begin
69>                 if exists (select a1.accID
70>                    from ACC_Accession a1, ACC_Accession a2, inserted i
71>                    where a1._MGIType_key = 3 and
72>                          a1. _LogicalDB_key = 9 and
73>                          a1._Object_key = i._Probe_key and
74>                          a1.accID = a2.accID and
75>                          a2._MGIType_key = 2 and
76>                          a2._LogicalDB_key = 9 and
77>                          a2._Object_key = i._Marker_key)
78>  
79>                 begin
80>                         print "Please review the relationship(s) between the updated Marker and its Seq IDs.  These relationships may no longer be appropriate."
81>                 end
82> 	end 
83> end
84> 
85> if update(_Marker_key)
86> begin
87> 	update PRB_RFLV
88> 	set _Marker_key = inserted._Marker_key
89> 	from PRB_RFLV, PRB_Reference, inserted, deleted
90> 	where inserted._Probe_key = PRB_Reference._Probe_key
91> 	      and PRB_Reference._Reference_key = PRB_RFLV._Reference_key
92> 	      and PRB_RFLV._Marker_key = deleted._Marker_key
93> end
94> 
1> 
2> drop trigger PRB_Marker_Delete
1>  
2> create trigger PRB_Marker_Delete
3> on PRB_Marker
4> for delete
5> as
6> 
7> if @@rowcount = 1
8> begin
9>         /* If deleting an encoding Marker from a Molecular Segment and */
10>         /* Molecular Segment contains a Seq ID and */
11>         /* the Marker is associated with the Seq ID */
12>  
13>         if (select relationship from deleted) = 'E'
14>         begin
15>                 if exists (select a1.accID
16>                    from ACC_Accession a1, ACC_Accession a2, deleted d
17>                    where a1._MGIType_key = 3 and
18>                          a1. _LogicalDB_key = 9 and
19>                          a1._Object_key = d._Probe_key and
20>                          a1.accID = a2.accID and
21>                          a2._MGIType_key = 2 and
22>                          a2._LogicalDB_key = 9 and
23>                          a2._Object_key = d._Marker_key)
24>  
25>                 begin
26>                         print "Please review the relationship(s) between the deleted Marker and its Seq IDs.  These relationships may no longer be appropriate."
27>                 end
28> 	end 
29> 
30> end
31> 
1>  
2> drop trigger PRB_Reference_Update
1> 
2> create trigger PRB_Reference_Update
3> on PRB_Reference
4> for update
5> as
6> 
7> /* Disallow edits to WashU data - TR 611 */
8> 
9> if exists (select * from BIB_All_View b, inserted d
10> 	where d._Refs_key = b._Refs_key and
11> 	      b.jnum = 57656)
12>    and
13>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
14> begin
15>         rollback transaction
16>         raiserror 99999 "J:57656, WashU-HHMI Database Download.  Cannot update record."
17> 	return
18> end
19> 
1> 
2> drop trigger PRB_Reference_Delete
1> 
2> create trigger PRB_Reference_Delete
3> on PRB_Reference
4> for delete
5> as
6> 
7> /* Disallow edits to WashU data - TR 611 */
8> 
9> if exists (select * from BIB_All_View b, deleted d
10> 	where d._Refs_key = b._Refs_key and
11> 	      b.jnum = 57656)
12>    and
13>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
14> begin
15>         rollback transaction
16>         raiserror 99999 "J:57656, WashU-HHMI Database Download.  Cannot delete record."
17> 	return
18> end
19> 
20> /* Delete dependent records */
21> 
22> delete PRB_Alias from PRB_Alias, deleted
23> where PRB_Alias._Reference_key = deleted._Reference_key
24> 
25> delete PRB_Ref_Notes from PRB_Ref_Notes, deleted
26> where PRB_Ref_Notes._Reference_key = deleted._Reference_key
27> 
28> delete PRB_RFLV from PRB_RFLV, deleted
29> where PRB_RFLV._Reference_key = deleted._Reference_key
30> 
31> delete ACC_AccessionReference 
32> from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m, deleted
33> where a._Object_key = deleted._Probe_key
34> and a._MGIType_key = m._MGIType_key
35> and m.name = "Segment"
36> and a._Accession_key = ar._Accession_key
37> and ar._Refs_key = deleted._Refs_key
38>  
1> 
2> drop trigger PRB_RFLV_Delete
1> 
2> create trigger PRB_RFLV_Delete
3> on PRB_RFLV
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete PRB_Allele from PRB_Allele, deleted
10> where PRB_Allele._RFLV_key = deleted._RFLV_key
11> 
1> 
2> drop trigger PRB_Source_Insert
1> 
2> create trigger PRB_Source_Insert
3> on PRB_Source
4> for insert
5> as
6> 
7> /* The same exact logic to prevent invalid Age values must */
8> /* be used in the update trigger as well */
9> 
10> /* Ignore multi-row data */
11> 
12> if @@rowcount > 1
13> begin
14> 	return
15> end
16> 
17> /* Disallow edits to WashU data - TR 611 */
18> 
19> if exists (select * from PRB_Probe p, PRB_Reference_View r, inserted i
20> 	where i._Source_key = p._Source_key and
21> 	      p._Probe_key = r._Probe_key and
22>       	      r.jnum = 57656)
23>     and
24>     (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
25> begin
26>        	rollback transaction
27>        	raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot modify the Source information."
28> 	return
29> end
30> 
31> declare @age varchar(50)
32> select @age = inserted.age from inserted
33> 
34> /* If tissue = 'unfertilized egg', then age must be 'Not Applicable' */
35> 
36> if (select PRB_Tissue.tissue
37> 	from PRB_Tissue, inserted
38> 	where inserted._Tissue_key = PRB_Tissue._Tissue_key) = "unfertilized egg"
39>    and @age != "Not Applicable"
40> begin
41>         rollback transaction
42>         raiserror 99999 "Age for this tissue MUST be Not Applicable"
43> 	return
44> end
45> 
46> /* If age is 'Not Applicable', then tissue must be 'unfertilized egg' */
47> 
48> if @age = "Not Applicable"
49>    and
50>    (select PRB_Tissue.tissue
51> 	from PRB_Tissue, inserted
52> 	where inserted._Tissue_key = PRB_Tissue._Tissue_key) != "unfertilized egg"
53> begin
54>         rollback transaction
55>         raiserror 99999 "Age for this tissue CANNOT be Not Applicable"
56> 	return
57> end
58> 
59> /* Separate agePrefix from ageSuffix (numerics) */
60> 
61> declare @agePrefix varchar(50)
62> declare @ageSuffix varchar(50)
63> declare @idx integer
64> 
65> select @agePrefix = @age
66> select @idx = patindex("%[0-9]%", @age)
67> 
68> if @idx > 0
69> begin
70> 	select @agePrefix = substring(@age, 1, @idx - 1)
71> 	select @ageSuffix = substring(@age, @idx, char_length(@age))
72> end
73> 
74> /* If age is one of the following prefixes, then there can be no numeric values */
75> 
76> if @agePrefix in ('Not Specified', 'Not Applicable', 'embryonic', 'perinatal',
77> 	'postnatal', 'postnatal newborn', 'postnatal immature', 'postnatal adult')
78>    and @ageSuffix is not null
79> begin
80>         rollback transaction
81>         raiserror 99999 "The Age value specified CANNOT contain numeric values"
82> 	return
83> end
84> 
85> /* If age is one of the following prefixes, then there must be numeric values */
86> 
87> if @agePrefix in ('embryonic day', 'postnatal day', 'postnatal week',
88> 	'postnatal month', 'postnatal year')
89>    and @ageSuffix is null
90> begin
91>         rollback transaction
92>         raiserror 99999 "The Age value specified MUST contain numeric values"
93> 	return
94> end
95> 
1> 
2> drop trigger PRB_Source_Update
1> 
2> create trigger PRB_Source_Update
3> on PRB_Source
4> for update
5> as
6> 
7> /* The same exact logic to prevent invalid Age values must */
8> /* be used in the insert trigger as well */
9> 
10> /* Ignore multi-row data */
11> 
12> if @@rowcount > 1
13> begin
14> 	return
15> end
16> 
17> /* Disallow edits to WashU data - TR 611 */
18> 
19> if exists (select * from PRB_Probe p, PRB_Reference_View r, inserted i
20> 	where i._Source_key = p._Source_key and
21> 	      p._Probe_key = r._Probe_key and
22>       	      r.jnum = 57656)
23>     and
24>     (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
25> begin
26>        	rollback transaction
27>        	raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot modify the Source information."
28> 	return
29> end
30> 
31> declare @age varchar(50)
32> select @age = inserted.age from inserted
33> 
34> /* If tissue = 'unfertilized egg', then age must be 'Not Applicable' */
35> 
36> if (select PRB_Tissue.tissue
37> 	from PRB_Tissue, inserted
38> 	where inserted._Tissue_key = PRB_Tissue._Tissue_key) = "unfertilized egg"
39>    and @age != "Not Applicable"
40> begin
41>         rollback transaction
42>         raiserror 99999 "Age for this tissue MUST be Not Applicable"
43> 	return
44> end
45> 
46> /* If age is 'Not Applicable', then tissue must be 'unfertilized egg' */
47> 
48> if @age = "Not Applicable"
49>    and
50>    (select PRB_Tissue.tissue
51> 	from PRB_Tissue, inserted
52> 	where inserted._Tissue_key = PRB_Tissue._Tissue_key) != "unfertilized egg"
53> begin
54>         rollback transaction
55>         raiserror 99999 "Age for this tissue CANNOT be Not Applicable"
56> 	return
57> end
58> 
59> /* Separate agePrefix from ageSuffix (numerics) */
60> 
61> declare @agePrefix varchar(50)
62> declare @ageSuffix varchar(50)
63> declare @idx integer
64> 
65> select @agePrefix = @age
66> select @idx = patindex("%[0-9]%", @age)
67> 
68> if @idx > 0
69> begin
70> 	select @agePrefix = substring(@age, 1, @idx - 1)
71> 	select @ageSuffix = substring(@age, @idx, char_length(@age))
72> end
73> 
74> /* If age is one of the following prefixes, then there can be no numeric values */
75> 
76> if @agePrefix in ('Not Specified', 'Not Applicable', 'embryonic', 'perinatal',
77> 	'postnatal', 'postnatal newborn', 'postnatal immature', 'postnatal adult')
78>    and @ageSuffix is not null
79> begin
80>         rollback transaction
81>         raiserror 99999 "The Age value specified CANNOT contain numeric values"
82> 	return
83> end
84> 
85> /* If age is one of the following prefixes, then there must be numeric values */
86> 
87> if @agePrefix in ('embryonic day', 'postnatal day', 'postnatal week',
88> 	'postnatal month', 'postnatal year')
89>    and @ageSuffix is null
90> begin
91>         rollback transaction
92>         raiserror 99999 "The Age value specified MUST contain numeric values"
93> 	return
94> end
95> 
1> 
2> drop trigger PRB_Source_Delete
1> 
2> create trigger PRB_Source_Delete
3> on PRB_Source
4> for delete
5> as
6> 
7> /* Disallow deletion if Source is referenced elsewhere */
8> 
9> if exists (select * from PRB_Probe, deleted
10>          where PRB_Probe._Source_key = deleted._Source_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Molecular Segment Library is referenced in Probe Record(s)"
14> 	return
15> end
16>  
17> if exists (select * from GXD_Antigen, deleted
18>          where GXD_Antigen._Source_key = deleted._Source_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Molecular Segment Library is referenced in GXD Antigen Record(s)"
22> 	return
23> end
24>  
1> 
2> drop trigger PRB_Strain_Insert
1> 
2> create trigger PRB_Strain_Insert
3> on PRB_Strain
4> for insert
5> as
6> 
7> if (select count(*) from PRB_Strain, inserted
8>          where PRB_Strain.strain = inserted.strain) > 1
9> begin
10>         print "Potential Duplicate Strain Found"
11> end
12>  
1> 
2> drop trigger PRB_Strain_Update
1> 
2> create trigger PRB_Strain_Update
3> on PRB_Strain
4> for update
5> as
6> 
7> if (select count(*) from PRB_Strain, inserted
8>          where PRB_Strain.strain = inserted.strain) > 1
9> begin
10>         print "Potential Duplicate Strain Found"
11> end
12>  
13> update PRB_Strain 
14> set modification_date = getdate()
15> from PRB_Strain, inserted
16> where PRB_Strain._Strain_key = inserted._Strain_key
17> 
1> 
2> drop trigger PRB_Strain_Delete
1> 
2> create trigger PRB_Strain_Delete
3> on PRB_Strain
4> for delete
5> as
6> 
7> /* Disallow deletion if Strain is referenced elsewhere */
8> 
9> if exists (select * from PRB_Source, deleted
10>     where PRB_Source._Strain_key = deleted._Strain_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Strain is referenced in Molecular Segment Library Record(s)"
14> 	return
15> end
16> 
17> if exists (select * from PRB_Allele_Strain, deleted
18>          where PRB_Allele_Strain._Strain_key = deleted._Strain_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Strain is referenced in RFLP Record(s)"
22> 	return
23> end
24> 
25> if exists (select * from MLD_FISH, deleted
26>          where MLD_FISH._Strain_key = deleted._Strain_key)
27> begin
28>         rollback transaction
29>         raiserror 99999 "Strain is referenced in FISH Record(s)"
30> 	return
31> end
32>  
33> if exists (select * from MLD_InSitu, deleted
34>          where MLD_InSitu._Strain_key = deleted._Strain_key)
35> begin
36>         rollback transaction
37>         raiserror 99999 "Strain is referenced in InSitu Record(s)"
38> 	return
39> end
40>  
41> if exists (select * from CRS_Cross, deleted
42>          where CRS_Cross._femaleStrain_key = deleted._Strain_key)
43> begin
44>         rollback transaction
45>         raiserror 99999 "Strain is referenced in Cross Record(s)"
46> 	return
47> end
48>  
49> if exists (select * from CRS_Cross, deleted
50>          where CRS_Cross._maleStrain_key = deleted._Strain_key)
51> begin
52>         rollback transaction
53>         raiserror 99999 "Strain is referenced in Cross Record(s)"
54> 	return
55> end
56>  
57> if exists (select * from CRS_Cross, deleted
58>          where CRS_Cross._StrainHO_key = deleted._Strain_key)
59> begin
60>         rollback transaction
61>         raiserror 99999 "Strain is referenced in Cross Record(s)"
62> 	return
63> end
64>  
65> if exists (select * from CRS_Cross, deleted
66>          where CRS_Cross._StrainHT_key = deleted._Strain_key)
67> begin
68>         rollback transaction
69>         raiserror 99999 "Strain is referenced in Cross Record(s)"
70> 	return
71> end
72>  
73> if exists (select * from GXD_Genotype, deleted
74>          where GXD_Genotype._Strain_key = deleted._Strain_key)
75> begin
76>         rollback transaction
77>         raiserror 99999 "Strain is referenced in GXD Genotype Record(s)"
78> 	return
79> end
80>  
81> if exists (select * from ALL_Allele, deleted
82>          where ALL_Allele._Strain_key = deleted._Strain_key)
83> begin
84>         rollback transaction
85>         raiserror 99999 "Strain is referenced in Allele Record(s)"
86> 	return
87> end
88>  
89> delete PRB_Strain_Marker from PRB_Strain_Marker, deleted
90> where PRB_Strain_Marker._Strain_key = deleted._Strain_key
91> 
1> 
2> drop trigger PRB_Tissue_Delete
1> 
2> create trigger PRB_Tissue_Delete
3> on PRB_Tissue
4> for delete
5> as
6> 
7> /* Disallow deletion if Tissue is referenced elsewhere */
8> 
9> if exists (select * from PRB_Source, deleted
10>     where PRB_Source._Tissue_key = deleted._Tissue_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Tissue is referenced in Molecular Segment Library Record(s)"
14> 	return
15> end
16>  
1> 
2> drop trigger PRB_Vector_Types_Delete
1> 
2> create trigger PRB_Vector_Types_Delete
3> on PRB_Vector_Types
4> for delete
5> as
6> 
7> /* Disallow deletion if Vector_Types is referenced elsewhere */
8> 
9> if exists (select * from PRB_Probe, deleted
10>     where PRB_Probe._Vector_key = deleted._Vector_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Vector Type is referenced in Molecular Segment Record(s)"
14> 	return
15> end
16>  
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop trigger RI_RISet_Update
1> 
2> create trigger RI_RISet_Update
3> on RI_RISet
4> for update
5> as
6> 
7> /* Update origin, designation, abbreviation values in individual */
8> /* experiment records whenever the "master" RI record is changed. */
9> /* The fields in the MLD_RI table are actually obsolete and should */
10> /* be removed from this table. */
11> 
12> update MLD_RI
13> set origin = inserted.origin, 
14>     designation = inserted.designation,
15>     abbrev1 = inserted.abbrev1,
16>     abbrev2 = inserted.abbrev2
17> from MLD_RI, inserted
18> where MLD_RI._RISet_key = inserted._RISet_key
19> 
1> 
2> drop trigger RI_RISet_Delete
1> 
2> create trigger RI_RISet_Delete
3> on RI_RISet
4> for delete
5> as
6> 
7> /* Disallow deletion if RI Set is referenced elsewhere */
8> 
9> if exists (select * from MLD_RI, deleted
10>     where MLD_RI._RISet_key = deleted._RISet_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "RI is referenced in MLDP Record(s)"
14> 	return
15> end
16> 
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view ACC_View
1> 
2> create view ACC_View
3> as
4> select a.*, MGIType = m.name,
5> LogicalDB = l.name, l.description, l._Species_key,
6> ActualDB = d.name, d.url, d.allowsMultiple, d.delimiter
7> from ACC_Accession a, ACC_MGIType m, ACC_LogicalDB l, ACC_ActualDB d
8> where a._MGIType_key = m._MGIType_key
9> and a._LogicalDB_Key = l._LogicalDB_key
10> and l._LogicalDB_key = d._LogicalDB_key
11> and d.active = 1
1> 
2> grant select on ACC_View to public
1>  
2> drop view ACC_LogicalDB_View
1> 
2> create view ACC_LogicalDB_View
3> as
4> select a.*, species = s.name
5> from ACC_LogicalDB a, MRK_Species s
6> where a._Species_key *= s._Species_key
1> 
2> grant select on ACC_LogicalDB_View to public
1>  
2> drop view ACC_Reference_View
1> 
2> create view ACC_Reference_View
3> as
4> select a.*, b.jnum, b.jnumID, b.short_citation
5> from ACC_View a, ACC_AccessionReference r, BIB_All_View b
6> where a._Accession_key = r._Accession_key
7> and r._Refs_key = b._Refs_key
1> 
2> grant select on ACC_Reference_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view ALL_Acc_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'ALL_Acc_View', because it doesn't exist in the system
catalogs.
1> 
2> create view ALL_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 11
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on ALL_Acc_View to public
1>  
2> drop view ALL_Allele_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'ALL_Allele_View', because it doesn't exist in the system
catalogs.
1>  
2> create view ALL_Allele_View
3> as
4> select a.*, markerSymbol = m.symbol, s.strain, im.mode, t.alleleType
5> from ALL_Allele a, MRK_Marker m, PRB_Strain s, ALL_Inheritance_mode im, ALL_Type t
6> where a._Marker_key = m._Marker_key
7> and a._Strain_key = s._Strain_key
8> and a._Mode_key = im._Mode_key
9> and a._Allele_Type_key = t._Allele_Type_key
1> 
2> grant select on ALL_Allele_View to public
1>  
2> drop view ALL_Allele_Refs_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'ALL_Allele_Refs_View', because it doesn't exist in the
system catalogs.
1> 
2> create view ALL_Allele_Refs_View
3> as
4> select a.*, b.jnum, b.short_citation
5> from ALL_Allele_View a, BIB_All_View b
6> where a._Refs_key = b._Refs_key
1> 
2> grant select on ALL_Allele_Refs_View to public
1>  
2> drop view ALL_Allele_MolRefs_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'ALL_Allele_MolRefs_View', because it doesn't exist in the
system catalogs.
1> 
2> create view ALL_Allele_MolRefs_View
3> as
4> select a.*, b.jnum, b.short_citation
5> from ALL_Allele_View a, BIB_All_View b
6> where a._Molecular_Refs_key = b._Refs_key
1> 
2> grant select on ALL_Allele_MolRefs_View to public
1>  
2> drop view ALL_Allele_Mutation_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'ALL_Allele_Mutation_View', because it doesn't exist in the
system catalogs.
1> 
2> create view ALL_Allele_Mutation_View
3> as
4> select am.*, m.mutation
5> from ALL_Allele_Mutation am, ALL_Molecular_Mutation m
6> where am._Mutation_key = m._Mutation_key
1> 
2> grant select on ALL_Allele_Mutation_View to public
1> 
2> drop view ALL_Synonym_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'ALL_Synonym_View', because it doesn't exist in the system
catalogs.
1> 
2> create view ALL_Synonym_View
3> as
4> select s.*, b.jnum, b.short_citation, a._Marker_key, m.symbol
5> from ALL_Synonym s, BIB_All_View b, ALL_Allele a, MRK_Marker m
6> where s._Refs_key = b._Refs_key
7> and s._Allele_key = a._Allele_key
8> and a._Marker_key = m._Marker_key
1> 
2> grant select on ALL_Synonym_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view BIB_Acc_View
1> 
2> create view BIB_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 1
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on BIB_Acc_View to public
1>  
2> /* BIB_All_View contains all BIB_Refs records, their J#s */
3> /* a long citation and a short citation */
4> 
5> drop view BIB_All_View
1>  
2> create view BIB_All_View
3> as
4> select r.*, 
5> reviewStatus = s.name,
6> jnumID = a.accID, jnum = a.numericPart,
7> citation = r.journal + " " + r.date + ";" + r.vol + "(" + r.issue + "):" + r.pgs,
8> short_citation = r._primary + ", " + r.journal + " " + r.date + ";" + 
9> r.vol + "(" + r.issue + "):" + r.pgs
10> from BIB_Refs r, BIB_ReviewStatus s, ACC_Accession a
11> where r._ReviewStatus_key = s._ReviewStatus_key
12> and r._Refs_key = a._Object_key
13> and a._MGIType_key = 1
14> and a.prefixPart =  "J:"
15> and a.preferred = 1
1>  
2> grant select on BIB_All_View to public
1>  
2> /* BIB_View contains all non-Submission BIB_Refs records, */
3> /* their J#s, a long citation and a short citation */
4> /* Submission references are not currently accessible on the Web */
5> 
6> drop view BIB_View
1> 
2> create view BIB_View
3> as
4> select r.*,
5> reviewStatus = s.name,
6> jnumID = a.accID, jnum = a.numericPart,
7> citation = r.journal + " " + r.date + ";" + r.vol + "(" + r.issue + "):" + r.pgs,
8> short_citation = r._primary + ", " + r.journal + " " + r.date + ";" + 
9> r.vol + "(" + r.issue + "):" + r.pgs
10> from BIB_Refs r, BIB_ReviewStatus s, ACC_Accession a
11> where r._ReviewStatus_key = s._ReviewStatus_key
12> and r._Refs_key = a._Object_key
13> and a._MGIType_key = 1
14> and a.prefixPart =  "J:"
15> and a.preferred = 1
16> and (journal != 'Submission' or journal is null)
1> 
2> grant select on BIB_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view CRS_Cross_View
1> 
2> create view CRS_Cross_View
3> as
4> select c.*, display = whoseCross + " [Type " + type + " (" + abbrevHO + "/" + abbrevHT + ")]",
5> femaleStrain = s1.strain, maleStrain = s2.strain,
6> strainHO = s3.strain, strainHT = s4.strain
7> from CRS_Cross c, PRB_Strain s1, PRB_Strain s2, PRB_Strain s3, PRB_Strain s4
8> where c._femaleStrain_key = s1._Strain_key
9> and c._maleStrain_key = s2._Strain_key
10> and c._StrainHO_key = s3._Strain_key
11> and c._StrainHT_key = s4._Strain_key
1> 
2> grant select on CRS_Cross_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view GO_Marker_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'GO_Marker_View', because it doesn't exist in the system
catalogs.
1> 
2> create view GO_Marker_View
3> as
4> select gm._Marker_key, m.symbol, go.ontologyName, gt.goTerm, ge.evidence, jnumID = a.accID
5> from GO_MarkerGO gm, MRK_Marker m, GO_Ontology go, GO_Term gt, GO_DataEvidence gd, GO_Evidence ge, ACC_Accession a
6> where gm._Marker_key = m._Marker_key
7> and gm._Term_key = gt._Term_key
8> and gt._Ontology_key = go._Ontology_key
9> and gm._MarkerGO_key = gd._MarkerGO_key
10> and gd._Evidence_key = ge._Evidence_key
11> and gd._Refs_key = a._Object_key
12> and a._MGIType_key = 1
13> and a.prefixPart = "J:"
1> 
2> grant select on GO_Marker_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view GXD_Antigen_Acc_View
1>  
2> create view GXD_Antigen_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 7
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on GXD_Antigen_Acc_View to public
1> 
2> drop view GXD_Antibody_Acc_View
1>  
2> create view GXD_Antibody_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 6
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on GXD_Antibody_Acc_View to public
1> 
2> drop view GXD_Assay_Acc_View
1>  
2> create view GXD_Assay_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 8
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on GXD_Assay_Acc_View to public
1> 
2> drop view GXD_Antigen_View
1> 
2> create view GXD_Antigen_View
3> as
4> select g.*, mgiID = a.accID, a.prefixPart, a.numericPart,
5> s.species, s.age, s.sex, s.cellLine, library = s.name,
6> s.description, s._Refs_key, s._Strain_key, s.strain, s._Tissue_key, s.tissue
7> from GXD_Antigen g, GXD_Antigen_Acc_View a, PRB_Source_View s
8> where g._Antigen_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and a.preferred = 1
11> and g._Source_key = s._Source_key
1> 
2> grant select on GXD_Antigen_View to public
1>  
2> drop view GXD_Antibody_View
1>  
2> create view GXD_Antibody_View
3> as
4> select ab.*, mgiID = a.accID, a.prefixPart, a.numericPart, 
5> ac.class, ap.antibodyType, ag.antigenName
6> from GXD_Antibody ab, GXD_Antibody_Acc_View a, GXD_AntibodyClass ac, GXD_AntibodyType ap, GXD_Antigen ag
7> where ab._Antibody_key = a._Object_key
8> and a.prefixPart = "MGI:"
9> and a.preferred = 1
10> and ab._AntibodyClass_key = ac._AntibodyClass_key
11> and ab._AntibodyType_key = ap._AntibodyType_key
12> and ab._Antigen_key *= ag._Antigen_key
1>  
2> grant select on GXD_Antibody_View to public
1>  
2> drop view GXD_AntibodyRef_View
1>  
2> create view GXD_AntibodyRef_View
3> as
4> select a._Antibody_key, a._Refs_key, c.jnumID, c.jnum, c.short_citation
5> from GXD_Antibody a, BIB_All_View c
6> where a._Refs_key = c._Refs_key
1>  
2> grant select on GXD_AntibodyRef_View to public
1>  
2> drop view GXD_AntibodyAntigen_View
1>  
2> create view GXD_AntibodyAntigen_View
3> as
4> select ab._Antibody_key, ab.antibodyName, ag.*
5> from GXD_Antibody ab, GXD_Antigen_View ag
6> where ab._Antigen_key = ag._Antigen_key
1>  
2> grant select on GXD_AntibodyAntigen_View to public
1>  
2> drop view GXD_AntibodyMarker_View
1>  
2> create view GXD_AntibodyMarker_View
3> as
4> select a._Antibody_key, a.antibodyName, am._Marker_key, m.symbol, m.chromosome
5> from GXD_Antibody a, GXD_AntibodyMarker am, MRK_Marker m
6> where a._Antibody_key = am._Antibody_key
7> and am._Marker_key = m._Marker_key
1>  
2> grant select on GXD_AntibodyMarker_View to public
1>  
2> drop view GXD_AntibodyAlias_View
1>  
2> create view GXD_AntibodyAlias_View
3> as
4> select a.antibodyName, aa.*
5> from GXD_Antibody a, GXD_AntibodyAlias aa
6> where a._Antibody_key = aa._Antibody_key
1>  
2> grant select on GXD_AntibodyAlias_View to public
1>  
2> drop view GXD_AntibodyAliasRef_View
1>  
2> create view GXD_AntibodyAliasRef_View
3> as
4> select a.antibodyName, aa.*, c.jnumID, c.jnum, c.short_citation
5> from GXD_Antibody a, GXD_AntibodyAlias aa, BIB_All_View c
6> where a._Antibody_key = aa._Antibody_key
7> and aa._Refs_key = c._Refs_key
1>  
2> grant select on GXD_AntibodyAliasRef_View to public
1>  
2> drop view GXD_Assay_View
1> 
2> create view GXD_Assay_View
3> as
4> select g.*, mgiID = ac.accID, ac.prefixPart, ac.numericPart,
5> aty.assayType, aty.isRNAAssay, aty.isGelAssay,
6> m.symbol, m.chromosome, m.name,
7> c.jnumID, c.jnum, c.short_citation
8> from GXD_Assay g, GXD_Assay_Acc_View ac, GXD_AssayType aty, MRK_Marker m, BIB_All_View c
9> where g._Assay_key = ac._Object_key
10> and ac.prefixPart = "MGI:"
11> and ac.preferred = 1
12> and g._AssayType_key = aty._AssayType_key
13> and g._Marker_key = m._Marker_key
14> and g._Refs_key = c._Refs_key
1> 
2> grant select on GXD_Assay_View to public
1> 
2> drop view GXD_AntibodyPrep_View
1> 
2> create view GXD_AntibodyPrep_View
3> as
4> select a._Assay_key, ap.*, s.secondary, l.label, ab.antibodyName, ac.accID
5> from GXD_Assay a, GXD_AntibodyPrep ap, GXD_Secondary s, GXD_Label l,
6> GXD_Antibody ab, ACC_Accession ac
7> where a._AntibodyPrep_key = ap._AntibodyPrep_key
8> and ap._Secondary_key = s._Secondary_key
9> and ap._Label_key = l._Label_key
10> and ap._Antibody_key = ab._Antibody_key
11> and ab._Antibody_key = ac._Object_key
12> and ac._MGIType_key = 6
13> and ac.prefixPart = "MGI:"
14> and ac.preferred = 1
1> 
2> grant select on GXD_AntibodyPrep_View to public
1> 
2> drop view GXD_ProbePrep_View
1>  
2> create view GXD_ProbePrep_View
3> as
4> select a._Assay_key, pp.*, s.sense, l.label, c.coverage, v.visualization, probeName = p.name, ac.accID
5> from GXD_Assay a, GXD_ProbePrep pp, GXD_ProbeSense s, GXD_Label l, GXD_LabelCoverage c, GXD_VisualizationMethod v,
6> PRB_Probe p, ACC_Accession ac
7> where a._ProbePrep_key = pp._ProbePrep_key
8> and pp._Sense_key = s._Sense_key
9> and pp._Label_key = l._Label_key
10> and pp._Coverage_key = c._Coverage_key
11> and pp._Visualization_key = v._Visualization_key
12> and pp._Probe_key = p._Probe_key
13> and p._Probe_key = ac._Object_key
14> and ac._MGIType_key = 3
15> and ac.prefixPart = "MGI:"
16> and ac.preferred = 1
1>  
2> grant select on GXD_ProbePrep_View to public
1>  
2> drop view GXD_Genotype_View
1>  
2> create view GXD_Genotype_View
3> as
4> select g.*, s.strain
5> from GXD_Genotype g, PRB_Strain s
6> where g._Strain_key = s._Strain_key
1>  
2> grant select on GXD_Genotype_View to public
1>  
2> drop view GXD_AllelePair_View
1> 
2> create view GXD_AllelePair_View
3> as
4> select a.*, m.symbol, allele1 = a1.symbol, allele2 = a2.symbol
5> from GXD_AllelePair a, MRK_Marker m, ALL_Allele a1, ALL_Allele a2
6> where a._Marker_key = m._Marker_key
7> and a._Allele_key_1 = a1._Allele_key
8> and a._Allele_key_2 *= a2._Allele_key
1> 
2> grant select on GXD_AllelePair_View to public
1> 
2> drop view GXD_Specimen_View
1> 
2> create view GXD_Specimen_View
3> as
4> select s.*, e.embeddingMethod, f.fixation, g.strain
5> from GXD_Specimen s, GXD_EmbeddingMethod e, GXD_FixationMethod f, GXD_Genotype_View g
6> where s._Embedding_key = e._Embedding_key
7> and s._Fixation_key = f._Fixation_key
8> and s._Genotype_key = g._Genotype_key
1> 
2> grant select on GXD_Specimen_View to public
1> 
2> drop view GXD_InSituResult_View
1> 
2> create view GXD_InSituResult_View
3> as
4> select r.*, s.strength, p.pattern
5> from GXD_InSituResult r, GXD_Strength s, GXD_Pattern p
6> where r._Strength_key = s._Strength_key
7> and r._Pattern_key = p._Pattern_key
1> 
2> grant select on GXD_InSituResult_View to public
1> 
2> drop view GXD_ISResultImage_View
1> 
2> create view GXD_ISResultImage_View
3> as
4> /* figurepaneLabel is the concatenation of figureLabel and paneLabel for display purposes */
5> select r._Specimen_key, r.sequenceNum, i.*, figurepaneLabel = m.figureLabel + convert(varchar(10), p.paneLabel), 
6> p._Image_key, p.paneLabel, m.figureLabel, m.xDim, m.yDim
7> from GXD_InSituResult r, GXD_InSituResultImage i, IMG_ImagePane p, IMG_Image m
8> where r._Result_key = i._Result_key
9> and i._ImagePane_key = p._ImagePane_key
10> and p._Image_key = m._Image_key
1> 
2> grant select on GXD_ISResultImage_View to public
1> 
2> drop view GXD_GelLane_View
1> 
2> create view GXD_GelLane_View
3> as
4> /* sampleAmount_str is a string version of sampleAmount without trailing zeroes for display purposes */
5> select l.*, t.rnaType, g.strain, c.gelLaneContent,
6> sampleAmount_str = ltrim(str(l.sampleAmount,10,2))
7> from GXD_GelLane l, GXD_GelRNAType t, GXD_Genotype_View g, GXD_GelControl c
8> where l._GelRNAType_key = t._GelRNAType_key
9> and l._Genotype_key = g._Genotype_key
10> and l._GelControl_key = c._GelControl_key
1> 
2> grant select on GXD_GelLane_View to public
1> 
2> drop view GXD_GelRow_View
1> 
2> create view GXD_GelRow_View
3> as
4> /* size_str is a string version of size without trailing zeroes for display purposes */
5> select l.*, size_str = ltrim(str(l.size,10,2)), u.units
6> from GXD_GelRow l, GXD_GelUnits u
7> where l._GelUnits_key = u._GelUnits_key
1> 
2> grant select on GXD_GelRow_View to public
1> 
2> drop view GXD_GelBand_View
1> 
2> create view GXD_GelBand_View
3> as
4> select b.*, s.strength, l._Assay_key, laneNum = l.sequenceNum, rowNum = r.sequenceNum
5> from GXD_GelBand b, GXD_Strength s, GXD_GelLane l, GXD_GelRow r
6> where b._Strength_key = s._Strength_key
7> and b._GelLane_key = l._GelLane_key
8> and b._GelRow_key = r._GelRow_key
1> 
2> grant select on GXD_GelBand_View to public
1> 
2> drop view GXD_GelLaneStructure_View
1> 
2> create view GXD_GelLaneStructure_View
3> as
4> select l._Assay_key, l.sequenceNum, g.*, s.printName, t.stage, t._Stage_key,
5> dbName = "[DB]:  Stage" + convert(varchar(5), t.stage) + ";" + s.printName
6> from GXD_GelLane l, GXD_GelLaneStructure g, GXD_Structure s, GXD_TheilerStage t
7> where l._GelLane_key = g._GelLane_key
8> and g._Structure_key = s._Structure_key
9> and s._Stage_key = t._Stage_key
1> 
2> grant select on GXD_GelLaneStructure_View to public
1> 
2> drop view GXD_ISResultStructure_View
1> 
2> create view GXD_ISResultStructure_View
3> as
4> select r._Specimen_key, r.sequenceNum, g.*, s.printName, t.stage, t._Stage_key,
5> dbName = "[DB]:  Stage" + convert(varchar(5), t.stage) + ";" + s.printName
6> from GXD_InSituResult r, GXD_ISResultStructure g, GXD_Structure s, GXD_TheilerStage t
7> where r._Result_key = g._Result_key
8> and g._Structure_key = s._Structure_key
9> and s._Stage_key = t._Stage_key
1> 
2> grant select on GXD_ISResultStructure_View to public
1> 
2> drop view GXD_Index_View
1> 
2> create view GXD_Index_View
3> as
4> select i.*, m.symbol, c.jnumID, c.jnum, c.short_citation
5> from GXD_Index i, MRK_Marker m, BIB_All_View c
6> where i._Marker_key = m._Marker_key
7> and i._Refs_key = c._Refs_key
1> 
2> grant select on GXD_Index_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view HMD_Homology_View
1> 
2> create view HMD_Homology_View
3> as
4> select r._Class_key, r._Refs_key, r.creation_date, r.modification_date,
5> classRef = convert(varchar(10), r._Class_key) + ':' + convert(varchar(10), r._Refs_key),
6> h._Homology_key, h._Marker_key,
7> m.symbol, m.name, m.chromosome, m.cytogeneticOffset,
8> m._Species_key, m.species, m.commonName, m.latinName,
9> b.jnumID, b.jnum, b.short_citation
10> from HMD_Homology r, HMD_Homology_Marker h, 
11> MRK_Marker_View m, BIB_View b
12> where r._Homology_key = h._Homology_key
13> and h._Marker_key = m._Marker_key
14> and r._Refs_key = b._Refs_key
1> 
2> grant select on HMD_Homology_View to public
1> 
2> drop view HMD_Homology_Assay_View
1> 
2> create view HMD_Homology_Assay_View
3> as
4> select h.*, a.assay
5> from HMD_Homology_Assay h, HMD_Assay a
6> where h._Assay_key = a._Assay_key
1> 
2> grant select on HMD_Homology_Assay_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view IMG_Image_Acc_View
1>  
2> create view IMG_Image_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 9
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on IMG_Image_Acc_View to public
1> 
2> drop view IMG_Image_View
1> 
2> create view IMG_Image_View
3> as
4> select i.*, mgiID = a.accID, a.prefixPart, a.numericPart,
5> c.jnumID, c.jnum, c.short_citation
6> from IMG_Image i, IMG_Image_Acc_View a, BIB_All_View c
7> where i._Image_key = a._Object_key
8> and a.prefixPart = "MGI:"
9> and a.preferred = 1
10> and i._Refs_key = c._Refs_key
1> 
2> grant select on IMG_Image_View to public
1> 
2> drop view IMG_ImagePane_View
1> 
2> create view IMG_ImagePane_View
3> as
4> select i.*, f.fieldType
5> from IMG_ImagePane i, IMG_FieldType f
6> where i._FieldType_key = f._FieldType_key
1> 
2> grant select on IMG_ImagePane_View to public
1> 
2> drop view IMG_ImagePaneRef_View
1> 
2> create view IMG_ImagePaneRef_View
3> as
4> select r._Image_key, r._Refs_key, i._ImagePane_key, paneLabel = r.figureLabel + i.paneLabel,
5> c.jnumID, c.jnum, c.short_citation
6> from IMG_Image r, IMG_ImagePane i, BIB_All_View c
7> where r._Image_key = i._Image_key
8> and r._Refs_key = c._Refs_key
1> 
2> grant select on IMG_ImagePaneRef_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view MGI_Table_Column_View
1> 
2> create view MGI_Table_Column_View
3> as 
4> SELECT _Table_id = t._Table_id, table_name = o.name, table_description = t.description,
5> column_name = c.name, _Column_id = cc._Column_id, column_description = cc.description,
6> example = cc.example, t.creation_date, t.modification_date
7> FROM
8> syscolumns c, MGI_Columns cc, sysobjects o, MGI_Tables t
9> WHERE
10> o.id = t._Table_id AND cc._Column_id = c.colid AND
11> o.id = c.id AND cc._Table_id = t._Table_id AND ((o.type='U'))
1> 
2> grant select on MGI_Table_Column_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view MLC_Marker_edit_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'MLC_Marker_edit_View', because it doesn't exist in the
system catalogs.
1>  
2> create view MLC_Marker_edit_View
3> as
4> select m.*, m1.symbol, tagSymbol = m2.symbol 
5> from MLC_Marker_edit m, MRK_Marker m1, MRK_Marker m2
6> where m._Marker_key = m1._Marker_key
7> and m._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLC_Marker_edit_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view MLD_Acc_View
1>  
2> create view MLD_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 4
7> and a._LogicalDB_key = l._LogicalDB_key
1>  
2> grant select on MLD_Acc_View to public
1>  
2> drop view MLD_Marker_View
1> 
2> create view MLD_Marker_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, g.*, m.symbol, c._primary, c.authors
5> from BIB_View c, MLD_Marker g, MRK_Marker m
6> where g._Refs_key = c._Refs_key
7> and g._Marker_key = m._Marker_key
1> 
2> grant select on MLD_Marker_View to public
1> 
2> drop view MLD_Expt_View
1> 
2> create view MLD_Expt_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, x.*, c._primary, c.authors, 
5> mgiID = a.accID, a.prefixPart, a.numericPart
6> from BIB_View c, MLD_Expts x, MLD_Acc_View a
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and a.preferred = 1
1> 
2> grant select on MLD_Expt_View to public
1> 
2> drop view MLD_Expt_Marker_View
1> 
2> create view MLD_Expt_Marker_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, m.symbol, x.exptType, x.tag, e.*, 
5> allele = al.symbol, assay = a.description, c._primary, c.authors
6> from BIB_View c, MLD_Expts x, MLD_Expt_Marker e, ALL_Allele al, MLD_Assay_Types a, MRK_Marker m
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key = m._Marker_key
10> and e._Allele_key *= al._Allele_key
11> and e._Assay_Type_key = a._Assay_Type_key
1> 
2> grant select on MLD_Expt_Marker_View to public
1> 
2> drop view MLD_FISH_View
1> 
2> create view MLD_FISH_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, s.strain, c._primary, c.authors
5> from BIB_View c, MLD_Expts x, MLD_FISH e, PRB_Strain s
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Strain_key = s._Strain_key
1> 
2> grant select on MLD_FISH_View to public
1> 
2> drop view MLD_Hybrid_View
1> 
2> create view MLD_Hybrid_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, c._primary, c.authors 
5> from BIB_View c, MLD_Expts x, MLD_Hybrid e
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
1> 
2> grant select on MLD_Hybrid_View to public
1> 
2> drop view MLD_Concordance_View
1> 
2> create view MLD_Concordance_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, m.symbol, c._primary, c.authors 
5> from BIB_View c, MLD_Expts x, MLD_Concordance e, MRK_Marker m
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Marker_key *= m._Marker_key
1> 
2> grant select on MLD_Concordance_View to public
1> 
2> drop view MLD_InSitu_View
1> 
2> create view MLD_InSitu_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, s.strain, c._primary, c.authors
5> from BIB_View c, MLD_Expts x, MLD_InSitu e, PRB_Strain s
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Strain_key = s._Strain_key
1> 
2> grant select on MLD_InSitu_View to public
1> 
2> drop view MLD_Matrix_View
1> 
2> create view MLD_Matrix_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, x.tag,
5> e._Expt_key, e.female, e.female2, e.male, e.male2,
6> s.*,
7> femaleStrain = s1.strain, maleStrain = s2.strain,
8> strainHO = s3.strain, strainHT = s4.strain,
9> c._primary, c.authors
10> from BIB_View c, MLD_Expts x, MLD_Matrix e, CRS_Cross s,
11> PRB_Strain s1, PRB_Strain s2, PRB_Strain s3, PRB_Strain s4
12> where c._Refs_key = x._Refs_key
13> and x._Expt_key = e._Expt_key
14> and e._Cross_key = s._Cross_key
15> and s._femaleStrain_key = s1._Strain_key
16> and s._maleStrain_key = s2._Strain_key
17> and s._StrainHO_key = s3._Strain_key
18> and s._StrainHT_key = s4._Strain_key
1> 
2> grant select on MLD_Matrix_View to public
1> 
2> drop view MLD_MC2point_View
1> 
2> create view MLD_MC2point_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, c._primary, c.authors 
6> from BIB_View c, MLD_Expts x, MLD_MC2point e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_MC2point_View to public
1> 
2> drop view MLD_Statistics_View
1> 
2> create view MLD_Statistics_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, x.exptType, x.tag, c._primary, c.authors
6> from BIB_View c, MLD_Expts x, MLD_Statistics e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_Statistics_View to public
1> 
2> drop view MLD_Distance_View
1> 
2> create view MLD_Distance_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, c._primary, c.authors
6> from BIB_View c, MLD_Expts x, MLD_Distance e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_Distance_View to public
1> 
2> drop view MLD_RI_View
1> 
2> create view MLD_RI_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, x.tag, e._Expt_key, e.RI_IdList, 
5> s._RISet_key, s.origin, s.designation, abbrev1 = rtrim(s.abbrev1), abbrev2 = rtrim(s.abbrev2), 
6> c._primary, c.authors 
7> from BIB_View c, MLD_Expts x, MLD_RI e, RI_RISet s
8> where c._Refs_key = x._Refs_key
9> and x._Expt_key = e._Expt_key
10> and e._RISet_key *= s._RISet_key
1> 
2> grant select on MLD_RI_View to public
1> 
2> drop view MLD_RIData_View
1> 
2> create view MLD_RIData_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, m.symbol, c._primary, c.authors 
5> from BIB_View c, MLD_Expts x, MLD_RIData e, MRK_Marker m
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Marker_key = m._Marker_key
1> 
2> grant select on MLD_RIData_View to public
1> 
2> drop view MLD_RI2Point_View
1> 
2> create view MLD_RI2Point_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, c._primary, c.authors 
6> from BIB_View c, MLD_Expts x, MLD_RI2Point e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_RI2Point_View to public
1> 
2> drop view MLD_Hit_View
1>  
2> create view MLD_Hit_View
3> as
4> select x.*, probeKey = h._Probe_key, probe = p1.name, 
5> targetKey = h._Target_key, target = p2.name
6> from MLD_Expts x, MLD_Hit h, PRB_Probe p1, PRB_Probe p2
7> where x._Expt_key = h._Expt_key
8> and h._Probe_key = p1._Probe_key
9> and h._Target_key = p2._Probe_key
1>  
2> grant select on MLD_Hit_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view MRK_Acc_View
1> 
2> create view MRK_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 2
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on MRK_Acc_View to public
1>  
2> drop view MRK_Marker_View
1>  
2> create view MRK_Marker_View
3> as
4> select m.*, 
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> status = ms.status
8> from MRK_Marker m, MRK_Species s, MRK_Status ms
9> where m._Species_key = s._Species_key
10> and m._Marker_Status_key = ms._Marker_Status_key
1> 
2> grant select on MRK_Marker_View to public
1>  
2> drop view MRK_Mouse_View
1>  
2> create view MRK_Mouse_View
3> as
4> select m.*, o.offset, offset_str = str(o.offset,10,2),
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> status = ms.status,
8> mgiID = a.accID, a.prefixPart, a.numericPart, a._Accession_key,
9> markerType = t.name
10> from MRK_Marker m, MRK_Offset o, MRK_Species s, MRK_Status ms, MRK_Acc_View a, MRK_Types t
11> where m._Species_key = 1
12> and m._Marker_key = o._Marker_key
13> and o.source = 0
14> and m._Species_key = s._Species_key
15> and m._Marker_Status_key = ms._Marker_Status_key
16> and m._Marker_key = a._Object_key
17> and a.prefixPart = "MGI:"
18> and a.preferred = 1
19> and m._Marker_Type_key = t._Marker_Type_key
1> 
2> grant select on MRK_Mouse_View to public
1>  
2> drop view MRK_NonMouse_View
1> 
2> create view MRK_NonMouse_View
3> as
4> select m.*,
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> a.accID, a._Accession_key
8> from MRK_Marker m, MRK_Species s, MRK_Acc_View a
9> where m._Species_key != 1
10> and m._Species_key = s._Species_key
11> and m._Marker_key = a._Object_key
12> and a._LogicalDB_key != 9
1> 
2> grant select on MRK_NonMouse_View to public
1> 
2> drop view MRK_Alias_View
1> 
2> create view MRK_Alias_View
3> as
4> select a.*, alias = m1.symbol, m2.symbol
5> from MRK_Alias a, MRK_Marker m1, MRK_Marker m2
6> where a._Marker_key = m2._Marker_key
7> and a._Alias_key = m1._Marker_key
1> 
2> grant select on MRK_Alias_View to public
1> 
2> drop view MRK_Classes_View
1> 
2> create view MRK_Classes_View
3> as
4> select c.*, m.symbol, l.name
5> from MRK_Classes c, MRK_Marker m, MRK_Class l
6> where c._Marker_key = m._Marker_key
7> and c._Class_key = l._Class_key
1> 
2> grant select on MRK_Classes_View to public
1> 
2> drop view MRK_History_View
1> 
2> create view MRK_History_View
3> as
4> select h.*, event_display = convert(char(10), h.event_date, 101), e.event, er.eventReason, history = m1.symbol, historyName = m1.name, m2.symbol
5> from MRK_History h, MRK_Event e, MRK_EventReason er, MRK_Marker m1, MRK_Marker m2
6> where h._Marker_Event_key = e._Marker_Event_key
7> and h._Marker_EventReason_key = er._Marker_EventReason_key
8> and h._Marker_key = m2._Marker_key
9> and h._History_key = m1._Marker_key
1> 
2> grant select on MRK_History_View to public
1> 
2> drop view MRK_History_Ref_View
1>  
2> create view MRK_History_Ref_View
3> as
4> select h.*, event_display = convert(char(10), h.event_date, 101), e.event, er.eventReason,
5> history = m1.symbol, historyName = m1.name, m2.symbol,
6> b.jnumID, b.jnum, b.short_citation
7> from MRK_History h, MRK_Event e, MRK_EventReason er, MRK_Marker m1, MRK_Marker m2, BIB_View b
8> where h._Marker_Event_key = e._Marker_Event_key
9> and h._Marker_EventReason_key = er._Marker_EventReason_key
10> and h._Marker_key = m2._Marker_key
11> and h._History_key = m1._Marker_key
12> and h._Refs_key = b._Refs_key
1>  
2> grant select on MRK_History_Ref_View to public
1>  
2> drop view MRK_Current_View
1> 
2> create view MRK_Current_View
3> as
4> select c.*, current_symbol = m1.symbol, m2.symbol, m1.chromosome, m1._Marker_Type_key
5> from MRK_Current c, MRK_Marker m1, MRK_Marker m2
6> where c._Marker_key = m2._Marker_key
7> and c._Current_key = m1._Marker_key
1> 
2> grant select on MRK_Current_View to public
1> 
2> drop view MRK_Anchors_View
1> 
2> create view MRK_Anchors_View
3> as
4> select a.*, m.symbol
5> from MRK_Anchors a, MRK_Marker m
6> where a._Marker_key = m._Marker_key
1> 
2> grant select on MRK_Anchors_View to public
1> 
2> drop view MRK_Reference_View
1> 
2> create view MRK_Reference_View
3> as
4> select r.*, m.symbol, b.jnumID, b.jnum, b.short_citation, b.isReviewArticle
5> from MRK_Reference r, MRK_Marker m, BIB_View b
6> where r._Marker_key = m._Marker_key
7> and r._Refs_key = b._Refs_key
1> 
2> grant select on MRK_Reference_View to public
1> 
2> drop view MRK_AccRef_View
1>  
2> create view MRK_AccRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, ar._Refs_key, b.jnum, b.short_citation
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, BIB_All_View b
6> where a._MGIType_key = 2
7> and a._Accession_key = ar._Accession_key
8> and a._LogicalDB_key = l._LogicalDB_key
9> and a._MGIType_key = m._MGIType_key
10> and ar._Refs_key = b._Refs_key
1>  
2> grant select on MRK_AccRef_View to public
1> 
2> drop view MRK_AccNoRef_View
1>  
2> create view MRK_AccNoRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name,
5> subType = mt.name,
6> description = ma.symbol + ", " + ma.name + ", Chr " + ma.chromosome
7> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, MRK_Marker ma, MRK_Types mt
8> where a._MGIType_key = 2
9> and a._LogicalDB_key = l._LogicalDB_key
10> and a._MGIType_key = m._MGIType_key
11> and a._Object_key = ma._Marker_key
12> and ma._Marker_Type_key = mt._Marker_Type_key
13> and not exists (select r.* from ACC_AccessionReference r
14> where a._Accession_key = r._Accession_key)
1>  
2> grant select on MRK_AccNoRef_View to public
1>  
2> drop view MRK_Other_View
1>  
2> create view MRK_Other_View
3> as
4> select o.*, b.jnumID, b.jnum, b.short_citation, b.isReviewArticle
5> from MRK_Other o, BIB_View b
6> where o._Refs_key = b._Refs_key
1>  
2> grant select on MRK_Other_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view PRB_Acc_View
1> 
2> create view PRB_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 3
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on PRB_Acc_View to public
1> 
2> drop view PRB_AccNoRef_View
1> 
2> create view PRB_AccNoRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, description = p.name
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, PRB_Probe p
6> where a._MGIType_key = 3
7> and a._LogicalDB_key = l._LogicalDB_key
8> and a._MGIType_key = m._MGIType_key
9> and a._Object_key = p._Probe_key
10> and not exists (select r.* from ACC_AccessionReference r
11> where a._Accession_key = r._Accession_key)
1> 
2> grant select on PRB_AccNoRef_View to public
1> 
2> drop view PRB_AccRef_View
1> 
2> create view PRB_AccRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, r._Reference_key
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, PRB_Reference r
6> where a._Accession_key = ar._Accession_key
7> and a._LogicalDB_key = l._LogicalDB_key
8> and a._MGIType_key = m._MGIType_key
9> and a._Object_key = r._Probe_key
10> and ar._Refs_key = r._Refs_key
1> 
2> grant select on PRB_AccRef_View to public
1> 
2> drop view PRB_AccRefNoSeq_View
1> 
2> create view PRB_AccRefNoSeq_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, r._Reference_key
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, PRB_Reference r
6> where a._Accession_key = ar._Accession_key
7> and a._LogicalDB_Key != 9
8> and a._LogicalDB_key = l._LogicalDB_key
9> and a._MGIType_key = m._MGIType_key
10> and a._Object_key = r._Probe_key
11> and ar._Refs_key = r._Refs_key
1> 
2> grant select on PRB_AccRefNoSeq_View to public
1> 
2> drop view PRB_Strain_Acc_View
1> 
2> create view PRB_Strain_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 10
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on PRB_Strain_Acc_View to public
1>  
2> drop view PRB_Source_View
1>  
2> create view PRB_Source_View
3> as
4> select p.*, s.strain, sStandard = s.standard, t.tissue, tStandard = t.standard
5> from PRB_Source p, PRB_Strain s, PRB_Tissue t
6> where p._Strain_key = s._Strain_key 
7> and p._Tissue_key = t._Tissue_key 
1> 
2> grant select on PRB_Source_View to public
1>  
2> drop view PRB_View
1> 
2> create view PRB_View
3> as
4> select p.*, v.vectorType, mgiID = a.accID, a.prefixPart, a.numericPart,
5> s.species, s.age, s.sex, s.cellLine, library = s.name,
6> s.description, s._Refs_key, s._Strain_key, s.strain, s._Tissue_key, s.tissue
7> from PRB_Probe p, PRB_Acc_View a, PRB_Source_View s, PRB_Vector_Types v
8> where p._Probe_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and a.preferred = 1
11> and p._Vector_key = v._Vector_key
12> and p._Source_key = s._Source_key
1> 
2> grant select on PRB_View to public
1> 
2> drop view PRB_Primer_View
1>  
2> create view PRB_Primer_View
3> as
4> select p._Probe_key, p.name,
5> p.regionCovered,
6> p.regionCovered2,
7> p.DNAtype, p.primer1sequence, p.primer2sequence,
8> p.repeatUnit, p.productSize, p.moreProduct,
9> p.creation_date, p.modification_date,
10> mgiID = a.accID, a.prefixPart, a.numericPart
11> from PRB_Probe p, PRB_Acc_View a
12> where p.DNAtype = "primer"
13> and p._Probe_key = a._Object_key
14> and a.prefixPart = "MGI:"
1>   
2> grant select on PRB_Primer_View to public
1>     
2> drop view PRB_Probe_View
1>  
2> create view PRB_Probe_View
3> as
4> select p._Probe_key, p.name,
5> p.regionCovered,
6> p.regionCovered2,
7> p.insertSize, p.DNAtype,
8> p.derivedFrom, parentClone = p2.name,
9> p._Vector_key, v.vectorType, p.insertSite,
10> p.creation_date, p.modification_date,
11> s._Source_key, sourceName = s.name, s._Refs_key,
12> s.species, s.age, s.sex, s.cellLine, s._Strain_key, s.strain, s._Tissue_key, s.tissue,
13> mgiID = a.accID, a.prefixPart, a.numericPart
14> from PRB_Probe p, PRB_Acc_View a, PRB_Source_View s, PRB_Vector_Types v, PRB_Probe p2
15> where p.DNAtype != "primer"
16> and p._Probe_key = a._Object_key
17> and a.prefixPart = "MGI:"
18> and p._Source_key = s._Source_key
19> and p._Vector_key = v._Vector_key
20> and p.derivedFrom *= p2._Probe_key
1> 
2> grant select on PRB_Probe_View to public
1>  
2> drop view PRB_Parent_View
1> 
2> create view PRB_Parent_View
3> as
4> select p._Probe_key, p.name, a.accID, accPrefix = a.prefixPart, accNumeric = a.numericPart,
5> parentKey = p2._Probe_key, parentClone = p2.name,
6> parentID = a2.accID, parentPrefix = a2.prefixPart, parentNumeric = a2.numericPart
7> from PRB_Probe p, PRB_Acc_View a, PRB_Probe p2, PRB_Acc_View a2
8> where p._Probe_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and p.derivedFrom = p2._Probe_key
11> and p2._Probe_key = a2._Object_key
12> and a2.prefixPart = "MGI:"
1> 
2> grant select on PRB_Parent_View to public
1> 
2> drop view PRB_Marker_View
1> 
2> create view PRB_Marker_View
3> as
4> select g._Probe_key, p.name, g._Marker_key, m.symbol, m.chromosome, g.relationship
5> from PRB_Probe p, PRB_Marker g, MRK_Marker m
6> where p._Probe_key = g._Probe_key
7> and g._Marker_key = m._Marker_key
1> 
2> grant select on PRB_Marker_View to public
1> 
2> drop view PRB_Reference_View
1> 
2> create view PRB_Reference_View
3> as
4> select c.jnum, c.jnumID, c.short_citation, r.*
5> from PRB_Reference r, BIB_All_View c
6> where r._Refs_key = c._Refs_key
1> 
2> grant select on PRB_Reference_View to public
1> 
2> drop view PRB_RFLV_View
1> 
2> create view PRB_RFLV_View
3> as
4> select r.*, a._Allele_key, a.allele, a.fragments, s.strain, m.symbol, s._Strain_key
5> from PRB_RFLV r, PRB_Allele a, PRB_Allele_Strain p, PRB_Strain s, MRK_Marker m
6> where r._RFLV_key = a._RFLV_key
7> and a._Allele_key = p._Allele_key
8> and p._Strain_key = s._Strain_key
9> and r._Marker_key = m._Marker_key
1> 
2> grant select on PRB_RFLV_View to public
1> 
2> drop view PRB_SourceRef_View
1>  
2> create view PRB_SourceRef_View
3> as
4> select p.*, c.jnumID, c.jnum, c.short_citation
5> from PRB_Source_View p, BIB_All_View c
6> where p._Refs_key = c._Refs_key
1> 
2> grant select on PRB_SourceRef_View to public
1> 
2> drop view PRB_Strain_Marker_View
1> 
2> create view PRB_Strain_Marker_View
3> as
4> select s.*, m.symbol
5> from PRB_Strain_Marker s, MRK_Marker m
6> where s._Marker_key = m._Marker_key
1> 
2> grant select on PRB_Strain_Marker_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view BIB_Summary_All_View
1> 
2> create view BIB_Summary_All_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
8> from ACC_Accession a, ACC_Accession a2, BIB_Refs b
9> where a._MGIType_key = 1
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 1
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = b._Refs_key
1> 
2> grant select on BIB_Summary_All_View to public
1>  
2> drop view BIB_Summary_View
1> 
2> create view BIB_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
8> from ACC_Accession a, ACC_Accession a2, BIB_Refs b
9> where a._MGIType_key = 1
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 1
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = b._Refs_key
17> and (b.journal != 'Submission' or b.journal is null)
1> 
2> grant select on BIB_Summary_View to public
1>  
2> drop view MRK_Summary_View
1>  
2> create view MRK_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = mt.name,
7> description = m.symbol + ", " + m.name + ", Chr " + m.chromosome
8> from ACC_Accession a, ACC_Accession a2, MRK_Marker m, MRK_Types mt
9> where a._MGIType_key = 2
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 2
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = m._Marker_key
17> and m._Species_key = 1
18> and m._Marker_Type_key = mt._Marker_Type_key
1>  
2> grant select on MRK_Summary_View to public
1>  
2> drop view HMD_Summary_View
1>  
2> create view HMD_Summary_View
3> as
4> select a.*,
5> mgiID = null,
6> subType = mt.name,
7> description = m.symbol + ", " + m.name + ", Chr " + m.chromosome
8> from ACC_Accession a, MRK_Marker m, MRK_Types mt
9> where a._MGIType_key = 2
10> and a.private = 0
11> and a._Object_key = m._Marker_key
12> and m._Species_key != 1
13> and m._Marker_Type_key = mt._Marker_Type_key
1>  
2> grant select on HMD_Summary_View to public
1> 
2> drop view PRB_Summary_View
1>  
2> create view PRB_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = p.DNAtype,
7> description = p.name
8> from ACC_Accession a, ACC_Accession a2, PRB_Probe p
9> where a._MGIType_key = 3
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 3
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = p._Probe_key
1>  
2> grant select on PRB_Summary_View to public
1>  
2> drop view MLD_Summary_View
1>  
2> create view MLD_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = e.exptType,
7> description = b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
8> from ACC_Accession a, ACC_Accession a2, MLD_Expts e, BIB_Refs b
9> where a._MGIType_key = 4
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 4
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = e._Expt_key
17> and e._Refs_key = b._Refs_key
1>  
2> grant select on MLD_Summary_View to public
1>  
2> drop view GXD_Antibody_Summary_View
1>  
2> create view GXD_Antibody_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = t.antibodyType,
7> description = g.antibodyName
8> from ACC_Accession a, ACC_Accession a2, GXD_Antibody g, GXD_AntibodyType t
9> where a._MGIType_key = 6
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 6
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = g._Antibody_key
17> and g._AntibodyType_key = t._AntibodyType_key
1>  
2> grant select on GXD_Antibody_Summary_View to public
1>  
2> drop view GXD_Antigen_Summary_View
1>  
2> create view GXD_Antigen_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = g.antigenName
8> from ACC_Accession a, ACC_Accession a2, GXD_Antigen g
9> where a._MGIType_key = 7
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 7
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = g._Antigen_key
1>  
2> grant select on GXD_Antigen_Summary_View to public
1> 
2> drop view GXD_Assay_Summary_View
1>  
2> create view GXD_Assay_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = t.assayType,
7> description = m.symbol
8> from ACC_Accession a, ACC_Accession a2, GXD_Assay g, GXD_AssayType t, MRK_Marker m
9> where a._MGIType_key = 8
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 8
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = g._Assay_key
17> and g._AssayType_key = t._AssayType_key
18> and g._Marker_key = m._Marker_key
1>   
2> grant select on GXD_Assay_Summary_View to public
1> 
2> drop view IMG_Image_Summary_View
1>  
2> create view IMG_Image_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = g.figureLabel + " " + 
8> b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
9> from ACC_Accession a, ACC_Accession a2, IMG_Image g, BIB_Refs b
10> where a._MGIType_key = 9
11> and a.private = 0
12> and a._Object_key = a2._Object_key
13> and a2._LogicalDB_key = 1
14> and a2._MGIType_key = 9
15> and a2.prefixPart = "MGI:"
16> and a2.preferred = 1
17> and a._Object_key = g._Image_key
18> and g._Refs_key = b._Refs_key
1>  
2> grant select on IMG_Image_Summary_View to public
1> 
2> drop view ALL_Summary_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'ALL_Summary_View', because it doesn't exist in the system
catalogs.
1>  
2> create view ALL_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = t.alleleType,
7> description = al.symbol + ", " + al.name
8> from ACC_Accession a, ACC_Accession a2, ALL_Allele al, ALL_Type t
9> where a._MGIType_key = 11
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 11
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = al._Allele_key
17> and al._Allele_Type_key = t._Allele_Type_key
1>  
2> grant select on ALL_Summary_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view MRK_Acc_View
1> 
2> create view MRK_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 2
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on MRK_Acc_View to public
1>  
2> drop view MRK_Marker_View
1>  
2> create view MRK_Marker_View
3> as
4> select m.*, 
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> status = ms.status
8> from MRK_Marker m, MRK_Species s, MRK_Status ms
9> where m._Species_key = s._Species_key
10> and m._Marker_Status_key = ms._Marker_Status_key
1> 
2> grant select on MRK_Marker_View to public
1>  
2> drop view MRK_Mouse_View
1>  
2> create view MRK_Mouse_View
3> as
4> select m.*, o.offset, offset_str = str(o.offset,10,2),
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> status = ms.status,
8> mgiID = a.accID, a.prefixPart, a.numericPart, a._Accession_key,
9> markerType = t.name
10> from MRK_Marker m, MRK_Offset o, MRK_Species s, MRK_Status ms, MRK_Acc_View a, MRK_Types t
11> where m._Species_key = 1
12> and m._Marker_key = o._Marker_key
13> and o.source = 0
14> and m._Species_key = s._Species_key
15> and m._Marker_Status_key = ms._Marker_Status_key
16> and m._Marker_key = a._Object_key
17> and a.prefixPart = "MGI:"
18> and a.preferred = 1
19> and m._Marker_Type_key = t._Marker_Type_key
1> 
2> grant select on MRK_Mouse_View to public
1>  
2> drop view MRK_NonMouse_View
1> 
2> create view MRK_NonMouse_View
3> as
4> select m.*,
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> a.accID, a._Accession_key
8> from MRK_Marker m, MRK_Species s, MRK_Acc_View a
9> where m._Species_key != 1
10> and m._Species_key = s._Species_key
11> and m._Marker_key = a._Object_key
12> and a._LogicalDB_key != 9
1> 
2> grant select on MRK_NonMouse_View to public
1> 
2> drop view MRK_Alias_View
1> 
2> create view MRK_Alias_View
3> as
4> select a.*, alias = m1.symbol, m2.symbol
5> from MRK_Alias a, MRK_Marker m1, MRK_Marker m2
6> where a._Marker_key = m2._Marker_key
7> and a._Alias_key = m1._Marker_key
1> 
2> grant select on MRK_Alias_View to public
1> 
2> drop view MRK_Classes_View
1> 
2> create view MRK_Classes_View
3> as
4> select c.*, m.symbol, l.name
5> from MRK_Classes c, MRK_Marker m, MRK_Class l
6> where c._Marker_key = m._Marker_key
7> and c._Class_key = l._Class_key
1> 
2> grant select on MRK_Classes_View to public
1> 
2> drop view MRK_History_View
1> 
2> create view MRK_History_View
3> as
4> select h.*, event_display = convert(char(10), h.event_date, 101), e.event, er.eventReason, history = m1.symbol, historyName = m1.name, m2.symbol
5> from MRK_History h, MRK_Event e, MRK_EventReason er, MRK_Marker m1, MRK_Marker m2
6> where h._Marker_Event_key = e._Marker_Event_key
7> and h._Marker_EventReason_key = er._Marker_EventReason_key
8> and h._Marker_key = m2._Marker_key
9> and h._History_key = m1._Marker_key
1> 
2> grant select on MRK_History_View to public
1> 
2> drop view MRK_History_Ref_View
1>  
2> create view MRK_History_Ref_View
3> as
4> select h.*, event_display = convert(char(10), h.event_date, 101), e.event, er.eventReason,
5> history = m1.symbol, historyName = m1.name, m2.symbol,
6> b.jnumID, b.jnum, b.short_citation
7> from MRK_History h, MRK_Event e, MRK_EventReason er, MRK_Marker m1, MRK_Marker m2, BIB_View b
8> where h._Marker_Event_key = e._Marker_Event_key
9> and h._Marker_EventReason_key = er._Marker_EventReason_key
10> and h._Marker_key = m2._Marker_key
11> and h._History_key = m1._Marker_key
12> and h._Refs_key = b._Refs_key
1>  
2> grant select on MRK_History_Ref_View to public
1>  
2> drop view MRK_Current_View
1> 
2> create view MRK_Current_View
3> as
4> select c.*, current_symbol = m1.symbol, m2.symbol, m1.chromosome, m1._Marker_Type_key
5> from MRK_Current c, MRK_Marker m1, MRK_Marker m2
6> where c._Marker_key = m2._Marker_key
7> and c._Current_key = m1._Marker_key
1> 
2> grant select on MRK_Current_View to public
1> 
2> drop view MRK_Anchors_View
1> 
2> create view MRK_Anchors_View
3> as
4> select a.*, m.symbol
5> from MRK_Anchors a, MRK_Marker m
6> where a._Marker_key = m._Marker_key
1> 
2> grant select on MRK_Anchors_View to public
1> 
2> drop view MRK_Reference_View
1> 
2> create view MRK_Reference_View
3> as
4> select r.*, m.symbol, b.jnumID, b.jnum, b.short_citation, b.isReviewArticle
5> from MRK_Reference r, MRK_Marker m, BIB_View b
6> where r._Marker_key = m._Marker_key
7> and r._Refs_key = b._Refs_key
1> 
2> grant select on MRK_Reference_View to public
1> 
2> drop view MRK_AccRef_View
1>  
2> create view MRK_AccRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, ar._Refs_key, b.jnum, b.short_citation
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, BIB_All_View b
6> where a._MGIType_key = 2
7> and a._Accession_key = ar._Accession_key
8> and a._LogicalDB_key = l._LogicalDB_key
9> and a._MGIType_key = m._MGIType_key
10> and ar._Refs_key = b._Refs_key
1>  
2> grant select on MRK_AccRef_View to public
1> 
2> drop view MRK_AccNoRef_View
1>  
2> create view MRK_AccNoRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name,
5> subType = mt.name,
6> description = ma.symbol + ", " + ma.name + ", Chr " + ma.chromosome
7> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, MRK_Marker ma, MRK_Types mt
8> where a._MGIType_key = 2
9> and a._LogicalDB_key = l._LogicalDB_key
10> and a._MGIType_key = m._MGIType_key
11> and a._Object_key = ma._Marker_key
12> and ma._Marker_Type_key = mt._Marker_Type_key
13> and not exists (select r.* from ACC_AccessionReference r
14> where a._Accession_key = r._Accession_key)
1>  
2> grant select on MRK_AccNoRef_View to public
1>  
2> drop view MRK_Other_View
1>  
2> create view MRK_Other_View
3> as
4> select o.*, b.jnumID, b.jnum, b.short_citation, b.isReviewArticle
5> from MRK_Other o, BIB_View b
6> where o._Refs_key = b._Refs_key
1>  
2> grant select on MRK_Other_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop view HMD_Homology_View
1> 
2> create view HMD_Homology_View
3> as
4> select r._Class_key, r._Refs_key, r.creation_date, r.modification_date,
5> classRef = convert(varchar(10), r._Class_key) + ':' + convert(varchar(10), r._Refs_key),
6> h._Homology_key, h._Marker_key,
7> m.symbol, m.name, m.chromosome, m.cytogeneticOffset,
8> m._Species_key, m.species, m.commonName, m.latinName,
9> b.jnumID, b.jnum, b.short_citation
10> from HMD_Homology r, HMD_Homology_Marker h, 
11> MRK_Marker_View m, BIB_View b
12> where r._Homology_key = h._Homology_key
13> and h._Marker_key = m._Marker_key
14> and r._Refs_key = b._Refs_key
1> 
2> grant select on HMD_Homology_View to public
1> 
2> drop view HMD_Homology_Assay_View
1> 
2> create view HMD_Homology_Assay_View
3> as
4> select h.*, a.assay
5> from HMD_Homology_Assay h, HMD_Assay a
6> where h._Assay_key = a._Assay_key
1> 
2> grant select on HMD_Homology_Assay_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop procedure ACC_resetMax
1> 
2> create procedure ACC_resetMax
3>   @objectKey int,
4>   @mgiType varchar(80),
5>   @prefixPart varchar(20) = "MGI:"
6> as
7> 
8> /* If deleting object which is using the maxNumericPart 
9>    from ACC_AccessionMax, then reset the maxNumericPart
10>    so there aren't so many holes.  During withdrawals,
11>    new Marker symbols may not receive MGI accession numbers,
12>    but the MRK_Marker insert trigger will always insert one
13> */
14> 
15> declare @numericPart int
16> select @numericPart = a.numericPart 
17> from ACC_Accession a, ACC_MGIType m
18> where a._Object_key = @objectKey
19> and a.prefixPart = @prefixPart
20> and a._MGIType_key = m._MGIType_key
21> and m.name = @mgiType
22> 
23> if (select maxNumericPart from ACC_AccessionMax where prefixPart = @prefixPart) = @numericPart
24> begin
25> 	update ACC_AccessionMax
26> 	set maxNumericPart = maxNumericPart - 1
27> 	where prefixPart = @prefixPart
28> end
29> 
1> 
2> grant execute on ACC_resetMax to progs
1> 
2> grant execute on ACC_resetMax to editors
1> 
2> drop procedure ACC_findMax
1> 
2> create procedure ACC_findMax
3>   @prefixPart varchar(20) = "MGI:"
4> as
5> 
6> /* Return maxNumericPart for given prefixPart */
7> 
8> select maxNumericPart
9> from ACC_AccessionMax
10> where prefixPart = @prefixPart
1> 
2> grant execute on ACC_findMax to progs
1> 
2> grant execute on ACC_findMax to editors
1> 
2> grant execute on ACC_findMax to public
1> 
2> drop procedure ACC_setMax
1> 
2> create procedure ACC_setMax
3>   @increment integer,
4>   @prefixPart varchar(20) = "MGI:"
5> as
6> 
7> /* Increment the max MGI Accession Number by @increment */
8> 
9> update ACC_AccessionMax
10> set maxNumericPart = maxNumericPart + @increment
11> where prefixPart= @prefixPart
12> 
1> 
2> grant execute on ACC_setMax to progs
1> 
2> drop procedure ACC_reserveMGIBlock
1> 
2> create procedure ACC_reserveMGIBlock
3>   @blockOf integer
4> as
5> 
6> /* Reserve blocks of Accession IDs for IMAGE consortium, etc. */
7> 
8> select maxNumericPart + 1 "BEGIN BLOCK"
9> from ACC_AccessionMax
10> where prefixPart = "MGI:"
11> 
12> select @blockOf = @blockOf + 1
13> exec ACC_setMax @blockOf
14> 
15> select maxNumericPart "END BLOCK"
16> from ACC_AccessionMax
17> where prefixPart = "MGI:"
18> 
1> 
2> grant execute on ACC_reserveMGIBlock to progs
1> 
2> drop procedure ACC_assignMGI
1> 
2> create procedure ACC_assignMGI
3>   @objectKey int,
4>   @mgiType varchar(80),
5>   @prefixPart varchar(20) = "MGI:",
6>   @nextMGI int = -1,
7>   @preferred int = 1
8> as
9> 
10> /* Assign MGI or J accession number
11>    Allow override of J accession number
12>    Increment ACC_AccessionMax.maxNumericPart
13> */
14> 
15> declare @nextACC int
16> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
17> 
18> declare @mgiTypeKey int
19> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
20> 
21> if @nextMGI = -1
22> begin
23> 	select @nextMGI = maxNumericPart + 1 
24> 	from ACC_AccessionMax where prefixPart = @prefixPart
25> end
26> else if @prefixPart != "J:"
27> begin
28>     rollback transaction
29>     raiserror 99999 "Cannot override generation of MGI accession number"
30>     return
31> end
32> 
33> declare @accID varchar(30)
34> select @accID = @prefixPart + convert(varchar(20), @nextMGI)
35> 
36> insert into ACC_Accession 
37> (_Accession_key, accID, prefixPart, numericPart, 
38> _LogicalDB_key, _Object_key, _MGIType_key, preferred)
39> values(@nextACC, @accID, @prefixPart, @nextMGI, 1, @objectKey, @mgiTypeKey, @preferred)
40> 
41> if (select maxNumericPart from ACC_AccessionMax
42>     where prefixPart = @prefixPart) <= @nextMGI
43> begin
44> 	update ACC_AccessionMax 
45> 	set maxNumericPart = @nextMGI 
46> 	where prefixPart = @prefixPart
47> end
48> 
1> 
2> grant execute on ACC_assignMGI to progs
1> 
2> grant execute on ACC_assignMGI to editors
1> 
2> drop procedure ACC_assignJ
1> 
2> create procedure ACC_assignJ
3>   @objectKey int,
4>   @nextMGI int = -1
5> as
6> 
7> if @nextMGI != -1
8> begin
9> 	declare @exists int
10> 	select @exists = count(*) from BIB_Acc_View
11>                where prefixPart = "J:" and 
12> 	       numericPart = @nextMGI
13> 	if @exists > 0
14> 	begin
15>   		rollback transaction
16>   		raiserror 99999 "This J Number is already in use"
17>   		return
18> 	end
19> end
20> 
21> exec ACC_assignMGI @objectKey, "Reference", "J:", @nextMGI
22> 
1> 
2> grant execute on ACC_assignJ to progs
1> 
2> grant execute on ACC_assignJ to editors
1> 
2> drop procedure ACCRef_insert
1>  
2> create procedure ACCRef_insert
3>   @accKey int,
4>   @refsKey int
5> as
6>  
7> /* Insert record into ACC_AccessionReference table */
8> 
9> insert into ACC_AccessionReference
10> (_Accession_key, _Refs_key)
11> values(@accKey, @refsKey)
12> 
1>  
2> grant execute on ACCRef_insert to progs
1>  
2> grant execute on ACCRef_insert to editors
1>  
2> drop procedure ACC_insert
1>  
2> create procedure ACC_insert
3>   @objectKey int,
4>   @accID varchar(30),
5>   @logicalDB int,
6>   @mgiType varchar(80),
7>   @refsKey int = -1,
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* Insert record into master Accession table. */
13> /* If reference is given, insert record into Accession Reference table. */
14> 
15> if @accID is null
16> 	return
17> 
18> declare @nextACC int
19> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
20>  
21> declare @mgiTypeKey int
22> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
23>  
24> declare @prefixPart varchar(20)
25> declare @numericPart int
26> exec ACC_split @accID, @prefixPart out, @numericPart out
27> 						      
28> insert into ACC_Accession
29> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
30> values(@nextACC, @accID, @prefixPart, @numericPart, @logicalDB, @objectKey, @mgiTypeKey, @private, @preferred)
31> 
32> if @refsKey != -1
33> begin
34> 	exec ACCRef_insert @nextACC, @refsKey
35> end
36> 
1>  
2> grant execute on ACC_insert to progs
1>  
2> grant execute on ACC_insert to editors
1>  
2> drop procedure ACC_insert_bySpecies
1>  
2> create procedure ACC_insert_bySpecies
3>   @objectKey int,
4>   @accID varchar(30),
5>   @speciesKey int
6> as
7>  
8> /* Insert record into master Accession table for a given species */
9> 
10> if @accID is null
11> 	return
12> 
13> declare @logicalDBKey int
14> select @logicalDBKey = _LogicalDB_key from ACC_LogicalDB 
15> where _Species_key = @speciesKey
16>  
17> declare @private int
18> select @private = 0
19> 
20> exec ACC_insert @objectKey, @accID, @logicalDBKey, "Marker", -1, 1, @private
21>  
1>  
2> grant execute on ACC_insert_bySpecies to progs
1>  
2> grant execute on ACC_insert_bySpecies to editors
1>  
2> drop procedure ACCRef_process
1>  
2> create procedure ACCRef_process
3>   @objectKey int,
4>   @refsKey int,
5>   @accID varchar(30),
6>   @logicalDB int,
7>   @mgiType varchar(80),
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* Disallow edits to WashU data - TR 611 */
13> 
14> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
15> 	   and
16> 	  (select user_name()) not in ("mgd_dbo", "dbo")
17> begin
18> 	rollback transaction
19> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
20> 	return
21> end
22> 
23> /* Disallow edits to UniGene data - TR 983 */
24> 
25> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
26> 	   and
27> 	  (select user_name()) not in ("mgd_dbo", "dbo")
28> begin
29> 	rollback transaction
30> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
31> 	return
32> end
33> 
34> /* If the Object/Acc ID pair already exists, then use that _Accession_key */
35> /* and simply insert a new ACC_AccessionReference record (ACCRef_insert) */
36> /* Else, create a new ACC_Accession and ACC_AccessionReference record (ACC_insert) */
37> 
38> declare @accKey integer
39> select @accKey = a._Accession_key 
40> from ACC_Accession a, ACC_MGIType m
41> where accID = @accID
42> and a._Object_key = @objectKey
43> and a._MGIType_key = m._MGIType_key
44> and m.name = @mgiType
45> and a._LogicalDB_key = @logicalDB
46> 
47> begin tran
48> 
49> if @accKey is not null
50> 	exec ACCRef_insert @accKey, @refsKey
51> else
52> 	exec ACC_insert @objectKey, @accID, @logicalDB, @mgiType, @refsKey, @preferred, @private
53> 
54> /* TR 1270 - if adding a Sequence Acc ID to a Marker...
55>  *
56>  * try to update the IMAGE/Marker association
57> */
58> 
59> if @mgiType = "Marker" and @logicalDB = 9
60> begin
61> 	exec MRK_updateIMAGESeqAssoc @objectKey, @accID
62> 
63> 	if @@error != 0
64> 	begin
65> 		rollback transaction
66> 	end
67> end
68> 
69> commit tran
70> 
1>  
2> grant execute on ACCRef_process to progs
1>  
2> grant execute on ACCRef_process to editors
1>  
2> drop procedure ACC_update
1>  
2> create procedure ACC_update
3>   @accKey int,
4>   @accID varchar(30),
5>   @origRefsKey int = -1,
6>   @refsKey int = -1
7> as
8>  
9> /* Disallow edits to WashU data - TR 611 */
10> 
11> if @refsKey > 0
12>    and
13>    (
14>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
15>    or
16>    exists (select * from BIB_All_View where _Refs_key = @origRefsKey and jnum = 57656)
17>    )
18>    and
19>    (select user_name()) not in ("mgd_dbo", "dbo")
20> begin
21> 	rollback transaction
22> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
23> 	return
24> end
25> 
26> /* Disallow edits to UniGene data - TR 983 */
27> 
28> if @refsKey > 0
29>    and
30>    (
31>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
32>    or
33>    exists (select * from BIB_All_View where _Refs_key = @origRefsKey and jnum = 57747)
34>    )
35>    and
36>    (select user_name()) not in ("mgd_dbo", "dbo")
37> begin
38> 	rollback transaction
39> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
40> 	return
41> end
42> 
43> begin tran
44> 
45> declare @isMarkerSeq integer
46> select @isMarkerSeq = 0
47> 
48> if (select _MGIType_key from ACC_Accession 
49> 	where _Accession_key = @accKey) = 2
50>    and
51>    (select _LogicalDB_key from ACC_Accession 
52> 	where _Accession_key = @accKey) = 9
53> begin
54> 	select @isMarkerSeq = 1
55> end
56> 
57> declare @objectKey integer
58> declare @origAccID varchar(30)
59> 
60> select @objectKey = _Object_key from ACC_Accession where _Accession_key = @accKey
61> select @origAccID = accID from ACC_Accession where _Accession_key = @accKey
62> 
63> /* Update the Accession record for a given Accession key */
64> 
65> if @accID is null
66> begin
67> 	exec ACC_delete_byAccKey @accKey
68> end
69> else
70> begin
71> 	declare @prefixPart varchar(20)
72> 	declare @numericPart int
73> 	exec ACC_split @accID, @prefixPart out, @numericPart out
74> 						      
75> 	if (@prefixPart = "J:" or substring(@prefixPart,1,4) = "MGD-")
76> 	begin
77> 		if (select count(*) from ACC_Accession
78> 	    	    where numericPart = @numericPart and
79> 			  prefixPart = @prefixPart) >= 1
80> 		begin
81> 			rollback transaction
82> 			raiserror 99999 "Duplicate MGI Accession Number"
83> 			return
84> 		end
85> 	end
86> 
87> 	update ACC_Accession
88>   	set accID = @accID, 
89>       	prefixPart = @prefixPart, 
90>       	numericPart = @numericPart,
91>       	modification_date = getdate()
92>   	where _Accession_key = @accKey
93> 
94> 	if @refsKey > 0
95> 	begin
96> 		update ACC_AccessionReference
97> 		set _Refs_key = @refsKey
98>   		where _Accession_key = @accKey and
99> 		      _Refs_key = @origRefsKey
100> 	end
101> end
102> 
103> /* TR 1270 - if updating a Sequence Acc ID of a Marker...
104>  *
105>  * delete the old IMAGE/Marker encodes relationship
106>  *
107> */
108> 
109> if @origAccID != @accID and @isMarkerSeq = 1
110> begin
111> 	exec MRK_deleteIMAGESeqAssoc @objectKey, @origAccID
112> 
113> 	if @@error != 0
114> 	begin
115> 		rollback transaction
116> 	end
117> end
118> 
119> /* TR 1270 - if updating a Sequence Acc ID of a Marker...
120>  *
121>  * update the IMAGE/Marker association
122> */
123> 
124> if @isMarkerSeq = 1
125> begin
126> 	exec MRK_updateIMAGESeqAssoc @objectKey, @accID
127> 
128> 	if @@error != 0
129> 	begin
130> 		rollback transaction
131> 	end
132> end
133> 
134> commit tran
135> 
1>  
2> grant execute on ACC_update to progs
1>  
2> grant execute on ACC_update to editors
1>  
2> drop procedure ACC_delete_byObject
1> 
2> create procedure ACC_delete_byObject
3>   @objectKey int,
4>   @mgiType varchar(80)
5> as
6> 
7> /* Delete all accession records for a given Object */
8> 
9> delete ACC_Accession 
10> from ACC_Accession a, ACC_MGIType m
11> where a._Object_key = @objectKey 
12> and a._MGIType_key = m._MGIType_key
13> and m.name = @mgiType
14> 
15> /* May have to reset the MGI or J: Max part */
16> 
17> exec ACC_resetMax @objectKey, @mgiType
18> exec ACC_resetMax @objectKey, @mgiType, "J:"
19> 
1>  
2> grant execute on ACC_delete_byObject to progs
1>  
2> grant execute on ACC_delete_byObject to editors
1>  
2> drop procedure ACC_delete_byAccKey
1> 
2> create procedure ACC_delete_byAccKey
3>   @accKey int,
4>   @refsKey int = -1
5> as
6> 
7> /* Disallow edits to WashU data - TR 611 */
8> 
9> if @refsKey > 0
10>    and
11>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
12>    and
13>    (select user_name()) not in ("mgd_dbo", "dbo")
14> begin
15> 	rollback transaction
16> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
17> 	return
18> end
19> 
20> /* Disallow edits to UniGene data - TR 983 */
21> 
22> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
23> 	   and
24> 	  (select user_name()) not in ("mgd_dbo", "dbo")
25> begin
26> 	rollback transaction
27> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
28> 	return
29> end
30> 
31> begin tran
32> 
33> declare @isMarkerSeq integer
34> select @isMarkerSeq = 0
35> 
36> declare @deleteIMAGESeqAssoc integer
37> select @deleteIMAGESeqAssoc = 0
38> 
39> if (select _MGIType_key from ACC_Accession 
40> 	where _Accession_key = @accKey) = 2
41>    and
42>    (select _LogicalDB_key from ACC_Accession 
43> 	where _Accession_key = @accKey) = 9
44> begin
45> 	select @isMarkerSeq = 1
46> end
47> 
48> declare @objectKey integer
49> declare @accID varchar(30)
50> 
51> select @objectKey = _Object_key from ACC_Accession where _Accession_key = @accKey
52> select @accID = accID from ACC_Accession where _Accession_key = @accKey
53> 
54> if @refsKey = -1
55> begin
56> 	delete ACC_Accession where _Accession_key = @accKey
57> 	select @deleteIMAGESeqAssoc = 1
58> end
59> else
60> begin
61> 	delete ACC_AccessionReference 
62> 	where _Accession_key = @accKey
63> 	and _Refs_key = @refsKey
64> 
65> 	/* If the deletion of the detail would leave the master all alone...
66>    	   then delete the master too.
67> 	*/
68> 
69> 	if not exists (select * from ACC_AccessionReference
70>     		where _Accession_key = @accKey)
71> 	begin
72> 	    delete ACC_Accession where _Accession_key = @accKey
73> 	    select @deleteIMAGESeqAssoc = 1
74> 	end
75> end
76> 
77> /* TR 1270 - if deleting a Sequence Acc ID of a Marker...
78> *
79> * delete the old IMAGE/Marker encodes relationship
80> *
81> */
82> 
83> if @isMarkerSeq = 1 and @deleteIMAGESeqAssoc = 1
84> begin
85> 	exec MRK_deleteIMAGESeqAssoc @objectKey, @accID
86> 
87> 	if @@error != 0
88> 	begin
89> 		rollback transaction
90> 	end
91> end
92> 
93> commit tran
94> 
1>  
2> grant execute on ACC_delete_byAccKey to progs
1>  
2> grant execute on ACC_delete_byAccKey to editors
1>  
2> drop procedure ACC_delete_byAccRef
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'ACC_delete_byAccRef', because it doesn't exist in the
system catalogs.
1> 
2> /* 1> declare @prefixPart varchar(20) */
3> /* 2> declare @numericPart int */
4> /* 3> exec ACC_split "MGI:12345", @prefixPart out, @numericPart out */
5> /* 4> go */
6> /* (return status = 0) */
7> /* Return parameters: */
8> /* ---- -----------  */
9> /* MGI:       12345  */
10> 
11> drop procedure ACC_split
1> 
2> create procedure ACC_split
3>   @accID varchar(20),
4>   @prefixPart varchar(20) out,
5>   @numericPart integer out
6> as
7> 
8> declare @temp varchar(20) 
9> declare @suffix varchar(20)
10> declare @acclen integer
11> declare @idx integer
12> 
13> /* Remove trailing blanks */
14> select @accID = rtrim(@accID)
15> select @acclen = char_length(@accID)
16> select @temp = reverse(@accID)
17> select @idx  = patindex("%[^0-9]%",@temp)
18> 
19> /* If @idx = 0, then no prefix */
20> 
21> if @idx = 0
22> begin
23>   select @numericPart = convert(integer, @accID)
24>   select @prefixPart = NULL
25> end
26> 
27> else
28> 
29> begin
30>   select @prefixPart = reverse(substring(@temp,@idx,@acclen-@idx+1))
31>   select @suffix = substring(@accID,
32>                              char_length(@prefixPart)+1,
33>                              @acclen - char_length(@prefixPart))
34> 
35>   if @suffix is not NULL
36>      select @numericPart = convert(integer, @suffix)
37>   else
38>      select @numericPart = NULL
39> end
40> 
1> 
2> grant execute on ACC_split to progs
1>  
2> grant execute on ACC_split to editors
1>  
2> grant execute on ACC_split to public
1>  
2> drop procedure ACC_fetch_byLogical
1>  
2> create procedure ACC_fetch_byLogical
3>   @objectKey integer,
4>   @mgiType varchar(80),
5>   @logicalDB varchar(80) = "MGI"
6> as
7>  
8> select a.accID, a.prefixPart, a.numericPart
9> from ACC_Accession a, ACC_MGIType m, ACC_LogicalDB l
10> where a._Object_key = @objectKey
11> and a._MGIType_key = m._MGIType_key
12> and m.name = @mgiType
13> and a._LogicalDB_key = l._LogicalDB_key
14> and l.name = @logicalDB
15> 
1>  
2> grant execute on ACC_fetch_byLogical to progs
1>  
2> grant execute on ACC_fetch_byLogical to public
1>  
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop procedure ALL_convertAllele
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'ALL_convertAllele', because it doesn't exist in the
system catalogs.
1>  
2> create procedure ALL_convertAllele
3>   @markerKey integer,
4>   @oldSymbol varchar(25),
5>   @newSymbol varchar(25),
6>   @alleleOf integer = 0
7> as
8>  
9> begin transaction
10> 
11> declare @userID varchar(30)
12> select @userID = user_name()
13> 
14> /* Convert allele symbols of @markerKey using @oldSymbol and @newSymbol values */
15> 
16> /* If old Symbol is NOT allele of new Symbol... */
17> /* Convert new alleles:  */
18> /*	+<oldsymbol>	  --> +<newsymbol> */
19> /*	oldallele<allele> --> newsymbol<allele> */
20> /*      oldallele         --> newsymbol         */
21> 
22> if @alleleOf = 0
23> begin
24> 	/* Non-Wild Type Allele */
25> 	/*	oldallele<allele> --> newsymbol<allele> */
26> 
27> 	update ALL_Allele
28> 	set symbol = @newSymbol + "<" + 
29> 		substring(symbol, charindex("<", symbol) + 1, char_length(symbol)),
30> 		reviewed = 0, userID = @userID, modification_date = getdate()
31> 	where _Marker_key = @markerKey and symbol like '%<%' and symbol not like '+%'
32> 
33> 	/*      oldallele         --> newsymbol         */
34> 
35> 	update ALL_Allele set symbol = @newSymbol, 
36> 		reviewed = 0, userID = @userID, modification_date = getdate()
37> 	where _Marker_key = @markerKey and symbol = @oldSymbol
38> 
39> 	/* Wild Type Allele */
40> 	/*	+<oldsymbol>	  --> +<newsymbol> */
41> 	
42> 	update ALL_Allele
43> 	set symbol = '+<' + @newSymbol + '>', 
44> 		reviewed = 0, userID = @userID, modification_date = getdate()
45> 	where _Marker_key = @markerKey and symbol like '+<' + @oldSymbol + '>'
46> end
47> else
48> begin
49> 	/* If old Symbol is an Allele of new Symbol... */
50> 	/* Convert new alleles:  */
51> 	/*	+<oldsymbol>	  --> newsymbol<oldsymbol>        */
52> 	/*	oldallele<allele> --> newsymbol<oldallele-allele> */
53> 	/*      oldallele         --> newsymbol<oldallele>        */
54> 
55> 	/* Non Wild Type */
56> 	/*	oldallele<allele> --> newsymbol<oldallele-allele> */
57> 
58> 	update ALL_Allele
59> 	set symbol = @newSymbol + "<" + substring(symbol, 1, charindex("<", symbol) - 1) + "-" + 
60> 	     	substring(symbol, charindex("<", symbol) + 1, char_length(symbol)),
61> 		reviewed = 0, userID = @userID, modification_date = getdate()
62> 	where _Marker_key = @markerKey and symbol like '%<%' and symbol not like '+%'
63> 
64> 	/*      oldallele         --> newsymbol<oldallele>        */
65> 
66> 	update ALL_Allele
67> 	set symbol = @newSymbol + "<" + symbol + ">", 
68> 		reviewed = 0, userID = @userID, modification_date = getdate()
69> 	where _Marker_key = @markerKey and symbol not like '%<%' and symbol not like '+%'
70> 
71> 	/* Wild Type Allele */
72> 	/*	+<oldsymbol>	  --> newsymbol<oldsymbol>        */
73> 
74> 	update ALL_Allele
75> 	set symbol = @newSymbol + "<" + 
76> 		substring(symbol, charindex("<", symbol) + 1, char_length(symbol)),
77> 		reviewed = 0, userID = @userID, modification_date = getdate()
78> 	where _Marker_key = @markerKey and symbol like '+%'
79> end
80> 
81> commit transaction
82> 
1> 
2> grant execute on ALL_convertAllele to djr, ljm, rmb
1>  
2> grant execute on ALL_convertAllele to progs
1>  
2> drop procedure ALL_insertAllele
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'ALL_insertAllele', because it doesn't exist in the
system catalogs.
1>  
2> create procedure ALL_insertAllele
3>   @markerKey integer,
4>   @refsKey integer,
5>   @symbol varchar(50),
6>   @name varchar(255),
7>   @userID varchar(30) = null,
8>   @molRefsKey integer = null,
9>   @strainKey integer = -1,
10>   @modeKey integer = -1,
11>   @typeKey integer = -1,
12>   @reviewed bit = 0,
13>   @oldSymbol varchar(50) = null
14> as
15> 
16> declare @alleleKey integer
17> select @alleleKey = max(_Allele_key) + 1 from ALL_Allele
18> 
19> if @userID is null
20> 	select @userID = user_name()
21> 
22> /* Insert New Allele into ALL_Allele */
23> 
24> insert ALL_Allele 
25> (_Allele_key, _Refs_key, _Molecular_Refs_key, _Marker_key, _Strain_key, _Mode_key, _Allele_Type_key, reviewed, userID, symbol, name)
26> values(@alleleKey, @refsKey, @molRefsKey, @markerKey, @strainKey, @modeKey, @typeKey, @reviewed, @userID, @symbol, @name)
27> 
28> if @oldSymbol is not null
29> begin
30> 	update MLD_Expt_Marker set _Allele_key = @alleleKey
31> 	where _Marker_key = @markerKey and gene = @oldSymbol
32> end
33> 
1> 
2> grant execute on ALL_insertAllele to djr, ljm, rmb
1>  
2> grant execute on ALL_insertAllele to progs
1>  
2> drop procedure ALL_mergeAllele
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'ALL_mergeAllele', because it doesn't exist in the
system catalogs.
1>  
2> create procedure ALL_mergeAllele
3>   @oldAlleleKey int,
4>   @newAlleleKey int
5> as
6> 
7> /*
8>  * Update old Allele key to new Allele key
9>  * in all relevant tables which contain an Allele key.
10>  * When finished, remove the Allele record for the old
11>  * Allele key.
12> */
13> 
14> update GXD_AllelePair
15> set _Allele_key_1 = @newAlleleKey
16> where _Allele_key_1 = @oldAlleleKey
17> 
18> update GXD_AllelePair
19> set _Allele_key_2 = @newAlleleKey
20> where _Allele_key_2 = @oldAlleleKey
21> 
22> update MLD_Expt_Marker
23> set _Allele_key = @newAlleleKey
24> where _Allele_key = @oldAlleleKey
25> 
26> delete from ALL_Allele
27> where _Allele_key = @oldAlleleKey
28> 
1> 
2> grant execute on ALL_mergeAllele to editors
1>  
2> grant execute on ALL_mergeAllele to progs
1>  
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop procedure BIB_byJnum
1> 
2> create procedure BIB_byJnum
3>   @jnum	integer
4> as
5> 
6> /* Selects _Refs_key and short citation for given */
7> /* numeric J: (ex. BIB_byJnum 12345) */
8> 
9> select b._Refs_key, b.short_citation, b.isReviewArticle 
10> from BIB_View b, BIB_Acc_View ba
11> where ba.numericPart = @jnum
12> and ba.prefixPart = "J:"
13> and ba._Object_key = b._Refs_key
1> 
2> grant execute on BIB_byJnum to progs
1> 
2> grant execute on BIB_byJnum to public
1> 
2> drop procedure BIB_HMD_Exists
1> 
2> create procedure BIB_HMD_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of Homology records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from HMD_Homology where _Refs_key = @key
10> 
1> 
2> grant execute on BIB_HMD_Exists to public
1> 
2> drop procedure BIB_MLC_Exists
1> 
2> create procedure BIB_MLC_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of MLC records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from MLC_Reference where _Refs_key = @key
10> union
11> select count(*) from MLC_Reference_edit where _Refs_key = @key
12> 
1> 
2> grant execute on BIB_MLC_Exists to public
1> 
2> drop procedure BIB_MLD_Exists
1> 
2> create procedure BIB_MLD_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of Mapping records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from MLD_Marker where _Refs_key = @key
10> 
1> 
2> grant execute on BIB_MLD_Exists to public
1> 
2> drop procedure BIB_PRB_Exists
1> 
2> create procedure BIB_PRB_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of Molecular Segment records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from PRB_Reference where _Refs_key = @key
10> 
1> 
2> grant execute on BIB_PRB_Exists to public
1> 
2> drop procedure BIB_GXD_Exists
1> 
2> create procedure BIB_GXD_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of GXD index records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from GXD_Index where _Refs_key = @key
10> union
11> select count(*) from GXD_Assay where _Refs_key = @key
12> 
1> 
2> grant execute on BIB_GXD_Exists to public
1> 
2> drop procedure BIB_getYear
1> 
2> create procedure BIB_getYear
3>   @dateStr varchar(30)
4> as
5> 
6> /* Given input string of a date, split out the 4-digit year */
7> 
8> declare @year integer
9> declare @idx integer
10>  
11> select @idx = patindex("%[0-9][0-9][0-9][0-9]%", @dateStr)
12>  
13> if @idx = 0
14> begin
15>         select @year = NULL
16> end
17> else
18> begin
19>         select @year = convert(int, substring(@dateStr, @idx, 4))
20> end
21>  
22> select @year
23> 
1> 
2> grant execute on BIB_getYear to progs
1>  
2> grant execute on BIB_getYear to editors
1>  
2> grant execute on BIB_getYear to public
1>  
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop procedure GXD_loadCacheByAssay
1> 
2> create procedure GXD_loadCacheByAssay
3>   @assayKey int
4> as
5> 
6> /*
7>  * Load the GXD_Expression (cache) table for the given Assay
8>  * Should be called after any modification to any table within
9>  * the GXD_Assay hierarchy.
10>  */
11> 
12> /* Delete any pre-existing cache results for given assay */
13> 
14> delete from GXD_Expression where _Assay_key = @assayKey
15> 
16> /* Retrieve values from GXD_Assay Table for given Assay */
17> 
18> declare @assayTypeKey int	/* Assay Type Key */
19> declare @markerKey int		/* Marker Key */
20> declare @isGelAssay int		/* Is Assay Type a Gel Assay? */
21> 
22> select @assayTypeKey = a._AssayType_key,
23>        @markerKey = a._Marker_key,
24>        @isGelAssay = t.isGelAssay
25> from GXD_Assay a, GXD_AssayType t
26> where a._Assay_key = @assayKey
27> and a._AssayType_key = t._AssayType_key
28> 
29> /* Variables to hold values needed for cache table from Gel/InSitu Results */
30> 
31> declare @laneKey int
32> declare @specimenKey int
33> declare @resultKey int
34> declare @structureKey int
35> declare @genotypeKey int
36> declare @controlKey int
37> declare @age varchar(50)
38> declare @ageMin float
39> declare @ageMax float
40> 
41> declare @isExpressed int	/* was any expression detected? */
42> 
43> /*
44>  * If Assay is a Gel:
45>  *   For each Gel Lane:
46>  *     If Gel Lane is not a Control:
47>  *       If any Gel Bands in the Gel Lane have strength != "Absent":
48>  *         expressed = yes
49>  *       Else:
50>  *         expressed = no
51>  *       For each Structure associated with Gel Lane:
52>  *	   Insert into cache table
53>  * Else If Assay is InSitu:
54>  *   For each Specimen:
55>  *     For each Specimen Result:
56>  *       For each Structure associated with Result:
57>  *         If any Result has strength != "Absent" and != "Not Applicable":
58>  *           expressed = yes
59>  *         Else:
60>  *           expressed = no
61>  *	   Insert into cache table
62>  */
63> 
64> /* If Assay is a Gel */
65> 
66> if (@isGelAssay = 1)
67> begin
68> 
69>   declare lane_cursor cursor for
70>   select _GelLane_key, _Genotype_key, _GelControl_key, age, ageMin, ageMax
71>   from GXD_GelLane
72>   where _Assay_key = @assayKey
73>   for read only
74>  
75>   open lane_cursor
76>   fetch lane_cursor into @laneKey, @genotypeKey, @controlKey, @age, @ageMin, @ageMax
77>  
78>   /* For each Gel Lane */
79> 
80>   while (@@sqlstatus = 0)
81>   begin
82> 
83>     /* If Gel Lane is not a Control (control = No) */
84> 
85>     if (@controlKey = 1)
86>     begin
87> 
88>       /* If any Gel Bands in the Gel Lane have strength != "Absent":
89>        *   expressed = yes
90>        * Else:
91>        *   expressed = no
92>       */
93> 
94>       if (select count(b._GelBand_key) 
95> 	  from GXD_GelBand b, GXD_GelLane l, GXD_Strength s
96> 	  where l._Assay_key = @assayKey
97> 	  and l._GelLane_key = @laneKey
98> 	  and l._GelLane_key = b._GelLane_key
99> 	  and b._Strength_key = s._Strength_key
100> 	  and s.strength != "Absent") > 0
101>       begin
102> 	select @isExpressed = 1
103>       end
104>       else
105>       begin
106> 	select @isExpressed = 0
107>       end
108> 
109>       declare structure_cursor cursor for
110>       select _Structure_key from GXD_GelLaneStructure where _GelLane_key = @laneKey
111>       for read only
112> 
113>       open structure_cursor
114>       fetch structure_cursor into @structureKey
115> 
116>       /* For each Structure associated with Gel Lane */
117> 
118>       while (@@sqlstatus = 0)
119>       begin
120> 
121>         /* Insert into cache table */
122> 
123> 	insert GXD_Expression 
124>         select max(_Expression_key) + 1, 
125> 	       @assayKey, @assayTypeKey, @genotypeKey, @markerKey, @structureKey,
126> 	       @isExpressed, @age, @ageMin, @ageMax, getdate(), getdate()
127> 	from GXD_Expression
128> 
129>         fetch structure_cursor into @structureKey
130>       end
131>       close structure_cursor
132>       deallocate cursor structure_cursor
133>     end
134>     fetch lane_cursor into @laneKey, @genotypeKey, @controlKey, @age, @ageMin, @ageMax
135>   end
136>  
137>   close lane_cursor
138>   deallocate cursor lane_cursor
139> end
140> 
141> /* If Assay is a InSitu */
142> 
143> else
144> begin
145>   declare specimen_cursor cursor for
146>   select _Specimen_key, _Genotype_key, age, ageMin, ageMax
147>   from GXD_Specimen
148>   where _Assay_key = @assayKey
149>   for read only
150> 
151>   open specimen_cursor
152>   fetch specimen_cursor into @specimenKey, @genotypeKey, @age, @ageMin, @ageMax
153> 
154>   /* For each Specimen */
155> 
156>   while (@@sqlstatus = 0)
157>   begin
158>     declare result_cursor cursor for
159>     select _Result_key
160>     from GXD_InSituResult
161>     where _Specimen_key = @specimenKey
162>     for read only
163> 
164>     open result_cursor
165>     fetch result_cursor into @resultKey
166> 
167>     /* For each Specimen Result */
168> 
169>     while (@@sqlstatus = 0)
170>     begin
171> 
172>       /* If Result has strength != "Absent" and != "Not Applicable":
173>        *   expressed = yes
174>        * Else:
175>        *   expressed = no
176>       */
177> 
178>       if (select count(r._Strength_key)
179> 	  from GXD_InSituResult r, GXD_Strength s
180> 	  where r._Result_key = @resultKey
181> 	  and r._Strength_key = s._Strength_key
182> 	  and s.strength != "Absent"
183> 	  and s.strength != "Not Applicable") = 1
184>       begin
185> 	select @isExpressed = 1
186>       end
187>       else
188>       begin
189> 	select @isExpressed = 0
190>       end
191> 
192>       declare structure_cursor cursor for
193>       select _Structure_key
194>       from GXD_ISResultStructure
195>       where _Result_key = @resultKey
196>       for read only
197> 
198>       open structure_cursor
199>       fetch structure_cursor into @structureKey
200> 
201>       /* For each Structure associated with a Result */
202> 
203>       while (@@sqlstatus = 0)
204>       begin
205> 
206>         /* Insert into cache table */
207> 
208> 	insert GXD_Expression 
209>         select max(_Expression_key) + 1, 
210> 	       @assayKey, @assayTypeKey, @genotypeKey, @markerKey, @structureKey,
211> 	       @isExpressed, @age, @ageMin, @ageMax, getdate(), getdate()
212> 	from GXD_Expression
213> 
214>         fetch structure_cursor into @structureKey
215>       end
216>       close structure_cursor
217>       deallocate cursor structure_cursor
218> 
219>       /* Retrieve next Result */
220> 
221>       fetch result_cursor into @resultKey
222>     end
223> 
224>     close result_cursor
225>     deallocate cursor result_cursor
226> 
227>     /* Retrieve next Specimen */
228> 
229>     fetch specimen_cursor into @specimenKey, @genotypeKey, @age, @ageMin, @ageMax
230>   end
231> 
232>   close specimen_cursor
233>   deallocate cursor specimen_cursor
234> end
235>  
1> 
2> grant execute on GXD_loadCacheByAssay to progs
1> 
2> grant execute on GXD_loadCacheByAssay to editors
1> 
2> drop procedure GXD_loadCacheAll
1> 
2> create procedure GXD_loadCacheAll
3> as
4> 
5> /*
6>  * Load the GXD_Expression (cache) table for all Assays
7>  */
8> 
9> declare @assaykey int
10> 
11> declare assay_cursor cursor for
12> select _Assay_key from GXD_Assay
13> for read only
14>  
15> open assay_cursor
16> fetch assay_cursor into @assaykey
17> 
18> while (@@sqlstatus = 0)
19> begin
20>   exec GXD_loadCacheByAssay @assaykey
21>   fetch assay_cursor into @assaykey
22> end
23> 
24> close assay_cursor
25> deallocate cursor assay_cursor
26> 
1> 
2> grant execute on GXD_loadCacheAll to progs
1> 
2> grant execute on GXD_loadCacheAll to editors
1> 
2> 
3> drop procedure IMG_setPDO
1> 
2> create procedure IMG_setPDO (
3> 	@pixID int = NULL, 
4> 	@xDim int, 
5> 	@yDim int, 
6> 	@image_key int
7> ) as 
8> /* If image_key is valid and a PIX foreign accession number
9>    doesnot already exist for the _Image_key and the PIX: accession
10>    ID doesnot already exist, the new ID is added to ACC_Accession
11>    and the x,y dim update the image record.
12>    ASSUMES:
13>    - _LogicalDB_key for "MGI Image Archive" is 19,
14>    - _MGIType_key for mgi Image objects is 9
15>    REQUIRES:
16>    - four integer inputs
17>    - _Image_key exists
18>    - _Image_key is not referenced by an existing PIX:#
19>    - PIX:# does not exist (referencing another _Image_key)
20> */
21> 
22> declare @accID varchar(80), @prefix varchar(4), @imageLDB int, @imageType int
23> 
24> select @prefix = 'PIX:', 
25> 	   @imageLDB = 19,
26> 	   @imageType = 9
27> 
28> if @pixID is NULL or @image_key is NULL or @xDim is NULL or @yDim is NULL
29>   BEGIN
30> 	rollback transaction
31> 	raiserror 99999 "All four arguments must be non-NULL."
32> 	return
33>   END
34> else
35> 	select @accID = @prefix + convert(varchar(10), @pixID)
36> 
37> /* ck for missing image rec */
38> if not exists (select 1 from IMG_Image where _Image_key = @image_key)
39>   BEGIN
40> 	rollback transaction
41> 	raiserror 99999 "%1! _Image_key does not exist.", @image_key
42> 	return
43>   END
44> 
45> /* check that this PIX:# does not already exist */
46> if exists (select 1 from ACC_Accession 
47>    where accID = @accID and _MGIType_key = @imageType
48>    and _LogicalDB_key = @imageLDB 
49>    )
50>   BEGIN
51> 	rollback transaction
52> 	raiserror 99999 "%1! accession already exists.", @accID
53> 	return
54>   END
55> 
56> /* check that image record is not referenced by another PIX:# */
57> if exists (select 1 from ACC_Accession
58>    where _Object_key = @image_key and prefixPart = @prefix
59>    and _LogicalDB_key = @imageLDB and _MGIType_key = @imageType
60>    )
61>   BEGIN
62> 	rollback transaction
63> 	raiserror 99999 "A PIX: accession already exists for _Image_key %1!.", @image_key
64> 	return
65>   END
66> 
67> 
68> /* insert the new PIX: accession record */
69> exec ACC_insert @image_key, 
70> 				@accID, 
71> 				@imageLDB, 
72> 				"Image", 
73> 				-1, 
74> 				1, 
75> 				1
76> 
77> if @@error != 0
78>   BEGIN
79> 	rollback transaction
80> 	raiserror 99999 "ACC_insert failed."
81> 	return	
82>   END
83> 
84> /* set the image dimensions */
85> update IMG_Image set xDim = @xDim, yDim = @yDim
86> where _Image_key = @image_key
87> 
88> if @@error != 0
89>   BEGIN
90> 	rollback transaction
91> 	raiserror 99999, "Update x,y Dimensions failed."
92> 	return
93>   END
94> 
1> 
2> grant execute on IMG_setPDO to progs
1> 
2> grant execute on IMG_setPDO to editors
1> 
2> 
3> /* Structure table stored procs.
4>    Note that these must be executed from within 
5>    a transaction block for rollbacks to work correctly */
6> 
7> drop procedure GXD_SetStructDescPrintName 
1> 
2> create procedure 
3>     GXD_SetStructDescPrintName @structure_key int, @path VARCHAR(255)
4> as
5>        /* Sets the printName of a Structure and all of the descendents 
6>         * that depend on this Structure's printStop status (those descendents
7>         * that do not have printStop set to 1).
8>         *
9>         * definition <current_structure> : 
10>         *          Structure w/_Structure_key = @structure_key  
11>         *
12>         * @structure_key : Structure key of the <current_structure> (the 
13>         *                  structure that might need printName updated)
14>         * @path          : The inclusive path from an ancestor of 
15>         *                  <current_structure> with printStop set to 1. 
16>         *                  This path does not include the <current_structure>'s 
17>         *                  preferred name.
18>         */
19> 
20>        declare @current_prefname VARCHAR(255)
21> 
22>        /* get the preferred name of the current structure */ 
23>        select @current_prefname = sn.structure
24>        from GXD_Structure s, GXD_StructureName sn
25>        where s._Structure_key = @structure_key
26>        and sn._StructureName_key = s._StructureName_key
27> 
28>        /* grow the path using the prefname */
29>        declare @pathlength int
30>        select @pathlength = char_length(@path) + 1 +   /* +1 for ; */
31>                             char_length(@current_prefname)
32>        if @pathlength > 255 
33>        begin
34>             /* truncate the path with an ellipsis. Look for one */
35>             declare @ellipsis int 
36>             declare @numchars_to_remove int
37> 
38>             /* number of characters to remove from @path so we have room
39>                for the ellipsis, ';', and current_prefname */
40>             select @numchars_to_remove = @pathlength - 255 + 3
41> 
42>             select @ellipsis = charindex("...", @path)
43>             if @ellipsis = 0  /* then no ellipsis yet, add one */
44>               begin
45>                  select @path = substring(@path,1,255-@numchars_to_remove)
46>                                 + "..."
47>               end
48>             else
49>               begin
50>                  /* find the ellipsis, and remove text to the right of it */
51>                  select @path = substring(@path,@ellipsis + 3,255) 
52>               end
53>        end
54> 
55>        if char_length(rtrim(@path)) > 0
56>            select @path = rtrim(@path) + ";" + @current_prefname
57>        else
58>            select @path = @current_prefname
59> 
60>        /* update the current node's printName */
61> 
62>        update GXD_Structure
63>        set printName = @path
64>        where _Structure_key = @structure_key 
65> 
66>        if @@error != 0  /* then update failed */ 
67>        begin
68>             raiserror 99999 "GXD_SetStructDescPrintName: Update of printName failed"
69>             rollback transaction
70>             return
71>        end
72>     
73>        /* Now fixup immediate descendent's printNames */
74> 
75>        declare @dek int
76> 
77>        declare desc_cursor cursor 
78>        for select s._Structure_key
79>            from GXD_Structure s
80>            where s._Parent_key = @structure_key 
81>              and s.printStop = 0     /* if printStop is 1, we can ignore it */
82>       
83> 
84>       open desc_cursor
85>       fetch desc_cursor into @dek
86> 
87>       while (@@sqlstatus = 0)
88>       begin 
89>          exec GXD_SetStructDescPrintName @dek, @path
90>          if @@error != 0  /* transaction failed for some reason */
91>          begin
92>             rollback transaction  /* rollback and return */
93>             raiserror 99999 "GXD_SetStructDescPrintName: Recursive call failed"
94>             close desc_cursor
95>             return
96>          end
97>          fetch desc_cursor into @dek 
98>       end
99> 
100>       close desc_cursor
1> 
2> 
3> grant execute on GXD_SetStructDescPrintName to progs
1> 
2> grant execute on GXD_SetStructDescPrintName to editors
1> 
2> 
3> drop procedure GXD_ComputePrintNamesFrom
1> 
2> 
3> create procedure
4>     GXD_ComputePrintNamesFrom  @structure_key int = null
5> as
6>    /* Changes printName for node with _Structure_key = @structure_key,
7>     * and all of its descendents, as appropriate.
8>     *
9>     * uses GXD_SetStructDescPrintName to set descendent's printNames.
10>     */
11> 
12>    if @structure_key is null
13>    begin
14>           rollback transaction
15>           raiserror 99999 "GXD_ComputePrintNamesFrom: Structure key not provided"
16>           return
17>    end
18>    else
19>    begin
20>        declare @printStop bit
21>        declare @path VARCHAR(255)
22>        
23>        /* get the printStop of the specified structure */
24> 
25>        select @printStop = s.printStop
26>               from GXD_Structure s
27>               where s._Structure_key = @structure_key
28> 
29>        /* path to the current node */ 
30>        select @path = ""
31> 
32>        if @printStop = 0 
33>        begin
34>             /* we must determine the path by moving up the tree until
35>                we find an ancestor with a printStop set, accumulating
36>                the path.
37>              */
38>             declare @ansk int  /* ancestor structure key */
39>             declare @aprintStop bit
40>             declare @aprefname VARCHAR(255)
41> 
42>             declare ancest_cursor cursor
43>             for select c._Structure_key
44>                 from GXD_Structure s, GXD_StructureClosure c
45>                 where c._Descendent_key = @structure_key
46>                 and c._Structure_key = s._Structure_key
47>                 order by s.treeDepth desc 
48> 
49>             open ancest_cursor
50>             fetch ancest_cursor into @ansk
51> 
52>             while (@@sqlstatus = 0)
53>             begin
54>                /* we have an ancestor, find out its printStop status */
55>                select @aprintStop = s.printStop, @aprefname = sn.structure
56>                from GXD_Structure s, GXD_StructureName sn
57>                where s._Structure_key = @ansk 
58>                and s._StructureName_key = sn._StructureName_key
59>                   
60>                select @path = ltrim(rtrim(@aprefname)) + @path 
61> 
62>                if @aprintStop = 1   /* found a printStop set */
63>                   break
64>                else                 /* we need to go higher */ 
65>                   select @path = ";" + @path
66> 
67>                fetch ancest_cursor into @ansk  /* get another key */
68>             end
69> 
70>             close ancest_cursor
71>        end
72> 
73>        /* @path is now set appropriately, downto the current node,
74>           but not inclusive of it. Now, fixup all the descendents */ 
75>           
76>        begin transaction
77> 
78>        exec GXD_SetStructDescPrintName @structure_key, @path
79>        if @@error != 0
80>        begin
81>           rollback transaction
82>           raiserror 99999 "GXD_ComputePrintNamesFrom: call to GXD_SetStructDescPrintName failed"
83>           return
84>        end
85>        else
86>           commit transaction
87>    end
1>        
2> grant execute on GXD_ComputePrintNamesFrom to progs
1> 
2> grant execute on GXD_ComputePrintNamesFrom to editors
1> 
2> 
3> drop procedure GXD_SetPreferredName
1> 
2> create procedure GXD_SetPreferredName 
3>      @structure_key int = null, @name varchar(255) = null
4> as
5>    /* 
6>     * Sets the preferred name of the structure whose _Structure_key = 
7>     * @structure_key.  Deletes the StructureName that *was* the preferred
8>     * name iff the current preferred name is different from the one being
9>     * set. Modifies the GXD_Structure and GXD_StructureName
10>     * tables.  Fails if node is not MGI-added (edinburghkey != NULL).
11>     *
12>     * If a StructureName doesn't exist where _Structure_key = @structure_key
13>     * and @name = structure, then a new StructureName record 
14>     * is created with _Structure_key = @structure_key, and structure = @name. 
15>     *
16>     * The _StructureName_key attribute of the structure with _Structure_key = 
17>     * @structure_key is set to point to either the existing or newly-created
18>     * StructureName record.  
19>     *
20>     * Always sets modification_date to getdate(), even if a new structurename
21>     * isn't created.  The ADI relies on this behavior.
22>     *
23>     */
24>    
25>    if @structure_key is null
26>    begin
27>        rollback transaction
28>        raiserror 99999 "GXD_SetPreferredName: Structure key not provided"
29>        return
30>    end
31>     
32>    if @name is null
33>    begin
34>        rollback transaction
35>        raiserror 99999 "GXD_SetPreferredName: Name not provided"
36>        return
37>    end
38> 
39>    if (select edinburghkey 
40>        from GXD_Structure s
41>        where s._Structure_key = @structure_key) != NULL
42>    begin
43>        rollback transaction
44>        raiserror 99999 "GXD_SetPreferredName: Cannot set preferred name for non MGI-added structures"
45>        return
46>    end
47>   
48>    /* determine the current preferred name key */
49>    declare @cpnk integer       /* current structure name key */
50> 
51>    select @cpnk = sn._StructureName_key
52>    from GXD_Structure s, GXD_StructureName sn
53>    where s._Structure_key = @structure_key
54>    and s._Structure_key = sn._Structure_key
55>    and s._StructureName_key = sn._StructureName_key
56> 
57>    declare @ctsn integer 
58>    declare @different integer  /* set to true if our set name !=
59>                                   current preferred name */ 
60>    select @different = 0       /* assume we are changing the 
61>                                   preferred name to the *same* name */
62>  
63>    /* find out how many StructureName entries match our desired preferred
64>       name */
65>    select @ctsn = count(*) 
66>                   from GXD_StructureName
67>                   where _Structure_key = @structure_key
68>                   and structure = @name
69> 
70>    if @ctsn = 0  /* if none, then we must create the StructureName */ 
71>    begin         /* and delete the old one */
72>        select @different = 1  /* set delete flag for current pref. name */
73> 
74>        declare @snk integer
75> 
76>        /* insert the new StructureName */
77>        select @snk = max(_StructureName_key) + 1 from GXD_StructureName
78>        insert into GXD_StructureName (_StructureName_key, _Structure_key,
79>                                       structure, mgiAdded) 
80>        values(@snk, @structure_key, @name, 1)
81> 
82>        if @@error != 0  /* then insert failed */ 
83>        begin
84>             rollback transaction
85> 	        raiserror 99999 "Insert into GXD_StructureName failed"
86>             return
87>        end
88>       
89>        /* set ctsn to 1, as if the StructureName had been there all along */
90>        select @ctsn = 1
91>    end
92> 
93>    if @ctsn = 1 /* then update GXD_Structure to reference this name */
94>    begin
95>         update GXD_Structure 
96>                   set _StructureName_key = (
97>                       select _StructureName_key 
98>                       from GXD_StructureName
99>                       where _Structure_key = @structure_key
100>                       and structure = @name )
101>                   where _Structure_key = @structure_key
102> 
103>        if @@error != 0  /* then insert failed */ 
104>        begin
105>           rollback transaction
106> 	      raiserror 99999 "GXD_SetPreferredName: Update of _StructureName_key in GXD_Structure failed"
107>           return
108>        end
109>       
110>        /* we update the structurename's modification date, regardless */ 
111> 
112>        update GXD_StructureName
113>               set modification_date = getdate()
114>               where _StructureName_key = @cpnk
115> 
116>        if @@error != 0  /* then update failed */ 
117>        begin
118>           rollback transaction
119> 	      raiserror 99999 "GXD_SetPreferredName: Update of modification_date in GXD_Structure failed"
120>           return
121>        end
122> 
123>        /* delete the current structureName, referenced by the structure's
124>           _StructureName_key, if we have a new structureName to point to */
125> 
126>        if @different = 1
127>        begin
128>            delete from GXD_StructureName
129>            where _Structure_key = @structure_key 
130>            and _StructureName_key = @cpnk
131>        
132>            if @@error != 0  /* then insert failed */ 
133>            begin
134>               rollback transaction
135> 	          raiserror 99999 "GXD_SetPreferredName: Could not delete previous preferred name"
136>               return
137>            end
138>        end
139> 
140>        /* recompute printNames, since the Update trigger cannot without
141>           causing infinite recursive calls */
142> 
143>        exec GXD_ComputePrintNamesFrom @structure_key
144>        if @@error != 0  /* then insert failed */ 
145>        begin
146>           rollback transaction
147> 	      raiserror 99999 "GXD_SetPreferredName: Call to GXD_ComputePrintNamesFrom failed"
148>           return
149>        end
150>    end
151>    else  /* then greater than 1, an error */
152>    begin
153> 	  rollback transaction
154> 	  raiserror 99999 "GXD_SetPreferredName: Duplicate names for structure in GXD_StructureName"
155> 	  return	
156>    end
157>              
158> 
1> 
2> grant execute on GXD_SetPreferredName to progs
1> 
2> grant execute on GXD_SetPreferredName to editors
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop procedure HMD_getChromosomes
1> 
2> create procedure HMD_getChromosomes
3>                 @_Species_key int = NULL
4> as
5> /*
6>  * 	Procedure takes a species key and returns the ordered
7>  *	list of chromosomes.
8>  *
9>  *	DOW Jan 17, 1996
10>  */
11> select chromosome 
12> from MRK_Chromosome 
13> where _Species_key = @_Species_key 
14> order by sequenceNum
1> 
2> grant execute on HMD_getChromosomes to public
1> 
2> drop procedure HMD_getOxfordGrid
1> 
2> create procedure HMD_getOxfordGrid
3>                 @Species1 int = NULL,
4>                 @Species2 int = NULL
5> as
6> 
7> /* Return all Chromosome Pairs/Homology Classes involving Species 1 & Species 2 */
8> /* Include Chromosome UN. To exclude, add the following where clauses */
9> /*	    m1.chromosome != 'UN' and	*/
10> /*	    m2.chromosome != 'UN'	*/
11> 
12> select distinct c1 = m1.chromosome, c2 = m2.chromosome, h1._Class_key
13>                 from    MRK_Marker m1,
14>                         MRK_Marker m2,
15>                         HMD_Homology h1,
16>                         HMD_Homology h2,
17>                         HMD_Homology_Marker hm1,
18>                         HMD_Homology_Marker hm2
19>                 where   m1._Species_key = @Species1 and
20>                         m1._Marker_key = hm1._Marker_key and
21> 			hm1._Homology_key = h1._Homology_key and
22>                         h1._Class_key = h2._Class_key and
23> 			h2._Homology_key = hm2._Homology_key and
24>                         hm2._Marker_key = m2._Marker_key and
25>                         m2._Species_key = @Species2 
26> order by c1, c2
27>  
1> 
2> grant execute on HMD_getOxfordGrid to public
1>  
2> drop procedure HMD_hasHomology
1> 
2> create procedure HMD_hasHomology
3>                 @_Marker_key int = NULL,
4>                 @_Refs_key int = NULL
5> as
6> /*
7>  * 	Procedure takes either a Marker key or a Ref key,
8>  *	and determines whether not a homology will exists.
9>  *	For a homology to be returned, for a _Class_key,
10>  *	there must be more than one marker.
11>  *
12>  *	DOW Jan 10, 1996
13>  */
14> declare @count int
15> declare @has_Homology int
16> create table #classes
17>         (_Class_key int)
18> 
19> /*
20>  *	has_Homology is the value to be returned.
21>  *	Default is "no homology" 
22>  */	
23> select @has_Homology = 0
24> 
25> /*	Do with a query using a _Marker_key...	*/
26> if (@_Marker_key != NULL and @_Refs_key = NULL)
27>         insert #classes
28>         select h._Class_key
29>         from HMD_Homology h, HMD_Homology_Marker m
30>         where m._Marker_key = @_Marker_key and
31> 	      m._Homology_key = h._Homology_key
32> /*	...or a _Refs_key...	*/
33> else if (@_Refs_key != NULL and @_Marker_key = NULL)
34>         insert #classes
35>         select _Class_key
36>         from HMD_Homology
37>         where _Refs_key = @_Refs_key
38> /*	...but not both!!	*/
39> else
40> begin
41> 	print 'Cannot process with both _Refs_key AND _Marker_key!'
42> 	select @has_Homology
43> 	return 
44> end
45> 
46> /*
47>  *	Cursor simply does a count of distinct markers(species) in a class
48>  */
49> declare classCount cursor for
50> select count(distinct m._Marker_key)
51> from HMD_Homology h, HMD_Homology_Marker m, #classes c
52> where h._Class_key = c._Class_key
53>       and h._Homology_key = m._Homology_key
54> group by h._Class_key
55> for read only
56> 
57> open classCount
58> 
59> /*	Pull out classes, one by one...	*/
60> fetch classCount
61>         into @count
62> 
63> /*	Nothing here... bail out!	*/
64> if (@@sqlstatus = 2)
65> begin
66> 	print 'Nothing found'
67> 	select @has_Homology
68>         return 
69> end
70> /*
71>  * 	If cursor result is not empty, then process
72>  * 	each row to determine if class has a homology
73>  * 	including more than one species (marker).
74>  */
75> while (@@sqlstatus = 0)
76> begin
77>         if (@count > 1)
78> /*	There is a valid homology within this class.	*/
79>                 select @has_Homology = 1
80> 
81> /*	Fetch next row.	*/
82>         fetch classCount
83>                 into @count
84> end
85> /*	This select will return the value of @has_Homology as a row of data */
86> select @has_Homology
87> 
88> close classCount
89> 
90> deallocate cursor classCount
1> 
2> grant execute on HMD_hasHomology to public
1>  
2> checkpoint
1> 
2> drop procedure HMD_updateClass
1> 
2> create procedure HMD_updateClass
3>   @_Class_key integer,
4>   @_Refs_key integer,
5>   @isNewClass integer = 1
6> as
7> 
8> /* Merge classes of Homologies which, due to a new Homology record */
9> /* should really be one class (due to transitivity nature of Homology) */
10> 
11> /* For each Class which exists which contains Markers from New Class... */
12> 
13> select _Class_key = @_Class_key
14> into #classes
15> union
16> select distinct h2._Class_key 
17> from HMD_Homology h1, HMD_Homology_Marker hm1, 
18>      HMD_Homology h2, HMD_Homology_Marker hm2
19> where h1._Class_key = @_Class_key and
20>       h1._Homology_key = hm1._Homology_key and
21>       hm1._Marker_key = hm2._Marker_key and
22>       hm2._Homology_key = h2._Homology_key and
23>       h2._Class_key != @_Class_key
24> 
25> /* Select all Species/Symbol pairs from the New Class */
26> 
27> select distinct hm._Marker_key, m._Species_key
28> into #markers
29> from #classes c, HMD_Homology h, HMD_Homology_Marker hm, MRK_Marker m
30> where c._Class_key = h._Class_key and
31>       h._Homology_key = hm._Homology_key and
32>       hm._Marker_key = m._Marker_key
33> 
34> declare @speciesKey integer
35> declare @dupspeciesKey integer
36> declare @do_update integer
37> select @do_update = 1
38> 
39> /* Fetch counts for Species/Symbol pairs */
40> 
41> declare classCount cursor for select _Species_key from #markers group by _Species_key having count(*) > 1
42> open classCount
43> fetch classCount into @speciesKey
44> 
45> while (@@sqlstatus = 0)
46> begin
47> 	select @do_update = 0
48> 	select @dupspeciesKey = @speciesKey
49> 	fetch classCount into @speciesKey
50> end
51> 
52> close classCount
53> deallocate cursor classCount
54> 
55> if (@do_update = 1) /* Merge Classes */
56> begin
57>         update HMD_Homology
58> 	set _Class_key = @_Class_key
59> 	from #classes c, HMD_Homology h
60> 	where c._Class_key = h._Class_key
61> 
62> 	/* Return the @_Class_key:@_Refs_key */
63> 	select convert(varchar(10), @_Class_key) + ':' + convert(varchar(10), @_Refs_key)
64> end
65> else
66> begin
67> 	declare @species varchar(255)
68> 	select @species = name from MRK_Species where _Species_key = @dupspeciesKey
69> 
70> 	/* Return the @_Class_key:@_Refs_key */
71> 	select convert(varchar(10), @_Class_key) + ':' + convert(varchar(10), @_Refs_key)
72> 
73> 	/* If this is a new class record, then delete it if there is a conflict */
74> 	if (@isNewClass = 1)
75> 	begin
76> 		delete from HMD_Class where _Class_key = @_Class_key
77> 	end
78> 
79> 	raiserror 99999 "Another Homology has been detected which conflicts with Species:  %1!", @species
80> 
81> end
82> 
1> 
2> grant execute on HMD_updateClass to progs
1> 
2> grant execute on HMD_updateClass to editors
1> 
2> checkpoint
1> 
2> drop procedure HMD_Cleanup
1> 
2> create procedure HMD_Cleanup
3>   @_Class_key integer,
4>   @_Homology_key integer
5> as
6> 
7> /* Clean up any orphan HMD_Class or HMD_Homology records after deletions */
8> 
9> if (select count(*) from HMD_Homology_Marker where _Homology_key = @_Homology_key) = 0
10> begin
11> 	delete HMD_Homology where _Homology_key = @_Homology_key
12> end
13> 
14> if (select count(*) from HMD_Homology where _Class_key = @_Class_key) = 0
15> begin
16> 	delete HMD_Class where _Class_key = @_Class_key
17> end
18> 
19> /* Delete all non-mouse, non-human Markers no longer referenced in Homology */
20> 
21> delete MRK_Marker from MRK_Marker m
22> where m._Species_key != 1 and m._Species_key != 2
23>       and not exists 
24>       (select h.* from HMD_Homology_Marker h where m._Marker_key = h._Marker_key)
25> 
1> 
2> grant execute on HMD_Cleanup to progs
1> 
2> grant execute on HMD_Cleanup to editors
1> 
2> drop procedure HMD_nomenUpdate
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'HMD_nomenUpdate', because it doesn't exist in the
system catalogs.
1> 
2> create procedure HMD_nomenUpdate
3> 	@oldMarkerKey int,
4> 	@newMarkerKey int
5> as
6> 
7> begin transaction
8> 
9> /* set the _Class_key of the old Marker's homology class */
10> /* to the _Class_key of the *new Marker's homology class */
11> 
12> update HMD_Homology 
13> set _Class_key = (select distinct h._Class_key 
14> 	from HMD_Homology h, HMD_Homology_Marker m 
15> 	where m._Marker_key = @newMarkerKey and 
16> 	      m._Homology_key = h._Homology_key) 
17> from HMD_Homology h, HMD_Homology_Marker m 
18> where m._Marker_key = @oldMarkerKey and 
19>       m._Homology_key = h._Homology_key
20> 
21> /* update the appropriate homology/marker records */
22> 
23> update HMD_Homology_Marker 
24> set _Marker_key = @newMarkerKey
25> where _Marker_key = @oldMarkerKey
26> 
27> /* remove the old marker */
28> 
29> delete from MRK_Marker 
30> where _Marker_key = @oldMarkerKey
31> 
32> /* remove the old class record */
33> 
34> delete HMD_Class 
35> from HMD_Homology h, HMD_Homology_Marker m 
36> where m._Marker_key = @oldMarkerKey and 
37>       m._Homology_key = h._Homology_key
38> 
39> commit transaction
40> 
1> 
2> grant execute on HMD_nomenUpdate to progs
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop procedure MGI_Table_Column_Cleanup
1> 
2> CREATE PROCEDURE MGI_Table_Column_Cleanup
3> /*
4> JCG: Jan. 7, 1999
5> This procedure attempts to get MGI_Tables and MGI_Columns in sync with
6> sysobjects and syscolumns
7> */
8> 
9> as
10> 
11> /* Make sure that an old temp table with this name doesn't exists */
12> if exists (select name from sysobjects
13>            where name = '#temp_add_table'
14>            and type = 'U')
15>    drop table #temp_add_table
16> 
17> /*
18> NEW TABLE ADDED TO SCHEMA
19> */
20> /* Find tables in sysobjects which are not in MGI_Tables and insert them
21> into a temp table */
22> SELECT
23> MGI_Tables._Table_id, sysobjects.name
24> into #temp_add_table
25> FROM
26> MGI_Tables MGI_Tables, sysobjects sysobjects
27> WHERE
28> MGI_Tables._Table_id =* sysobjects.id
29> AND
30> sysobjects.type='U'
31> ORDER BY
32> sysobjects.name
33> 
34> /* From the temp table, select only those values where the table name is not
35> found in MGI_Tables. */
36> insert into MGI_Tables
37> SELECT object_id(name), NULL, getDate(), getDate()
38> FROM
39> #temp_add_table
40> WHERE
41> _Table_id is NULL
42> 
43> /* Also, find the appropriate columns and put into MGI_Columns so
44> that MGI_Tables and MGI_Columns are in sync */
45> insert into MGI_Columns
46> SELECT object_id(t.name), colid, NULL, NULL, getDate(), getDate()
47> FROM
48> #temp_add_table t, syscolumns c
49> WHERE
50> _Table_id is NULL
51> AND
52> object_id(t.name) = id
53> 
54> if exists (select name from sysobjects
55>            where name = '#temp_add_table'
56>            and type = 'U')
57>    drop table #temp_add_table
58> 
59> /*
60> WHAT IF YOU BCP IN A TRUNCATED COLUMN LIST?
61> THIS SECTION ADDS COLUMN DEFINITIONS FOR TABLES THAT ARE IN MGI_TABLES
62> BUT NOT MGI_COLUMNS - SYNCS COLUMNS WITH TABLES
63> */
64> 
65> if exists (select name from sysobjects
66>            where name = '#temp_update_table'
67>            and type = 'U')
68>    drop table #temp_update_table
69> 
70> SELECT
71> MGI_Columns._Table_id, syscolumns.id, syscolumns.colid
72> into #temp_update_table
73> FROM
74> MGI_Columns MGI_Columns,
75> syscolumns syscolumns,
76> sysobjects sysobjects
77> WHERE
78> syscolumns.id *= MGI_Columns._Table_id
79> and
80> syscolumns.id = sysobjects.id
81> and
82> sysobjects.type = 'U'
83> 
84> insert into MGI_Columns
85> SELECT
86> id, colid, NULL, NULL, getDate(), getDate()
87> FROM
88> #temp_update_table
89> WHERE
90> _Table_id is NULL
91> 
92> if exists (select name from sysobjects
93>            where name = '#temp_update_table'
94>            and type = 'U')
95>    drop table #temp_update_table
96> 
97> /*
98> THIS SECTION DELETES TABLES DEFINITION WHEN A TABLE IS DELETED
99> */
100> 
101> /*Algorithm:
102> 
103> If table not found in sysobjects, delete from MGI_Tables and
104> remove all column entries. Do a join to find _Table_id with no id
105> */
106> 
107> DELETE from MGI_Tables
108> where _Table_id in
109> (select DISTINCT _Table_id
110> from
111> MGI_Tables t, sysobjects o
112> WHERE
113> _Table_id NOT in (select id from sysobjects where type = 'U'))
114> 
115> if exists (select name from sysobjects
116>            where name = '#temp_delete_table'
117>            and type = 'U')
118>    drop table #temp_delete_table
119> 
120> 
121> SELECT DISTINCT _Table_id, id
122> into #temp_delete_table
123> FROM
124> MGI_Columns, sysobjects
125> WHERE
126> _Table_id *= id
127> 
128> /* If there is an id in MGI_Columns which is not in syscolumns then delete its entri
129> es */
130> delete from MGI_Columns
131> WHERE
132> _Table_id in (select _Table_id from #temp_delete_table where id is NULL)
133> 
134> if exists (select name from sysobjects
135>            where name = '#temp_delete_table'
136>            and type = 'U')
137>    drop table #temp_delete_table
138> 
139> RETURN
1> 
2> grant execute on MGI_Table_Column_Cleanup to public
1> 
2> drop procedure MGI_resetSequenceNum
1> 
2> create procedure MGI_resetSequenceNum
3>   @table varchar(255),		/* Table Name */
4>   @key int			/* Primary key */
5> as
6> 
7> /* Re-order the sequenceNum field so that they are 
8>    continuous and there are no gaps.
9> 
10>    ex. 1,2,5,6,7 would be reordered to 1,2,3,4,5
11> */
12> 
13> declare @pkey int	/* primary key of records to update */
14> declare @oldSeq int	/* current sequence number */
15> declare @newSeq int	/* new sequence number */
16> select @newSeq = 1
17>  
18> if (@table = "GXD_GelLane")
19> begin
20>   declare seq_cursor cursor for
21>   select _GelLane_key, sequenceNum
22>   from GXD_GelLane
23>   where _Assay_key = @key
24>   order by sequenceNum
25>   for read only
26> end
27> else if (@table = "GXD_GelRow")
28> begin
29>   declare seq_cursor cursor for
30>   select _GelRow_key, sequenceNum
31>   from GXD_GelRow
32>   where _Assay_key = @key
33>   order by sequenceNum
34>   for read only
35> end
36> else if (@table = "GXD_Specimen")
37> begin
38>   declare seq_cursor cursor for
39>   select _Specimen_key, sequenceNum
40>   from GXD_Specimen
41>   where _Assay_key = @key 
42>   order by sequenceNum 
43>   for read only
44> end
45> else if (@table = "GXD_InSituResult")
46> begin
47>   declare seq_cursor cursor for
48>   select _Result_key, sequenceNum
49>   from GXD_InSituResult
50>   where _Specimen_key = @key
51>   order by sequenceNum
52>   for read only
53> end
54> else if (@table = "MRK_History")
55> begin
56>   declare seq_cursor cursor for
57>   select _Marker_key, sequenceNum
58>   from MRK_History
59>   where _Marker_key = @key
60>   order by sequenceNum
61>   for read only
62> end
63> else if (@table = "MLD_Marker")
64> begin
65>   declare seq_cursor cursor for
66>   select _Refs_key, sequenceNum
67>   from MLD_Marker
68>   where _Refs_key = @key
69>   order by sequenceNum
70>   for read only
71> end
72> else if (@table = "MLD_Expt_Marker")
73> begin
74>   declare seq_cursor cursor for
75>   select _Expt_key, sequenceNum
76>   from MLD_Expt_Marker
77>   where _Expt_key = @key
78>   order by sequenceNum
79>   for read only
80> end
81> else if (@table = "MLD_MCDataList")
82> begin
83>   declare seq_cursor cursor for
84>   select _Expt_key, sequenceNum
85>   from MLD_MCDataList
86>   where _Expt_key = @key
87>   order by sequenceNum
88>   for read only
89> end
90> else if (@table = "MLD_MC2point")
91> begin
92>   declare seq_cursor cursor for
93>   select _Expt_key, sequenceNum
94>   from MLD_MC2point
95>   where _Expt_key = @key
96>   order by sequenceNum
97>   for read only
98> end
99> else if (@table = "MLD_RIData")
100> begin
101>   declare seq_cursor cursor for
102>   select _Expt_key, sequenceNum
103>   from MLD_RIData
104>   where _Expt_key = @key
105>   order by sequenceNum
106>   for read only
107> end
108> else if (@table = "MLD_RI2Point")
109> begin
110>   declare seq_cursor cursor for
111>   select _Expt_key, sequenceNum
112>   from MLD_RI2Point
113>   where _Expt_key = @key
114>   order by sequenceNum
115>   for read only
116> end
117> else if (@table = "MLD_FISH_Region")
118> begin
119>   declare seq_cursor cursor for
120>   select _Expt_key, sequenceNum
121>   from MLD_FISH_Region
122>   where _Expt_key = @key
123>   order by sequenceNum
124>   for read only
125> end
126> else if (@table = "MRK_Chromosome")
127> begin
128>   declare seq_cursor cursor for
129>   select _Species_key, sequenceNum
130>   from MRK_Chromosome
131>   where _Species_key = @key
132>   order by sequenceNum
133>   for read only
134> end
135> else if (@table = "MLD_Statistics")
136> begin
137>   declare seq_cursor cursor for
138>   select _Expt_key, sequenceNum
139>   from MLD_Statistics
140>   where _Expt_key = @key
141>   order by sequenceNum
142>   for read only
143> end
144> else
145> begin
146>   return
147> end
148> 
149> open seq_cursor
150> fetch seq_cursor into @pkey, @oldSeq
151>  
152> while (@@sqlstatus = 0)
153> begin
154>   if (@table = "GXD_GelLane")
155>   begin
156>     update GXD_GelLane set sequenceNum = @newSeq
157>       where _GelLane_key = @pkey
158>   end
159>   else if (@table = "GXD_GelRow")
160>   begin
161>     update GXD_GelRow set sequenceNum = @newSeq
162>       where _GelRow_key = @pkey
163>   end
164>   else if (@table = "GXD_Specimen")
165>   begin
166>     update GXD_Specimen set sequenceNum = @newSeq
167>       where _Specimen_key = @pkey
168>   end
169>   else if (@table = "GXD_InSituResult")
170>   begin
171>     update GXD_InSituResult set sequenceNum = @newSeq
172>       where _Result_key = @pkey
173>   end
174>   else if (@table = "MRK_History")
175>   begin
176>     update MRK_History set sequenceNum = @newSeq
177>       where _Marker_key = @pkey and sequenceNum = @oldSeq
178>   end
179>   else if (@table = "MLD_Marker")
180>   begin
181>     update MLD_Marker set sequenceNum = @newSeq
182>       where _Refs_key = @pkey and sequenceNum = @oldSeq
183>   end
184>   else if (@table = "MLD_Expt_Marker")
185>   begin
186>     update MLD_Expt_Marker set sequenceNum = @newSeq
187>       where _Expt_key = @pkey and sequenceNum = @oldSeq
188>   end
189>   else if (@table = "MLD_MCDataList")
190>   begin
191>     update MLD_MCDataList set sequenceNum = @newSeq
192>       where _Expt_key = @pkey and sequenceNum = @oldSeq
193>   end
194>   else if (@table = "MLD_MC2point")
195>   begin
196>     update MLD_MC2point set sequenceNum = @newSeq
197>       where _Expt_key = @pkey and sequenceNum = @oldSeq
198>   end
199>   else if (@table = "MLD_RIData")
200>   begin
201>     update MLD_RIData set sequenceNum = @newSeq
202>       where _Expt_key = @pkey and sequenceNum = @oldSeq
203>   end
204>   else if (@table = "MLD_RI2Point")
205>   begin
206>     update MLD_RI2Point set sequenceNum = @newSeq
207>       where _Expt_key = @pkey and sequenceNum = @oldSeq
208>   end
209>   else if (@table = "MLD_FISH_Region")
210>   begin
211>     update MLD_FISH_Region set sequenceNum = @newSeq
212>       where _Expt_key = @pkey and sequenceNum = @oldSeq
213>   end
214>   else if (@table = "MRK_Chromosome")
215>   begin
216>     update MRK_Chromosome set sequenceNum = @newSeq
217>       where _Species_key = @pkey and sequenceNum = @oldSeq
218>   end
219>   else if (@table = "MLD_Statistics")
220>   begin
221>     update MLD_Statistics set sequenceNum = @newSeq
222>       where _Expt_key = @pkey and sequenceNum = @oldSeq
223>   end
224>   select @newSeq = @newSeq + 1
225>   fetch seq_cursor into @pkey, @oldSeq
226> end
227>  
228> close seq_cursor
229> deallocate cursor seq_cursor
230>  
1> 
2> grant execute on MGI_resetSequenceNum to progs
1> 
2> grant execute on MGI_resetSequenceNum to editors
1> 
2> drop procedure GEN_rowcount
1>  
2> create procedure GEN_rowcount
3>   @table varchar(30)
4> as
5> 
6> select convert(char(10),rowcnt(MAX(doampg)))
7> from sysobjects o, sysindexes i
8> where o.name = @table
9> and o.id = i.id
1> 
2> grant execute on GEN_rowcount to public
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop procedure Current_Symbol
1> 
2> create procedure Current_Symbol 
3>   @symbol varchar(25)
4> as
5> 
6> 
7> declare item cursor for
8>    select m._Marker_key, m.symbol 
9>    from MRK_Marker m 
10>    where m.symbol = @symbol
11>    and _Species_key = 1
12> 
13> declare @mk int
14> declare @sym varchar(25) 
15> open item 
16> 
17> while (@@sqlstatus = 0)
18> begin
19>    fetch item into @mk, @sym
20>    if (@@sqlstatus = 2) break
21>    select _Current_key = c._Current_key, 
22>           _Marker_key =  c._Marker_key,
23>           current_symbol = m.symbol, 
24> 		  symbol = @sym
25>    from MRK_Current c, MRK_Marker m
26>    where c._Current_key = m._Marker_key
27>    and m._Species_key = 1
28>    and c._Marker_key = @mk
29> end
30> 
31> close item
32> 			
1> 
2> grant execute on Current_Symbol to public
3> grant execute on Current_Symbol to progs
1> 
2> checkpoint
1> 
2> drop procedure MLC_transfer
1> 
2> create procedure MLC_transfer
3>     @_Marker_key int
4> as
5> /* This proc transfers rows with primary_key = @_Marker_key from the MLC 
6>  * edit tables to the Production MLC tables.  If the MLC_Text_edit table
7>  * does not contain a row with _Marker_key = @_Marker_key, then this is
8>  * a delete that will be propagated to the Production MLC tables.
9>  */
10> 
11> begin transaction
12> 
13> declare @doinsert bit
14> select @doinsert = 1  /* assume we are copying, not deleting */
15> 
16> 
17> /* determine if this is a copy or delete */
18> 
19> if (select count(*) 
20>     from MLC_Text_edit
21>     where _Marker_key = @_Marker_key) = 0
22> begin  /* then we must propagate a delete */
23>     select @doinsert = 0
24> end
25> 
26> 
27> /* make sure to set the textsize to avoid truncation during selects
28>    when copying data between MLC_Text_edit and MLC_Text */
29> 
30> set textsize 500000
31> 
32> /* MLC_Text */
33> 
34> /* delete the rows from the Production table that will be replaced
35>    with rows from the corresponding _edit table */ 
36> 
37> delete from MLC_Text where _Marker_key = @_Marker_key
38> if @@error != 0
39> begin
40>    rollback transaction
41>    raiserror 99999 "Delete from MLC_Text failed, mk = %1!", @_Marker_key
42>    return
43> end
44> 
45> if @doinsert = 1
46> begin
47>    /* insert the updated rows into production tables */ 
48>    insert MLC_Text 
49>    select * from MLC_Text_edit where _Marker_key = @_Marker_key
50> 
51>    if @@error != 0
52>    begin
53>       rollback transaction
54>       raiserror 99999 "Insert into MLC_Text failed, mk = %1!", @_Marker_key
55>       return
56>    end
57> end
58> 
59> /* MLC_Marker */
60> 
61> /* delete the rows from the Production table that will be replaced
62>    with rows from the corresponding _edit table */ 
63> 
64> delete from MLC_Marker where _Marker_key = @_Marker_key
65> if @@error != 0
66> begin
67>    rollback transaction
68>    raiserror 99999 "Delete from MLC_Marker failed, mk = %1!", @_Marker_key
69>    return
70> end
71> 
72> if @doinsert = 1
73> begin
74>    /* insert the updated rows into production tables */ 
75>    insert MLC_Marker 
76>    select * from MLC_Marker_edit where _Marker_key = @_Marker_key
77> 
78>    if @@error != 0
79>    begin
80>       rollback transaction
81>       raiserror 99999 "Insert into MLC_Marker failed, mk = %1!", @_Marker_key
82>       return
83>    end
84> end
85> 
86> 
87> /* MLC_Reference */
88> 
89> /* delete the rows from the Production table that will be replaced
90>    with rows from the corresponding _edit table */ 
91> 
92> delete from MLC_Reference where _Marker_key = @_Marker_key
93> if @@error != 0
94> begin
95>    rollback transaction
96>    raiserror 99999 "Delete from MLC_Reference failed, mk = %1!", @_Marker_key
97>    return
98> end
99> 
100> if @doinsert = 1
101> begin
102>    /* insert the updated rows into production tables */ 
103>    insert MLC_Reference 
104>    select * from MLC_Reference_edit where _Marker_key = @_Marker_key
105> 
106>    if @@error != 0
107>    begin
108>       rollback transaction
109>       raiserror 99999 "Insert into MLC_Reference failed, mk = %1!", @_Marker_key
110>       return
111>    end
112> end
113> 
114> commit transaction
1> 
2> grant execute on MLC_transfer to progs
1> 
2> grant execute on MLC_transfer to cml, jblake, rmb, wjb, dbradt, lmm, sr, cgw, dph
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> /* obsolete procedures */
3> 
4> drop procedure MRK_insertAllele
1> 
2> drop procedure MRK_mergeAllele
1> 
2> /* end obsolete procedures */
3> 
4> drop procedure MRK_insertHistory
1>  
2> create procedure MRK_insertHistory
3>   @markerKey integer,
4>   @historyKey integer,
5>   @refKey integer,
6>   @eventKey integer,
7>   @eventReasonKey integer,
8>   @name varchar(255) = null,
9>   @event_date datetime = null
10> as
11>  
12> /* Insert new History record into MRK_History */
13>  
14> declare @maxSeq int
15> select @maxSeq = max(sequenceNum) from MRK_History where _Marker_key = @markerKey
16> 
17> if @maxSeq is null
18> begin
19> 	select @maxSeq = 0
20> end
21> 
22> if @event_date is null
23> begin
24> 	select @event_date = getdate()
25> end
26>  
27> insert MRK_History 
28> (_Marker_key, _History_key, _Refs_key, _Marker_Event_key, _Marker_EventReason_key, sequenceNum, name, event_date)
29> values(@markerKey, @historyKey, @refKey, @eventKey, @eventReasonKey, @maxSeq + 1, @name, @event_date)
30> 
1>  
2> grant execute on MRK_insertHistory to djr, ljm, rmb
1>  
2> grant execute on MRK_insertHistory to progs
1>  
2> drop procedure MRK_MaxOffset
1> 
2> create procedure MRK_MaxOffset
3> 	@chromosome varchar(2),
4> 	@source int 
5> as
6> 
7> select maxOffset = max(o.offset)
8> from MRK_Offset o, MRK_Marker m
9> where o._Marker_key = m._Marker_key
10> and o.source = @source 
11> and m.chromosome = @chromosome 
12> and m._Species_key = 1
13> 
1> 
2> grant execute on MRK_MaxOffset to public
1> 
2> drop procedure MRK_MiniMapMarkers
1> 
2> create procedure MRK_MiniMapMarkers
3> 	@_Marker_key int,
4> 	@source int 
5> as
6> 
7> /* retrieve data for all anchor markers on the chromosome */
8> 
9> select distinct m._Marker_key, m.symbol, m.name, m.chromosome, o.offset, m.cytogeneticOffset
10> from MRK_Marker m, MRK_Offset o, MRK_Anchors a
11> where m._Marker_key = a._Marker_key
12> 	and o.source = @source
13> 	and o._Marker_key = m._Marker_key
14> 	and o.offset > -1.0
15> 	and a.chromosome = (select m.chromosome 
16> 	from MRK_Marker m
17> 	where m._Marker_key = @_Marker_key)
18> 
19> union
20> 
21> /* get the data for the marker itself */
22> 
23> select distinct m._Marker_key, m.symbol, m.name, m.chromosome, o.offset, m.cytogeneticOffset
24> from MRK_Marker m, MRK_Offset o
25> where m._Marker_key = @_Marker_key
26> 	and o.source = @source
27> 	and o._Marker_key = m._Marker_key
28> 	and o.offset > -1.0
1> 
2> grant execute on MRK_MiniMapMarkers to public
1> 
2> drop procedure MRK_isAnchor
1>  
2> create procedure MRK_isAnchor
3>   @key int
4> as
5> 
6> /* Determine if Marker key exists in MRK_Anchors table */
7> 
8> declare @found int
9> select @found = count(*) from MRK_Anchors where _Marker_key = @key
10> select @found
11> 
1> 
2> grant execute on MRK_isAnchor to public
1>  
2> drop procedure MRK_breakpointSplit
1> 
2> create procedure MRK_breakpointSplit
3>   @markerKey integer,
4>   @distalCytoBand varchar(20) = null
5> as
6> 
7> /* See TR#120; procedure to split cytogenetic marker into 2 distinct markers */
8> 
9> declare @band varchar(20)
10> declare @symbol varchar(25)
11> declare @name varchar(255)
12> declare @markerType integer
13> declare @idx integer
14> 
15> select @symbol = symbol, @band = cytogeneticOffset, @name = name, @markerType = _Marker_Type_key
16> from MRK_Marker where _Marker_key = @markerKey
17> 
18> if @markerType != 3
19> begin
20> 	rollback transaction
21> 	raiserror 99999 "Invalid Marker for Breakpoint Split: %1!", @symbol
22> 	return
23> end
24> 
25> select @idx = charindex(" & ", @band)
26> 
27> declare @proximalBand varchar(20)
28> declare @distalBand varchar(20)
29> 
30> declare @proximalSymbol varchar(25)
31> declare @distalSymbol varchar(25)
32> 
33> declare @proximalName varchar(255)
34> declare @distalName varchar(255)
35> 
36> declare @proximalKey integer
37> declare @distalKey integer
38> 
39> /* If symbol band is not in the format 'X & Y', then distal band remains NULL */
40> 
41> if @idx = 0
42> begin
43> 	select @proximalBand = @band
44> 	/* distal band is null */
45> end
46> else
47> begin
48> 	select @proximalBand = substring(@band, 1, @idx - 1)
49> 	select @distalBand = substring(@band, @idx + 3, char_length(@band))
50> end
51> 
52> /* If caller supplies a distal band, use it */
53> 
54> if @distalCytoBand is not null
55> begin
56> 	select @distalBand = @distalCytoBand
57> end
58> 
59> select @proximalSymbol = @symbol + "-p"
60> select @proximalName = @name + ", proximal"
61> select @proximalKey = @markerKey
62> 
63> select @distalSymbol = @symbol + "-d"
64> select @distalName = @name + ", distal"
65> select @distalKey = max(_Marker_key) + 1 from MRK_Marker
66> 
67> /* Update the symbol, name and cytogenetic offset for the current Marker to the proximal symbol */
68> 
69> update MRK_Marker
70> set symbol = @proximalSymbol,
71>     name = @proximalName,
72>     cytogeneticOffset = @proximalBand
73> where _Marker_key = @proximalKey
74> 
75> update MRK_History
76> set name = @proximalName
77> where _Marker_key = @proximalKey
78> and name = @name
79> 
80> /* Copy proximal symbol info to a new distal symbol */
81> 
82> insert into MRK_Marker 
83> (_Marker_key, _Species_key, _Marker_Type_key, symbol, name, chromosome, cytogeneticOffset)
84> select @distalKey, _Species_key, _Marker_Type_key, @distalSymbol, @distalName, chromosome, @distalBand
85> from MRK_Marker where _Marker_key = @proximalKey
86> 
87> /* Notes */
88> insert into MRK_Notes
89> (_Marker_key, sequenceNum, note)
90> select @distalKey, sequenceNum, note
91> from MRK_Notes where _Marker_key = @proximalKey
92> 
93> /* Offset */
94> insert into MRK_Offset
95> (_Marker_key, source, offset)
96> select @distalKey, source, offset
97> from MRK_Offset where _Marker_key = @proximalKey
98> 
99> /* References */
100> insert into MRK_Reference
101> (_Marker_key, _Refs_key, auto)
102> select @distalKey, _Refs_key, auto
103> from MRK_Reference where _Marker_key = @proximalKey
104> 
105> /* History */
106> insert into MRK_History
107> (_Marker_key, _Marker_Event_key, _Marker_EventReason_key, _History_key, _Refs_key, sequenceNum, name, event_date)
108> select @distalKey, _Marker_Event_key, _Marker_EventReason_key, _History_key, _Refs_key, sequenceNum, name, event_date
109> from MRK_History where _Marker_key = @proximalKey and _History_key != @proximalKey
110> 
111> insert into MRK_History
112> (_Marker_key, _Marker_Event_key, _Marker_EventReason_key, _History_key, _Refs_key, sequenceNum, name, event_date)
113> select @distalKey, _Marker_Event_key, _Marker_EventReason_key, @distalKey, _Refs_key, sequenceNum, @distalName, event_date
114> from MRK_History where _Marker_key = @proximalKey and _History_key = @proximalKey
115> 
116> /* Other Names */
117> select seq = identity(5), name, _Refs_key
118> into #otherTmp
119> from MRK_Other where _Marker_key = @proximalKey
120> 
121> declare @maxOther int
122> select @maxOther = max(_Other_key) from MRK_Other
123> 
124> insert into MRK_Other
125> (_Other_key, _Marker_key, _Refs_key, name)
126> select @maxOther + seq, @distalKey, _Refs_key, name
127> from #otherTmp
128>  
129> /* Accession Numbers */
130> /* Copy all nonMGI preferred Accession numbers of proximal symbol to distal symbol */
131> 
132> select seq = identity(5), a.*
133> into #accTmp
134> from ACC_Accession a where a._Object_key = @proximalKey
135> and a._MGIType_key = 2
136> 
137> declare @maxAcc int
138> select @maxAcc = max(_Accession_key) from ACC_Accession
139> 
140> insert into ACC_Accession
141> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
142> select @maxAcc + seq, accID, prefixPart, numericPart, _LogicalDB_key, @distalKey, _MGIType_key,
143> private, preferred
144> from #accTmp
145> where prefixPart != "MGI:" and preferred != 1
146>  
147> /* Insert Other Name entries for both proximal and distal symbols */
148> 
149> declare @otherKey int
150> select @otherKey = max(_Other_key) + 1 from MRK_Other
151> insert into MRK_Other values(@otherKey, @proximalKey, NULL, @symbol, getdate(), getdate())
152> insert into MRK_Other values(@otherKey + 1, @distalKey, NULL, @symbol, getdate(), getdate())
153> 
154> select @proximalKey, @proximalSymbol
155> select @distalKey, @distalSymbol
156> 
1> 
2> grant execute on MRK_breakpointSplit to djr, ljm, rmb
1> 
2> grant execute on MRK_breakpointSplit to progs
1> 
2> drop procedure MRK_addChromosome
1> 
2> create procedure MRK_addChromosome
3>   @speciesKey integer,
4>   @chromosome varchar(8)
5> as
6> 
7> /* If Chromosome for given Species does not exist in MRK_Chromosome, */
8> /* then insert the chromosome into MRK_Chromosome. */
9> /* MRK_Chromosome is used to sequentially order the Chromosome values within */
10> /* a given Species for sorting in Homology, reports, Oxford Grids, etc. */
11> 
12> if (select count(*) from MRK_Chromosome
13>     where _Species_key = @speciesKey and chromosome = @chromosome) = 0
14> begin
15>         /* Get next available sequence number */
16>         declare @nextseq integer
17> 
18>         select @nextseq = max(sequenceNum) + 1 
19>         	from MRK_Chromosome
20>         	where _Species_key = @speciesKey
21> 
22>         if @nextseq is NULL or @nextseq = 0
23>         begin
24>         	select @nextseq = 1
25>         end
26> 
27>         insert into MRK_Chromosome (_Species_key, chromosome, sequenceNum)
28> 	values(@speciesKey, @chromosome, @nextseq)
29> 
30> end
1> 
2> grant execute on MRK_addChromosome to editors
1> 
2> grant execute on MRK_addChromosome to progs
1> 
2> drop procedure MRK_updateIMAGESeqAssoc
1>  
2> create procedure MRK_updateIMAGESeqAssoc
3>   @markerKey integer,
4>   @accID varchar(30)
5> as
6>  
7> /* TR 1270
8>  *
9>  * update/add marker/clone/E association
10>  * if accID exists for IMAGE clone
11>  *
12>  * see TR for more specific details
13> */
14> 
15> declare @cloneKey integer
16> 
17> select @cloneKey = p._Probe_key
18> from PRB_Probe p, PRB_Acc_View a
19> where p.name = 'I.M.A.G.E. clone'
20> and p._Probe_key = a._Object_key
21> and a._LogicalDB_key = 9
22> and a.accID = @accID
23> 
24> /* @accID is not attached to an IMAGE clone. do nothing. */
25> if @cloneKey is null
26> begin
27> 	return
28> end
29> 
30> /* if another "E" marker exists for the clone, print message and return */
31> 
32> if exists (select 1 from PRB_Marker 
33> 	where _Probe_key = @cloneKey
34> 	and _Marker_key != @markerKey
35> 	and relationship = 'E')
36> begin
37> 	print "The Clone/Sequence Accession number %1! has an encodes relationship with another Marker.", @accID
38> 	return
39> end
40> 
41> /* 
42>  * if clone/marker relationship exists, update to 'E'
43>  * else insert clone/marker/E relationship record
44> */
45> 
46> if exists (select 1 from PRB_Marker 
47> 	where _Probe_key = @cloneKey
48> 	and _Marker_key = @markerKey)
49> begin
50> 	update PRB_Marker set relationship = 'E', modification_date = getdate()
51> 	where _Probe_key = @cloneKey
52> 	and _Marker_key = @markerKey
53> end
54> else
55> begin
56> 	insert into PRB_Marker values(@cloneKey, @markerKey, 'E', getdate(), getdate())
57> end
58> 
59> /* delete all putative associations for clone */
60> 
61> delete from PRB_Marker where _Probe_key = @cloneKey and relationship = 'P'
62> 
1> 
2> grant execute on MRK_updateIMAGESeqAssoc to editors
1>  
2> grant execute on MRK_updateIMAGESeqAssoc to progs
1>  
2> drop procedure MRK_deleteIMAGESeqAssoc
1>  
2> create procedure MRK_deleteIMAGESeqAssoc
3>   @markerKey integer,
4>   @accID varchar(30)
5> as
6> 
7> /* TR 1270
8>  *
9>  * delete marker/clone/E association
10>  * if accID exists for IMAGE clone
11>  *
12>  * see TR for more specific details
13> */
14> 
15> declare @cloneKey integer
16> 
17> select @cloneKey = p._Probe_key
18> from PRB_Probe p, PRB_Acc_View a
19> where p.name = 'I.M.A.G.E. clone'
20> and p._Probe_key = a._Object_key
21> and a._LogicalDB_key = 9
22> and a.accID = @accID
23> 
24> /* @accID is not attached to an IMAGE clone. do nothing. */
25> if @cloneKey is null
26> begin
27> 	return
28> end
29> 
30> /* if @accid is still attached to the marker, do nothing. */
31> 
32> if exists (select 1 from MRK_Acc_View 
33> where _Object_key = @markerKey
34> and accID = @accID)
35> begin
36> 	return
37> end
38> 
39> delete from PRB_Marker 
40> where _Probe_key = @cloneKey
41> and _Marker_key = @markerKey
42> and relationship = "E"
43> 
1> 
2> grant execute on MRK_deleteIMAGESeqAssoc to editors
1>  
2> grant execute on MRK_deleteIMAGESeqAssoc to progs
1>  
2> drop procedure MRK_reloadLabel
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRK_reloadLabel', because it doesn't exist in the
system catalogs.
1> 
2> create procedure MRK_reloadLabel
3> 	@markerKey integer
4> as
5> 
6> /* Delete all MRK_Label records for a Marker and regenerate */
7> 
8> delete from MRK_Label where _Marker_key = @markerKey
9> 
10> declare marker_cursor cursor for
11> select _Marker_Status_key, _Species_key, symbol, labelType = "S"
12> from MRK_Marker
13> where _Marker_key = @markerKey
14> union
15> select _Marker_Status_key, _Species_key, name, labelType = "N"
16> from MRK_Marker
17> where _Marker_key = @markerKey
18> union
19> select distinct m2._Marker_Status_key, m2._Species_key, m2.symbol, labelType = "S" 
20> from MRK_History h, MRK_Marker m, MRK_Marker m2 
21> where h._Marker_key = @markerKey
22> and h._Marker_key = m._Marker_key 
23> and h._History_key = m2._Marker_key 
24> union
25> select distinct m2._Marker_Status_key, m2._Species_key, h.name, labelType = "N" 
26> from MRK_History h, MRK_Marker m, MRK_Marker m2 
27> where h._Marker_key = @markerKey
28> and h.name is not null 
29> and h._Marker_key = m._Marker_key 
30> and h._History_key = m2._Marker_key 
31> union
32> select distinct -2, 1, o.name, labelType = "Y" 
33> from MRK_Other o
34> where o._Marker_key = @markerKey
35> for read only
36> 
37> open marker_cursor
38> 
39> declare @statusKey integer
40> declare @speciesKey integer
41> declare @label varchar(255)
42> declare @labelType char(1)
43> 
44> fetch marker_cursor into @statusKey, @speciesKey, @label, @labelType
45> 
46> while (@@sqlstatus = 0)
47> begin
48> 	insert into MRK_Label (_Marker_key, _Marker_Status_key, _Species_key, label, labelType)
49> 	values (@markerKey, @statusKey, @speciesKey, @label, @labelType)
50> 
51> 	if @@error != 0
52> 	begin
53> 		rollback transaction
54> 		raiserror 99999 "Could Re-load Marker Label"
55> 		return
56> 	end
57> 
58> 	fetch marker_cursor into @statusKey, @speciesKey, @label, @labelType
59> end
60> 
61> close marker_cursor
62> deallocate cursor marker_cursor
63> 
1> 
2> grant execute on MRK_reloadLabel to editors
1> 
2> grant execute on MRK_reloadLabel to progs
1> 
2> drop procedure MRK_reloadReference
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRK_reloadReference', because it doesn't exist in the
system catalogs.
1> 
2> create procedure MRK_reloadReference
3> 	@markerKey integer
4> as
5> 
6> /* Select all unique Marker/Reference pairs */
7> 
8> declare marker_cursor cursor for
9> select distinct r._Refs_key, auto = 1 
10> from PRB_Marker m, PRB_Reference r 
11> where m._Marker_key = @markerKey
12> and m._Probe_key = r._Probe_key 
13> union 
14> select distinct h._Refs_key, auto = 1 
15> from HMD_Homology_Marker hm, HMD_Homology h 
16> where hm._Marker_key = @markerKey
17> and hm._Homology_key = h._Homology_key 
18> union 
19> select distinct _Refs_key, auto = 1 
20> from MRK_History
21> where _Marker_key = @markerKey
22> and _Refs_key is not null 
23> union 
24> select distinct _Refs_key, auto = 1 
25> from MLD_Marker 
26> where _Marker_key = @markerKey
27> union 
28> select distinct _Refs_key, auto = 1 
29> from GXD_Index 
30> where _Marker_key = @markerKey
31> union 
32> select distinct _Refs_key, auto = 1 
33> from GXD_Assay 
34> where _Marker_key = @markerKey
35> union 
36> select distinct _Refs_key, auto = 1 
37> from MRK_Other 
38> where _Marker_key = @markerKey
39> and _Refs_key is not null 
40> union 
41> select distinct ar._Refs_key, auto = 1 
42> from ACC_Accession a, ACC_AccessionReference ar 
43> where a._Object_key = @markerKey
44> and a._MGIType_key = 2 
45> and a._LogicalDB_key = 9 
46> and a._Accession_key = ar._Accession_key 
47> union 
48> select distinct _Refs_key, auto = 0 
49> from MRK_Reference
50> where _Marker_key = @markerKey and auto = 0
51> for read only
52> 
53> open marker_cursor
54> 
55> delete from MRK_Reference where _Marker_key = @markerKey
56> 
57> declare @refKey integer
58> declare @auto bit
59> 
60> fetch marker_cursor into @refKey, @auto
61> 
62> while (@@sqlstatus = 0)
63> begin
64> 	if not exists (select * from MRK_Reference where _Marker_key = @markerKey
65> 		and _Refs_key = @refKey)
66> 	begin
67> 		insert into MRK_Reference (_Marker_key, _Refs_key, auto)
68> 		values (@markerKey, @refKey, @auto)
69> 
70> 		if @@error != 0
71> 		begin
72> 			rollback transaction
73> 			raiserror 99999 "Could Re-load Marker Reference"
74> 			return
75> 		end
76> 	end
77> 
78> 	fetch marker_cursor into @refKey, @auto
79> end
80> 
81> close marker_cursor
82> deallocate cursor marker_cursor
83> 
1> 
2> grant execute on MRK_reloadReference to editors
1> 
2> grant execute on MRK_reloadReference to progs
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop procedure MRKXfer_count_MLD
1>  
2> create procedure MRKXfer_count_MLD
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Markers in MLDP for marker/reference pair */
8> 
9> select count(*) from MLD_Marker
10> where _Marker_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_MLD to public
1>  
2> drop procedure MRKXfer_MLD
1>  
2> create procedure MRKXfer_MLD
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return MGI Experiment Accession numbers for marker/reference pair */
8> 
9> select distinct e._Expt_key 
10> into #expts
11> from MLD_Marker m, MLD_Expts e
12> where m._Marker_key = @markerKey and
13>       m._Refs_key = @refKey and
14>       m._Refs_key = e._Refs_key
15> 
16> select distinct a.mgiID
17> from #expts t, MLD_Summary_View a
18> where t._Expt_key = a._Object_key
19> 
1> 
2> grant execute on MRKXfer_MLD to public
1>  
2> drop procedure MRKXfer_count_HMD
1>  
2> create procedure MRKXfer_count_HMD
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Homology records for marker/reference pair */
8> 
9> select count(r._Refs_key) from HMD_Homology_Marker m, HMD_Homology r
10> where m._Marker_key = @markerKey and
11>       m._Homology_Key = r._Homology_key and
12>       r._Refs_key = @refKey
13> 
1> 
2> grant execute on MRKXfer_count_HMD to public
1>  
2> drop procedure MRKXfer_count_GXDIndex
1>  
2> create procedure MRKXfer_count_GXDIndex
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Index records for marker/reference pair */
8> 
9> select count(_Refs_key) from GXD_Index
10> where _Marker_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_GXDIndex to public
1>  
2> drop procedure MRKXfer_count_GXDAntibody
1>  
2> create procedure MRKXfer_count_GXDAntibody
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Antibody records for marker/reference pair */
8> 
9> select a._Refs_key
10> into #count
11> from GXD_Antibody a, GXD_AntibodyMarker am
12> where a._Refs_key = @refKey and 
13>       a._Antibody_key = am._Antibody_key and
14>       am._Marker_key = @markerKey
15> union
16> select a._Refs_key
17> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
18> where a._Antibody_key = am._Antibody_key and 
19>       am._Marker_key = @markerKey and 
20>       a._Antibody_key = aa._Antibody_key and 
21>       aa._Refs_key = @refKey
22> 
23> select count(*) from #count
24> 
1> 
2> grant execute on MRKXfer_count_GXDAntibody to public
1>  
2> drop procedure MRKXfer_count_GXDAntibodyAssay
1>  
2> create procedure MRKXfer_count_GXDAntibodyAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Assay records which use the Antibody for marker/reference pair
8>    to detect the Marker.
9> */
10>  
11> select a._Antibody_key 
12> into #antibody
13> from GXD_Antibody a, GXD_AntibodyMarker am
14> where a._Refs_key = @refKey and
15>       a._Antibody_key = am._Antibody_key and
16>       am._Marker_key = @markerKey
17> union
18> select a._Antibody_key
19> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
20> where a._Antibody_key = am._Antibody_key and
21>       am._Marker_key = @markerKey and
22>       a._Antibody_key = aa._Antibody_key and
23>       aa._Refs_key = @refKey
24>  
25> select count(a._Assay_key)
26> from #antibody p, GXD_AntibodyPrep xa, GXD_Assay a
27> where p._Antibody_key = xa._Antibody_key and
28>       xa._AntibodyPrep_key = a._AntibodyPrep_key and
29>       a._Marker_key = @markerKey
30> 
1>  
2> grant execute on MRKXfer_count_GXDAntibodyAssay to public
1>  
2> drop procedure MRKXfer_GXDAntibodyAssay
1>  
2> create procedure MRKXfer_GXDAntibodyAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Assay records which use the Antibody for marker/reference pair
8>    to detect the Marker.
9> */
10>  
11> select a._Antibody_key
12> into #antibody
13> from GXD_Antibody a, GXD_AntibodyMarker am
14> where a._Refs_key = @refKey and
15>       a._Antibody_key = am._Antibody_key and
16>       am._Marker_key = @markerKey
17> union
18> select a._Antibody_key
19> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
20> where a._Antibody_key = am._Antibody_key and
21>       am._Marker_key = @markerKey and
22>       a._Antibody_key = aa._Antibody_key and
23>       aa._Refs_key = @refKey
24>  
25> select a._Assay_key
26> into #assay
27> from #antibody p, GXD_AntibodyPrep xa, GXD_Assay a
28> where p._Antibody_key = xa._Antibody_key and
29>       xa._AntibodyPrep_key = a._AntibodyPrep_key and
30>       a._Marker_key = @markerKey
31>  
32> select a.mgiID
33> from #assay t, GXD_Assay_Summary_View a
34> where t._Assay_key = a._Object_key
35> 
1>  
2> grant execute on MRKXfer_GXDAntibodyAssay to public
1>  
2> drop procedure MRKXfer_GXDAntibody
1>  
2> create procedure MRKXfer_GXDAntibody
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return MGI Antibody Accession numbers for marker/reference pair */
8> 
9> select a._Antibody_key 
10> into #antibody
11> from GXD_Antibody a, GXD_AntibodyMarker am
12> where a._Refs_key = @refKey and
13>       a._Antibody_key = am._Antibody_key and
14>       am._Marker_key = @markerKey
15> union
16> select a._Antibody_key
17> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
18> where a._Antibody_key = am._Antibody_key and
19>       am._Marker_key = @markerKey and
20>       a._Antibody_key = aa._Antibody_key and
21>       aa._Refs_key = @refKey
22>  
23> select a.mgiID
24> from #antibody t, GXD_Antibody_Summary_View a
25> where t._Antibody_key = a._Object_key
26> 
1>  
2> grant execute on MRKXfer_GXDAntibody to public
1>  
2> drop procedure MRKXfer_count_GXDAssay
1>  
2> create procedure MRKXfer_count_GXDAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Assay records for marker/reference pair */
8> 
9> select count(_Refs_key) from GXD_Assay
10> where _Marker_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_GXDAssay to public
1>  
2> drop procedure MRKXfer_GXDAssay
1>  
2> create procedure MRKXfer_GXDAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return MGI Assay Accession numbers for marker/reference pair */
8> 
9> select _Assay_key
10> into #assay
11> from GXD_Assay
12> where _Marker_key = @markerKey and
13>       _Refs_key = @refKey
14> 
15> select a.mgiID
16> from #assay t, GXD_Assay_Summary_View a
17> where t._Assay_key = a._Object_key
18> 
1>  
2> grant execute on MRKXfer_GXDAssay to public
1>  
2> drop procedure MRKXfer_count_MLC
1>  
2> create procedure MRKXfer_count_MLC
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of MLC Text records for marker/reference pair */
8> 
9> select count(m._Marker_key) 
10> from MLC_Text_edit m, MLC_Reference_edit r
11> where m._Marker_key = @markerKey
12> and m._Marker_key = r._Marker_key
13> and r._Refs_key = @refKey
14> 
1> 
2> grant execute on MRKXfer_count_MLC to public
1>  
2> drop procedure MRKXfer_count_PRB
1>  
2> create procedure MRKXfer_count_PRB
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Probe records for marker/reference pair */
8> 
9> select count(distinct p.name) from PRB_Probe p, PRB_Marker m, PRB_Reference r
10> where m._Marker_key = @markerKey and
11>       m._Probe_key = r._Probe_key and
12>       r._Refs_key = @refKey and
13>       m._Probe_key = p._Probe_key
14> 
1> 
2> grant execute on MRKXfer_count_PRB to public
1>  
2> drop procedure MRKXfer_PRB
1>  
2> create procedure MRKXfer_PRB
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for marker/reference pair */
8> 
9> select distinct p.name, p._Probe_key
10> from PRB_Probe p, PRB_Marker m, PRB_Reference r
11> where m._Marker_key = @markerKey and
12>       m._Probe_key = r._Probe_key and
13>       r._Refs_key = @refKey and
14>       m._Probe_key = p._Probe_key
15>  
1>  
2> grant execute on MRKXfer_PRB to public
1> 
2> drop procedure MRKXfer_count_PRBAssay
1>  
2> create procedure MRKXfer_count_PRBAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for Assays which use Probe to detect Marker */
8> 
9> select distinct p.name, p._Probe_key
10> into #probe
11> from PRB_Probe p, PRB_Marker m, PRB_Reference r
12> where m._Marker_key = @markerKey and
13>       m._Probe_key = r._Probe_key and
14>       r._Refs_key = @refKey and
15>       m._Probe_key = p._Probe_key
16>  
17> select count(a._Assay_key)
18> from #probe p, GXD_ProbePrep xp, GXD_Assay a
19> where p._Probe_key = xp._Probe_key and
20>       xp._ProbePrep_key = a._ProbePrep_key and
21>       a._Marker_key = @markerKey
22> 
1> 
2> grant execute on MRKXfer_count_PRBAssay to public
1> 
2> drop procedure MRKXfer_PRBAssay
1>  
2> create procedure MRKXfer_PRBAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for Assays which use Probe to detect Marker */
8> 
9> select distinct p.name, p._Probe_key
10> into #probe
11> from PRB_Probe p, PRB_Marker m, PRB_Reference r
12> where m._Marker_key = @markerKey and
13>       m._Probe_key = r._Probe_key and
14>       r._Refs_key = @refKey and
15>       m._Probe_key = p._Probe_key
16>  
17> select a._Assay_key
18> into #assay
19> from #probe p, GXD_ProbePrep xp, GXD_Assay a
20> where p._Probe_key = xp._Probe_key and
21>       xp._ProbePrep_key = a._ProbePrep_key and
22>       a._Marker_key = @markerKey
23> 
24> select a.mgiID
25> from #assay t, GXD_Assay_Summary_View a
26> where t._Assay_key = a._Object_key
27> 
1> 
2> grant execute on MRKXfer_PRBAssay to public
1> 
2> drop procedure MRKXfer_count_PRBReference
1>  
2> create procedure MRKXfer_count_PRBReference
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Probes for marker/reference pair */
8> /* which contain more than one reference */
9>  
10> select distinct p._Probe_key, p.name
11> into #probe
12> from PRB_Probe p, PRB_Marker m, PRB_Reference r
13> where m._Marker_key = @markerKey and
14>       m._Probe_key = r._Probe_key and
15>       r._Refs_key = @refKey and
16>       m._Probe_key = p._Probe_key
17>  
18> select distinct t._Probe_key
19> into #count
20> from #probe t, PRB_Reference r
21> where t._Probe_key = r._Probe_key
22> group by t._Probe_key
23> having count(*) > 1
24>  
25> select count(*) from #count
26> 
1>  
2> grant execute on MRKXfer_count_PRBReference to public
1>  
2> drop procedure MRKXfer_PRBReference
1>  
2> create procedure MRKXfer_PRBReference
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for marker/reference pair */
8> /* which contain more than one reference */
9> 
10> 
11> select distinct p._Probe_key, p.name
12> into #probe
13> from PRB_Probe p, PRB_Marker m, PRB_Reference r
14> where m._Marker_key = @markerKey and
15>       m._Probe_key = r._Probe_key and
16>       r._Refs_key = @refKey and
17>       m._Probe_key = p._Probe_key
18>  
19> select t.name, t._Probe_key
20> from #probe t, PRB_Reference r
21> where t._Probe_key = r._Probe_key
22> group by t._Probe_key
23> having count(*) > 1
24> 
1>  
2> grant execute on MRKXfer_PRBReference to public
1> 
2> drop procedure MRKXfer_count_PRBNote
1>  
2> create procedure MRKXfer_count_PRBNote
3>   @probeKey integer,
4>   @marker varchar(25)
5> as
6>  
7> /* Return number of Probe Notes for probe/marker pair */
8> 
9> select count(_Probe_key) 
10> from PRB_Notes
11> where _Probe_key = @probeKey and
12>       note like "%" + @marker + "%"
13> 
1>  
2> grant execute on MRKXfer_count_PRBNote to public
1> 
2> drop procedure MRKXfer_count_MRKAccession
1>  
2> create procedure MRKXfer_count_MRKAccession
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Markers with accession/reference pair */
8> 
9> select count(*) from MRK_AccRef_View
10> where _Object_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_MRKAccession to public
1>  
2> drop procedure MRKXfer_MRKAccession
1>  
2> create procedure MRKXfer_MRKAccession
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Accession numbers for marker/reference pair */
8>  
9> select distinct accID
10> from MRK_AccRef_View
11> where _Object_key = @markerKey and
12>       _Refs_key = @refKey
13>  
1>  
2> grant execute on MRKXfer_MRKAccession to public
1>  
2> drop procedure MRKXfer_update
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_update', because it doesn't exist in the
system catalogs.
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> /* drop obsolete procedures */
3> 
4> drop procedure MRK_convertAllele
1>  
2> drop procedure MRK_copyAcc
1>  
2> drop procedure MRK_copyHistory
1>  
2> create procedure MRK_copyHistory
3>   @oldKey integer,
4>   @newKey integer
5> as
6>  
7> begin transaction
8> 
9> /* Copy History of @oldKey to @newKey */
10>  
11> declare history_cursor cursor for
12> select _History_key, _Refs_key, _Marker_Event_key, _Marker_EventReason_key, name, event_date
13> from MRK_History
14> where _Marker_key = @oldKey
15> order by sequenceNum
16> for read only
17> 
18> open history_cursor
19> 
20> declare @historyKey integer
21> declare @refKey integer
22> declare @name varchar(255)
23> declare @eventKey integer
24> declare @eventReasonKey integer
25> declare @event_date datetime
26> 
27> fetch history_cursor into @historykey, @refKey, @eventKey, @eventReasonKey, @name, @event_date
28> 
29> while (@@sqlstatus = 0)
30> begin
31> 	exec MRK_insertHistory @newKey, @historyKey, @refKey, @eventKey, @eventReasonKey, @name, @event_date
32> 	fetch history_cursor into @historykey, @refKey, @eventKey, @eventReasonKey, @name, @event_date
33> end
34> 
35> close history_cursor
36> deallocate cursor history_cursor
37> 
38> commit transaction
39> 
1>  
2> grant execute on MRK_copyHistory to djr, ljm, rmb
1>  
2> grant execute on MRK_copyHistory to progs
1>  
2> drop procedure MRK_updateKeys
1> 
2> create procedure MRK_updateKeys
3>   @oldKey integer,
4>   @newKey integer
5> as
6> 
7> begin transaction
8> 
9> /* Executed during merge withdrawal process */
10> 
11> /*
12>    Set the preferred bit to 0 for all MGI Acc# brought over from old symbol if
13>    the new symbol already contains a preferred MGI Acc#.
14>    Associate all Accession numbers w/ new symbol.
15> */
16> 
17> if (select count(*) 
18>     from ACC_Accession 
19>     where _MGIType_key = 2 and 
20> 	  prefixPart = "MGI:" and
21> 	  _Object_key = @newKey and
22> 	  preferred = 1) > 0
23> begin
24> 	update ACC_Accession 
25> 	set _Object_key = @newKey, preferred = 0
26> 	where _LogicalDB_key = 1 and _MGIType_key = 2 and _Object_key = @oldKey
27> end
28> 
29> update ACC_Accession 
30> set _Object_key = @newKey
31> where _MGIType_key = 2 and _Object_key = @oldKey
32> 
33> /* Associate aliases, classes, other names, references w/ new symbol */
34> 
35> /* Remove reflexive Alias records, if they exist */
36> 
37> delete from MRK_Alias where _Marker_key = @oldKey and _Alias_key = @newKey
38> delete from MRK_Alias where _Alias_key = @oldKey and _Marker_key = @newKey
39> 
40> update MRK_Alias set _Marker_key = @newKey where _Marker_key = @oldKey
41> update MRK_Alias set _Alias_key = @newKey where _Alias_key = @oldKey
42> update ALL_Allele set _Marker_key = @newKey where _Marker_key = @oldKey
43> update MRK_Anchors set _Marker_key = @newKey where _Marker_key = @oldKey
44> update MRK_Other set _Marker_key = @newKey where _Marker_key = @oldKey
45> 
46> /* MRK_Classes may contain potential duplicates */
47> 
48> insert into MRK_Classes
49> select @newKey, m._Class_key, m.creation_date, m.modification_date
50> from MRK_Classes m
51> where m._Marker_key = @oldKey
52> and not exists (select m2.* from MRK_Classes m2
53> where m2._Marker_key = @newKey
54> and m2._Class_key = m._Class_key)
55> 
56> delete from MRK_Classes where _Marker_key = @oldKey
57> 
58> /* Update all auxiliary references to old symbol w/ new symbol */
59> 
60> update CRS_Matrix set _Marker_key = @newKey where _Marker_key = @oldKey
61> update CRS_References set _Marker_key = @newKey where _Marker_key = @oldKey
62> update HMD_Homology_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
63> update GXD_AllelePair set _Marker_key = @newKey where _Marker_key = @oldKey
64> update GXD_AntibodyMarker set _Marker_key = @newKey where _Marker_key = @oldKey
65> update GXD_Assay set _Marker_key = @newKey where _Marker_key = @oldKey
66> update GXD_Expression set _Marker_key = @newKey where _Marker_key = @oldKey
67> update GXD_Index set _Marker_key = @newKey where _Marker_key = @oldKey
68> 
69> /* Include MLD_Marker and MLD_Expt_Marker because sometimes Markers are */
70> /* mentioned in one table and not the other */
71> 
72> update MLD_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
73> update MLD_Expt_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
74> update MLD_Concordance set _Marker_key = @newKey where _Marker_key = @oldKey
75> update MLD_Distance set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
76> update MLD_Distance set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
77> update MLD_MC2point set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
78> update MLD_MC2point set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
79> update MLD_RI2Point set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
80> update MLD_RI2Point set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
81> update MLD_RIData set _Marker_key = @newKey where _Marker_key = @oldKey
82> update MLD_Statistics set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
83> update MLD_Statistics set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
84> update GO_MarkerGO set _Marker_key = @newKey where _Marker_key = @oldKey
85> 
86> update PRB_Strain 
87> set s.needsReview = 1
88> from PRB_Strain s, PRB_Strain_Marker m
89> where m._Marker_key = @oldKey
90> and m._Strain_key = s._Strain_key
91>  
92> update PRB_Strain_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
93> 
94> /* PRB_Marker may contain potential duplicates */
95> 
96> insert into PRB_Marker
97> select m._Probe_key, @newKey, m.relationship, m.creation_date, m.modification_date
98> from PRB_Marker m
99> where m._Marker_key = @oldKey
100> and not exists (select m2.* from PRB_Marker m2
101> where m2._Marker_key = @newKey
102> and m2._Probe_key = m._Probe_key)
103>   
104> delete from PRB_Marker where _Marker_key = @oldKey
105> update PRB_RFLV set _Marker_key = @newKey where _Marker_key = @oldKey
106> 
107> /* Update MLC tables iff New Symbol entry doesn't exist in MLC */
108> /* Nomenclature updates are propagated to the non-edit tables immediately */
109> 
110> if not exists (select * from MLC_Marker_edit where _Marker_key = @newKey)
111> begin
112>   update MLC_Marker_edit set _Marker_key = @newKey where _Marker_key = @oldKey
113>   update MLC_Marker_edit set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
114>   update MLC_Reference_edit set _Marker_key = @newKey where _Marker_key = @oldKey
115>   update MLC_Text_edit set _Marker_key = @newKey where _Marker_key = @oldKey
116>   update MLC_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
117>   update MLC_Marker set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
118>   update MLC_Reference set _Marker_key = @newKey where _Marker_key = @oldKey
119>   update MLC_Text set _Marker_key = @newKey where _Marker_key = @oldKey
120> end
121> 
122> /* Insert non-auto Marker References to the new symbol */
123> /* MRK_Reference may contain potential duplicates */
124> 
125> insert into MRK_Reference
126> select @newKey, m._Refs_key, m.auto, m.creation_date, m.modification_date
127> from MRK_Reference m
128> where m._Marker_key = @oldKey and m.auto = 0
129> and not exists (select m2.* from MRK_Reference m2
130> where m2._Marker_key = @newKey
131> and m2._Refs_key = m._Refs_key)
132> 
133> delete from MRK_Reference where _Marker_key = @oldKey
134> 
135> /* Reload MRK_Label and MRK_Reference for both old and new symbols */
136> 
137> exec MRK_reloadLabel @oldKey
138> exec MRK_reloadLabel @newKey
139> exec MRK_reloadReference @oldKey
140> exec MRK_reloadReference @newKey
141> 
142> commit transaction
143> 
1> 
2> grant execute on MRK_updateKeys to djr, ljm, rmb
1> 
2> grant execute on MRK_updateKeys to progs
1> 
2> drop procedure MRK_updateOffset
1> 
2> create procedure MRK_updateOffset
3>   @oldKey integer,
4>   @newKey integer
5> as
6> 
7> /* Update cytogenetic and centimorgan offsets for @newKey 
8>  * using @oldKey values.
9>  */
10> 
11> begin transaction
12> 
13> declare @oldCyto varchar(20)
14> declare @newCyto varchar(20)
15> 
16> declare @oldMGD float
17> declare @newMGD float
18> 
19> declare @oldCC float
20> declare @newCC float
21> 
22> declare @oldMIT float
23> declare @newMIT float
24> 
25> select @oldCyto = cytogeneticOffset from MRK_Marker where _Marker_key = @oldKey
26> select @newCyto = cytogeneticOffset from MRK_Marker where _Marker_key = @newKey
27> 
28> select @oldMGD = offset from MRK_Offset where _Marker_key = @oldKey and source = 0
29> select @oldCC = offset from MRK_Offset where _Marker_key = @oldKey and source = 1
30> select @oldMIT = offset from MRK_Offset where _Marker_key = @oldKey and source = 2
31> 
32> select @newMGD = offset from MRK_Offset where _Marker_key = @newKey and source = 0
33> select @newCC = offset from MRK_Offset where _Marker_key = @newKey and source = 1
34> select @newMIT = offset from MRK_Offset where _Marker_key = @newKey and source = 2
35> 
36> -- If the new symbol lacks an Cytogenetic offset, then use the old symbols' offset
37> 
38> if @newCyto is null
39> begin
40>   update MRK_Marker set cytogeneticOffset = @oldCyto where _Marker_key = @newKey
41> end
42> 
43> -- If the new symbol lacks an MGD offset, then use the old symbols' offset
44> 
45> if @newMGD < 0
46> begin
47>   update MRK_Offset set offset = @oldMGD where _Marker_key = @newKey and source = 0
48> end
49> 
50> -- If the new symbol lacks a CC offset, then use the old symbol's CC offset
51> 
52> if @newCC < 0 and @oldCC > 0
53> begin
54>   update MRK_Offset set offset = @oldCC where _Marker_key = @newKey and source = 1
55> end
56> else if @newCC is null and @oldCC is not null
57> begin
58>   insert MRK_Offset (_Marker_key, source, offset) values(@newKey, 1, @oldCC)
59> end
60> 
61> -- If the new symbol lacks an MIT offset, then use the old symbol's MIT offset
62> 
63> if @newMIT < 0 and @oldMIT > 0
64> begin
65>   update MRK_Offset set offset = @oldMIT where _Marker_key = @newKey and source = 2
66> end
67> else if @newMIT is null and @oldMIT is not null
68> begin
69>   insert MRK_Offset (_Marker_key, source, offset) values(@newKey, 2, @oldMIT)
70> end
71> 
72> commit transaction
73> 
1> 
2> grant execute on MRK_updateOffset to djr, ljm, rmb
1> 
2> grant execute on MRK_updateOffset to progs
1> 
2> drop procedure MRK_simpleWithdrawal
1> 
2> create procedure MRK_simpleWithdrawal
3> 	@oldKey integer,
4> 	@refKey integer,
5> 	@eventReasonKey integer,
6> 	@newSymbol varchar(25),
7> 	@newName varchar(255)
8> as
9> 
10> /*
11>  * This procedure will process a simple marker withdrawal.
12>  * A simple marker withdrawal requires:
13>  *	a) the "old" marker key
14>  *	b) the reference key
15>  *	c) the event reason key
16>  *	c) the "new" marker symbol which does not already exist
17>  *	d) the "new" marker name
18>  *
19>  * Since the server is not case-sensitive, the caller is
20>  * responsible for making sure the new symbol is unique and correct.
21>  *
22> */
23> 
24> begin transaction
25> 
26> declare @oldSymbol varchar(25)
27> declare @oldName varchar(255)
28> select @oldSymbol = symbol,
29>        @oldName = name 
30> from MRK_Marker where _Marker_key = @oldKey 
31>      and _Species_key = 1
32>      and _Marker_Status_key = 1
33> 
34> if @oldSymbol is null
35> begin
36> 	raiserror 99999 "Invalid Old Symbol Key %1!", @oldKey
37> 	rollback transaction
38> 	return
39> end
40> 
41> declare @withdrawnName varchar(255)
42> select @withdrawnName = "withdrawn, = " + @newSymbol
43> 
44> /* Create a new marker record using the old marker record as the template */
45> 
46> declare @newKey integer
47> select @newKey = max(_Marker_key) + 1 from MRK_Marker
48> 
49> insert into MRK_Marker 
50> (_Marker_key, _Species_key, _Marker_Type_key, _Marker_Status_key, symbol, name, chromosome)
51> select @newKey, _Species_key, _Marker_Type_key, 2, symbol, @withdrawnName, chromosome
52> from MRK_Marker
53> where _Marker_key = @oldKey
54> 
55> if @@error != 0
56> begin
57> 	raiserror 99999 "Could not add marker in MRK_simpleWithdrawal"
58> 	rollback transaction
59> 	return
60> end
61> 
62> /* Remove the MGI Accession ID that was created during the insert */
63> /* We don't need this Accession ID */
64> delete from ACC_Accession where _MGIType_key = 2 and _Object_key = @newKey
65> 
66> if @@error != 0
67> begin
68> 	raiserror 99999 "Could not delete MGI Accession ID in MRK_simpleWithdrawal"
69> 	rollback transaction
70> 	return
71> end
72> 
73> /* Create Offset for new marker */
74> insert into MRK_Offset values(@newKey, 0, -999.0, getdate(), getdate())
75> 
76> if @@error != 0
77> begin
78> 	raiserror 99999 "Could not add offset in MRK_simpleWithdrawal"
79> 	rollback transaction
80> 	return
81> end
82> 
83> /* Update the Current marker of the new marker */
84> update MRK_Current set _Current_key = @oldKey where _Marker_key = @newKey
85> 
86> if @@error != 0
87> begin
88> 	raiserror 99999 "Could not update current in MRK_simpleWithdrawal"
89> 	rollback transaction
90> 	return
91> end
92> 
93> /* Update old marker record with new symbol and name values */
94> update MRK_Marker 
95> set symbol = @newSymbol, name = @newName
96> where _Marker_key = @oldKey
97> 
98> if @@error != 0
99> begin
100> 	raiserror 99999 "Could not update marker in MRK_simpleWithdrawal"
101> 	rollback transaction
102> 	return
103> end
104> 
105> /* Update history lines */
106> update MRK_History set _History_key = @newKey where _Marker_key = @oldKey
107> and _History_key = @oldKey
108> 
109> if @@error != 0
110> begin
111> 	raiserror 99999 "Could not update history in MRK_simpleWithdrawal"
112> 	rollback transaction
113> 	return
114> end
115> 
116> /* Add History line for withdrawal */
117> exec MRK_insertHistory @oldKey, @newKey, @refKey, 2, @eventReasonKey, @oldName
118> 
119> if @@error != 0
120> begin
121> 	raiserror 99999 "Could not add history in MRK_simpleWithdrawal"
122> 	rollback transaction
123> 	return
124> end
125> 
126> /* Add History line for assignment */
127> exec MRK_insertHistory @oldKey, @oldKey, @refKey, 1, @eventReasonKey, @newName
128> 
129> if @@error != 0
130> begin
131> 	raiserror 99999 "Could not add history in MRK_simpleWithdrawal"
132> 	rollback transaction
133> 	return
134> end
135> 
136> /* Convert alleles */
137> exec ALL_convertAllele @oldKey, @oldSymbol, @newSymbol
138> 
139> if @@error != 0
140> begin
141> 	raiserror 99999 "Could not convert alleles in MRK_simpleWithdrawal"
142> 	rollback transaction
143> 	return
144> end
145> 
146> /* Re-load labels */
147> 
148> exec MRK_reloadLabel @oldKey
149> 
150> if @@error != 0
151> begin
152> 	raiserror 99999 "Could not reload Labels."
153> 	rollback transaction
154> 	return
155> end
156> 
157> /* Re-load labels */
158> 
159> exec MRK_reloadReference @oldKey
160> 
161> if @@error != 0
162> begin
163> 	raiserror 99999 "Could not reload References."
164> 	rollback transaction
165> 	return
166> end
167> 
168> commit transaction
169> 
1> 
2> grant execute on MRK_simpleWithdrawal to djr, ljm, rmb
1> 
2> grant execute on MRK_simpleWithdrawal to progs
1> 
2> drop procedure MRK_mergeWithdrawal
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRK_mergeWithdrawal', because it doesn't exist in the
system catalogs.
1> 
2> create procedure MRK_mergeWithdrawal
3> 	@oldKey integer,
4> 	@newKey integer,
5> 	@refKey integer,
6> 	@eventKey integer,
7> 	@eventReasonKey integer
8> as
9> 
10> /*
11>  * This procedure will process a merge marker withdrawal.
12>  * A merge withdrawal is a withdrawal where both the "old" and "new"
13>  * markers already exist in the database.
14>  *
15>  * A merge marker withdrawal requires:
16>  *	a) the "old" marker key
17>  *	b) the "new" marker key
18>  *	c) the reference key
19>  *	d) the event key
20>  *	e) the event reason key
21>  *
22>  * Caller must still run symbolchg.py for MLC updates.
23> */
24> 
25> begin transaction
26> 
27> declare @oldSymbol varchar(25)
28> declare @oldName varchar(255)
29> select @oldSymbol = symbol,
30>        @oldName = name 
31> from MRK_Marker where _Marker_key = @oldKey
32>      and _Species_key = 1
33>      and _Marker_Status_key = 1
34> 
35> if @oldSymbol is null
36> begin
37> 	raiserror 99999 "Invalid Old Symbol Key %1!", @oldKey
38> 	rollback transaction
39> 	return
40> end
41> 
42> declare @newSymbol varchar(25)
43> select @newSymbol = symbol
44> from MRK_Marker where _Marker_key = @newKey
45>      and _Species_key = 1
46>      and _Marker_Status_key = 1
47> 
48> if @newSymbol is null
49> begin
50> 	raiserror 99999 "Invalid New Symbol Key %1!", @newKey
51> 	rollback transaction
52> 	return
53> end
54> 
55> declare @withdrawnName varchar(255)
56> declare @alleleOf integer
57> 
58> if @eventKey = 4
59> begin
60> 	select @withdrawnName = "withdrawn, allele of " + @newSymbol
61> 	select @alleleOf = 1
62> end
63> else
64> begin
65> 	select @withdrawnName = "withdrawn, = " + @newSymbol
66> 	select @alleleOf = 0
67> end
68> 
69> /* If new symbol has a chromosome of UN, update the new symbol's chromosome value */
70> /* with the old symbol chromosome value */
71> 
72> if (select chromosome from MRK_Marker where _Marker_key = @newKey) = "UN"
73> begin
74> 	declare @newChr char(8)
75> 	select @newChr = chromosome from MRK_Marker where _Marker_key = @oldKey
76> 	update MRK_Marker set chromosome = @newChr where _Marker_key = @newKey
77> 
78> 	if @@error != 0
79> 	begin
80> 		raiserror 99999 "Could not update new symbol's chromosome in MRK_mergeWithdrawal"
81> 		rollback transaction
82> 		return
83> 	end
84> end
85> 
86> /* Update offset values of new symbol */
87> 
88> exec MRK_updateOffset @oldKey, @newKey
89> 
90> if @@error != 0
91> begin
92> 	raiserror 99999 "Could not update offset values in MRK_mergeWithdrawal"
93> 	rollback transaction
94> 	return
95> end
96> 
97> /* Update MGD offset of old symbol */
98> 
99> update MRK_Offset set offset = -999.0 where _Marker_key = @oldKey and source = 0
100> 
101> if @@error != 0
102> begin
103> 	raiserror 99999 "Could not update offset of old symbol in MRK_mergeWithdrawal"
104> 	rollback transaction
105> 	return
106> end
107> 
108> /* Delete remaining offsets of old symbol */
109> 
110> delete MRK_Offset where _Marker_key = @oldKey and source > 0
111> 
112> if @@error != 0
113> begin
114> 	raiserror 99999 "Could not delete offsets of old symbol in MRK_mergeWithdrawal"
115> 	rollback transaction
116> 	return
117> end
118> 
119> /* Update name/cytogenetic offset of old symbol */
120> 
121> update MRK_Marker 
122> set name = @withdrawnName, cytogeneticOffset = null, _Marker_Status_key = 2
123> where _Marker_key = @oldKey
124> 
125> if @@error != 0
126> begin
127> 	raiserror 99999 "Could not update name of old symbol in MRK_mergeWithdrawal"
128> 	rollback transaction
129> 	return
130> end
131> 
132> /* Convert Alleles */
133> 
134> exec ALL_convertAllele @oldKey, @oldSymbol, @newSymbol, @alleleOf
135> 
136> if @@error != 0
137> begin
138> 	raiserror 99999 "Could not convert alleles in MRK_mergeWithdrawal"
139> 	rollback transaction
140> 	return
141> end
142> 
143> if @alleleOf = 1
144> begin
145> 	/* If no alleles exist for the old symbol, create a newSymbol<oldSymbol> allele */
146> 
147> 	if not exists (select 1 from ALL_Allele where _Marker_key = @oldKey)
148> 	begin
149> 		declare @alleleSymbol varchar(50)
150> 		select @alleleSymbol = @newSymbol + "<" + @oldSymbol + ">"
151> 
152> 		exec ALL_insertAllele @newKey,@refKey,@alleleSymbol,@oldName,null,null,-1,-1,-1,0,@oldSymbol
153> 
154> 		if @@error != 0
155> 		begin
156> 			raiserror 99999 "Could not insert allele in MRK_mergeWithdrawal"
157> 			rollback transaction
158> 			return
159> 		end
160> 	end
161> end
162> 
163> /* Update current symbols */
164> 
165> update MRK_Current set _Current_key = @newKey where _Current_key = @oldKey
166> 
167> if @@error != 0
168> begin
169> 	raiserror 99999 "Could not update current symbols in MRK_mergeWithdrawal"
170> 	rollback transaction
171> 	return
172> end
173> 
174> /* Copy History records from old symbol to new symbol */
175> 
176> exec MRK_copyHistory @oldKey, @newKey
177> 
178> if @@error != 0
179> begin
180> 	raiserror 99999 "Could not copy history records in MRK_mergeWithdrawal"
181> 	rollback transaction
182> 	return
183> end
184> 
185> /* Insert history record for withdrawal */
186> 
187> exec MRK_insertHistory @newKey, @oldKey, @refKey, @eventKey, @eventReasonKey, @oldName
188> 
189> if @@error != 0
190> begin
191> 	raiserror 99999 "Could not create history record in MRK_mergeWithdrawal"
192> 	rollback transaction
193> 	return
194> end
195> 
196> /* Remove history records from old symbol */
197> 
198> delete from MRK_History where _Marker_key = @oldKey
199> 
200> if @@error != 0
201> begin
202> 	raiserror 99999 "Could not delete obsolete history records in MRK_mergeWithdrawal"
203> 	rollback transaction
204> 	return
205> end
206> 
207> /* Update keys from old key to new key */
208> 
209> exec MRK_updateKeys @oldKey, @newKey
210> 
211> if @@error != 0
212> begin
213> 	raiserror 99999 "Could not update keys in MRK_mergeWithdrawal"
214> 	rollback transaction
215> 	return
216> end
217> 
218> commit transaction
219> 
1> 
2> grant execute on MRK_mergeWithdrawal to djr, ljm, rmb
1> 
2> grant execute on MRK_mergeWithdrawal to progs
1> 
2> drop procedure MRK_alleleWithdrawal
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRK_alleleWithdrawal', because it doesn't exist in
the system catalogs.
1> 
2> create procedure MRK_alleleWithdrawal
3> 	@oldKey integer,
4> 	@newKey integer,
5> 	@refKey integer,
6> 	@eventReasonKey integer
7> as
8> 
9> /*
10>  * This procedure will process an allele marker withdrawal.
11>  *
12>  * An allele marker withdrawal requires:
13>  *	a) the "old" marker key
14>  *	b) the "new" marker key
15>  *	c) the reference key
16>  *	d) the event reason key
17>  *
18> */
19> 
20> begin transaction
21> 
22> declare @oldSymbol varchar(25)
23> declare @oldName varchar(255)
24> select @oldSymbol = symbol,
25>        @oldName = name 
26> from MRK_Marker where _Marker_key = @oldKey
27>      and _Species_key = 1
28>      and _Marker_Status_key = 1
29> 
30> if @oldSymbol is null
31> begin
32> 	raiserror 99999 "Invalid Old Symbol Key %1!", @oldKey
33> 	rollback transaction
34> 	return
35> end
36> 
37> declare @newSymbol varchar(25)
38> select @newSymbol = symbol
39> from MRK_Marker where _Marker_key = @newKey
40>      and _Species_key = 1
41>      and _Marker_Status_key = 1
42> 
43> if @newSymbol is null
44> begin
45> 	raiserror 99999 "Invalid New Symbol Key %1!", @newKey
46> 	rollback transaction
47> 	return
48> end
49> 
50> exec MRK_mergeWithdrawal @oldKey, @newKey, @refKey, 4, @eventReasonKey
51> 
52> if @@error != 0
53> begin
54> 	raiserror 99999 "Could not execute allele withdrawal call to merge withdrawal"
55> 	rollback transaction
56> 	return
57> end
58> 
59> commit transaction
60> 
1> 
2> grant execute on MRK_alleleWithdrawal to djr, ljm, rmb
1> 
2> grant execute on MRK_alleleWithdrawal to progs
1> 
2> drop procedure MRK_splitWithdrawal
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRK_splitWithdrawal', because it doesn't exist in the
system catalogs.
1> 
2> create procedure MRK_splitWithdrawal
3>         @oldKey integer,
4>         @refKey integer,
5> 	@eventReasonKey integer,
6>         @newSymbols varchar(255) /* list of new symbols separated by commas */
7> as
8> 
9> /* In a split, none of the new symbols are expected to exist in the database */
10> /*
11>  * This procedure will process a split marker withdrawal.
12>  * A split withdrawal is a withdrawal where there are more than
13>  * one "new" markers and none of the new markers exist in the database.
14>  *
15>  * A split marker withdrawal requires:
16>  *	a) the "old" marker key
17>  *	b) a list of comma-separated new symbols (ex. "new-1,new-2,new-3")
18>  *	c) the reference key
19>  *
20>  * Other data (mapping, homology, etc.) associated with the "split" marker
21>  * remains with the split marker and must be manually moved to one of the
22>  * new markers.
23>  *
24>  * MLC changes must also be done manually.
25>  *
26> */
27> 
28> 
29> begin transaction
30> 
31> declare @oldName varchar(255)
32> select @oldName = name 
33> from MRK_Marker where _Marker_key = @oldKey
34>      and _Species_key = 1
35>      and _Marker_Status_key = 1
36> 
37> if @oldName is null
38> begin
39> 	raiserror 99999 "Invalid Old Symbol Key %1!", @oldKey
40> 	rollback transaction
41> 	return
42> end
43> 
44> declare @withdrawnName varchar(255)
45> select @withdrawnName = "withdrawn, = " + substring(@newSymbols, 1, char_length(@newSymbols) - 1)
46> 
47> /* Remove all current markers for old key;  these will be replaced by the new symbols */
48> 
49> delete from MRK_Current where _Marker_key = @oldKey
50> 
51> if @@error != 0
52> begin
53> 	raiserror 99999 "Could not delete current symbols in MRK_splitWithdrawal"
54> 	rollback transaction
55> 	return
56> end
57> 
58> /* For each new marker:
59>  *
60>  *	a.  add the new marker record
61>  *	a.  transfer the offset values of the old marker to the new marker
62>  *	b.  set the new key as one of the current keys of the old symbol
63>  *	c.  copy the old symbol's history to the new marker
64>  *	d.  insert the assignment history line for the new marker
65> */
66> 
67> declare @newKey integer
68> declare @newSymbol varchar(25)
69> declare @idx integer
70> 
71> while (@newSymbols != null)
72> begin
73> 	select @idx = charindex(",", @newSymbols)
74> 
75> 	if @idx > 0
76> 	begin
77> 		select @newSymbol = substring(@newSymbols, 1, @idx - 1)
78> 		select @newSymbols = substring(@newSymbols, @idx + 1, char_length(@newSymbols))
79> 	end
80> 	else
81> 	begin
82> 		/* at end of list of @newSymbols */
83> 		select @newSymbol = @newSymbols
84> 		select @newSymbols = ""
85> 	end
86> 
87> 	if @newSymbol != null
88> 	begin
89> 		select @newKey = max(_Marker_key) + 1 from MRK_Marker
90> 
91> 		/* during a split, each new marker is created and gets a new MGI accession number */
92> 		/* the original MGI accession number stays associated with the split marker */
93> 
94> 		insert into MRK_Marker 
95> 		(_Marker_key, _Species_key, _Marker_Type_key, _Marker_Status_key, symbol, name, chromosome)
96> 		select @newKey, _Species_key, _Marker_Type_key, 1, @newSymbol, name, chromosome
97> 		from MRK_Marker
98> 		where _Marker_key = @oldKey
99> 
100> 		if @@error != 0
101> 		begin
102> 			raiserror 99999 "Could not add marker %1! in MRK_splitWithdrawal", @newSymbol
103> 			rollback transaction
104> 			return
105> 		end
106> 
107> 		/* create MGD offset record for new Marker.  */
108> 
109> 		insert into MRK_Offset
110> 		(_Marker_key, source, offset)
111> 		select @newKey, source, offset
112> 		from MRK_Offset
113> 		where _Marker_key = @oldKey
114> 		and source = 0
115> 
116> 		if @@error != 0
117> 		begin
118> 			raiserror 99999 "Could not add marker offset in MRK_splitWithdrawal"
119> 			rollback transaction
120> 			return
121> 		end
122> 
123> 		/* update Marker offsets of new symbol */
124> 
125> 		exec MRK_updateOffset @oldKey, @newKey
126> 
127> 		if @@error != 0
128> 		begin
129> 			raiserror 99999 "Could not update marker offsets in MRK_splitWithdrawal"
130> 			rollback transaction
131> 			return
132> 		end
133> 
134> 		insert MRK_Current (_Current_key, _Marker_key) values (@newKey, @oldKey)
135> 
136> 		if @@error != 0
137> 		begin
138> 			raiserror 99999 "Could not add current marker in MRK_splitWithdrawal"
139> 			rollback transaction
140> 			return
141> 		end
142> 
143> 		exec MRK_copyHistory @oldKey, @newKey
144> 
145> 		if @@error != 0
146> 		begin
147> 			raiserror 99999 "Could not copy history in MRK_splitWithdrawal"
148> 			rollback transaction
149> 			return
150> 		end
151> 
152> 		exec MRK_insertHistory @newKey, @oldKey, @refKey, 5, @eventReasonKey, @oldName
153> 
154> 		if @@error != 0
155> 		begin
156> 			raiserror 99999 "Could not insert history in MRK_splitWithdrawal"
157> 			rollback transaction
158> 			return
159> 		end
160> 
161> 		/* Add History line for assignment */
162> 		exec MRK_insertHistory @newKey, @newKey, @refKey, 1, @eventReasonKey, @oldName
163> 
164> 		if @@error != 0
165> 		begin
166> 			raiserror 99999 "Could not insert history in MRK_splitWithdrawal"
167> 			rollback transaction
168> 			return
169> 		end
170> 	end
171> end
172> 
173> /* Now make the final necessary modifications to the old symbol */
174> 
175> update MRK_Offset set offset = -999.0 where _Marker_key = @oldKey and source = 0
176> 
177> if @@error != 0
178> begin
179> 	raiserror 99999 "Could not update marker offset in MRK_splitWithdrawal"
180> 	rollback transaction
181> 	return
182> end
183> 
184> delete from MRK_Offset where _Marker_key = @oldKey and source > 0
185> 
186> if @@error != 0
187> begin
188> 	raiserror 99999 "Could not delete marker offsets in MRK_splitWithdrawal"
189> 	rollback transaction
190> 	return
191> end
192> 
193> update MRK_Marker
194> set name = @withdrawnName, cytogeneticOffset = null, _Marker_Status_key = 2
195> where _Marker_key = @oldKey
196> 
197> if @@error != 0
198> begin
199> 	raiserror 99999 "Could not update marker in MRK_splitWithdrawal"
200> 	rollback transaction
201> 	return
202> end
203> 
204> delete from MRK_History where _Marker_key = @oldKey
205> 
206> if @@error != 0
207> begin
208> 	raiserror 99999 "Could not delete obsolete history in MRK_splitWithdrawal"
209> 	rollback transaction
210> 	return
211> end
212> 
213> /* Re-load labels */
214> 
215> exec MRK_reloadLabel @oldKey
216> 
217> if @@error != 0
218> begin
219> 	raiserror 99999 "Could not reload Labels."
220> 	rollback transaction
221> 	return
222> end
223> 
224> /* Re-load labels */
225> 
226> exec MRK_reloadReference @oldKey
227> 
228> if @@error != 0
229> begin
230> 	raiserror 99999 "Could not reload References."
231> 	rollback transaction
232> 	return
233> end
234> 
235> commit transaction
236> 
1> 
2> grant execute on MRK_splitWithdrawal to djr, ljm, rmb
1> 
2> grant execute on MRK_splitWithdrawal to progs
1> 
2> drop procedure MRK_deleteWithdrawal
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRK_deleteWithdrawal', because it doesn't exist in
the system catalogs.
1> 
2> create procedure MRK_deleteWithdrawal
3> 	@oldKey integer,
4> 	@refKey integer,
5> 	@eventReasonKey integer
6> as
7> 
8> /*
9>  * This procedure will process a delete withdrawal.
10>  * A delete marker withdrawal requires:
11>  *	a) the "old" marker key
12>  *	b) a reference key
13>  *
14> */
15> 
16> declare @oldSymbol varchar(25)
17> declare @oldName varchar(255)
18> select @oldSymbol = symbol,
19>        @oldName = name 
20> from MRK_Marker where _Marker_key = @oldKey 
21>      and _Species_key = 1
22>      and _Marker_Status_key = 1
23> 
24> if @oldSymbol is null
25> begin
26> 	raiserror 99999 "Invalid Old Symbol Key %1!", @oldKey
27> 	rollback transaction
28> 	return
29> end
30> 
31> /* Update MGD offset of old symbol */
32> 
33> update MRK_Offset set offset = -999.0 where _Marker_key = @oldKey and source = 0
34> 
35> if @@error != 0
36> begin
37> 	raiserror 99999 "Could not update offset of old symbol in MRK_deleteWithdrawal"
38> 	rollback transaction
39> 	return
40> end
41> 
42> /* Update Marker info */
43> 
44> update MRK_Marker
45> set name = "withdrawn", _Marker_Status_key = 2
46> where _Marker_key = @oldKey
47> 
48> if @@error != 0
49> begin
50> 	raiserror 99999 "Could not update marker in MRK_deleteWithdrawal"
51> 	rollback transaction
52> 	return
53> end
54> 
55> /* Add History line for withdrawal */
56> exec MRK_insertHistory @oldKey, @oldKey, @refKey, 6, @eventReasonKey, @oldName
57> 
58> if @@error != 0
59> begin
60> 	raiserror 99999 "Could not add history in MRK_deleteWithdrawal"
61> 	rollback transaction
62> 	return
63> end
64> 
1> 
2> grant execute on MRK_deleteWithdrawal to djr, ljm, rmb
1> 
2> grant execute on MRK_deleteWithdrawal to progs
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop procedure PRB_getStrainReferences
1>  
2> create procedure PRB_getStrainReferences
3>   @strainKey int,
4>   @countOnly int = 0
5> as
6> 
7> /* Select all References and Data Sets for given Strain */
8>  
9> select distinct e._Refs_key, dataSet = 'Mapping'
10> into #references
11> from MLD_Expts e, MLD_InSitu m
12> where e._Expt_key = m._Expt_key
13> and m._Strain_key = @strainKey
14> union
15> select distinct e._Refs_key, dataSet = 'Mapping'
16> from MLD_Expts e, MLD_FISH m
17> where e._Expt_key = m._Expt_key
18> and m._Strain_key = @strainKey
19> union
20> select distinct e._Refs_key, dataSet = 'Mapping'
21> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
22> where e._Expt_key = m._Expt_key
23> and m._Cross_key = c._Cross_key
24> and c._femaleStrain_key = @strainKey
25> union
26> select distinct e._Refs_key, dataSet = 'Mapping'
27> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
28> where e._Expt_key = m._Expt_key
29> and m._Cross_key = c._Cross_key
30> and c._maleStrain_key = @strainKey
31> union
32> select distinct e._Refs_key, dataSet = 'Mapping'
33> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
34> where e._Expt_key = m._Expt_key
35> and m._Cross_key = c._Cross_key
36> and c._StrainHO_key = @strainKey
37> union
38> select distinct e._Refs_key, dataSet = 'Mapping'
39> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
40> where e._Expt_key = m._Expt_key
41> and m._Cross_key = c._Cross_key
42> and c._StrainHT_key = @strainKey
43> union
44> select distinct a._Refs_key, dataSet = 'Expression'
45> from GXD_Genotype s, GXD_Expression x, GXD_Assay a
46> where s._Strain_key = @strainKey
47> and s._Genotype_key = x._Genotype_key
48> and x._Assay_key = a._Assay_key
49> union
50> select distinct r._Refs_key, dataSet = 'RFLP'
51> from PRB_Reference r, PRB_RFLV v, PRB_Allele a, PRB_Allele_Strain s
52> where r._Reference_key = v._Reference_key
53> and v._RFLV_key = a._RFLV_key
54> and a._Allele_key = s._Allele_key
55> and s._Strain_key = @strainKey
56> union
57> select distinct _Refs_key, dataSet = 'Allele'
58> from ALL_Allele
59> where _Strain_key = @strainKey
60>  
61> if @countOnly = 1
62> begin
63> 	select count(*) from #references
64> end
65> else
66> begin
67> 	select a.jnumID, r.dataSet
68> 	from #references r, BIB_View a
69> 	where r._Refs_key = a._Refs_key
70> 	order by a.jnum
71> end
72> 
1> 
2> grant execute on PRB_getStrainReferences to public
1>  
2> drop procedure PRB_getStrainDataSets
1>  
2> create procedure PRB_getStrainDataSets
3>   @strainKey int,
4>   @countOnly int = 0
5> as
6> 
7> /* Select all Probes and Data Sets for given Strain */
8>  
9> select _Source_key, _Strain_key
10> into #source from PRB_Source
11> where _Strain_key = @strainKey
12> order by _Source_key
13> 
14> if (select count(*) from #source) = 0
15> begin
16> 	return
17> end
18> 
19> create unique clustered index index_Source_key on #source(_Source_key) with sorted_data
20> 
21> select p._Probe_key, dataSet = 'Molecular Segment'
22> into #probes
23> from PRB_Probe p, #source s
24> where p._Source_key = s._Source_key
25> union
26> select a._Antigen_key, dataSet = 'Antigen'
27> from GXD_Antigen a, #source s
28> where a._Source_key = s._Source_key
29> union
30> select a._Allele_key, dataSet = 'Allele'
31> from ALL_Allele a, #source s
32> where a._Strain_key = s._Strain_key
33> 
34> 
35> if @countOnly = 1
36> begin
37> 	select count(*) from #probes
38> end
39> else
40> begin
41> 	select a.accID, p.dataSet
42> 	from #probes p, PRB_Acc_View a
43> 	where p.dataSet = 'Molecular Segment'
44> 	and p._Probe_key = a._Object_key
45> 	and a.prefixPart = 'MGI:'
46> 	and a.preferred = 1
47> 	union
48> 	select a.accID, p.dataSet
49> 	from #probes p, GXD_Antigen_Acc_View a
50> 	where p.dataSet = 'Antigen'
51> 	and p._Probe_key = a._Object_key
52> 	and a.prefixPart = 'MGI:'
53> 	and a.preferred = 1
54> 	union
55> 	select a.accID, p.dataset
56> 	from #probes p, ALL_Acc_View a
57> 	where p.dataSet = 'Allele'
58> 	and a.prefixPart = 'MGI:'
59> 	and a.preferred = 1
60> 	order by a.accID
61> end
62> 
1> 
2> grant execute on PRB_getStrainDataSets to public
1>  
2> drop procedure PRB_mergeTissue
1>  
2> create procedure PRB_mergeTissue
3>   @oldTissueKey int,
4>   @newTissueKey int
5> as
6> 
7> /*
8>  * Update old Tissue key to new Tissue key
9>  * in all relevant tables which contain a Tissue key.
10>  * When finished, remove the Tissue record for the old
11>  * Tissue key.
12> */
13> 
14> update PRB_Source
15> set _Tissue_key = @newTissueKey
16> where _Tissue_key = @oldTissueKey
17> 
18> delete from PRB_Tissue
19> where _Tissue_key = @oldTissueKey
20> 
1> 
2> grant execute on PRB_mergeTissue to editors
1>  
2> grant execute on PRB_mergeTissue to progs
1>  
2> drop procedure PRB_mergeStandardTissue
1>  
2> create procedure PRB_mergeStandardTissue
3>   @tissue varchar(255),
4>   @fromStandard int = 0,
5>   @toStandard int = 1
6> as
7>  
8> /* Given a Tissue, merge all of the records into one Tissue.
9>  *
10>  * Merge all Non-Standard Tissues into the Standard Tissue (default)
11>  * (exec PRB_mergeStandardTissue "Tissue")
12>  *
13>  * OR
14>  *
15>  * Merge all Standard Tissues into the Non-Standard Tissue
16>  * (exec PRB_mergeStandardTissue "Tissue", 1, 0)
17>  *
18> */
19> 
20> declare @newTissueKey integer
21> declare @oldTissueKey integer
22> 
23> if (select count(_Tissue_key) from PRB_Tissue
24>     where tissue = @tissue and standard = @toStandard) > 1
25> begin
26> 	rollback transaction
27> 	raiserror 99999 "More than one designation exists for Tissue: %1!", @tissue
28> 	return
29> end
30> 
31> if (select count(_Tissue_key) from PRB_Tissue
32>     where tissue = @tissue and standard = @toStandard) = 0
33> begin
34> 	rollback transaction
35> 	raiserror 99999 "No correct designation exists for Tissue: %1!", @tissue
36> 	return
37> end
38> 
39> select @newTissueKey = _Tissue_key from PRB_Tissue
40> where tissue = @tissue and standard = @toStandard
41> 
42> declare tissue_cursor cursor for
43> select _Tissue_key
44> from PRB_Tissue
45> where tissue = @tissue and standard = @fromStandard
46> for read only
47>  
48> open tissue_cursor
49>  
50> fetch tissue_cursor into @oldTissueKey
51>  
52> while (@@sqlstatus = 0)
53> begin
54> 	exec PRB_mergeTissue @oldTissueKey, @newTissueKey
55>         fetch tissue_cursor into @oldTissueKey
56> end
57>  
58> close tissue_cursor
59>  
60> deallocate cursor tissue_cursor
61>  
1> 
2> grant execute on PRB_mergeStandardTissue to editors
1>  
2> grant execute on PRB_mergeStandardTissue to progs
1>  
2> drop procedure PRB_getTissueDataSets
1>  
2> create procedure PRB_getTissueDataSets
3>   @tissueKey int,
4>   @countOnly int = 0
5> as
6> 
7> /* Select all Data Sets for given Tissue */
8>  
9> select _Source_key into #source from PRB_Source
10> where _Tissue_key = @tissueKey
11> order by _Source_key
12> 
13> if (select count(*) from #source) = 0
14> begin
15> 	return
16> end
17> 
18> create unique clustered index index_Source_key on #source(_Source_key) with sorted_data
19> 
20> select dataKey = p._Probe_key, dataSet = 'Molecular Segment'
21> into #datasets
22> from PRB_Probe p, #source s
23> where p._Source_key = s._Source_key
24> union
25> select dataKey = a._Antigen_key, dataSet = 'Antigen'
26> from GXD_Antigen a, #source s
27> where a._Source_key = s._Source_key
28> 
29> if @countOnly = 1
30> begin
31> 	select count(*) from #datasets
32> end
33> else
34> begin
35> 	select a.accID, d.dataSet, a.numericPart
36> 	from #datasets d, PRB_Acc_View a
37> 	where d.datakey = a._Object_key
38> 	and a.prefixPart = 'MGI:'
39> 	and a.preferred = 1
40> 	union
41> 	select a.accID, d.dataSet, a.numericPart
42> 	from #datasets d, GXD_Antigen_Acc_View a
43> 	where d.datakey = a._Object_key
44> 	and a.prefixPart = 'MGI:'
45> 	and a.preferred = 1
46> 	order by a.numericPart
47> end
48> 
1> 
2> grant execute on PRB_getTissueDataSets to public
1>  
2> checkpoint
1> 
2> drop procedure PRB_insertReference
1> 
2> create procedure PRB_insertReference
3> 	@refKey integer,
4> 	@probeKey integer,
5> 	@holder varchar(40)
6> as
7> 
8> /* Insert record into PRB_Reference if _Refs_key/_Probe_key pair does not already exist */
9> 
10> if (select count(*) from PRB_Reference 
11> 	where _Refs_key = @refKey and _Probe_key = @probeKey) > 0
12> begin
13> 	return
14> end
15> 
16> declare @maxReferenceKey integer
17> select @maxReferenceKey = max(_Reference_key) + 1 from PRB_Reference
18> 
19> insert into PRB_Reference
20> values (@maxReferenceKey, @probeKey, @refKey, @holder, 0, 0, getdate(), getdate())
21> 
1> 
2> grant execute on PRB_insertReference to editors
1> 
2> grant execute on PRB_insertReference to progs
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> /* obsolete procedures */
3> 
4> drop procedure MRK_insertAllele
Msg 3701, Level 11, State 1:
Line 4:
Cannot drop the procedure 'MRK_insertAllele', because it doesn't exist in the
system catalogs.
1> 
2> drop procedure MRK_mergeAllele
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRK_mergeAllele', because it doesn't exist in the
system catalogs.
1> 
2> /* end obsolete procedures */
3> 
4> drop procedure MRK_insertHistory
1>  
2> create procedure MRK_insertHistory
3>   @markerKey integer,
4>   @historyKey integer,
5>   @refKey integer,
6>   @eventKey integer,
7>   @eventReasonKey integer,
8>   @name varchar(255) = null,
9>   @event_date datetime = null
10> as
11>  
12> /* Insert new History record into MRK_History */
13>  
14> declare @maxSeq int
15> select @maxSeq = max(sequenceNum) from MRK_History where _Marker_key = @markerKey
16> 
17> if @maxSeq is null
18> begin
19> 	select @maxSeq = 0
20> end
21> 
22> if @event_date is null
23> begin
24> 	select @event_date = getdate()
25> end
26>  
27> insert MRK_History 
28> (_Marker_key, _History_key, _Refs_key, _Marker_Event_key, _Marker_EventReason_key, sequenceNum, name, event_date)
29> values(@markerKey, @historyKey, @refKey, @eventKey, @eventReasonKey, @maxSeq + 1, @name, @event_date)
30> 
1>  
2> grant execute on MRK_insertHistory to djr, ljm, rmb
1>  
2> grant execute on MRK_insertHistory to progs
1>  
2> drop procedure MRK_MaxOffset
1> 
2> create procedure MRK_MaxOffset
3> 	@chromosome varchar(2),
4> 	@source int 
5> as
6> 
7> select maxOffset = max(o.offset)
8> from MRK_Offset o, MRK_Marker m
9> where o._Marker_key = m._Marker_key
10> and o.source = @source 
11> and m.chromosome = @chromosome 
12> and m._Species_key = 1
13> 
1> 
2> grant execute on MRK_MaxOffset to public
1> 
2> drop procedure MRK_MiniMapMarkers
1> 
2> create procedure MRK_MiniMapMarkers
3> 	@_Marker_key int,
4> 	@source int 
5> as
6> 
7> /* retrieve data for all anchor markers on the chromosome */
8> 
9> select distinct m._Marker_key, m.symbol, m.name, m.chromosome, o.offset, m.cytogeneticOffset
10> from MRK_Marker m, MRK_Offset o, MRK_Anchors a
11> where m._Marker_key = a._Marker_key
12> 	and o.source = @source
13> 	and o._Marker_key = m._Marker_key
14> 	and o.offset > -1.0
15> 	and a.chromosome = (select m.chromosome 
16> 	from MRK_Marker m
17> 	where m._Marker_key = @_Marker_key)
18> 
19> union
20> 
21> /* get the data for the marker itself */
22> 
23> select distinct m._Marker_key, m.symbol, m.name, m.chromosome, o.offset, m.cytogeneticOffset
24> from MRK_Marker m, MRK_Offset o
25> where m._Marker_key = @_Marker_key
26> 	and o.source = @source
27> 	and o._Marker_key = m._Marker_key
28> 	and o.offset > -1.0
1> 
2> grant execute on MRK_MiniMapMarkers to public
1> 
2> drop procedure MRK_isAnchor
1>  
2> create procedure MRK_isAnchor
3>   @key int
4> as
5> 
6> /* Determine if Marker key exists in MRK_Anchors table */
7> 
8> declare @found int
9> select @found = count(*) from MRK_Anchors where _Marker_key = @key
10> select @found
11> 
1> 
2> grant execute on MRK_isAnchor to public
1>  
2> drop procedure MRK_breakpointSplit
1> 
2> create procedure MRK_breakpointSplit
3>   @markerKey integer,
4>   @distalCytoBand varchar(20) = null
5> as
6> 
7> /* See TR#120; procedure to split cytogenetic marker into 2 distinct markers */
8> 
9> declare @band varchar(20)
10> declare @symbol varchar(25)
11> declare @name varchar(255)
12> declare @markerType integer
13> declare @idx integer
14> 
15> select @symbol = symbol, @band = cytogeneticOffset, @name = name, @markerType = _Marker_Type_key
16> from MRK_Marker where _Marker_key = @markerKey
17> 
18> if @markerType != 3
19> begin
20> 	rollback transaction
21> 	raiserror 99999 "Invalid Marker for Breakpoint Split: %1!", @symbol
22> 	return
23> end
24> 
25> select @idx = charindex(" & ", @band)
26> 
27> declare @proximalBand varchar(20)
28> declare @distalBand varchar(20)
29> 
30> declare @proximalSymbol varchar(25)
31> declare @distalSymbol varchar(25)
32> 
33> declare @proximalName varchar(255)
34> declare @distalName varchar(255)
35> 
36> declare @proximalKey integer
37> declare @distalKey integer
38> 
39> /* If symbol band is not in the format 'X & Y', then distal band remains NULL */
40> 
41> if @idx = 0
42> begin
43> 	select @proximalBand = @band
44> 	/* distal band is null */
45> end
46> else
47> begin
48> 	select @proximalBand = substring(@band, 1, @idx - 1)
49> 	select @distalBand = substring(@band, @idx + 3, char_length(@band))
50> end
51> 
52> /* If caller supplies a distal band, use it */
53> 
54> if @distalCytoBand is not null
55> begin
56> 	select @distalBand = @distalCytoBand
57> end
58> 
59> select @proximalSymbol = @symbol + "-p"
60> select @proximalName = @name + ", proximal"
61> select @proximalKey = @markerKey
62> 
63> select @distalSymbol = @symbol + "-d"
64> select @distalName = @name + ", distal"
65> select @distalKey = max(_Marker_key) + 1 from MRK_Marker
66> 
67> /* Update the symbol, name and cytogenetic offset for the current Marker to the proximal symbol */
68> 
69> update MRK_Marker
70> set symbol = @proximalSymbol,
71>     name = @proximalName,
72>     cytogeneticOffset = @proximalBand
73> where _Marker_key = @proximalKey
74> 
75> update MRK_History
76> set name = @proximalName
77> where _Marker_key = @proximalKey
78> and name = @name
79> 
80> /* Copy proximal symbol info to a new distal symbol */
81> 
82> insert into MRK_Marker 
83> (_Marker_key, _Species_key, _Marker_Type_key, symbol, name, chromosome, cytogeneticOffset)
84> select @distalKey, _Species_key, _Marker_Type_key, @distalSymbol, @distalName, chromosome, @distalBand
85> from MRK_Marker where _Marker_key = @proximalKey
86> 
87> /* Notes */
88> insert into MRK_Notes
89> (_Marker_key, sequenceNum, note)
90> select @distalKey, sequenceNum, note
91> from MRK_Notes where _Marker_key = @proximalKey
92> 
93> /* Offset */
94> insert into MRK_Offset
95> (_Marker_key, source, offset)
96> select @distalKey, source, offset
97> from MRK_Offset where _Marker_key = @proximalKey
98> 
99> /* References */
100> insert into MRK_Reference
101> (_Marker_key, _Refs_key, auto)
102> select @distalKey, _Refs_key, auto
103> from MRK_Reference where _Marker_key = @proximalKey
104> 
105> /* History */
106> insert into MRK_History
107> (_Marker_key, _Marker_Event_key, _Marker_EventReason_key, _History_key, _Refs_key, sequenceNum, name, event_date)
108> select @distalKey, _Marker_Event_key, _Marker_EventReason_key, _History_key, _Refs_key, sequenceNum, name, event_date
109> from MRK_History where _Marker_key = @proximalKey and _History_key != @proximalKey
110> 
111> insert into MRK_History
112> (_Marker_key, _Marker_Event_key, _Marker_EventReason_key, _History_key, _Refs_key, sequenceNum, name, event_date)
113> select @distalKey, _Marker_Event_key, _Marker_EventReason_key, @distalKey, _Refs_key, sequenceNum, @distalName, event_date
114> from MRK_History where _Marker_key = @proximalKey and _History_key = @proximalKey
115> 
116> /* Other Names */
117> select seq = identity(5), name, _Refs_key
118> into #otherTmp
119> from MRK_Other where _Marker_key = @proximalKey
120> 
121> declare @maxOther int
122> select @maxOther = max(_Other_key) from MRK_Other
123> 
124> insert into MRK_Other
125> (_Other_key, _Marker_key, _Refs_key, name)
126> select @maxOther + seq, @distalKey, _Refs_key, name
127> from #otherTmp
128>  
129> /* Accession Numbers */
130> /* Copy all nonMGI preferred Accession numbers of proximal symbol to distal symbol */
131> 
132> select seq = identity(5), a.*
133> into #accTmp
134> from ACC_Accession a where a._Object_key = @proximalKey
135> and a._MGIType_key = 2
136> 
137> declare @maxAcc int
138> select @maxAcc = max(_Accession_key) from ACC_Accession
139> 
140> insert into ACC_Accession
141> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
142> select @maxAcc + seq, accID, prefixPart, numericPart, _LogicalDB_key, @distalKey, _MGIType_key,
143> private, preferred
144> from #accTmp
145> where prefixPart != "MGI:" and preferred != 1
146>  
147> /* Insert Other Name entries for both proximal and distal symbols */
148> 
149> declare @otherKey int
150> select @otherKey = max(_Other_key) + 1 from MRK_Other
151> insert into MRK_Other values(@otherKey, @proximalKey, NULL, @symbol, getdate(), getdate())
152> insert into MRK_Other values(@otherKey + 1, @distalKey, NULL, @symbol, getdate(), getdate())
153> 
154> select @proximalKey, @proximalSymbol
155> select @distalKey, @distalSymbol
156> 
1> 
2> grant execute on MRK_breakpointSplit to djr, ljm, rmb
1> 
2> grant execute on MRK_breakpointSplit to progs
1> 
2> drop procedure MRK_addChromosome
1> 
2> create procedure MRK_addChromosome
3>   @speciesKey integer,
4>   @chromosome varchar(8)
5> as
6> 
7> /* If Chromosome for given Species does not exist in MRK_Chromosome, */
8> /* then insert the chromosome into MRK_Chromosome. */
9> /* MRK_Chromosome is used to sequentially order the Chromosome values within */
10> /* a given Species for sorting in Homology, reports, Oxford Grids, etc. */
11> 
12> if (select count(*) from MRK_Chromosome
13>     where _Species_key = @speciesKey and chromosome = @chromosome) = 0
14> begin
15>         /* Get next available sequence number */
16>         declare @nextseq integer
17> 
18>         select @nextseq = max(sequenceNum) + 1 
19>         	from MRK_Chromosome
20>         	where _Species_key = @speciesKey
21> 
22>         if @nextseq is NULL or @nextseq = 0
23>         begin
24>         	select @nextseq = 1
25>         end
26> 
27>         insert into MRK_Chromosome (_Species_key, chromosome, sequenceNum)
28> 	values(@speciesKey, @chromosome, @nextseq)
29> 
30> end
1> 
2> grant execute on MRK_addChromosome to editors
1> 
2> grant execute on MRK_addChromosome to progs
1> 
2> drop procedure MRK_updateIMAGESeqAssoc
1>  
2> create procedure MRK_updateIMAGESeqAssoc
3>   @markerKey integer,
4>   @accID varchar(30)
5> as
6>  
7> /* TR 1270
8>  *
9>  * update/add marker/clone/E association
10>  * if accID exists for IMAGE clone
11>  *
12>  * see TR for more specific details
13> */
14> 
15> declare @cloneKey integer
16> 
17> select @cloneKey = p._Probe_key
18> from PRB_Probe p, PRB_Acc_View a
19> where p.name = 'I.M.A.G.E. clone'
20> and p._Probe_key = a._Object_key
21> and a._LogicalDB_key = 9
22> and a.accID = @accID
23> 
24> /* @accID is not attached to an IMAGE clone. do nothing. */
25> if @cloneKey is null
26> begin
27> 	return
28> end
29> 
30> /* if another "E" marker exists for the clone, print message and return */
31> 
32> if exists (select 1 from PRB_Marker 
33> 	where _Probe_key = @cloneKey
34> 	and _Marker_key != @markerKey
35> 	and relationship = 'E')
36> begin
37> 	print "The Clone/Sequence Accession number %1! has an encodes relationship with another Marker.", @accID
38> 	return
39> end
40> 
41> /* 
42>  * if clone/marker relationship exists, update to 'E'
43>  * else insert clone/marker/E relationship record
44> */
45> 
46> if exists (select 1 from PRB_Marker 
47> 	where _Probe_key = @cloneKey
48> 	and _Marker_key = @markerKey)
49> begin
50> 	update PRB_Marker set relationship = 'E', modification_date = getdate()
51> 	where _Probe_key = @cloneKey
52> 	and _Marker_key = @markerKey
53> end
54> else
55> begin
56> 	insert into PRB_Marker values(@cloneKey, @markerKey, 'E', getdate(), getdate())
57> end
58> 
59> /* delete all putative associations for clone */
60> 
61> delete from PRB_Marker where _Probe_key = @cloneKey and relationship = 'P'
62> 
1> 
2> grant execute on MRK_updateIMAGESeqAssoc to editors
1>  
2> grant execute on MRK_updateIMAGESeqAssoc to progs
1>  
2> drop procedure MRK_deleteIMAGESeqAssoc
1>  
2> create procedure MRK_deleteIMAGESeqAssoc
3>   @markerKey integer,
4>   @accID varchar(30)
5> as
6> 
7> /* TR 1270
8>  *
9>  * delete marker/clone/E association
10>  * if accID exists for IMAGE clone
11>  *
12>  * see TR for more specific details
13> */
14> 
15> declare @cloneKey integer
16> 
17> select @cloneKey = p._Probe_key
18> from PRB_Probe p, PRB_Acc_View a
19> where p.name = 'I.M.A.G.E. clone'
20> and p._Probe_key = a._Object_key
21> and a._LogicalDB_key = 9
22> and a.accID = @accID
23> 
24> /* @accID is not attached to an IMAGE clone. do nothing. */
25> if @cloneKey is null
26> begin
27> 	return
28> end
29> 
30> /* if @accid is still attached to the marker, do nothing. */
31> 
32> if exists (select 1 from MRK_Acc_View 
33> where _Object_key = @markerKey
34> and accID = @accID)
35> begin
36> 	return
37> end
38> 
39> delete from PRB_Marker 
40> where _Probe_key = @cloneKey
41> and _Marker_key = @markerKey
42> and relationship = "E"
43> 
1> 
2> grant execute on MRK_deleteIMAGESeqAssoc to editors
1>  
2> grant execute on MRK_deleteIMAGESeqAssoc to progs
1>  
2> drop procedure MRK_reloadLabel
1> 
2> create procedure MRK_reloadLabel
3> 	@markerKey integer
4> as
5> 
6> /* Delete all MRK_Label records for a Marker and regenerate */
7> 
8> delete from MRK_Label where _Marker_key = @markerKey
9> 
10> declare marker_cursor cursor for
11> select _Marker_Status_key, _Species_key, symbol, labelType = "S"
12> from MRK_Marker
13> where _Marker_key = @markerKey
14> union
15> select _Marker_Status_key, _Species_key, name, labelType = "N"
16> from MRK_Marker
17> where _Marker_key = @markerKey
18> union
19> select distinct m2._Marker_Status_key, m2._Species_key, m2.symbol, labelType = "S" 
20> from MRK_History h, MRK_Marker m, MRK_Marker m2 
21> where h._Marker_key = @markerKey
22> and h._Marker_key = m._Marker_key 
23> and h._History_key = m2._Marker_key 
24> union
25> select distinct m2._Marker_Status_key, m2._Species_key, h.name, labelType = "N" 
26> from MRK_History h, MRK_Marker m, MRK_Marker m2 
27> where h._Marker_key = @markerKey
28> and h.name is not null 
29> and h._Marker_key = m._Marker_key 
30> and h._History_key = m2._Marker_key 
31> union
32> select distinct -2, 1, o.name, labelType = "Y" 
33> from MRK_Other o
34> where o._Marker_key = @markerKey
35> for read only
36> 
37> open marker_cursor
38> 
39> declare @statusKey integer
40> declare @speciesKey integer
41> declare @label varchar(255)
42> declare @labelType char(1)
43> 
44> fetch marker_cursor into @statusKey, @speciesKey, @label, @labelType
45> 
46> while (@@sqlstatus = 0)
47> begin
48> 	insert into MRK_Label (_Marker_key, _Marker_Status_key, _Species_key, label, labelType)
49> 	values (@markerKey, @statusKey, @speciesKey, @label, @labelType)
50> 
51> 	if @@error != 0
52> 	begin
53> 		rollback transaction
54> 		raiserror 99999 "Could Re-load Marker Label"
55> 		return
56> 	end
57> 
58> 	fetch marker_cursor into @statusKey, @speciesKey, @label, @labelType
59> end
60> 
61> close marker_cursor
62> deallocate cursor marker_cursor
63> 
1> 
2> grant execute on MRK_reloadLabel to editors
1> 
2> grant execute on MRK_reloadLabel to progs
1> 
2> drop procedure MRK_reloadReference
1> 
2> create procedure MRK_reloadReference
3> 	@markerKey integer
4> as
5> 
6> /* Select all unique Marker/Reference pairs */
7> 
8> declare marker_cursor cursor for
9> select distinct r._Refs_key, auto = 1 
10> from PRB_Marker m, PRB_Reference r 
11> where m._Marker_key = @markerKey
12> and m._Probe_key = r._Probe_key 
13> union 
14> select distinct h._Refs_key, auto = 1 
15> from HMD_Homology_Marker hm, HMD_Homology h 
16> where hm._Marker_key = @markerKey
17> and hm._Homology_key = h._Homology_key 
18> union 
19> select distinct _Refs_key, auto = 1 
20> from MRK_History
21> where _Marker_key = @markerKey
22> and _Refs_key is not null 
23> union 
24> select distinct _Refs_key, auto = 1 
25> from MLD_Marker 
26> where _Marker_key = @markerKey
27> union 
28> select distinct _Refs_key, auto = 1 
29> from GXD_Index 
30> where _Marker_key = @markerKey
31> union 
32> select distinct _Refs_key, auto = 1 
33> from GXD_Assay 
34> where _Marker_key = @markerKey
35> union 
36> select distinct _Refs_key, auto = 1 
37> from MRK_Other 
38> where _Marker_key = @markerKey
39> and _Refs_key is not null 
40> union 
41> select distinct ar._Refs_key, auto = 1 
42> from ACC_Accession a, ACC_AccessionReference ar 
43> where a._Object_key = @markerKey
44> and a._MGIType_key = 2 
45> and a._LogicalDB_key = 9 
46> and a._Accession_key = ar._Accession_key 
47> union 
48> select distinct _Refs_key, auto = 0 
49> from MRK_Reference
50> where _Marker_key = @markerKey and auto = 0
51> for read only
52> 
53> open marker_cursor
54> 
55> delete from MRK_Reference where _Marker_key = @markerKey
56> 
57> declare @refKey integer
58> declare @auto bit
59> 
60> fetch marker_cursor into @refKey, @auto
61> 
62> while (@@sqlstatus = 0)
63> begin
64> 	if not exists (select * from MRK_Reference where _Marker_key = @markerKey
65> 		and _Refs_key = @refKey)
66> 	begin
67> 		insert into MRK_Reference (_Marker_key, _Refs_key, auto)
68> 		values (@markerKey, @refKey, @auto)
69> 
70> 		if @@error != 0
71> 		begin
72> 			rollback transaction
73> 			raiserror 99999 "Could Re-load Marker Reference"
74> 			return
75> 		end
76> 	end
77> 
78> 	fetch marker_cursor into @refKey, @auto
79> end
80> 
81> close marker_cursor
82> deallocate cursor marker_cursor
83> 
1> 
2> grant execute on MRK_reloadReference to editors
1> 
2> grant execute on MRK_reloadReference to progs
1> 
2> checkpoint
Password: 
1> 
2> use mgi_release
1> 
2> checkpoint
1> 
2> drop procedure ACC_resetMax
1> 
2> create procedure ACC_resetMax
3>   @objectKey int,
4>   @mgiType varchar(80),
5>   @prefixPart varchar(20) = "MGI:"
6> as
7> 
8> /* If deleting object which is using the maxNumericPart 
9>    from ACC_AccessionMax, then reset the maxNumericPart
10>    so there aren't so many holes.  During withdrawals,
11>    new Marker symbols may not receive MGI accession numbers,
12>    but the MRK_Marker insert trigger will always insert one
13> */
14> 
15> declare @numericPart int
16> select @numericPart = a.numericPart 
17> from ACC_Accession a, ACC_MGIType m
18> where a._Object_key = @objectKey
19> and a.prefixPart = @prefixPart
20> and a._MGIType_key = m._MGIType_key
21> and m.name = @mgiType
22> 
23> if (select maxNumericPart from ACC_AccessionMax where prefixPart = @prefixPart) = @numericPart
24> begin
25> 	update ACC_AccessionMax
26> 	set maxNumericPart = maxNumericPart - 1
27> 	where prefixPart = @prefixPart
28> end
29> 
1> 
2> grant execute on ACC_resetMax to progs
1> 
2> grant execute on ACC_resetMax to editors
1> 
2> drop procedure ACC_findMax
1> 
2> create procedure ACC_findMax
3>   @prefixPart varchar(20) = "MGI:"
4> as
5> 
6> /* Return maxNumericPart for given prefixPart */
7> 
8> select maxNumericPart
9> from ACC_AccessionMax
10> where prefixPart = @prefixPart
1> 
2> grant execute on ACC_findMax to progs
1> 
2> grant execute on ACC_findMax to editors
1> 
2> grant execute on ACC_findMax to public
1> 
2> drop procedure ACC_setMax
1> 
2> create procedure ACC_setMax
3>   @increment integer,
4>   @prefixPart varchar(20) = "MGI:"
5> as
6> 
7> /* Increment the max MGI Accession Number by @increment */
8> 
9> update ACC_AccessionMax
10> set maxNumericPart = maxNumericPart + @increment
11> where prefixPart= @prefixPart
12> 
1> 
2> grant execute on ACC_setMax to progs
1> 
2> drop procedure ACC_reserveMGIBlock
1> 
2> create procedure ACC_reserveMGIBlock
3>   @blockOf integer
4> as
5> 
6> /* Reserve blocks of Accession IDs for IMAGE consortium, etc. */
7> 
8> select maxNumericPart + 1 "BEGIN BLOCK"
9> from ACC_AccessionMax
10> where prefixPart = "MGI:"
11> 
12> select @blockOf = @blockOf + 1
13> exec ACC_setMax @blockOf
14> 
15> select maxNumericPart "END BLOCK"
16> from ACC_AccessionMax
17> where prefixPart = "MGI:"
18> 
1> 
2> grant execute on ACC_reserveMGIBlock to progs
1> 
2> drop procedure ACC_assignMGI
1> 
2> create procedure ACC_assignMGI
3>   @objectKey int,
4>   @mgiType varchar(80),
5>   @prefixPart varchar(20) = "MGI:",
6>   @nextMGI int = -1,
7>   @preferred int = 1
8> as
9> 
10> /* Assign MGI or J accession number
11>    Allow override of J accession number
12>    Increment ACC_AccessionMax.maxNumericPart
13> */
14> 
15> declare @nextACC int
16> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
17> 
18> declare @mgiTypeKey int
19> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
20> 
21> if @nextMGI = -1
22> begin
23> 	select @nextMGI = maxNumericPart + 1 
24> 	from ACC_AccessionMax where prefixPart = @prefixPart
25> end
26> else if @prefixPart != "J:"
27> begin
28>     rollback transaction
29>     raiserror 99999 "Cannot override generation of MGI accession number"
30>     return
31> end
32> 
33> declare @accID varchar(30)
34> select @accID = @prefixPart + convert(varchar(20), @nextMGI)
35> 
36> insert into ACC_Accession 
37> (_Accession_key, accID, prefixPart, numericPart, 
38> _LogicalDB_key, _Object_key, _MGIType_key, preferred)
39> values(@nextACC, @accID, @prefixPart, @nextMGI, 1, @objectKey, @mgiTypeKey, @preferred)
40> 
41> if (select maxNumericPart from ACC_AccessionMax
42>     where prefixPart = @prefixPart) <= @nextMGI
43> begin
44> 	update ACC_AccessionMax 
45> 	set maxNumericPart = @nextMGI 
46> 	where prefixPart = @prefixPart
47> end
48> 
1> 
2> grant execute on ACC_assignMGI to progs
1> 
2> grant execute on ACC_assignMGI to editors
1> 
2> drop procedure ACC_assignJ
1> 
2> create procedure ACC_assignJ
3>   @objectKey int,
4>   @nextMGI int = -1
5> as
6> 
7> if @nextMGI != -1
8> begin
9> 	declare @exists int
10> 	select @exists = count(*) from BIB_Acc_View
11>                where prefixPart = "J:" and 
12> 	       numericPart = @nextMGI
13> 	if @exists > 0
14> 	begin
15>   		rollback transaction
16>   		raiserror 99999 "This J Number is already in use"
17>   		return
18> 	end
19> end
20> 
21> exec ACC_assignMGI @objectKey, "Reference", "J:", @nextMGI
22> 
1> 
2> grant execute on ACC_assignJ to progs
1> 
2> grant execute on ACC_assignJ to editors
1> 
2> drop procedure ACCRef_insert
1>  
2> create procedure ACCRef_insert
3>   @accKey int,
4>   @refsKey int
5> as
6>  
7> /* Insert record into ACC_AccessionReference table */
8> 
9> insert into ACC_AccessionReference
10> (_Accession_key, _Refs_key)
11> values(@accKey, @refsKey)
12> 
1>  
2> grant execute on ACCRef_insert to progs
1>  
2> grant execute on ACCRef_insert to editors
1>  
2> drop procedure ACC_insert
1>  
2> create procedure ACC_insert
3>   @objectKey int,
4>   @accID varchar(30),
5>   @logicalDB int,
6>   @mgiType varchar(80),
7>   @refsKey int = -1,
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* Insert record into master Accession table. */
13> /* If reference is given, insert record into Accession Reference table. */
14> 
15> if @accID is null
16> 	return
17> 
18> declare @nextACC int
19> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
20>  
21> declare @mgiTypeKey int
22> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
23>  
24> declare @prefixPart varchar(20)
25> declare @numericPart int
26> exec ACC_split @accID, @prefixPart out, @numericPart out
27> 						      
28> insert into ACC_Accession
29> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
30> values(@nextACC, @accID, @prefixPart, @numericPart, @logicalDB, @objectKey, @mgiTypeKey, @private, @preferred)
31> 
32> if @refsKey != -1
33> begin
34> 	exec ACCRef_insert @nextACC, @refsKey
35> end
36> 
1>  
2> grant execute on ACC_insert to progs
1>  
2> grant execute on ACC_insert to editors
1>  
2> drop procedure ACC_insert_bySpecies
1>  
2> create procedure ACC_insert_bySpecies
3>   @objectKey int,
4>   @accID varchar(30),
5>   @speciesKey int
6> as
7>  
8> /* Insert record into master Accession table for a given species */
9> 
10> if @accID is null
11> 	return
12> 
13> declare @logicalDBKey int
14> select @logicalDBKey = _LogicalDB_key from ACC_LogicalDB 
15> where _Species_key = @speciesKey
16>  
17> declare @private int
18> select @private = 0
19> 
20> exec ACC_insert @objectKey, @accID, @logicalDBKey, "Marker", -1, 1, @private
21>  
1>  
2> grant execute on ACC_insert_bySpecies to progs
1>  
2> grant execute on ACC_insert_bySpecies to editors
1>  
2> drop procedure ACCRef_process
1>  
2> create procedure ACCRef_process
3>   @objectKey int,
4>   @refsKey int,
5>   @accID varchar(30),
6>   @logicalDB int,
7>   @mgiType varchar(80),
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* Disallow edits to WashU data - TR 611 */
13> 
14> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
15> 	   and
16> 	  (select user_name()) not in ("mgd_dbo", "dbo")
17> begin
18> 	rollback transaction
19> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
20> 	return
21> end
22> 
23> /* Disallow edits to UniGene data - TR 983 */
24> 
25> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
26> 	   and
27> 	  (select user_name()) not in ("mgd_dbo", "dbo")
28> begin
29> 	rollback transaction
30> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
31> 	return
32> end
33> 
34> /* If the Object/Acc ID pair already exists, then use that _Accession_key */
35> /* and simply insert a new ACC_AccessionReference record (ACCRef_insert) */
36> /* Else, create a new ACC_Accession and ACC_AccessionReference record (ACC_insert) */
37> 
38> declare @accKey integer
39> select @accKey = a._Accession_key 
40> from ACC_Accession a, ACC_MGIType m
41> where accID = @accID
42> and a._Object_key = @objectKey
43> and a._MGIType_key = m._MGIType_key
44> and m.name = @mgiType
45> and a._LogicalDB_key = @logicalDB
46> 
47> begin tran
48> 
49> if @accKey is not null
50> 	exec ACCRef_insert @accKey, @refsKey
51> else
52> 	exec ACC_insert @objectKey, @accID, @logicalDB, @mgiType, @refsKey, @preferred, @private
53> 
54> /* TR 1270 - if adding a Sequence Acc ID to a Marker...
55>  *
56>  * try to update the IMAGE/Marker association
57> */
58> 
59> if @mgiType = "Marker" and @logicalDB = 9
60> begin
61> 	exec MRK_updateIMAGESeqAssoc @objectKey, @accID
62> 
63> 	if @@error != 0
64> 	begin
65> 		rollback transaction
66> 	end
67> end
68> 
69> commit tran
70> 
1>  
2> grant execute on ACCRef_process to progs
1>  
2> grant execute on ACCRef_process to editors
1>  
2> drop procedure ACC_update
1>  
2> create procedure ACC_update
3>   @accKey int,
4>   @accID varchar(30),
5>   @origRefsKey int = -1,
6>   @refsKey int = -1
7> as
8>  
9> /* Disallow edits to WashU data - TR 611 */
10> 
11> if @refsKey > 0
12>    and
13>    (
14>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
15>    or
16>    exists (select * from BIB_All_View where _Refs_key = @origRefsKey and jnum = 57656)
17>    )
18>    and
19>    (select user_name()) not in ("mgd_dbo", "dbo")
20> begin
21> 	rollback transaction
22> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
23> 	return
24> end
25> 
26> /* Disallow edits to UniGene data - TR 983 */
27> 
28> if @refsKey > 0
29>    and
30>    (
31>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
32>    or
33>    exists (select * from BIB_All_View where _Refs_key = @origRefsKey and jnum = 57747)
34>    )
35>    and
36>    (select user_name()) not in ("mgd_dbo", "dbo")
37> begin
38> 	rollback transaction
39> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
40> 	return
41> end
42> 
43> begin tran
44> 
45> declare @isMarkerSeq integer
46> select @isMarkerSeq = 0
47> 
48> if (select _MGIType_key from ACC_Accession 
49> 	where _Accession_key = @accKey) = 2
50>    and
51>    (select _LogicalDB_key from ACC_Accession 
52> 	where _Accession_key = @accKey) = 9
53> begin
54> 	select @isMarkerSeq = 1
55> end
56> 
57> declare @objectKey integer
58> declare @origAccID varchar(30)
59> 
60> select @objectKey = _Object_key from ACC_Accession where _Accession_key = @accKey
61> select @origAccID = accID from ACC_Accession where _Accession_key = @accKey
62> 
63> /* Update the Accession record for a given Accession key */
64> 
65> if @accID is null
66> begin
67> 	exec ACC_delete_byAccKey @accKey
68> end
69> else
70> begin
71> 	declare @prefixPart varchar(20)
72> 	declare @numericPart int
73> 	exec ACC_split @accID, @prefixPart out, @numericPart out
74> 						      
75> 	if (@prefixPart = "J:" or substring(@prefixPart,1,4) = "MGD-")
76> 	begin
77> 		if (select count(*) from ACC_Accession
78> 	    	    where numericPart = @numericPart and
79> 			  prefixPart = @prefixPart) >= 1
80> 		begin
81> 			rollback transaction
82> 			raiserror 99999 "Duplicate MGI Accession Number"
83> 			return
84> 		end
85> 	end
86> 
87> 	update ACC_Accession
88>   	set accID = @accID, 
89>       	prefixPart = @prefixPart, 
90>       	numericPart = @numericPart,
91>       	modification_date = getdate()
92>   	where _Accession_key = @accKey
93> 
94> 	if @refsKey > 0
95> 	begin
96> 		update ACC_AccessionReference
97> 		set _Refs_key = @refsKey
98>   		where _Accession_key = @accKey and
99> 		      _Refs_key = @origRefsKey
100> 	end
101> end
102> 
103> /* TR 1270 - if updating a Sequence Acc ID of a Marker...
104>  *
105>  * delete the old IMAGE/Marker encodes relationship
106>  *
107> */
108> 
109> if @origAccID != @accID and @isMarkerSeq = 1
110> begin
111> 	exec MRK_deleteIMAGESeqAssoc @objectKey, @origAccID
112> 
113> 	if @@error != 0
114> 	begin
115> 		rollback transaction
116> 	end
117> end
118> 
119> /* TR 1270 - if updating a Sequence Acc ID of a Marker...
120>  *
121>  * update the IMAGE/Marker association
122> */
123> 
124> if @isMarkerSeq = 1
125> begin
126> 	exec MRK_updateIMAGESeqAssoc @objectKey, @accID
127> 
128> 	if @@error != 0
129> 	begin
130> 		rollback transaction
131> 	end
132> end
133> 
134> commit tran
135> 
1>  
2> grant execute on ACC_update to progs
1>  
2> grant execute on ACC_update to editors
1>  
2> drop procedure ACC_delete_byObject
1> 
2> create procedure ACC_delete_byObject
3>   @objectKey int,
4>   @mgiType varchar(80)
5> as
6> 
7> /* Delete all accession records for a given Object */
8> 
9> delete ACC_Accession 
10> from ACC_Accession a, ACC_MGIType m
11> where a._Object_key = @objectKey 
12> and a._MGIType_key = m._MGIType_key
13> and m.name = @mgiType
14> 
15> /* May have to reset the MGI or J: Max part */
16> 
17> exec ACC_resetMax @objectKey, @mgiType
18> exec ACC_resetMax @objectKey, @mgiType, "J:"
19> 
1>  
2> grant execute on ACC_delete_byObject to progs
1>  
2> grant execute on ACC_delete_byObject to editors
1>  
2> drop procedure ACC_delete_byAccKey
1> 
2> create procedure ACC_delete_byAccKey
3>   @accKey int,
4>   @refsKey int = -1
5> as
6> 
7> /* Disallow edits to WashU data - TR 611 */
8> 
9> if @refsKey > 0
10>    and
11>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
12>    and
13>    (select user_name()) not in ("mgd_dbo", "dbo")
14> begin
15> 	rollback transaction
16> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
17> 	return
18> end
19> 
20> /* Disallow edits to UniGene data - TR 983 */
21> 
22> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
23> 	   and
24> 	  (select user_name()) not in ("mgd_dbo", "dbo")
25> begin
26> 	rollback transaction
27> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
28> 	return
29> end
30> 
31> begin tran
32> 
33> declare @isMarkerSeq integer
34> select @isMarkerSeq = 0
35> 
36> declare @deleteIMAGESeqAssoc integer
37> select @deleteIMAGESeqAssoc = 0
38> 
39> if (select _MGIType_key from ACC_Accession 
40> 	where _Accession_key = @accKey) = 2
41>    and
42>    (select _LogicalDB_key from ACC_Accession 
43> 	where _Accession_key = @accKey) = 9
44> begin
45> 	select @isMarkerSeq = 1
46> end
47> 
48> declare @objectKey integer
49> declare @accID varchar(30)
50> 
51> select @objectKey = _Object_key from ACC_Accession where _Accession_key = @accKey
52> select @accID = accID from ACC_Accession where _Accession_key = @accKey
53> 
54> if @refsKey = -1
55> begin
56> 	delete ACC_Accession where _Accession_key = @accKey
57> 	select @deleteIMAGESeqAssoc = 1
58> end
59> else
60> begin
61> 	delete ACC_AccessionReference 
62> 	where _Accession_key = @accKey
63> 	and _Refs_key = @refsKey
64> 
65> 	/* If the deletion of the detail would leave the master all alone...
66>    	   then delete the master too.
67> 	*/
68> 
69> 	if not exists (select * from ACC_AccessionReference
70>     		where _Accession_key = @accKey)
71> 	begin
72> 	    delete ACC_Accession where _Accession_key = @accKey
73> 	    select @deleteIMAGESeqAssoc = 1
74> 	end
75> end
76> 
77> /* TR 1270 - if deleting a Sequence Acc ID of a Marker...
78> *
79> * delete the old IMAGE/Marker encodes relationship
80> *
81> */
82> 
83> if @isMarkerSeq = 1 and @deleteIMAGESeqAssoc = 1
84> begin
85> 	exec MRK_deleteIMAGESeqAssoc @objectKey, @accID
86> 
87> 	if @@error != 0
88> 	begin
89> 		rollback transaction
90> 	end
91> end
92> 
93> commit tran
94> 
1>  
2> grant execute on ACC_delete_byAccKey to progs
1>  
2> grant execute on ACC_delete_byAccKey to editors
1>  
2> drop procedure ACC_delete_byAccRef
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'ACC_delete_byAccRef', because it doesn't exist in the
system catalogs.
1> 
2> /* 1> declare @prefixPart varchar(20) */
3> /* 2> declare @numericPart int */
4> /* 3> exec ACC_split "MGI:12345", @prefixPart out, @numericPart out */
5> /* 4> go */
6> /* (return status = 0) */
7> /* Return parameters: */
8> /* ---- -----------  */
9> /* MGI:       12345  */
10> 
11> drop procedure ACC_split
1> 
2> create procedure ACC_split
3>   @accID varchar(20),
4>   @prefixPart varchar(20) out,
5>   @numericPart integer out
6> as
7> 
8> declare @temp varchar(20) 
9> declare @suffix varchar(20)
10> declare @acclen integer
11> declare @idx integer
12> 
13> /* Remove trailing blanks */
14> select @accID = rtrim(@accID)
15> select @acclen = char_length(@accID)
16> select @temp = reverse(@accID)
17> select @idx  = patindex("%[^0-9]%",@temp)
18> 
19> /* If @idx = 0, then no prefix */
20> 
21> if @idx = 0
22> begin
23>   select @numericPart = convert(integer, @accID)
24>   select @prefixPart = NULL
25> end
26> 
27> else
28> 
29> begin
30>   select @prefixPart = reverse(substring(@temp,@idx,@acclen-@idx+1))
31>   select @suffix = substring(@accID,
32>                              char_length(@prefixPart)+1,
33>                              @acclen - char_length(@prefixPart))
34> 
35>   if @suffix is not NULL
36>      select @numericPart = convert(integer, @suffix)
37>   else
38>      select @numericPart = NULL
39> end
40> 
1> 
2> grant execute on ACC_split to progs
1>  
2> grant execute on ACC_split to editors
1>  
2> grant execute on ACC_split to public
1>  
2> drop procedure ACC_fetch_byLogical
1>  
2> create procedure ACC_fetch_byLogical
3>   @objectKey integer,
4>   @mgiType varchar(80),
5>   @logicalDB varchar(80) = "MGI"
6> as
7>  
8> select a.accID, a.prefixPart, a.numericPart
9> from ACC_Accession a, ACC_MGIType m, ACC_LogicalDB l
10> where a._Object_key = @objectKey
11> and a._MGIType_key = m._MGIType_key
12> and m.name = @mgiType
13> and a._LogicalDB_key = l._LogicalDB_key
14> and l.name = @logicalDB
15> 
1>  
2> grant execute on ACC_fetch_byLogical to progs
1>  
2> grant execute on ACC_fetch_byLogical to public
1>  
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> drop trigger ACC_Accession_Insert
1> 
2> create trigger ACC_Accession_Insert
3> on ACC_Accession
4> for insert
5> as
6> 
7> if (select user_name()) not in ('mgd_dbo', 'dbo', 'djr', 'ljm', 'rmb', 'tier4')
8> begin
9>         if (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
10>                 where i._Object_key = n._Nomen_key) != 1
11>         begin
12>                 rollback transaction
13>                 raiserror 99999 "You do not have permission to edit this record."
14>                 return
15>         end
16> 
17> 	if (select distinct u.name from inserted i, MRK_Nomen n, sysusers u
18>         	where i._Object_key = n._Nomen_key and
19>               	n._Suid_key = u.suid) != (select user_name())
20> 	begin
21>         	rollback transaction
22>         	raiserror 99999 "You do not have permission to edit this record."
23>         	return
24> 	end
25> end
26> 
27> if @@rowcount = 1
28> begin
29>   declare @accID varchar(30)
30>   select @accID = accID from inserted
31> 
32>   /* If inserting the Sequence ID for a Marker */
33>   /* and the same ID exists for another Marker...*/
34> 
35>   if (select _LogicalDB_key from inserted) in (9) and
36>       (select _MGIType_key from inserted) = 1 and
37>       exists (select a._Accession_key
38>               from ACC_Accession a, inserted i
39>               where i.accID = a.accID and
40> 		    i._Object_key != a._Object_key and
41> 	            a._MGIType_key = 1)
42>   begin
43> 	print "The Accession ID '%1!' is associated with another Symbol.", @accID
44>   end
45> 
46> end
47> 
1> 
2> drop trigger ACC_Accession_Update
1> 
2> create trigger ACC_Accession_Update
3> on ACC_Accession
4> for update
5> as
6> 
7> if (select user_name()) not in ('mgd_dbo', 'dbo', 'djr', 'ljm', 'rmb', 'tier4')
8> begin
9>         if (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
10>                 where i._Object_key = n._Nomen_key) != 1
11>         begin
12>                 rollback transaction
13>                 raiserror 99999 "You do not have permission to edit this record."
14>                 return
15>         end
16> 
17> 	if (select distinct u.name from inserted i, MRK_Nomen n, sysusers u
18>         	where i._Object_key = n._Nomen_key and
19>               	n._Suid_key = u.suid) != (select user_name())
20> 	begin
21>         	rollback transaction
22>         	raiserror 99999 "You do not have permission to edit this record."
23>         	return
24> 	end
25> end
26> 
27> if @@rowcount = 1
28> begin
29>   declare @accID varchar(30)
30>   select @accID = accID from inserted
31> 
32>   /* If updating the Sequence ID for a Marker */
33>   /* and the same ID exists for another Marker...*/
34> 
35>   if (select _LogicalDB_key from inserted) in (9) and
36>       (select _MGIType_key from inserted) = 1 and
37>       exists (select a._Accession_key
38>               from ACC_Accession a, inserted i
39>               where i.accID = a.accID and
40> 		    i._Object_key != a._Object_key and
41> 	            a._MGIType_key = 1)
42>   begin
43> 	print "The Accession ID '%1!' is associated with another Symbol.", @accID
44>   end
45> end
46> 
1> 
2> drop trigger ACC_Accession_Delete
1> 
2> create trigger ACC_Accession_Delete
3> on ACC_Accession
4> for delete
5> as
6> 
7> if (select user_name()) not in ('mgd_dbo', 'dbo', 'djr', 'ljm', 'rmb', 'tier4')
8> begin
9>         if (select distinct n._Marker_Status_key from deleted d, MRK_Nomen n
10>                 where d._Object_key = n._Nomen_key) != 1
11>         begin
12>                 rollback transaction
13>                 raiserror 99999 "You do not have permission to edit this record."
14>                 return
15>         end
16> 
17> 	if (select distinct u.name from deleted d, MRK_Nomen n, sysusers u
18>         	where d._Object_key = n._Nomen_key and
19>               	n._Suid_key = u.suid) != (select user_name())
20> 	begin
21>         	rollback transaction
22>         	raiserror 99999 "You do not have permission to edit this record."
23>         	return
24> 	end
25> end
26> 
27> delete ACC_AccessionReference
28> from ACC_AccessionReference a, deleted d
29> where a._Accession_key = d._Accession_key
30> 
1> 
2> drop trigger ACC_AccessionReference_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'ACC_AccessionReference_Delete', because it doesn't
exist in the system catalogs.
1> 
2> create trigger ACC_AccessionReference_Delete
3> on ACC_AccessionReference
4> for delete
5> as
6> 
7> if (select user_name()) not in ('mgd_dbo', 'dbo', 'djr', 'ljm', 'rmb', 'tier4')
8> begin
9>         if (select distinct n._Marker_Status_key from deleted d, ACC_Accession a, MRK_Nomen n
10>                 where d._Accession_key = a._Accession_key and
11> 		a._Object_key = n._Nomen_key) != 1
12>         begin
13>                 rollback transaction
14>                 raiserror 99999 "You do not have permission to edit this record."
15>                 return
16>         end
17> 
18> 	if (select distinct u.name from deleted d, ACC_Accession a, MRK_Nomen n, sysusers u
19>         	where d._Accession_key = a._Accession_key and
20> 		a._Object_key = n._Nomen_key and
21>               	n._Suid_key = u.suid) != (select user_name())
22> 	begin
23>         	rollback transaction
24>         	raiserror 99999 "You do not have permission to edit this record."
25>         	return
26> 	end
27> end
28> 
1> 
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> drop trigger MRK_Nomen_Insert
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Nomen_Insert', because it doesn't exist in the
system catalogs.
1> 
2> create trigger MRK_Nomen_Insert
3> on MRK_Nomen
4> for insert
5> as
6> 
7> if (select user_name()) not in ('mgd_dbo', 'dbo', 'djr', 'ljm', 'rmb', 'tier4')
8> begin
9> 	if (select _Marker_Status_key from inserted) != 1
10> 	begin
11> 		rollback transaction
12> 		raiserror 99999 "You do not have permission to set the Status field to any value other than Pending."
13> 		return
14> 	end
15> end
16> 
17> if (select user_name()) not in ('mgd_dbo', 'dbo')
18> begin
19> 	if (select _Marker_Event_key from inserted) != 1
20> 	begin
21> 		rollback transaction
22> 		raiserror 99999 "You do not have permission to set the Event field to any value other than Assigned."
23> 		return
24> 	end
25> end
26> 
1> 
2> drop trigger MRK_Nomen_Update
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Nomen_Update', because it doesn't exist in the
system catalogs.
1> 
2> create trigger MRK_Nomen_Update
3> on MRK_Nomen
4> for update
5> as
6> 
7> /* Any user (except dbo) */
8> 
9> if (select user_name()) not in ('mgd_dbo', 'dbo')
10> begin
11> 	if (select _Marker_Status_key from deleted) = 5 and
12>            (select _Marker_Status_key from inserted) != 5
13> 	begin
14> 		rollback transaction
15> 		raiserror 99999 "You cannot modify status from Broadcast."
16> 		return
17> 	end
18> 
19> 	if update(_Marker_Event_key)
20> 	begin
21> 		rollback transaction
22> 		raiserror 99999 "You do not have permission to modify the Event field."
23> 		return
24> 	end
25> 
26> 	if update(_Suid_key)
27> 	begin
28> 		rollback transaction
29> 		raiserror 99999 "You do not have permission to modify the Submitted By field."
30> 		return
31> 	end
32> end
33> 
34> /* If Tier2 or Tier3 user */
35> 
36> if (select user_name()) in ('cgw', 'dph', 'dbradt', 'lglass', 'lmm', 'sr', 'tier2', 'tier3')
37> begin
38> 	/* Status must = "Pending" */
39> 	/* User modifying record must = user who submitted record */
40> 
41> 	if (select _Marker_Status_key from deleted) != 1
42> 	begin
43> 		rollback transaction
44> 		raiserror 99999 "You do not have permission to edit this record."
45> 		return
46> 	end
47> 
48> 	if (select distinct u.name from deleted d, sysusers u where d._Suid_key = u.suid) != (select user_name())
49> 	begin
50> 		rollback transaction
51> 		raiserror 99999 "You do not have permission to edit this record."
52> 		return
53> 	end
54> end
55> 
1> 
2> drop trigger MRK_Nomen_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Nomen_Delete', because it doesn't exist in the
system catalogs.
1> 
2> create trigger MRK_Nomen_Delete
3> on MRK_Nomen
4> for delete
5> as
6> 
7> /* If Tier2 or Tier3 user */
8> 
9> if (select user_name()) in ('cgw', 'dph', 'dbradt', 'lglass', 'lmm', 'sr', 'tier2', 'tier3')
10> begin
11> 	/* Status must = "Pending" */
12> 	/* User deleting record must = user who submitted record */
13> 
14> 	if (select _Marker_Status_key from deleted) != 1
15> 	begin
16> 		rollback transaction
17> 		raiserror 99999 "You do not have permission to edit this record."
18> 		return
19> 	end
20> 
21> 	if (select distinct u.name from deleted d, sysusers u where d._Suid_key = u.suid) != (select user_name())
22> 	begin
23> 		rollback transaction
24> 		raiserror 99999 "You do not have permission to edit this record."
25> 		return
26> 	end
27> end
28> 
29> delete MRK_Nomen_GeneFamily from MRK_Nomen_GeneFamily, deleted
30> where MRK_Nomen_GeneFamily._Nomen_key = deleted._Nomen_key
31>  
32> delete MRK_Nomen_Notes from MRK_Nomen_Notes, deleted
33> where MRK_Nomen_Notes._Nomen_key = deleted._Nomen_key
34>  
35> delete MRK_Nomen_Other from MRK_Nomen_Other, deleted
36> where MRK_Nomen_Other._Nomen_key = deleted._Nomen_key
37>  
38> delete MRK_Nomen_Reference from MRK_Nomen_Reference, deleted
39> where MRK_Nomen_Reference._Nomen_key = deleted._Nomen_key
40>  
41> delete ACC_Accession
42> from ACC_Accession a, ACC_MGIType m, deleted
43> where a._Object_key = deleted._Nomen_key
44> and a._MGIType_key = m._MGIType_key
45> and m.name = "Nomenclature"
46> 
1> 
2> drop trigger MRK_Nomen_GeneFamily_IUD
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Nomen_GeneFamily_IUD', because it doesn't exist in
the system catalogs.
1> 
2> create trigger MRK_Nomen_GeneFamily_IUD
3> on MRK_Nomen_GeneFamily
4> for insert, update, delete
5> as
6> 
7> if (select user_name()) not in ('dbo', 'mgd_dbo', 'djr', 'ljm', 'rmb', 'tier4')
8> begin
9> 	if (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
10> 		where i._Nomen_key = n._Nomen_key) != 1
11> 	begin
12> 		rollback transaction
13> 		raiserror 99999 "You do not have permission to edit this record."
14> 		return
15> 	end
16> 
17> 	if (select distinct n._Marker_Status_key from deleted d, MRK_Nomen n
18> 		where d._Nomen_key = n._Nomen_key) != 1
19> 	begin
20> 		rollback transaction
21> 		raiserror 99999 "You do not have permission to edit this record."
22> 		return
23> 	end
24> 
25> 	if (select distinct u.name from inserted i, MRK_Nomen n, sysusers u 
26> 		where i._Nomen_key = n._Nomen_key and
27> 	      	n._Suid_key = u.suid) != (select user_name())
28> 	begin
29> 		rollback transaction
30> 		raiserror 99999 "You do not have permission to edit this record."
31> 		return
32> 	end
33> 
34> 	if (select distinct u.name from deleted d, MRK_Nomen n, sysusers u 
35> 		where d._Nomen_key = n._Nomen_key and
36> 	      	n._Suid_key = u.suid) != (select user_name())
37> 	begin
38> 		rollback transaction
39> 		raiserror 99999 "You do not have permission to edit this record."
40> 		return
41> 	end
42> end
43> 
1> 
2> drop trigger MRK_Nomen_Notes_IUD
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Nomen_Notes_IUD', because it doesn't exist in the
system catalogs.
1> 
2> create trigger MRK_Nomen_Notes_IUD
3> on MRK_Nomen_Notes
4> for insert, update, delete
5> as
6> 
7> if (select user_name()) not in ('dbo', 'mgd_dbo', 'djr', 'ljm', 'rmb', 'tier4')
8> begin
9> 	if (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
10> 		where i._Nomen_key = n._Nomen_key) != 1
11> 	begin
12> 		rollback transaction
13> 		raiserror 99999 "You do not have permission to edit this record."
14> 		return
15> 	end
16> 
17> 	if (select distinct n._Marker_Status_key from deleted d, MRK_Nomen n
18> 		where d._Nomen_key = n._Nomen_key) != 1
19> 	begin
20> 		rollback transaction
21> 		raiserror 99999 "You do not have permission to edit this record."
22> 		return
23> 	end
24> 
25> 	if (select distinct u.name from inserted i, MRK_Nomen n, sysusers u 
26> 		where i._Nomen_key = n._Nomen_key and
27> 	      	n._Suid_key = u.suid) != (select user_name())
28> 	begin
29> 		rollback transaction
30> 		raiserror 99999 "You do not have permission to edit this record."
31> 		return
32> 	end
33> 
34> 	if (select distinct u.name from deleted d, MRK_Nomen n, sysusers u 
35> 		where d._Nomen_key = n._Nomen_key and
36> 	      	n._Suid_key = u.suid) != (select user_name())
37> 	begin
38> 		rollback transaction
39> 		raiserror 99999 "You do not have permission to edit this record."
40> 		return
41> 	end
42> end
43> 
1> 
2> drop trigger MRK_Nomen_Other_IUD
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Nomen_Other_IUD', because it doesn't exist in the
system catalogs.
1> 
2> create trigger MRK_Nomen_Other_IUD
3> on MRK_Nomen_Other
4> for insert, update, delete
5> as
6> 
7> if (select user_name()) not in ('dbo', 'mgd_dbo', 'djr', 'ljm', 'rmb', 'tier4')
8> begin
9> 	if (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
10> 		where i._Nomen_key = n._Nomen_key) != 1
11> 	begin
12> 		rollback transaction
13> 		raiserror 99999 "You do not have permission to edit this record."
14> 		return
15> 	end
16> 
17> 	if (select distinct n._Marker_Status_key from deleted d, MRK_Nomen n
18> 		where d._Nomen_key = n._Nomen_key) != 1
19> 	begin
20> 		rollback transaction
21> 		raiserror 99999 "You do not have permission to edit this record."
22> 		return
23> 	end
24> 
25> 	if (select distinct u.name from inserted i, MRK_Nomen n, sysusers u 
26> 		where i._Nomen_key = n._Nomen_key and
27> 	      	n._Suid_key = u.suid) != (select user_name())
28> 	begin
29> 		rollback transaction
30> 		raiserror 99999 "You do not have permission to edit this record."
31> 		return
32> 	end
33> 
34> 	if (select distinct u.name from deleted d, MRK_Nomen n, sysusers u 
35> 		where d._Nomen_key = n._Nomen_key and
36> 	      	n._Suid_key = u.suid) != (select user_name())
37> 	begin
38> 		rollback transaction
39> 		raiserror 99999 "You do not have permission to edit this record."
40> 		return
41> 	end
42> end
43> 
1> 
2> drop trigger MRK_Nomen_Reference_Insert
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Nomen_Reference_Insert', because it doesn't exist
in the system catalogs.
1> 
2> create trigger MRK_Nomen_Reference_Insert
3> on MRK_Nomen_Reference
4> for insert, update
5> as
6> 
7> if (select user_name()) not in ('dbo', 'mgd_dbo', 'djr', 'ljm', 'rmb', 'tier4')
8> begin
9> 	if (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
10> 		where i._Nomen_key = n._Nomen_key) != 1
11> 	begin
12> 		rollback transaction
13> 		raiserror 99999 "You do not have permission to edit this record."
14> 		return
15> 	end
16> 
17> 	if (select distinct u.name from inserted i, MRK_Nomen n, sysusers u 
18> 		where i._Nomen_key = n._Nomen_key and
19> 	      	n._Suid_key = u.suid) != (select user_name())
20> 	begin
21> 		rollback transaction
22> 		raiserror 99999 "You do not have permission to edit this record."
23> 		return
24> 	end
25> end
26> 
27> if @@rowcount > 1
28> begin
29> 	return
30> end
31> 
32> /* Whenever a Reference is added to Nomen, make sure the Nomen database */
33> /* is selected in the BIB_Refs table */
34> 
35> declare @dbs varchar(60)
36> 
37> select @dbs = b.dbs
38> from mgi_release..BIB_Refs b, inserted i
39> where i._Refs_key = b._Refs_key
40> 
41> if (charindex("Nomen", @dbs) = 0)
42> begin
43> 	if substring(@dbs, char_length(@dbs), char_length(@dbs)) = "/"
44> 	begin
45> 		select @dbs = @dbs + "Nomen/"
46> 	end
47> 	else
48> 	begin
49> 		select @dbs = @dbs + "/Nomen/"
50> 	end
51> 
52> 	update mgi_release..BIB_Refs
53> 	set b.dbs = @dbs
54> 	from mgi_release..BIB_Refs b, inserted i
55> 	where b._Refs_key = i._Refs_key
56> end
57> 
1> 
2> drop trigger MRK_Nomen_Reference_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Nomen_Reference_Delete', because it doesn't exist
in the system catalogs.
1> 
2> create trigger MRK_Nomen_Reference_Delete
3> on MRK_Nomen_Reference
4> for delete
5> as
6> 
7> if (select user_name()) not in ('dbo', 'mgd_dbo', 'djr', 'ljm', 'rmb', 'tier4')
8> begin
9> 	if (select distinct n._Marker_Status_key from deleted d, MRK_Nomen n
10> 		where d._Nomen_key = n._Nomen_key) != 1
11> 	begin
12> 		rollback transaction
13> 		raiserror 99999 "You do not have permission to edit this record."
14> 		return
15> 	end
16> 
17> 	if (select distinct u.name from deleted d, MRK_Nomen n, sysusers u 
18> 		where d._Nomen_key = n._Nomen_key and
19> 	      	n._Suid_key = u.suid) != (select user_name())
20> 	begin
21> 		rollback transaction
22> 		raiserror 99999 "You do not have permission to edit this record."
23> 		return
24> 	end
25> end
26> 
1> 
2> drop trigger MRK_Status_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_Status_Delete', because it doesn't exist in the
system catalogs.
1> 
2> create trigger MRK_Status_Delete
3> on MRK_Status
4> for delete
5> as
6> 
7> /* Disallow deletion if Status is currently referenced elsewhere */
8> 
9> if exists (select 1 from MRK_Nomen, deleted
10>     where MRK_Nomen._Marker_Status_key = deleted._Marker_Status_key)
11> begin
12> 	rollback transaction
13> 	raiserror 99999 "Marker Status is referenced in Nomen Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger MRK_GeneFamily_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MRK_GeneFamily_Delete', because it doesn't exist in the
system catalogs.
1> 
2> create trigger MRK_GeneFamily_Delete
3> on MRK_GeneFamily
4> for delete
5> as
6> 
7> /* Disallow deletion if Gene Family is currently referenced elsewhere */
8> 
9> if exists (select 1 from MRK_Nomen_GeneFamily, deleted
10>     where MRK_Nomen_GeneFamily._Marker_Family_key = deleted._Marker_Family_key)
11> begin
12> 	rollback transaction
13> 	raiserror 99999 "Gene Family is referenced in Nomen Record(s)"
14> 	return
15> end
16> 
1> 
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> drop view MGI_Table_Column_View
1> 
2> create view MGI_Table_Column_View
3> as 
4> SELECT _Table_id = t._Table_id, table_name = o.name, table_description = t.description,
5> column_name = c.name, _Column_id = cc._Column_id, column_description = cc.description,
6> example = cc.example, t.creation_date, t.modification_date
7> FROM
8> syscolumns c, MGI_Columns cc, sysobjects o, MGI_Tables t
9> WHERE
10> o.id = t._Table_id AND cc._Column_id = c.colid AND
11> o.id = c.id AND cc._Table_id = t._Table_id AND ((o.type='U'))
1> 
2> grant select on MGI_Table_Column_View to public
1>  
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> /* obsolete views */
3> drop view MRK_Nomen_Marker_View
1> 
2> drop view MRK_Nomen_Homology_View
1> 
2> /* end obsolete views (remove during next release) */
3> 
4> drop view MRK_Nomen_View
1> 
2> create view MRK_Nomen_View
3> as
4> select n.*, s.status, e.event, r.eventReason, markerType = t.name, submittedBy = u1.name, broadcastBy = u2.name
5> from MRK_Nomen n, MRK_Status s, mgi_release..MRK_Event e, mgi_release..MRK_EventReason r, mgi_release..MRK_Types t, sysusers u1, sysusers u2
6> where n._Marker_Status_key = s._Marker_Status_key
7> and n._Marker_Event_key = e._Marker_Event_key
8> and n._Marker_EventReason_key = r._Marker_EventReason_key
9> and n._Marker_Type_key = t._Marker_Type_key
10> and n._Suid_key = u1.suid
11> and n._Suid_broadcast_key *= u2.suid
1> 
2> grant select on MRK_Nomen_View to public
1> 
2> drop view MRK_Nomen_Other_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'MRK_Nomen_Other_View', because it doesn't exist in the
system catalogs.
1> 
2> create view MRK_Nomen_Other_View
3> as
4> select r.*, b.jnumID, b.jnum, b.short_citation, firstAuthor = b._primary
5> from MRK_Nomen_Other r, mgi_release..BIB_All_View b
6> where r._Refs_key = b._Refs_key
1> 
2> grant select on MRK_Nomen_Other_View to public
1>  
2> drop view MRK_Nomen_Reference_View
1> 
2> create view MRK_Nomen_Reference_View
3> as
4> select r.*, b.jnumID, b.jnum, b.short_citation, firstAuthor = b._primary, b.isReviewArticle
5> from MRK_Nomen_Reference r, mgi_release..BIB_All_View b
6> where r._Refs_key = b._Refs_key
1> 
2> grant select on MRK_Nomen_Reference_View to public
1>  
2> drop view MRK_Nomen_GeneFamily_View
1> 
2> create view MRK_Nomen_GeneFamily_View
3> as
4> select n.*, g.name
5> from MRK_Nomen_GeneFamily n, MRK_GeneFamily g
6> where n._Marker_Family_key = g._Marker_Family_key
1> 
2> grant select on MRK_Nomen_GeneFamily_View to public
1>  
2> drop view MRK_Nomen_User_View
1> 
2> /* When developing/testing, include 'pm' (Prita) and your id in view */
3> 
4> create view MRK_Nomen_User_View
5> as
6> select distinct l.suid, l.name, l.fullname, l.status
7> from master..syslogins l, nomen..sysusers u, nomen..sysusers g
8> where l.suid = u.suid
9> and u.gid = g.gid
10> and l.name in ('djr', 'dbradt', 'ljm', 'lglass', 'sr', 'rmb', 'dph', 'cgw', 'lmm', 'retired_editors', 'tier2', 'tier3', 'tier4')
11> 
1> 
2> grant select on MRK_Nomen_User_View to public
1> 
2> drop view MRK_Nomen_CoordNotes_View
1> 
2> create view MRK_Nomen_CoordNotes_View
3> as
4> select * from MRK_Nomen_Notes where noteType = 'C'
1> 
2> grant all on MRK_Nomen_CoordNotes_View to ljm, rmb, djr, tier4
1> 
2> grant all on MRK_Nomen_CoordNotes_View to progs
1> 
2> grant select on MRK_Nomen_CoordNotes_View to public
1> 
2> drop view MRK_Nomen_EditorNotes_View
1> 
2> create view MRK_Nomen_EditorNotes_View
3> as
4> select * from MRK_Nomen_Notes where noteType = 'E'
1> 
2> grant all on MRK_Nomen_EditorNotes_View to cgw, dbradt, dph, lmm, sr, rmb, tier3
1> 
2> grant all on MRK_Nomen_EditorNotes_View to progs
1> 
2> grant select on MRK_Nomen_EditorNotes_View to public
1> 
2> drop view MRK_Nomen_AccRef_View
1>  
2> create view MRK_Nomen_AccRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, ar._Refs_key, b.jnumID, b.jnum, b.short_citation
5> from ACC_Accession a, mgi_release..ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, mgi_release..BIB_All_View b
6> where a._MGIType_key = 1
7> and a._Accession_key = ar._Accession_key
8> and a._LogicalDB_key = l._LogicalDB_key
9> and a._MGIType_key = m._MGIType_key
10> and ar._Refs_key = b._Refs_key
1>  
2> grant select on MRK_Nomen_AccRef_View to public
1> 
2> drop view MRK_Nomen_AccNoRef_View
1>  
2> create view MRK_Nomen_AccNoRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name,
5> subType = mt.name,
6> description = ma.symbol + ", " + ma.name
7> from ACC_Accession a, mgi_release..ACC_LogicalDB l, ACC_MGIType m, MRK_Nomen ma, mgi_release..MRK_Types mt
8> where a._MGIType_key = 1
9> and a._LogicalDB_key = l._LogicalDB_key
10> and a._MGIType_key = m._MGIType_key
11> and a._Object_key = ma._Nomen_key
12> and ma._Marker_Type_key = mt._Marker_Type_key
13> and not exists (select r.* from ACC_AccessionReference r
14> where a._Accession_key = r._Accession_key)
1>  
2> grant select on MRK_Nomen_AccNoRef_View to public
1>  
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> /* 1> declare @prefixPart varchar(20) */
3> /* 2> declare @numericPart int */
4> /* 3> exec ACC_split "MGI:12345", @prefixPart out, @numericPart out */
5> /* 4> go */
6> /* (return status = 0) */
7> /* Return parameters: */
8> /* ---- -----------  */
9> /* MGI:       12345  */
10> 
11> drop procedure ACC_split
1> 
2> create procedure ACC_split
3>   @accID varchar(20),
4>   @prefixPart varchar(20) out,
5>   @numericPart integer out
6> as
7> 
8> declare @temp varchar(20) 
9> declare @suffix varchar(20)
10> declare @acclen integer
11> declare @idx integer
12> 
13> /* Remove trailing blanks */
14> select @accID = rtrim(@accID)
15> select @acclen = char_length(@accID)
16> select @temp = reverse(@accID)
17> select @idx  = patindex("%[^0-9]%",@temp)
18> 
19> /* If @idx = 0, then no prefix */
20> 
21> if @idx = 0
22> begin
23>   select @numericPart = convert(integer, @accID)
24>   select @prefixPart = NULL
25> end
26> 
27> else
28> 
29> begin
30>   select @prefixPart = reverse(substring(@temp,@idx,@acclen-@idx+1))
31>   select @suffix = substring(@accID,
32>                              char_length(@prefixPart)+1,
33>                              @acclen - char_length(@prefixPart))
34> 
35>   if @suffix is not NULL
36>      select @numericPart = convert(integer, @suffix)
37>   else
38>      select @numericPart = NULL
39> end
40> 
1> 
2> grant execute on ACC_split to progs
1>  
2> grant execute on ACC_split to editors
1>  
2> grant execute on ACC_split to public
1>  
2> drop procedure ACCRef_insert
1>  
2> create procedure ACCRef_insert
3>   @accKey int,
4>   @refsKey int
5> as
6>  
7> /* Insert record into ACC_AccessionReference table */
8> 
9> insert into ACC_AccessionReference
10> (_Accession_key, _Refs_key)
11> values(@accKey, @refsKey)
12> 
1>  
2> grant execute on ACCRef_insert to progs
1>  
2> grant execute on ACCRef_insert to editors
1>  
2> drop procedure ACC_insert
1>  
2> create procedure ACC_insert
3>   @objectKey int,
4>   @accID varchar(30),
5>   @logicalDB int,
6>   @mgiType varchar(80),
7>   @refsKey int = -1,
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* Insert record into master Accession table. */
13> /* If reference is given, insert record into Accession Reference table. */
14> 
15> if @accID is null
16> 	return
17> 
18> declare @nextACC int
19> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
20> 
21> if @nextACC is null
22> begin
23> 	select @nextACC = 1
24> end
25> 
26> declare @mgiTypeKey int
27> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
28>  
29> declare @prefixPart varchar(20)
30> declare @numericPart int
31> exec ACC_split @accID, @prefixPart out, @numericPart out
32> 						      
33> insert into ACC_Accession
34> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
35> values(@nextACC, @accID, @prefixPart, @numericPart, @logicalDB, @objectKey, @mgiTypeKey, @private, @preferred)
36> 
37> if @refsKey != -1
38> begin
39> 	exec ACCRef_insert @nextACC, @refsKey
40> end
41> 
1>  
2> grant execute on ACC_insert to progs
1>  
2> grant execute on ACC_insert to editors
1>  
2> drop procedure ACCRef_process
1>  
2> create procedure ACCRef_process
3>   @objectKey int,
4>   @refsKey int,
5>   @accID varchar(30),
6>   @logicalDB int,
7>   @mgiType varchar(80)
8> as
9>  
10> /* If the Object/Acc ID pair already exists, then use that _Accession_key */
11> /* and simply insert a new ACC_AccessionReference record (ACCRef_insert) */
12> /* Else, create a new ACC_Accession and ACC_AccessionReference record (ACC_insert) */
13> 
14> declare @accKey integer
15> select @accKey = a._Accession_key 
16> from ACC_Accession a, ACC_MGIType m
17> where accID = @accID
18> and a._Object_key = @objectKey
19> and a._MGIType_key = m._MGIType_key
20> and m.name = @mgiType
21> and a._LogicalDB_key = @logicalDB
22> 
23> if @accKey is not null
24> 	exec ACCRef_insert @accKey, @refsKey
25> else
26> 	exec ACC_insert @objectKey, @accID, @logicalDB, @mgiType, @refsKey
27> 
1>  
2> grant execute on ACCRef_process to progs
1>  
2> grant execute on ACCRef_process to editors
1>  
2> drop procedure ACC_delete_byAccKey
1> 
2> create procedure ACC_delete_byAccKey
3>   @accKey int,
4>   @refsKey int = -1
5> as
6> 
7> /* Delete ACC_Accession/ACC_AccessonReference records for a given _Accession_key */
8> 
9> if @refsKey = -1
10> begin
11> 	delete ACC_Accession where _Accession_key = @accKey
12> end
13> else
14> begin
15> 
16> 	delete ACC_AccessionReference 
17> 	where _Accession_key = @accKey
18> 	and _Refs_key = @refsKey
19> 
20>         /* If the deletion of the detail would leave the master all alone...
21>            then delete the master too.
22>         */
23> 
24>         if not exists (select * from ACC_AccessionReference
25>                 where _Accession_key = @accKey)
26>         begin
27>             delete ACC_Accession where _Accession_key = @accKey
28>         end
29> end
30> 
1>  
2> grant execute on ACC_delete_byAccKey to progs
1>  
2> grant execute on ACC_delete_byAccKey to editors
1>  
2> drop procedure ACC_update
1>  
2> create procedure ACC_update
3>   @accKey int,
4>   @accID varchar(30),
5>   @origRefsKey int = -1,
6>   @refsKey int = -1
7> as
8>  
9> /* Update the Accession record for a given Accession key */
10> 
11> if @accID is null
12> begin
13> 	exec ACC_delete_byAccKey @accKey
14> end
15> else
16> begin
17> 	declare @prefixPart varchar(20)
18> 	declare @numericPart int
19> 	exec ACC_split @accID, @prefixPart out, @numericPart out
20> 						      
21> 	if (@prefixPart = "J:" or substring(@prefixPart,1,4) = "MGD-")
22> 	begin
23> 		if (select count(*) from ACC_Accession
24> 	    	    where numericPart = @numericPart and
25> 			  prefixPart = @prefixPart) >= 1
26> 		begin
27> 			rollback transaction
28> 			raiserror 99999 "Duplicate MGI Accession Number"
29> 			return
30> 		end
31> 	end
32> 
33> 	update ACC_Accession
34>   	set accID = @accID, 
35>       	prefixPart = @prefixPart, 
36>       	numericPart = @numericPart,
37>       	modification_date = getdate()
38>   	where _Accession_key = @accKey
39> 
40> 	if @refsKey > 0
41> 	begin
42> 		update ACC_AccessionReference
43> 		set _Refs_key = @refsKey
44>   		where _Accession_key = @accKey and
45> 		      _Refs_key = @origRefsKey
46> 	end
47> end
48> 
1>  
2> grant execute on ACC_update to progs
1>  
2> grant execute on ACC_update to editors
1>  
2> drop procedure ACC_delete_byObject
1> 
2> create procedure ACC_delete_byObject
3>   @objectKey int,
4>   @mgiType varchar(80)
5> as
6> 
7> /* Delete all accession records for a given Object */
8> 
9> delete ACC_Accession
10> from ACC_Accession a, ACC_MGIType m
11> where a._Object_key = @objectKey
12> and a._MGIType_key = m._MGIType_key
13> and m.name = @mgiType
14> 
1>  
2> grant execute on ACC_delete_byObject to progs
1>  
2> grant execute on ACC_delete_byObject to editors
1>  
2> drop procedure ACC_delete_byAccRef
1> 
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> drop procedure MGI_Table_Column_Cleanup
1> 
2> CREATE PROCEDURE MGI_Table_Column_Cleanup
3> /*
4> JCG: Jan. 7, 1999
5> This procedure attempts to get MGI_Tables and MGI_Columns in sync with
6> sysobjects and syscolumns
7> */
8> 
9> as
10> 
11> /* Make sure that an old temp table with this name doesn't exists */
12> if exists (select name from sysobjects
13>            where name = '#temp_add_table'
14>            and type = 'U')
15>    drop table #temp_add_table
16> 
17> /*
18> NEW TABLE ADDED TO SCHEMA
19> */
20> /* Find tables in sysobjects which are not in MGI_Tables and insert them
21> into a temp table */
22> SELECT
23> MGI_Tables._Table_id, sysobjects.name
24> into #temp_add_table
25> FROM
26> MGI_Tables MGI_Tables, sysobjects sysobjects
27> WHERE
28> MGI_Tables._Table_id =* sysobjects.id
29> AND
30> sysobjects.type='U'
31> ORDER BY
32> sysobjects.name
33> 
34> /* From the temp table, select only those values where the table name is not
35> found in MGI_Tables. */
36> insert into MGI_Tables
37> SELECT object_id(name), NULL, getDate(), getDate()
38> FROM
39> #temp_add_table
40> WHERE
41> _Table_id is NULL
42> 
43> /* Also, find the appropriate columns and put into MGI_Columns so
44> that MGI_Tables and MGI_Columns are in sync */
45> insert into MGI_Columns
46> SELECT object_id(t.name), colid, NULL, NULL, getDate(), getDate()
47> FROM
48> #temp_add_table t, syscolumns c
49> WHERE
50> _Table_id is NULL
51> AND
52> object_id(t.name) = id
53> 
54> if exists (select name from sysobjects
55>            where name = '#temp_add_table'
56>            and type = 'U')
57>    drop table #temp_add_table
58> 
59> /*
60> WHAT IF YOU BCP IN A TRUNCATED COLUMN LIST?
61> THIS SECTION ADDS COLUMN DEFINITIONS FOR TABLES THAT ARE IN MGI_TABLES
62> BUT NOT MGI_COLUMNS - SYNCS COLUMNS WITH TABLES
63> */
64> 
65> if exists (select name from sysobjects
66>            where name = '#temp_update_table'
67>            and type = 'U')
68>    drop table #temp_update_table
69> 
70> SELECT
71> MGI_Columns._Table_id, syscolumns.id, syscolumns.colid
72> into #temp_update_table
73> FROM
74> MGI_Columns MGI_Columns,
75> syscolumns syscolumns,
76> sysobjects sysobjects
77> WHERE
78> syscolumns.id *= MGI_Columns._Table_id
79> and
80> syscolumns.id = sysobjects.id
81> and
82> sysobjects.type = 'U'
83> 
84> insert into MGI_Columns
85> SELECT
86> id, colid, NULL, NULL, getDate(), getDate()
87> FROM
88> #temp_update_table
89> WHERE
90> _Table_id is NULL
91> 
92> if exists (select name from sysobjects
93>            where name = '#temp_update_table'
94>            and type = 'U')
95>    drop table #temp_update_table
96> 
97> /*
98> THIS SECTION DELETES TABLES DEFINITION WHEN A TABLE IS DELETED
99> */
100> 
101> /*Algorithm:
102> 
103> If table not found in sysobjects, delete from MGI_Tables and
104> remove all column entries. Do a join to find _Table_id with no id
105> */
106> 
107> DELETE from MGI_Tables
108> where _Table_id in
109> (select DISTINCT _Table_id
110> from
111> MGI_Tables t, sysobjects o
112> WHERE
113> _Table_id NOT in (select id from sysobjects where type = 'U'))
114> 
115> if exists (select name from sysobjects
116>            where name = '#temp_delete_table'
117>            and type = 'U')
118>    drop table #temp_delete_table
119> 
120> 
121> SELECT DISTINCT _Table_id, id
122> into #temp_delete_table
123> FROM
124> MGI_Columns, sysobjects
125> WHERE
126> _Table_id *= id
127> 
128> /* If there is an id in MGI_Columns which is not in syscolumns then delete its entri
129> es */
130> delete from MGI_Columns
131> WHERE
132> _Table_id in (select _Table_id from #temp_delete_table where id is NULL)
133> 
134> if exists (select name from sysobjects
135>            where name = '#temp_delete_table'
136>            and type = 'U')
137>    drop table #temp_delete_table
138> 
139> RETURN
1> 
2> grant execute on MGI_Table_Column_Cleanup to public
1> 
2> drop procedure GEN_rowcount
1>  
2> create procedure GEN_rowcount
3>   @table varchar(30)
4> as
5> 
6> select convert(char(10),rowcnt(MAX(doampg)))
7> from sysobjects o, sysindexes i
8> where o.name = @table
9> and o.id = i.id
1> 
2> grant execute on GEN_rowcount to public
1> 
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> drop procedure NOMEN_verifyMarker
1> 
2> create procedure NOMEN_verifyMarker
3>   @symbol varchar(25)
4> as
5> 
6> /* Verify if marker symbol exists in Nomen or MGD master Marker list */
7> 
8> declare @status varchar(255)
9> 
10> if exists (select 1 from mgi_release..MRK_Marker m where m.symbol = @symbol and m._Species_key = 1)
11> begin
12> 	select @status = "Symbol '" + @symbol + "' exists in MGD\n"
13> end
14> 
15> if exists (select 1 from mgi_release..MRK_Marker m where m.symbol = @symbol + "-pending" and m._Species_key = 1)
16> begin
17> 	select @status = @status + "Symbol '" + @symbol + "-pending' exists in MGD\n"
18> end
19> 
20> if exists (select 1 from MRK_Nomen where symbol = @symbol)
21> begin
22> 	select @status = @status + "Symbol '" + @symbol + "' exists in Nomen\n"
23> end
24> 
25> if @status is not null
26> begin
27> 	raiserror 99999 @status
28> end
29> 
1> 
2> grant execute on NOMEN_verifyMarker to public
1> 
2> drop procedure NOMEN_updateBroadcastStatus
1> 
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> drop procedure Nomen_transferToMGD
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'Nomen_transferToMGD', because it doesn't exist in the
system catalogs.
1> 
2> create procedure Nomen_transferToMGD
3> 	@nomenKey integer
4> as
5> 
6> /* Transfer one marker to MGD */
7> 
8> begin transaction
9> 
10> if (select @nomenKey) is null
11> begin
12> 	raiserror 99999 "Must supply a key for Nomen_transferToMGD."
13> 	rollback transaction
14> 	return
15> end
16> 
17> declare @symbol varchar(25)
18> select @symbol = symbol from MRK_Nomen where _Nomen_key = @nomenKey
19> 
20> declare @uid integer
21> select @uid = u.suid from sysusers u where u.name = (select user_name())
22> 
23> if (select user_name()) not in ('mgd_dbo', 'dbo', 'djr', 'ljm', 'rmb', 'tier4') and
24>    @uid != (select _Suid_key from MRK_Nomen where _Nomen_key = @nomenKey)
25> begin
26> 	raiserror 99999 "You do not have permission to Broadcast symbol %1!.", @symbol
27> 	rollback transaction
28> 	return
29> end
30> 
31> if (select _Marker_Status_key from MRK_Nomen where _Nomen_key = @nomenKey) = 5
32> begin
33> 	raiserror 99999 "Symbol %1! has already been broadcast.", @symbol
34> 	rollback transaction
35> 	return
36> end
37> 
38> if (select _Marker_Status_key from MRK_Nomen where _Nomen_key = @nomenKey) = 2
39> begin
40> 	raiserror 99999 "Symbol %1! has been deleted.", @symbol
41> 	rollback transaction
42> 	return
43> end
44> 
45> if not exists 
46> 	(select _Refs_key from MRK_Nomen_Reference 
47> 		where _Nomen_key = @nomenKey and isPrimary = 1)
48> begin
49> 	raiserror 99999 "Symbol %1! has no Primary Reference.", @symbol
50> 	rollback transaction
51> 	return
52> end
53> 
54> declare @name varchar(255)
55> declare @statusKey integer
56> declare @eventKey integer
57> declare @eventReasonKey integer
58> declare @primaryRefKey integer
59> declare @markerKey integer
60> declare @accID varchar(30)
61> 
62> /* Create new marker record in MGD */
63> 
64> select @name = n.name,
65>        @eventKey = n._Marker_Event_key,
66>        @eventReasonKey = n._Marker_EventReason_key,
67>        @primaryRefKey = r._Refs_key,
68>        @statusKey = 1
69> from MRK_Nomen n, MRK_Nomen_Reference r
70> where n._Nomen_key = @nomenKey
71> and n._Nomen_key = r._Nomen_key
72> and r.isPrimary = 1
73> 
74> select @markerKey = max(_Marker_key) + 1 from mgi_release..MRK_Marker
75> 
76> insert into mgi_release..MRK_Marker
77> (_Marker_key, _Species_key, _Marker_Type_key, _Marker_Status_key, symbol, name, chromosome)
78> select @markerKey, 1, _Marker_Type_key, @statusKey, symbol, name, chromosome
79> from MRK_Nomen
80> where _Nomen_key = @nomenKey
81> 
82> if @@error != 0
83> begin
84> 	raiserror 99999 "Could not add symbol %1! in Nomen_transferToMGD.", @symbol
85> 	rollback transaction
86> 	return
87> end
88> 
89> /* Create Offset for new marker */
90> insert into mgi_release..MRK_Offset values(@markerKey, 0, -1.0, getdate(), getdate())
91> 
92> if @@error != 0
93> begin
94> 	raiserror 99999 "Could not add offset for symbol %1! in Nomen_transferToMGD.", @symbol
95> 	rollback transaction
96> 	return
97> end
98> 
99> /* Create History line for new marker */
100> exec mgi_release..MRK_insertHistory @markerKey, @markerKey, @primaryRefKey, @eventKey, @eventReasonKey, @name
101> 
102> if @@error != 0
103> begin
104> 	raiserror 99999 "Could not add history for symbol %1! in Nomen_transferToMGD.", @symbol
105> 	rollback transaction
106> 	return
107> end
108> 
109> /* Create Other Names for new marker */
110> 
111> declare @otherName varchar(255)
112> declare @otherRefKey integer
113> declare @otherKey integer
114> 
115> declare otherCursor cursor for
116> select name, _Refs_key
117> from MRK_Nomen_Other
118> where _Nomen_key = @nomenKey
119> for read only
120> 
121> open otherCursor
122> 
123> fetch otherCursor into @otherName, @otherRefKey
124> 
125> while (@@sqlstatus = 0)
126> begin
127> 	select @otherKey = max(_Other_key + 1) from mgi_release..MRK_Other
128> 
129> 	insert into mgi_release..MRK_Other 
130> 	(_Other_key, _Marker_key, _Refs_key, name)
131> 	values(@otherKey, @markerKey, @otherRefKey, @otherName)
132> 
133> 	if @@error != 0
134> 	begin
135> 		raiserror 99999 "Could not add other name %1! for symbol %2! in Nomen_transferToMGD.", @otherName, @symbol
136> 		rollback transaction
137> 		return
138> 	end
139> 
140> 	fetch otherCursor into @otherName, @otherRefKey
141> end
142> 
143> close otherCursor
144> deallocate cursor otherCursor
145> 
146> /* Create Related References for new marker */
147> 
148> declare @relatedRefKey integer
149> 
150> declare refCursor cursor for
151> select _Refs_key
152> from MRK_Nomen_Reference
153> where _Nomen_key = @nomenKey
154> and isPrimary = 0
155> and broadcastToMGD = 1
156> for read only
157> 
158> open refCursor
159> 
160> fetch refCursor into @relatedRefKey
161> 
162> while (@@sqlstatus = 0)
163> begin
164> 	insert into mgi_release..MRK_Reference
165> 	(_Marker_key, _Refs_key, auto)
166> 	values(@markerKey, @relatedRefKey, 0)
167> 
168> 	if @@error != 0
169> 	begin
170> 		raiserror 99999 "Could not add related reference %1! for symbol %2! in Nomen_transferToMGD."
171> 		rollback transaction
172> 		return
173> 	end
174> 
175> 	fetch refCursor into @relatedRefKey
176> end
177> 
178> close refCursor
179> deallocate cursor refCursor
180> 
181> declare @logicalDB integer
182> declare @refsKey integer
183> 
184> /* Create Accession IDs for new marker */
185> 
186> declare acc_cursor cursor for
187> select distinct a.accID, a._LogicalDB_key, r._Refs_key
188> from ACC_Accession a, ACC_AccessionReference r
189> where a._Object_key = @nomenKey
190> and a._Accession_key = r._Accession_key
191> for read only
192> 
193> open acc_cursor
194> 
195> fetch acc_cursor into @accID, @logicalDB, @refsKey
196> 
197> while (@@sqlstatus = 0)
198> begin
199> 	exec mgi_release..ACC_insert @markerKey, @accID, @logicalDB, 'Marker', @refsKey
200> 
201> 	if @@error != 0
202> 	begin
203> 		raiserror 99999 "Could not add accession id %1! for symbol %2! in Nomen_transferToMGD.", @accID, @symbol
204> 		rollback transaction
205> 		return
206> 	end
207> 
208> 	fetch acc_cursor into @accID, @logicalDB, @refsKey
209> end
210> 
211> close acc_cursor
212> deallocate cursor acc_cursor
213> 
214> /* Get MGI Accession ID of MGD Marker record */
215> 
216> select @accID = accid 
217> from mgi_release..MRK_Acc_View 
218> where _Object_key = @markerKey
219> and prefixPart = "MGI:"
220> and preferred = 1
221> 
222> /* Load MRK_Label and MRK_Reference */
223> 
224> exec mgi_release..MRK_reloadLabel @markerKey
225> exec mgi_release..MRK_reloadReference @markerKey
226> 
227> /* Update Status, Broadcast date, Broadcast User and MGI Acc ID */
228> 
229> update MRK_Nomen
230> set _Marker_Status_key = 5,
231>     _Suid_broadcast_key = @uid,
232>     broadcast_date = getdate(),
233>     mgiAccID = @accID
234> where _Nomen_key = @nomenKey
235> 
236> if @@error != 0
237> begin
238> 	raiserror 99999 "Could not update Status, Broadcast Date and Broadcast By for symbol %1! in Nomen_transferToMGD.", @symbol
239> 	rollback transaction
240> 	return
241> end
242> 
243> commit transaction
244> 
1> 
2> grant execute on Nomen_transferToMGD to ljm, djr, rmb, lmm, cgw, dbradt, dph, sr, tier3, tier4
1> 
2> grant execute on Nomen_transferToMGD to progs
1> 
2> drop procedure Nomen_transferAlltoMGD
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'Nomen_transferAlltoMGD', because it doesn't exist in
the system catalogs.
1> 
2> create procedure Nomen_transferAlltoMGD
3> as
4> 
5> /* Transfer all Approved Markers to MGD */
6> 
7> begin transaction
8> 
9> declare marker_cursor cursor for
10> select _Nomen_key
11> from MRK_Nomen
12> where _Marker_Status_key = 4
13> for read only
14> 
15> declare @nomenKey integer
16> 
17> open marker_cursor
18> 
19> fetch marker_cursor into @nomenKey
20> 
21> if @@sqlstatus != 0
22> begin
23> 	raiserror 99999 "There are no records to transfer to MGD."
24> 	rollback transaction
25> 	return
26> end
27> 
28> while (@@sqlstatus = 0)
29> begin
30> 	exec Nomen_transfertoMGD @nomenKey
31> 	fetch marker_cursor into @nomenKey
32> end
33> 
34> close marker_cursor
35> deallocate cursor marker_cursor
36> 
37> commit transaction
38> 
1> 
2> grant execute on Nomen_transferAllToMGD to ljm, djr, rmb, tier4
1> 
2> grant execute on Nomen_transferAllToMGD to progs
1> 
2> drop procedure Nomen_transferEditorRefToMGD
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'Nomen_transferEditorRefToMGD', because it doesn't
exist in the system catalogs.
1> 
2> create procedure Nomen_transferEditorRefToMGD
3> 	@refsKey integer
4> as
5> 
6> /* Tier 3 - Transfer all Pending Markers which contain primary reference "@refsKey" to MGD */
7> 
8> begin transaction
9> 
10> declare marker_cursor cursor for
11> select distinct n._Nomen_key
12> from MRK_Nomen n, MRK_Nomen_Reference r, MRK_Nomen_User_View u
13> where n._Marker_Status_key = 1
14> and n._Suid_key = u.suid
15> and u.name = (select user_name())
16> and n._Nomen_key = r._Nomen_key
17> and r.isPrimary = 1
18> and r._Refs_key = @refsKey
19> for read only
20> 
21> declare @nomenKey integer
22> 
23> open marker_cursor
24> 
25> fetch marker_cursor into @nomenKey
26> 
27> if @@sqlstatus != 0
28> begin
29> 	raiserror 99999 "There are no records to transfer to MGD."
30> 	rollback transaction
31> 	return
32> end
33> 
34> while (@@sqlstatus = 0)
35> begin
36> 	exec Nomen_transfertoMGD @nomenKey
37> 	fetch marker_cursor into @nomenKey
38> end
39> 
40> close marker_cursor
41> deallocate cursor marker_cursor
42> 
43> commit transaction
44> 
1> 
2> grant execute on Nomen_transferEditorRefToMGD to lmm, cgw, dbradt, dph, sr, tier3
1> 
2> grant execute on Nomen_transferEditorRefToMGD to progs
1> 
2> drop procedure Nomen_transferCoordRefToMGD
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'Nomen_transferCoordRefToMGD', because it doesn't
exist in the system catalogs.
1> 
2> create procedure Nomen_transferCoordRefToMGD
3> 	@refsKey integer
4> as
5> 
6> /* Tier 4 - Transfer all Approved Markers which contain primary reference "@refsKey" to MGD */
7> 
8> begin transaction
9> 
10> declare marker_cursor cursor for
11> select distinct n._Nomen_key
12> from MRK_Nomen n, MRK_Nomen_Reference r
13> where n._Marker_Status_key = 4
14> and n._Nomen_key = r._Nomen_key
15> and r.isPrimary = 1
16> and r._Refs_key = @refsKey
17> for read only
18> 
19> declare @nomenKey integer
20> 
21> open marker_cursor
22> 
23> fetch marker_cursor into @nomenKey
24> 
25> if @@sqlstatus != 0
26> begin
27> 	raiserror 99999 "There are no records to transfer to MGD."
28> 	rollback transaction
29> 	return
30> end
31> 
32> while (@@sqlstatus = 0)
33> begin
34> 	exec Nomen_transfertoMGD @nomenKey
35> 	fetch marker_cursor into @nomenKey
36> end
37> 
38> close marker_cursor
39> deallocate cursor marker_cursor
40> 
41> commit transaction
42> 
1> 
2> grant execute on Nomen_transferCoordRefToMGD to ljm, djr, rmb, tier4
1> 
2> grant execute on Nomen_transferCoordRefToMGD to progs
1> 
2> checkpoint
Password: 
1> 
2> use strains
1> 
2> checkpoint
1> 
2> drop trigger MLP_Strain_Delete
1> 
2> create trigger MLP_Strain_Delete
3> on MLP_Strain
4> for delete
5> as
6> 
7> delete mgi_release..PRB_Strain from mgi_release..PRB_Strain, deleted
8> where mgi_release..PRB_Strain._Strain_key = deleted._Strain_key
9> 
10> delete MLP_Notes from MLP_Notes, deleted
11> where MLP_Notes._Strain_key = deleted._Strain_key
12> 
13> delete MLP_StrainTypes from MLP_StrainTypes, deleted
14> where MLP_StrainTypes._Strain_key = deleted._Strain_key
15> 
16> delete mgi_release..ACC_Accession 
17> from mgi_release..ACC_Accession a, mgi_release..ACC_MGIType m, deleted
18> where a._Object_key = deleted._Strain_key
19> and a._MGIType_key = m._MGIType_key
20> and m.name = "Strain"
21> 
1> 
2> drop trigger MLP_StrainType_Delete
1> 
2> create trigger MLP_StrainType_Delete
3> on MLP_StrainType
4> for delete
5> as
6> 
7> /* Disallow deletion if Strain Type is referenced elsewhere */
8> 
9> if exists (select * from MLP_StrainTypes, deleted
10>          where MLP_StrainTypes._StrainType_key = deleted._StrainType_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Strain Type is referenced in Strain Record(s)"
14> 	return
15> end
16>  
1> 
2> drop trigger MLP_Species_Delete
1> 
2> create trigger MLP_Species_Delete
3> on MLP_Species
4> for delete
5> as
6> 
7> /* Disallow deletion if Species is referenced elsewhere */
8> 
9> if exists (select * from MLP_Strain, deleted
10>          where MLP_Strain._Species_key = deleted._Species_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Species is referenced in Strain Record(s)"
14> 	return
15> end
16>  
1> 
2> checkpoint
Password: 
1> 
2> use strains
1> 
2> checkpoint
1> 
2> drop view MLP_Strain_View
1> 
2> create view MLP_Strain_View
3> as
4> select s.*, sp.species, p.strain, p.standard, p.needsReview
5> from MLP_Strain s, MLP_Species sp, mgi_release..PRB_Strain p
6> where s._Species_key = sp._Species_key
7> and s._Strain_key = p._Strain_key
1> 
2> grant select on MLP_Strain_View to public
1> 
2> drop view MLP_StrainTypes_View
1> 
2> create view MLP_StrainTypes_View
3> as
4> select s.*, st.strainType
5> from MLP_StrainTypes s, MLP_StrainType st
6> where s._StrainType_key = st._StrainType_key
1> 
2> grant select on MLP_StrainTypes_View to public
1> 
2> checkpoint
Password: 
1> 
2> use strains
1> 
2> checkpoint
1> 
2> drop procedure GEN_rowcount
1>  
2> create procedure GEN_rowcount
3>   @table varchar(30)
4> as
5> 
6> select convert(char(10),rowcnt(MAX(doampg)))
7> from sysobjects o, sysindexes i
8> where o.name = @table
9> and o.id = i.id
1> 
2> grant execute on GEN_rowcount to public
1> 
2> checkpoint
Password: 
1> 
2> use strains
1> 
2> checkpoint
1> 
2> drop procedure MLP_mergeStrain
1>  
2> create procedure MLP_mergeStrain
3>   @oldStrainKey int,
4>   @newStrainKey int
5> as
6> 
7> /*
8>  * Update old Strain key to new Strain key
9>  * in all relevant tables which contain a Strain key.
10>  * When finished, remove the Strain record for the old
11>  * Strain key.
12> */
13> 
14> if (select count(*) from mgi_release..PRB_Allele_Strain where _Strain_key in (@oldStrainKey, @newStrainkey)
15>     group by _Allele_key having count(*) > 1) > 0
16> begin
17> 	declare @alleleKey integer
18> 	declare @probe varchar(255)
19> 	declare @jnum varchar(100)
20> 
21> 	declare allele_cursor cursor for
22> 	select distinct _Allele_key
23> 	from mgi_release..PRB_Allele_Strain
24> 	where _Strain_key in (@oldStrainKey, @newStrainkey)
25>         group by _Allele_key having count(*) > 1
26> 	for read only
27>  
28> 	open allele_cursor
29>  
30> 	fetch allele_cursor into @alleleKey
31>  
32> 	while (@@sqlstatus = 0)
33> 	begin
34> 		select @probe = p.name, @jnum = b.accID
35> 		from mgi_release..PRB_Allele a, mgi_release..PRB_RFLV v, mgi_release..PRB_Reference  r, mgi_release..PRB_Probe p, mgi_release..BIB_Acc_View b
36> 		where a._Allele_key = @alleleKey and
37> 		      a._RFLV_key = v._RFLV_key and
38> 		      v._Reference_key = r._Reference_key and
39> 		      r._Probe_key = p._Probe_key and
40> 		      r._Refs_key = b._Object_key and
41> 		      b.prefixPart = 'J:'
42> 
43> 		rollback transaction
44> 		raiserror 99999 "This merge would create a duplicate entry for Probe '%1!', %2!", @probe, @jnum
45> 		return
46> 	end
47>  
48> 	close allele_cursor
49>  
50> 	deallocate cursor allele_cursor
51> 
52> end
53> 
54> /* all Strains must have same symbols */
55> 
56> if exists (select m1.* from mgi_release..PRB_Strain_Marker m1
57>            where m1._Strain_key = @newStrainKey
58> 	   and not exists
59> 	   (select m2.* from mgi_release..PRB_Strain_Marker m2
60> 	    where m2._Strain_key = @oldStrainKey and
61> 	    m2._Marker_key = m1._Marker_key))
62> begin
63> 	rollback transaction
64> 	raiserror 99999 "Old and New Strains must have the same Marker Symbols"
65> 	return
66> end
67> 
68> if exists (select m1.* from mgi_release..PRB_Strain_Marker m1
69>            where m1._Strain_key = @oldStrainKey
70> 	   and not exists
71> 	   (select m2.* from mgi_release..PRB_Strain_Marker m2
72> 	    where m2._Strain_key = @newStrainKey and
73> 	    m2._Marker_key = m1._Marker_key))
74> begin
75> 	rollback transaction
76> 	raiserror 99999 "Old and New Strains must have the same Marker Symbols"
77> 	return
78> end
79> 
80> /* both Strains must have the same Strain Types */
81> 
82> if exists (select m1.* from MLP_StrainTypes m1
83>            where m1._Strain_key = @newStrainKey
84> 	   and not exists
85> 	   (select m2.* from MLP_StrainTypes m2
86> 	    where m2._Strain_key = @oldStrainKey and
87> 	    m2._StrainType_key = m1._StrainType_key))
88> begin
89> 	rollback transaction
90> 	raiserror 99999 "Old and New Strains must have the same Strain Types"
91> 	return
92> end
93> 
94> if exists (select m1.* from MLP_StrainTypes m1
95>            where m1._Strain_key = @oldStrainKey
96> 	   and not exists
97> 	   (select m2.* from MLP_StrainTypes m2
98> 	    where m2._Strain_key = @newStrainKey and
99> 	    m2._StrainType_key = m1._StrainType_key))
100> begin
101> 	rollback transaction
102> 	raiserror 99999 "Old and New Strains must have the same Strain Types"
103> 	return
104> end
105> 
106> /* both Strains must have the same Species value */
107> 
108> if (select _Species_key from MLP_Strain where _Strain_key = @newStrainKey) !=
109>    (select _Species_key from MLP_Strain where _Strain_key = @oldStrainKey)
110> begin
111> 	rollback transaction
112> 	raiserror 99999 "Old and New Strains must have the same Species"
113> 	return
114> end
115> 
116> /* both Strains must have the same Needs Review value */
117> 
118> if (select needsReview from mgi_release..PRB_Strain where _Strain_key = @newStrainKey) !=
119>    (select needsReview from mgi_release..PRB_Strain where _Strain_key = @oldStrainKey)
120> begin
121> 	rollback transaction
122> 	raiserror 99999 "Old and New Strains must have the same Needs Review value"
123> 	return
124> end
125> 
126> /* JAX Registry - must be equal OR use the one that exists */
127> 
128> declare @jaxRegistryNew varchar(30)
129> declare @jaxRegistryOld varchar(30)
130> 
131> select @jaxRegistryNew = NULL
132> select @jaxRegistryOld = NULL
133> 
134> if exists (select accID from mgi_release..ACC_Accession
135>            where _Object_key = @newStrainKey and _LogicalDB_Key = 22 and _MGIType_key = 10)
136> begin
137> 	select @jaxRegistryNew = accID from mgi_release..ACC_Accession
138> 	where _Object_key = @newStrainKey and _LogicalDB_Key = 22 and _MGIType_key = 10
139> end
140> 
141> if exists (select _Accession_key from mgi_release..ACC_Accession
142>            where _Object_key = @oldStrainKey and _LogicalDB_Key = 22 and _MGIType_key = 10)
143> begin
144> 	select @jaxRegistryOld = accID from mgi_release..ACC_Accession
145> 	where _Object_key = @oldStrainKey and _LogicalDB_Key = 22 and _MGIType_key = 10
146> end
147> 
148> if (@jaxRegistryNew != NULL and @jaxRegistryOld != NULL and
149>     @jaxRegistryNew != @jaxRegistryOld)
150> begin
151> 	rollback transaction
152> 	raiserror 99999 "Old and New Strains must have the same JAX Registry Number"
153> 	return
154> end
155> else if (@jaxRegistryOld != NULL)
156> begin
157>     select @jaxRegistryNew = @jaxRegistryOld
158> end
159> 
160> update mgi_release..ACC_Accession
161> set _Object_key = @newStrainKey
162> where accID = @jaxRegistryNew
163> and _LogicalDB_Key = 22
164> and _MGIType_key = 10
165> 
166> update mgi_release..PRB_Source
167> set _Strain_key = @newStrainKey
168> where _Strain_key = @oldStrainKey
169> 
170> update mgi_release..PRB_Allele_Strain
171> set _Strain_key = @newStrainKey
172> where _Strain_key = @oldStrainKey
173> 
174> update mgi_release..MLD_FISH
175> set _Strain_key = @newStrainKey
176> where _Strain_key = @oldStrainKey
177> 
178> update mgi_release..MLD_InSitu
179> set _Strain_key = @newStrainKey
180> where _Strain_key = @oldStrainKey
181> 
182> update mgi_release..CRS_Cross
183> set _femaleStrain_key = @newStrainKey
184> where _femaleStrain_key = @oldStrainKey
185> 
186> update mgi_release..CRS_Cross
187> set _maleStrain_key = @newStrainKey
188> where _maleStrain_key = @oldStrainKey
189> 
190> update mgi_release..CRS_Cross
191> set _StrainHO_key = @newStrainKey
192> where _StrainHO_key = @oldStrainKey
193> 
194> update mgi_release..CRS_Cross
195> set _StrainHT_key = @newStrainKey
196> where _StrainHT_key = @oldStrainKey
197> 
198> update mgi_release..GXD_Genotype
199> set _Strain_key = @newStrainKey
200> where _Strain_key = @oldStrainKey
201> 
202> update mgi_release..PRB_Strain_Marker
203> set _Strain_key = @newStrainKey
204> where _Strain_key = @oldStrainKey
205> 
206> update MLP_StrainTypes
207> set _Strain_key = @newStrainKey
208> where _Strain_key = @oldStrainKey
209> 
210> /* Delete trigger will delete records from PRB_Strain */
211> 
212> delete from MLP_Strain
213> where _Strain_key = @oldStrainKey
214> 
1> 
2> grant execute on MLP_mergeStrain to editors
1>  
2> grant execute on MLP_mergeStrain to progs
1>  
2> drop procedure MLP_mergeStandardStrain
1>  
2> create procedure MLP_mergeStandardStrain
3>   @strain varchar(255),
4>   @fromStandard int = 0,
5>   @toStandard int = 1
6> as
7>  
8> /* Given a Strain, merge all of the records into one Strain.
9>  *
10>  * Merge all Non-Standard Strains into the Standard Strain (default)
11>  * (exec PRB_mergeStandardStrain "Strain")
12>  *
13>  * OR
14>  *
15>  * Merge all Standard Strains into the Non-Standard Strain
16>  * (exec PRB_mergeStandardStrain "Strain", 1, 0)
17>  *
18> */
19> 
20> declare @newStrainKey integer
21> declare @oldStrainKey integer
22> 
23> if (select count(_Strain_key) from mgi_release..PRB_Strain
24>     where strain = @strain and standard = @toStandard) > 1
25> begin
26> 	rollback transaction
27> 	raiserror 99999 "More than one designation exists for Strain: %1!", @strain
28> 	return
29> end
30> 
31> if (select count(_Strain_key) from mgi_release..PRB_Strain
32>     where strain = @strain and standard = @toStandard) = 0
33> begin
34> 	rollback transaction
35> 	raiserror 99999 "No correct designation exists for Strain: %1!", @strain
36> 	return
37> end
38> 
39> select @newStrainKey = _Strain_key from mgi_release..PRB_Strain
40> where strain = @strain and standard = @toStandard
41> 
42> declare strain_cursor cursor for
43> select _Strain_key
44> from mgi_release..PRB_Strain
45> where strain = @strain and standard = @fromStandard
46> for read only
47>  
48> open strain_cursor
49>  
50> fetch strain_cursor into @oldStrainKey
51>  
52> while (@@sqlstatus = 0)
53> begin
54> 	exec MLP_mergeStrain @oldStrainKey, @newStrainKey
55>         fetch strain_cursor into @oldStrainKey
56> end
57>  
58> close strain_cursor
59>  
60> deallocate cursor strain_cursor
61>  
1> 
2> grant execute on MLP_mergeStandardStrain to editors
1>  
2> grant execute on MLP_mergeStandardStrain to progs
1>  
2> checkpoint
Load MiniGO..
Mon May 22 13:51:35 EDT 2000
Traceback (innermost last):
  File "./minigoload.py", line 694, in ?
    os.mkdir(output_dir)
posix.error: (17, 'File exists')
Mon May 22 13:51:35 EDT 2000
rm: Unable to remove directory ./0503_load: File exists
rm: ./0503_load/minigoload.log: override protection 644 (yes/no)? rm: ./0503_load/go_term.bcp: override protection 644 (yes/no)? rm: ./0503_load/marker_go.bcp: override protection 644 (yes/no)? rm: ./0503_load/data_evidence.bcp: override protection 644 (yes/no)? cannot open ./0522_load: No such file or directory
find: cannot open .: No such file or directory
