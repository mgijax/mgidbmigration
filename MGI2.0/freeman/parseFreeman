#!/usr/local/bin/python

#
#	parseFreeman
#
#	Script to parse Tom Freeman's ACeDB file and output a set
#	of bcp's for loading into GXD.
#
#	Joel Richardson
#	April 1998
#
#	This is a one-time-only script, not meant to be maintained.
#	(I.e., don't expect beautiful code and lots of comments!)
#
#	Command line args:
#		1. ACEDB file containing Tom's data
#		2. File containing list of STS names. These are the
#		   one's we'll extract from Tom's file.
#		3. Spreadsheet file, used for mapping genbank numbers
#		   to gene symbols.
#		4. File mapping tissue names as supplied by Tom to
#		   a path in the Anatomical Dictionary
#		5. Sybase server name
#		6. Sybase database name
#		7. Sybase user name
#		8. Name of file containing password for user
#
#	Processing:
#		General set up. Read password file. Get current date.
#		open log file. Read list of sts names.
#
#		Initialization from MGI. Translate each of Tom's tissue
#		names to a structure key in the adatomical dictionary. Find
#		reference for the data. Get current max keys for
#		tables we'll be populating. Find keys for various controlled
#		vocabulary terms and other items we'll need to reference.
#		Read spreadsheet file and, for each marker symbol, find
#		its _Marker_key.
#		(see: loadMGIdata())
#
#		Read/parse the ACEDB file. This loads a set of classes
#		into memory. (Uses library acedb.py.)
#
#		Create a bcp output file for each table we'll be writing.
#
#		Foreach name in sts name list:
#		    Retrieve that STS record from the ACEDB class,
#		    along with associated information on the sequence,
#		    assay conditions, etc. Translate values that Tom 
#		    uses (strengths, tissues, etc.) into keys in MGI. 
#		    (see: processSTS())
#
#		    Write bcp records. Each STS generate an expression assay 
#		    (one RT-PCR gel with 48 lanes and one row), a primer pair,
#		    and one image. Plus miscellaneous record to tie everything
#		    together.
#		    (see: writeBcps())
#
#
#		Update max MGI accession number in database (ACC_AccessionMax)
#		Write the max MGI numeric part that we assigned.
#
#		

import sys
import string
import regex
from acedb import *
import sybaseschema
import mgdlib

##############################################################

mgiserver = None
mgidatabase = None
mgiuser = None
mgipassword = None
mgischema = None

#
# The is the J# for Tom's Freeman's reference.
#
tomsJnumber = "J:46439"	

#
# The text to go in the IMG_Image.imageNote fields
#
IMAGE_NOTE = "Results of a single RT-PCR expression profiling assay. Duplicate reactions performed on the cDNA panel are shown one above the other. The amount of PCR product generated is indicated by color code. For more details, see information in reference."
 
#
# The text to go in the IMG_Image.copyrightNote fields
#
COPYRIGHT_NOTE = "Questions regarding the expression data or their use in publications should be directed to Tom Freeman, The Sanger Centre, UK (tcf@sanger.ac.uk). For details, see reference."

#
# These are the strength values that are used in the ace file, mapped to the values we use.
#
strengthVals = {
    "Positive_tissue" : "Strong",
    "Positive_tissue_weak" : "Moderate",
    "Positive_tissue_trace" : "Trace",
    "Positive_discrepancy" : "Not Specified"
}


#
# This is the subset of tissues in the ace file that appear in Tom's gel images.
# The tissues are ordered as they appear in the images. The tissue name are
# as they appear in the acedb file, which is not precisely the same as they
# appear in the images.
#
tissueList = [
    "Whole Brain",
    "Cortex",
    "Hippocampus",
    "Mid brain",
    "Striatum",
    "Olfactory bulb",
    "Cerebellum",
    "Spinal cord",
    "Pituitary gland",
    "Eye",
    "Skeletal muscle",
    "Heart",
    "Lung",
    "Spleen",
    "Liver",
    "Gall bladder",

    "Pancreas",
    "Kidney",
    "Bladder",
    "Adrenal gland",
    "Skin",
    "Adipose tissue",
    "Long bone\/marrow",
    "Paws",
    "Teeth",
    "Tongue",
    "Salivary gland",
    "Oesophagus",
    "Fundus",
    "Antrum",
    "Duodenum",
    "Jejunum",

    "Ileum",
    "Caecum",
    "Ascending",
    "Descending",
    "Appendix",
    "Thymus",
    "Mammary gland  Non preg.",
    "Mammary gland  preg.",
    "Testis",
    "Epididymis",
    "Ovary",
    "Cervix",
    "Placenta",
    "Mid-term foetus",
    "no RT-product",
    "human DNA/mouseDNA"
]

#
# Here's the same list of tissue name, as they appear in the images.
#
tissuePrintList = [
    "Whole brain",
    "Cortex",
    "Hippocampus",
    "Mid brain",
    "Striatum",
    "Olfactory bulb",
    "Cerebellum",
    "Spinal cord",
    "Pituitary gland",
    "Eye",
    "Skeletal muscle",
    "Heart",
    "Lung",
    "Spleen",
    "Liver",
    "Gall bladder",

    "Pancreas",
    "Kidney",
    "Bladder",
    "Adrenal gland",
    "Skin",
    "Adipose tissue",
    "Long bone",
    "Paw",
    "Teeth",
    "Tongue",
    "Salivary gland",
    "Oesophagus",
    "Fundus",
    "Antrum",
    "Duodenum",
    "Jejunum",

    "Ileum",
    "Caecum",
    "Asc. colon",
    "Desc. colon",
    "Appendix",
    "Thymus",
    "Mamm.gland non-preg.",
    "Mamm.gland preg",
    "Testis",
    "Epididymis",
    "Ovary",
    "Cervix",
    "Placenta",
    "Mid-term foetus",
    "No RT product",
    "Human DNA/MouseDNA"
]

#
# Here's a more convenient data structure, mapping Tom's tissue name to a tuple.
# Each tuple is of the form ( <position in Tom's list>, <our structure name>, <our structure id> )
#
tissueMapping = {}

#
# Dictionary mapping GenBank numbers to marker keys
#
markerByGenbank = {}

#
# Log file descriptor
#
logfd = None

#
# File descriptors for bcp files.
#
accBcp = None
assayBcp = None
assayNoteBcp = None
cacheBcp = None
gelBandBcp = None
gelLaneBcp = None
gelRowBcp = None
gelLaneStructureBcp = None
genotypeBcp = None
probePrepBcp = None

#
# Global flag to ensure we write only one genotype object
#
wroteGenotype = 0

#######################################################################

###################################################################
# debug
# Write a log message to the log file and to stderr.
###################################################################

def debug(s):
	if logfd:
		logfd.write( s + '\n' )
	if logfd != sys.stderr:
		sys.stderr.write(s + '\n')

###################################################################
# die
# Write an error message and exit.
###################################################################

def die(s):
	debug(s)
	sys.exit(-1)

###################################################################
# usage
# Print a usage string and exit.
###################################################################

def usage():
	die(("Usage: %s <ace file> <sts list file> <spreadsheet file> <tissue mapping file> " + \
		"<server> <database> <user> <password file>") % sys.argv[0] )

###################################################################
# psts
# Debugging routine. Print the raw acedb text for an
# sts, given its name.
###################################################################

def psts( stsname ):
	sts = STSClass.gimmeRcd(stsname)
	if sts == None:
		debug("Could not find STS " + stsname )
	else:
		debug( sts.theText() )

###################################################################
# pseq
# Debugging routine. Print the raw acedb text for a
# sequence, given its name.
###################################################################

def pseq( seqname ):
	seq = SequenceClass.gimmeRcd(seqname)
	if seq == None:
		debug("Could not find Sequence " + seqname )
	else:
		debug( seq.theText() )

###################################################################
# getMaxKey
# Utility routine. Given a table name, return the max primary
# key value currently in the database. 
###################################################################

def getMaxKey( tableName ):
	#
	# Utility function that returns the maximum assigned primary
	# key value for the named table. Table must have a declared
	# primary key that is a single integer column.
	#
	tbl = mgischema.getTableByName( tableName )
	if tbl == None:
		die("getMaxKey: could not find table " + tableName )
	pk = tbl.getPrimaryKeyColumns()
	if len(pk) != 1:
		die("getMaxKey: table %s does not have an integer primary key column." % tableName)

	cmd = "select max(%s) from %s" % ( pk[0].getName(), tableName )
	debug("getMaxKey: %s" % cmd)
	results = mgdlib.sql(cmd, "auto")
	key = results[0]['']
	if key == None:
		# table has no records.
		key = 1000
	debug("getMaxKey: %d" % key)
	return key

###################################################################
# getCVkey
# Utility routine. Given a table name, a column name, and
# a string value, return the primary key of the database
# record that matches. Used mainly to return the key for
# a given controlled vocabulary term.
###################################################################

def getCVkey( tableName, colName, value ):
	 
	tbl = mgischema.getTableByName( tableName )
	if tbl == None:
		die("getCVrecord: could not find table " + tableName )
	pk = tbl.getPrimaryKeyColumns()
	if len(pk) != 1:
		die("getCVrecord: table %s does not have an integer primary key column." % tableName)
	pkName = pk[0].getName()

	cmd = "select %s from %s" % (pkName, tableName)
	cmd = cmd + ' where %s = "%s"' % (colName, value)

	debug("getCVrecord: %s" % cmd)
	results = mgdlib.sql(cmd, "auto")

	if len(results) == 0:
		die("getCVkey: could not find %s in %s." % (value, tableName) )
	if len(results) > 1:
		debug("WARNING: getCVkey: %s occurs multiple times in %s." % (value,tableName) )

	debug( "getCVkey: %d" % results[0][pkName] )
	return results[0][pkName]

###################################################################
# findStructureKey
# Given a path of structure names, return the key of the last
# structure in the path. A path is of the form:
#	TS<n>: <name> : <name> : ... : <name>
# E.g.,
#	TS28: postnatal mouse: organ system: sensory organ: eye
###################################################################


def findStructureKey( path ):
	tokens = string.splitfields( path, ':' )
	stage = string.strip(tokens[0][2:])
	key = None
	for i in range(1, len(tokens)):
		name = string.strip( tokens[i])
		cmd = '''
		    select gs._Structure_key, gs.printName
		    from GXD_Structure gs, GXD_StructureName gn
		    where gs._StructureName_key = gn._StructureName_key
		    and gn.structure = "%s"
		    and gs._Stage_key = %s
		    ''' % (name, stage)
		if key == None:
			cmd = cmd + " and gs._Parent_key is null"
		else:
			cmd = cmd + " and gs._Parent_key = %d" % key

		results = mgdlib.sql( cmd, 'auto' )
		if len(results) == 0:
		    die("\tCould not find structure %s in path %s." % (name, path)) 
		if len(results) > 1:
		    debug(`results`)
		    die("\tStructure %s not unique in path %s." % (name, path)) 
		key = results[0]['_Structure_key']
	return key
		
###################################################################
# loadTissueKeys
# Read the file mapping Tom's tissue names to paths in the
# anatomical dictionary. For each one, translate the path
# into a structure key. Build a dictionary mapping Tom's
# name to the structure key.
###################################################################

def loadTissueKeys():
	global tissueMappingFile
	global tissueMapping

	debug("Loading tissue mapping file...")
	tissueMapping_fd = open( tissueMappingFile, 'r')
	line = tissueMapping_fd.readline()
	i = 0
	while line:
	    if string.strip(line) == '':
		    line = tissueMapping_fd.readline()
		    continue
	    tokens = string.splitfields( line, '\t' )
	    if tokens[0] not in tissueList:
		    die("Tissue %s not in tissue list" % tokens[0] )
	    else:
		    key = findStructureKey( tokens[1] )
		    debug( tokens[0] + " = " + `key` )
		    tissueMapping[ tokens[0] ] = [ i, tokens[1], key ]
		    i = i + 1
	    line = tissueMapping_fd.readline()

###################################################################
# searchMarkerByGenbank
# Given a GenBank number, return all associated markers (keys)
# according to the database. (Exclude "P"utative relationships.)
###################################################################

def searchMarkerByGenbank( genbankID ):
	#
	# Given a genbank number, look it up in MGI and return all
	# the associated marker keys.
	#
	global segmentMGItypeKey
	global genbankLDBkey
	cmd = '''
		select pm._Marker_key, pm.relationship
		from PRB_Marker pm, ACC_Accession ac
		where (pm.relationship is null or pm.relationship != "P")
		and pm._Probe_key = ac._Object_key
		and ac._MGIType_key = %d
		and ac._LogicalDB_key = %d
		and ac.accID = "%s"
		''' % (segmentMGItypeKey, genbankLDBkey, genbankID)
	results = mgdlib.sql(cmd, 'auto')
	tmp = []
	for r in results:
	    if not r['_Marker_key'] in tmp:
		    tmp.append( r['_Marker_key'] )

	return tmp

###################################################################
# loadGenBank
# Create a dictionary mapping GenBank numbers to marker
# keys. Base on the spreadsheet file (command line arg).
###################################################################

def loadGenBank():
	#
	# Read in Ken's excel file. Each line contains a genbank number and
	# a marker symbol. Look up the marker symbol in MGI to get its key.
	# (Use MRK_Current_View in case the symbol has changed.) Create
	# a dictionary mapping genbank number to marker key.
	#
	global markerByGenbank
	global stslist

	fd = open("spreadsheet.txt", 'r')
	line = fd.readline()
	while line:
		tokens = string.splitfields( line, '\t' )
		gb = string.strip(tokens[3])
		symbol = string.strip(tokens[4])
		if symbol == "" or symbol == "Sequence not in MGD":
		    line = fd.readline()
		    continue
		cmd = 'select _Current_key from MRK_Current_View where symbol = "%s"' % symbol
		results = mgdlib.sql(cmd, 'auto')
		if len(results) == 0:
			debug("Could not find marker %s" % symbol)
		elif len(results) > 1:
			debug("Multiple markers found for %s" % symbol)
		else:
			key = results[0]['_Current_key']
			#
			# Verify Ken's spreadsheet against MGI. I.e., independently
			# check that MGI associates the same Genbank# and gene.
			#
			if not key in searchMarkerByGenbank( gb ):
			    debug("%s: WARNING: MGI does not associate %s with %s" % (tokens[0], gb, symbol) )
			markerByGenbank[gb] = [ key ]

		line = fd.readline()

###################################################################
# loadMGIdata
# Initialize everything we need from the database, e.g.,
# current max key values, keys for controlled vocabulary
# terms, keys for anatomical structures, etc.
###################################################################

def loadMGIdata():
	global refsKey
	global maxProbeKey 
	global maxProbeRefKey
	global maxAccKey 
	global maxGenotypeKey 
	global maxPrepKey 
	global maxAssayKey 
	global maxLaneKey 
	global maxRowKey 
	global maxBandKey 
	global vectorKeyNA
	global senseKeyNA 
	global labelKeyNA 
	global coverageKeyNA 
	global visualizationKey 
	global assayTypeKey 
	global gelRNAtypeKey 
	global gelUnitsKey 
	global strengthKeyStrong 
	global strengthKeyModerate 
	global strengthKeyTrace 
	global strengthKeyNone 
	global strengthKeyNS 
	global strengthKeyNA 
	global strainKey
	global strainKeyNA
	global maxMGI
	global assayMGItypeKey
	global segmentMGItypeKey
	global imageMGItypeKey
	global genbankLDBkey
	global mgiLDBkey
	global maxCacheKey
	global maxImageKey
	global maxImagePaneKey
	global fieldTypeKeyNA


	#
	# This routine loads data from MGI that we'll need in order
	# to assign keys, connect to genes, etc.
	#

	mgdlib.set_sqlLogin( mgiuser, mgipassword, mgiserver, mgidatabase)


	#
	# Load the mapping from Tom's tissue names to anatomical
	# structure keys.
	#
	debug("Loading tissue keys...")
	loadTissueKeys()

	#
	# Load the schema. We'll need it later...
	#
	global mgischema
	debug("Loading database schema from %s.%s" % (mgiserver, mgidatabase) )
	mgischema = sybaseschema.Database( mgiserver, mgidatabase, mgiuser, mgipassword )
	mgischema.loadFromDBMS()

	#
	# Get the reference for Tom's data
	#
	cmd = 'select _Object_key from ACC_Accession where accID = "%s"' % tomsJnumber
	results = mgdlib.sql(cmd, "auto")
	if len(results) != 1:
		die("loadMGIdata: query for reference %s yielded %d results." %(tomsJnumber, len(results)))
	refsKey = results[0]["_Object_key"]

	# 
	# Need current max keys for the types of objects we'll be
	# creating: probes, accession ids, genotypes, probe preps,
	# gxd assays, gel lanes, rows, and bands.
	#
	maxProbeKey = getMaxKey("PRB_Probe")
	maxProbeRefKey = getMaxKey("PRB_Reference")
	maxAccKey = getMaxKey("ACC_Accession")
	maxGenotypeKey = getMaxKey("GXD_Genotype")
	maxPrepKey = getMaxKey("GXD_ProbePrep")
	maxAssayKey = getMaxKey("GXD_Assay")
	maxLaneKey = getMaxKey("GXD_GelLane")
	maxRowKey = getMaxKey("GXD_GelRow")
	maxBandKey = getMaxKey("GXD_GelBand")
	maxCacheKey = getMaxKey("GXD_Expression")
	maxImageKey = getMaxKey("IMG_Image")
	maxImagePaneKey = getMaxKey("IMG_ImagePane")

	#
	# Load controlled vocabulary key values for:
	#	vector type: N/A
	#	probe sense: N/A
	#	probe label: N/A
	#	probe coverage: N/A
	#	probe visualization: Ethidium bromide
	#	assay type: RT-PCR
	#	gelRNAtype: total
	#	gel row units: bp
	#	strength: need keys for all values
	#
	vectorKeyNA = getCVkey("PRB_Vector_Types", "vectorType", "Not Applicable")
	senseKeyNA = getCVkey("GXD_ProbeSense", "sense", "Not Applicable")
	labelKeyNA = getCVkey("GXD_Label", "label", "Not Applicable")
	coverageKeyNA = getCVkey("GXD_LabelCoverage", "coverage", "Not Applicable")
	visualizationKey = getCVkey("GXD_VisualizationMethod", "visualization", "Ethidium bromide")
	assayTypeKey = getCVkey("GXD_AssayType", "assayType", "RT-PCR")
	gelRNAtypeKey = getCVkey("GXD_GelRNAType","rnaType", "total")
	gelUnitsKey = getCVkey("GXD_GelUnits", "units", "bp")

	strengthKeyStrong = getCVkey("GXD_Strength", "strength", "Strong")
	strengthKeyModerate = getCVkey("GXD_Strength", "strength", "Moderate")
	strengthKeyTrace = getCVkey("GXD_Strength", "strength", "Trace")
	strengthKeyNone = getCVkey("GXD_Strength", "strength", "Absent")
	strengthKeyNS = getCVkey("GXD_Strength", "strength", "Not Specified")
	strengthKeyNA = getCVkey("GXD_Strength", "strength", "Not Applicable")

	fieldTypeKeyNA = getCVkey("IMG_FieldType", "fieldType", "Not Applicable")

	#
	# Find the strain key for C57BL/6J
	#
	strainKey = getCVkey("PRB_Strain", "strain", "C57BL/6J")
	strainKeyNA = getCVkey("PRB_Strain", "strain", "Not Applicable")

	#
	# Load max assigned MGI accession number
	#
	results = mgdlib.sql( 
		'select maxNumericPart from ACC_AccessionMax where prefixPart = "MGI:"',
		'auto')
	maxMGI = results[0]['maxNumericPart']
	debug("Max MGI# = %d" % maxMGI)

	#
	# Load MGI type keys for Segments, Assays, and Images
	#
	segmentMGItypeKey = getCVkey("ACC_MGIType", "name", "Segment")
	assayMGItypeKey = getCVkey("ACC_MGIType", "name", "Assay")
	imageMGItypeKey = getCVkey("ACC_MGIType", "name", "Image")

	#
	# Load logical database keys for MGI and GenBank
	mgiLDBkey = getCVkey("ACC_LogicalDB", "name", "MGI")
	genbankLDBkey = getCVkey("ACC_LogicalDB", "name", "Sequence DB")

	#
	# Load the mapping from GenBank numbers to markers (via Encodes)
	#
	debug("Loading GenBank numbers...")
	loadGenBank()

###################################################################
# getDate
# Get the current system date in a format suitable for 
# loading into Sybase records.
###################################################################

def getDate():
	global now
	now = mgdlib.date('%B %e %Y %T')
	debug("The time is: %s" % now)

###################################################################
# parseACC
# Given an accession number, return its prefix and numeric parts.
###################################################################

acc_re = regex.compile("[0-9]+$")
def parseAcc( acc ):
	pos = acc_re.search(acc)
	if pos == -1:
		return ( acc, "" )
	else:
		return ( acc[:pos], acc[pos:] )

###################################################################
# openBcps
# Open each bcp file for writing.
###################################################################

def openBcps():
	global accBcp 
	global assayBcp 
	global assayNoteBcp 
	global cacheBcp 
	global gelBandBcp 
	global gelLaneBcp 
	global gelRowBcp 
	global gelLaneStructureBcp 
	global genotypeBcp 
	global probePrepBcp 
	global probeBcp
	global probeRefBcp
	global prbMarkerBcp
	global imageBcp
	global imagePaneBcp

	accBcp = open("ACC_Accession.bcp", "w")
	assayBcp = open("GXD_Assay.bcp", "w")
	assayNoteBcp = open("GXD_AssayNote.bcp", "w")
	cacheBcp = open("GXD_Expression.bcp", "w")
	gelBandBcp = open("GXD_GelBand.bcp", "w")
	gelLaneBcp = open("GXD_GelLane.bcp", "w")
	gelRowBcp = open("GXD_GelRow.bcp", "w")
	gelLaneStructureBcp = open("GXD_GelLaneStructure.bcp", "w")
	genotypeBcp = open("GXD_Genotype.bcp", "w")
	probePrepBcp = open("GXD_ProbePrep.bcp", "w")
	probeBcp = open("PRB_Probe.bcp", "w")
	probeRefBcp = open("PRB_Reference.bcp", "w")
	prbMarkerBcp = open("PRB_Marker.bcp", "w")
	imageBcp = open("IMG_Image.bcp", "w")
	imagePaneBcp = open("IMG_ImagePane.bcp", 'w')

###################################################################
# writeBcp
# Given information for one STS, write all the bcp records
# necessary for one RT-PCR assay. Assign new keys and accession
# numbers along the way.
###################################################################

def writeBcp( name, genbankID, length, 
		primer1sequence, p1start, p1stop, 
		primer2sequence, p2start, p2stop,
		temp, time, cycles, mgcl2,
		results, markerKey, nCopies=1 ):

	global now
	global wroteGenotype

	global accBcp 
	global assayBcp 
	global assayNoteBcp 
	global cacheBcp 
	global gelBandBcp 
	global gelLaneBcp 
	global gelRowBcp 
	global gelLaneStructureBcp 
	global genotypeBcp 
	global probePrepBcp 
	global probeBcp
	global probeRefBcp
	global prbMarkerBcp
	global imageBcp
	global imagePaneBcp

	global refsKey
	global maxProbeKey 
	global maxProbeRefKey
	global maxAccKey 
	global maxGenotypeKey 
	global maxPrepKey 
	global maxAssayKey 
	global maxLaneKey 
	global maxRowKey 
	global maxBandKey 
	global maxCacheKey
	global vectorKeyNA
	global senseKeyNA 
	global labelKeyNA 
	global coverageKeyNA 
	global visualizationKey 
	global assayTypeKey 
	global gelRNAtypeKey 
	global gelUnitsKey 
	global strengthKeyStrong 
	global strengthKeyModerate 
	global strengthKeyTrace 
	global strengthKeyNone 
	global strengthKeyNS 
	global strengthKeyNA 
	global strainKey
	global strainKeyNA
	global maxMGI
	global genbankLDBkey
	global mgiLDBkey
	global fieldTypeKeyNA
	global imageMGItypeKey
	global maxImageKey
	global maxImagePaneKey

	debug("\twriteBcp: %s (%d copies)" % (name, nCopies))

	NULL = ""

	######################################
	# Write the primer (probe) record
	#
	maxProbeKey = maxProbeKey + 1
	if p1start == "-1" or p1stop == "-1" or p2start == "-1" or p2stop == "-1":
		regionCoveredNote = ''
	else:
		regionCoveredNote = ("First primer covers from base %s through %s in " + \
			"sequence %s; second primer covers from %s through %s.") \
			% (p1start, p1stop, genbankID, p2start, p2stop)
	probeBcp.write( string.joinfields(
		[ `maxProbeKey`, name, NULL, "-2", `vectorKeyNA`, primer1sequence, 
		  primer2sequence, regionCoveredNote, NULL, NULL, NULL, "primer", 
		  NULL, length, "0", now, now ], '\t') + '\n' )

	######################################
	# Write the probe ref record
	#
	maxProbeRefKey = maxProbeRefKey + 1
	probeRefBcp.write( string.joinfields(
		[ `maxProbeRefKey`, `maxProbeKey`, `refsKey`, "T. Freeman", "0", "0", now, now ],
		'\t') + '\n' )

	######################################
	# Write MGI accession record for the primer
	#
	maxMGI = maxMGI + 1
	maxAccKey = maxAccKey + 1
	accBcp.write( string.joinfields (
		[ `maxAccKey`, "MGI:" + `maxMGI`, "MGI:", `maxMGI`, `mgiLDBkey`,
		  `maxProbeKey`, `segmentMGItypeKey`, "0", "1", now, now, now], '\t') + '\n')
	######################################
	# Write GenBank accession record for the primer
	#
	maxAccKey = maxAccKey + 1
	(pp,np) = parseAcc( genbankID )
	accBcp.write( string.joinfields(
		[`maxAccKey`, genbankID, pp, np, `genbankLDBkey`, `maxProbeKey`,
		 `segmentMGItypeKey`, "0", "0", now, now, now], '\t') + '\n')

	######################################
	# Write the primer-marker association record
	#
	prbMarkerBcp.write( string.joinfields(
		[ `maxProbeKey`, `markerKey`, "A", now, now], '\t') + '\n')


	######################################
	# In some cases, the same primer is used in multiple assays. However, the ACeDB file
	# only has data for one assay per primer. This loop creates n assays for each primer. Each
	# assay has identical data. The idea is that it will be easier for an editor to go
	# in and modify a copy than to enter the additional assays from scratch.
	#
	for copyNum in range(nCopies):

		######################################
		# Write probe prep record
		#
		maxPrepKey = maxPrepKey + 1
		probePrepBcp.write( string.joinfields (
			[ `maxPrepKey`, `maxProbeKey`, `senseKeyNA`, `labelKeyNA`,
			  `coverageKeyNA`, `visualizationKey`, "Not Specified", now, now ], '\t' ) + '\n' )

		######################################
		# Write the image record. Each figure is labelled with the primer name.
		# For primers used in multiple assays, the additional images have labels
		# ending in ".2", ".3", etc.
		#
		figLabel = name
		if copyNum >= 1:
			figLabel = figLabel + '.%d' % (copyNum+1)
		maxImageKey = maxImageKey + 1
		imageBcp.write( string.joinfields(
			[ `maxImageKey`, `refsKey`, NULL, NULL, figLabel, 
			IMAGE_NOTE, COPYRIGHT_NOTE, now, now], '\t') + '\n')

		######################################
		# MGI accession number for the image.
		#
		maxMGI = maxMGI + 1
		maxAccKey = maxAccKey + 1
		accBcp.write( string.joinfields (
			[ `maxAccKey`, "MGI:" + `maxMGI`, "MGI:", `maxMGI`, `mgiLDBkey`,
			  `maxImageKey`, `imageMGItypeKey`, "0", "1", now, now, now], '\t') + '\n')

		######################################
		# Write the image pane record
		#
		maxImagePaneKey = maxImagePaneKey + 1
		imagePaneBcp.write( string.joinfields(
			[ `maxImagePaneKey`, `maxImageKey`, `fieldTypeKeyNA`, 
			NULL, now, now ], '\t' ) + '\n')

		######################################
		# Write assay record
		#
		maxAssayKey = maxAssayKey + 1
		assayBcp.write( string.joinfields(
			[ `maxAssayKey`, `assayTypeKey`, `refsKey`, `markerKey`, `maxPrepKey`, NULL,
			  `maxImagePaneKey`, now, now ], '\t') + '\n' )

		######################################
		# Write MGI accession record for the assay
		#
		maxMGI = maxMGI + 1
		maxAccKey = maxAccKey + 1
		accBcp.write( string.joinfields (
			[ `maxAccKey`, "MGI:" + `maxMGI`, "MGI:", `maxMGI`, `mgiLDBkey`,
			  `maxAssayKey`, `assayMGItypeKey`, "0", "1", now, now, now], '\t') + '\n')
		######################################
		# Write the assay note record
		#
		note = "MgCl2: %s mM; Annealing temp: %s; Annealing time: %s; Cycles: %s" % \
				( mgcl2, temp, time, cycles )
		assayNoteBcp.write( string.joinfields(
			[ `maxAssayKey`, "1", note, now, now ], '\t') + '\n' )

		######################################
		# Write genotype record
		# (Only do this once)
		#
		if not wroteGenotype:
			maxGenotypeKey = maxGenotypeKey + 1
			genotypeBcp.write( string.joinfields(
				[ `maxGenotypeKey`, `strainKeyNA`, now, now], '\t') + '\n')
			maxGenotypeKey = maxGenotypeKey + 1
			genotypeBcp.write( string.joinfields(
				[ `maxGenotypeKey`, `strainKey`, now, now], '\t') + '\n')
			wroteGenotype = 1

		######################################
		# Write gel row record
		#
		maxRowKey = maxRowKey + 1
		gelRowBcp.write( string.joinfields(
		    [`maxRowKey`, `maxAssayKey`, `gelUnitsKey`, 
			"1", length, NULL, now, now], '\t') + '\n')

		######################################
		# Write gel lane records. For each lane, write one gel band record
		#
		for i in range(len(tissueList)):
			laneNum = i + 1
			laneLabel = NULL
			isControl = 0
			age = "postnatal week 6-8"
			ageMin = "63.01"
			ageMax = "77.01"
			ageNote = NULL
			note = NULL
			sampleAmt = ".01"
			sex = "Pooled"

			gk = maxGenotypeKey
			rnaTypeKey = gelRNAtypeKey
			strengthKey = strengthKeyNA
			expressed = 1
			if results[i] == "None":
				strengthKey = strengthKeyNone
				expressed = 0
			elif results[i] == "Trace":
				strengthKey = strengthKeyTrace
			elif results[i] == "Moderate":
				strengthKey = strengthKeyModerate
			elif results[i] == "Strong":
				strengthKey = strengthKeyStrong
			elif results[i] == "Not Specified":
				strengthKey = strengthKeyNS

			if laneNum == 39:
				note = "Non-pregnant"
				sex = "Female"
			elif laneNum == 40:
				note = "Pregnant"
				sex = "Female"
			elif laneNum == 41:
				sex = "Male"
			elif laneNum == 42:
				sex = "Male"
			elif laneNum in [43,44,45]:
				sex = "Female"
			elif laneNum == 46:
				age = "embryonic day 15-16"
				ageMin = "15.0"
				ageMax = "16.0"
			elif laneNum == 47:
				isControl = 1
				note = "Blank - no RT product added."
				age = "Not Applicable"
				ageMin = NULL
				ageMax = NULL
				sex = "Not Applicable"
				strengthKey = strengthKeyNA
				sampleAmt = NULL
				rnaTypeKey = -2
				gk = -2
			elif laneNum == 48:
				isControl = 1
				note = "Human DNA (top); Mouse DNA (bot)"
				age = "Not Applicable"
				ageMin = NULL
				ageMax = NULL
				sex = "Not Applicable"
				strengthKey = strengthKeyNA
				sampleAmt = NULL
				rnaTypeKey = -2
				gk = -2

			maxLaneKey = maxLaneKey + 1
			gelLaneBcp.write( string.joinfields(
				[`maxLaneKey`, `maxAssayKey`, `gk`, `rnaTypeKey`,
				`laneNum`, laneLabel, `isControl`, sampleAmt, sex, age, ageMin, ageMax, 
				ageNote, note, now, now], '\t') + '\n')

			maxBandKey = maxBandKey + 1
			gelBandBcp.write( string.joinfields(
				[`maxBandKey`, `maxLaneKey`, `maxRowKey`, `strengthKey`, 
				NULL, now, now], '\t') + '\n')

			if not isControl:
			    structureKey = tissueMapping[tissueList[i]][2]
			    gelLaneStructureBcp.write( string.joinfields(
				[ `maxLaneKey`, `structureKey`, now, now], '\t') + '\n')

			    maxCacheKey = maxCacheKey + 1
			    cacheBcp.write( string.joinfields(
				[`maxCacheKey`, `maxAssayKey`, `assayTypeKey`, `maxGenotypeKey`,
				`markerKey`, `structureKey`, `expressed`, age, ageMin, ageMax,
				now, now], '\t') + '\n')



###################################################################
# bySTSname
# Comparison routine for sorting a list of STS names.
###################################################################

sts_re = regex.compile("st\([0-9]*\)_\([0-9]*\)")
def bySTSname(sts1, sts2):
	#
	# Comparison function for sorting STS names.
	# Parse name intro year/sequence. Then compare year
	# first, then sequence num. E.g. "st96_45" -> 96, 45
	#
	if sts_re.search(sts1) != -1:
		y1 = string.atoi(sts_re.group(1) )
		n1 = string.atoi(sts_re.group(2) )
		if sts_re.search(sts2) != -1:
			y2 = string.atoi( sts_re.group(1) )
			n2 = string.atoi( sts_re.group(2) )
			if y1 < y2:
				return -1
			elif y1 > y2:
				return 1
			elif n1 < n2:
				return -1
			elif n1 > n2:
				return 1
			else:
				return 0
		else:
			return -1
	elif sts_re.search(sts2) != -1:
		return 1
	elif sts1 < sts2:
		return -1
	elif sts1 > sts2:
		return 1
	else:
		return 0

###################################################################
# processSTS
# Given an STS name, extract the necessary from the ACEDB classes
# and pass along to the routine that write the bcp records.
###################################################################

def processSTS( sts, nCopies = 1 ):

	name = sts.rcdkey
	debug("%s: processing..." % name )

	#
	# If prescreen status == Fail, skip the record.
	#
	status = sts.gimmeTagValue("Prescreen_status")
	if status and string.find( status[0], "Fail" ) != -1:
		debug("\t%s:Status failed. Skipping." % name)
		return

	#
	# Extract results. In the ace file, each sts maps a strength value to some
	# number of tissue. We need to inver this, mapping each tissue to a strength
	# value. At the same time, map Tom's strength values to ours, and fill in
	# "None" as a strength for any tissue not listed.
	#
	someResults = 0
	results = [ "None" ] * len( tissueList )
	for strength in strengthVals.keys():
		ourStrength = strengthVals[ strength ]
		tissue = sts.firstTagValue(strength)
		while tissue:
			try:
			    [i, ourName, ourId] = tissueMapping[ tissue[0] ]
			    results[i] = ourStrength
			    someResults = 1
			except KeyError:
			    debug("\t%s: Tissue not in standard list: %s (%s)" % (name,tissue[0],ourStrength) )
			tissue = sts.nextTagValue(strength)

	if not someResults:
		debug("\t%s: No results. Skipping." % name)
		return

	debug("\t%s has results" % name)
	#
	# Sometimes, the prescreen status field is missing. Next check experimental
	# conditions field. If missing, skip the record. Otherwise, retrieve
	# the exp cond values.
	#
	expCond = sts.gimmeTagValue("Experimental_conditions")
	if expCond == None:
		time = ""
		temp = ""
		cycles = ""
		mgcl2 = ""
		date = "???"
	else:
		date = expCond[1]
		expCond = ExpConditionClass.gimmeRcd(expCond[0])
		(temp, time, cycles) = expCond.gimmeTagValue("Annealing_temp_time_cycle")

		buffer = ProtocolClass.gimmeRcd(expCond.gimmeTagValue("Buffer")[0])
		mgcl2 = buffer.gimmeTagValue("MgCl2")[0]
		# eliminate all but first decimal place
		di = string.find(mgcl2, ".")
		if di != -1:
			mgcl2 = mgcl2[:di+2]

	sts_re.search(name)
	debug("\tIMAGE: %s/%s\t%s@%s" % (sts_re.group(1), sts_re.group(2), cycles, temp))

	length = sts.gimmeTagValue("Expected_product_length")
	if length == None:
		debug("\t%s: No product length field." % name)
		length = ""
	else:
		length = length[0]

	#
	# Get the primer sequences.
	#
	primer1sequence = sts.gimmeTagValue("Oligo_1")[0]
	primer2sequence = sts.gimmeTagValue("Oligo_2")[0]

	#
	# Get the parent sequence record for this STS. Need the GenBank number,
	# the positions of the primer sequences within the complete sequence.
	#
	seq = sts.gimmeTagValue("Parent_sequence")
	if seq == None:
		debug("\t%s: No parent sequence. Skipping." % name)
		return
	seq = SequenceClass.gimmeRcd(seq[0])
	genbankID = seq.rcdkey
	if genbankID[0:3] == "Em:":
	    genbankID = genbankID[3:]

	p1start = p1stop = p2start = p2stop = -1
	oligo = seq.firstTagValue("Oligo")
	while oligo:
		if primer1sequence == oligo[0]:
			p1start = oligo[3]
			p1stop = oligo[4]
		elif primer2sequence == oligo[0]:
			p2start = oligo[3]
			p2stop = oligo[4]
		oligo = seq.nextTagValue("Oligo")

	if p1start == "-1":
		debug("\t%s: Could not match primer 1 in parent sequence record." % name)
	if p2start == "-1":
		debug("\t%s: Could not match primer 2 in parent sequence record." % name)

	#
	# Find the marker key for the GenBank number of this primer
	#
	if not markerByGenbank.has_key( genbankID ):
		debug("\t%s: GenBank ID %s not in MGI" % (name,genbankID))
		debug("\t%s: No BCP records written." % name)
		return

	markerKey = markerByGenbank[ genbankID ][0]
	if len(markerByGenbank[ genbankID ]) > 1:
		debug("\t%s: GenBank ID %s associated with multiple genes. Choosing first one, key = %d" % (name, genbankID, markerKey) )


	#
	# Now pass all these values we just parsed to a routine that
	# will output a collection of bcp records.
	#
	writeBcp( name, genbankID, length, 
		primer1sequence, p1start, p1stop, 
		primer2sequence, p2start, p2stop,
		temp, time, cycles, mgcl2,
		results, markerKey, nCopies )

###################################################################
# MAIN
###################################################################

if len(sys.argv) != 9:
	usage()

acedataFile = sys.argv[1]
stslistFile = sys.argv[2]
spreadsheetFile = sys.argv[3]
tissueMappingFile = sys.argv[4]
mgiserver = sys.argv[5]
mgidatabase = sys.argv[6]
mgiuser = sys.argv[7]
mgipasswordFile = sys.argv[8]

logfd = open( "freeman.load.log", 'w')

getDate()

debug("Reading dbo password...")
fd = open(mgipasswordFile, 'r')
mgipassword = string.strip(fd.readline())
fd.close()
debug("SERVER=%s, DATABASE=%s, USER=%s" % (mgiserver, mgidatabase, mgiuser) )

debug("Loading list of STSs to load...")
stsfd = open( stslistFile, 'r' )
stslist = map( string.split, stsfd.readlines() )
stsfd.close()
debug("%d names loaded" % len(stslist) )

debug("Loading data from MGI...")
loadMGIdata()


debug("Opening ACEDB file...")
aceFile =  AcedbFile( acedataFile )

debug("Loading classes...")
aceFile.loadAcedbClasses( ("STS", "Tissue", "Sequence", "Exp_conditions", "Protocol") )

STSClass = aceFile.gimmeClass("STS")
TissueClass = aceFile.gimmeClass("Tissue")
SequenceClass = aceFile.gimmeClass("Sequence")
ExpConditionClass = aceFile.gimmeClass("Exp_conditions")
ProtocolClass = aceFile.gimmeClass("Protocol")

debug( str( (STSClass,TissueClass,SequenceClass,ExpConditionClass,ProtocolClass) ) )

openBcps()

for stsrec in stslist:
	stsname = stsrec[0]
	nCopies = 1
	if len(stsrec) > 1:
		nCopies = string.atoi(stsrec[1])
	sts = STSClass.gimmeRcd(stsname)
	if sts == None:
		debug("%s: NOT FOUND IN ACE FILE" % stsname)
	else:
		processSTS(sts, nCopies)

#
# update ACC_AccessionMax with the max assigned MGI number
#
cmd = '''
        update ACC_AccessionMax
        set maxNumericPart = %d
        where prefixPart = "MGI:"
        ''' % maxMGI
debug( cmd )
mgdlib.sql(cmd,'auto')

getDate()
debug("Done.")

sys.exit(0)
