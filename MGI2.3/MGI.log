Sat Nov 20 18:00:01 EST 1999
Schema TR 153...
Password: 
Default unbound from table column.
(return status = 0) 
Default unbound from table column.
(return status = 0) 
Object name has been changed.
(return status = 0) 
(14 rows affected)
(1 row affected)
(1 row affected)
(1 row affected)
(1 row affected)
(1 row affected)
(1 row affected)
(1 row affected)
(1 row affected)
(1 row affected)
(1 row affected)
(1 row affected)
(1 row affected)
(1 row affected)
(1 row affected)
(1 row affected)
(1 row affected)
New primary key added.
(return status = 0) 
Msg 2601, Level 14, State 3:
Line 4:
Attempt to insert duplicate key row in object 'HMD_Assay' with unique index
'index_Assay_key'
Command has been aborted.
(0 rows affected)
Msg 2601, Level 14, State 3:
Line 2:
Attempt to insert duplicate key row in object 'HMD_Assay' with unique index
'index_assay'
Command has been aborted.
(0 rows affected)
Default bound to column.
(return status = 0) 
Default bound to column.
(return status = 0) 
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/18451.sql
cat
/opt/sybase/admin/dbo_sql /tmp/18451.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> revoke all on HMD_Assay from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on HMD_Assay to progs
1>  
2> grant all on HMD_Assay to plg, djr, sr, dbradt
1>  
2> grant select on HMD_Assay to public
1> 
2> revoke all on HMD_Class from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant select on HMD_Class to public
1> 
2> grant all on HMD_Class to plg, djr, sr, dbradt
1> 
2> grant all on HMD_Class to progs
1> 
2> revoke all on HMD_Homology_Assay from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on HMD_Notes from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on HMD_Homology to progs
1> 
2> grant all on HMD_Homology to plg, djr, sr, dbradt
1> 
2> grant select on HMD_Homology to public
1> 
2> grant all on HMD_Homology_Assay to progs
1> 
2> grant all on HMD_Homology_Assay to plg, djr, sr, dbradt
1> 
2> grant select on HMD_Homology_Assay to public
1> 
2> revoke all on HMD_Homology_Marker from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant select on HMD_Homology_Marker to public
1> 
2> grant all on HMD_Homology_Marker to plg, djr, sr, dbradt
1> 
2> grant all on HMD_Homology_Marker to progs
1> 
2> grant all on HMD_Notes to progs
1> 
2> grant all on HMD_Notes to plg, djr, sr, dbradt
1> 
2> grant select on HMD_Notes to public
1> 
2> checkpoint
rm /tmp/18451.sql
Schema TR 204 PRB...
Password: 
Msg 2714, Level 16, State 1:
Procedure 'bit_default', Line 1:
There is already an object named 'bit_default' in the database.
Default unbound from table column.
(return status = 0) 
Default unbound from table column.
(return status = 0) 
Default unbound from table column.
(return status = 0) 
Object name has been changed.
(return status = 0) 
(8205 rows affected)
New primary key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
Default bound to column.
(return status = 0) 
Default bound to column.
(return status = 0) 
Default bound to column.
(return status = 0) 
Default bound to column.
(return status = 0) 
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the table 'PRB_Strain_Marker', because it doesn't exist in the
system catalogs.
New primary key added.
(return status = 0) 
Default bound to column.
(return status = 0) 
Default bound to column.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/18465.sql
cat
/opt/sybase/admin/dbo_sql /tmp/18465.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> revoke all on PRB_Alias from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Alias to progs
1> 
2> grant all on PRB_Alias to rmb, djr, neb, plg, mlp, let 
1> 
2> grant select on PRB_Alias to public
1> 
2> revoke all on PRB_Allele from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Allele to progs
1> 
2> grant all on PRB_Allele to rmb, djr, neb, plg, mlp, let 
1> 
2> grant select on PRB_Allele to public
1> 
2> revoke all on PRB_Allele_Strain from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Allele_Strain to progs
1> 
2> grant all on PRB_Allele_Strain to rmb, djr, neb, plg, mlp, let 
1> 
2> grant select on PRB_Allele_Strain to public
1> 
2> revoke all on PRB_Marker from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Marker to progs
1> 
2> grant all on PRB_Marker to rmb, djr, neb, plg, mlp, let 
1> 
2> grant select on PRB_Marker to public
1> 
2> revoke all on PRB_Notes from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Notes to progs
1> 
2> grant all on PRB_Notes to rmb, djr, neb, plg, mlp, let 
1> 
2> grant select on PRB_Notes to public
1> 
2> revoke all on PRB_Probe from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Probe to progs
1> 
2> grant all on PRB_Probe to rmb, djr, neb, plg, mlp, let 
1> 
2> grant select on PRB_Probe to public
1> 
2> revoke all on PRB_Ref_Notes from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Ref_Notes to progs
1> 
2> grant all on PRB_Ref_Notes to rmb, djr, neb, plg, mlp, let 
1> 
2> grant select on PRB_Ref_Notes to public
1> 
2> revoke all on PRB_Reference from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Reference to progs
1> 
2> grant all on PRB_Reference to dab, dph, jms, rmb, djr, neb, plg, mlp, let 
1> 
2> grant select on PRB_Reference to public
1> 
2> revoke all on PRB_RFLV from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_RFLV to progs
1> 
2> grant all on PRB_RFLV to dab, rmb, djr, neb, plg, mlp, let 
1> 
2> grant select on PRB_RFLV to public
1> 
2> revoke all on PRB_Source from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1>  
2> grant all on PRB_Source to progs
1>  
2> grant all on PRB_Source to dab, rmb, djr, neb, plg, mlp, let, jms, dph
1>  
2> grant select on PRB_Source to public
1> 
2> revoke all on PRB_Strain from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Strain to progs
1> 
2> grant all on PRB_Strain to mlp
1> 
2> grant insert on PRB_Strain to editors
1> 
2> grant select on PRB_Strain to public
1> 
2> grant all on PRB_Strain_Marker to mlp, progs, djr, lglass, ljm
1> 
2> revoke all on PRB_Tissue from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Tissue to progs
1>  
2> grant all on PRB_Tissue to dab, rmb, djr, neb, plg, mlp, let
1>  
2> grant select on PRB_Tissue to public
1> 
2> grant all on PRB_Vector_Types to progs
1> 
2> grant all on PRB_Vector_Types to dab, rmb, djr, neb, plg, mlp, let
1> 
2> grant select on PRB_Vector_Types to public
1> 
2> checkpoint
rm /tmp/18465.sql
Schema TR 375...
Password: 
Rule unbound from table column.
(return status = 0) 
Default unbound from table column.
(return status = 0) 
Default unbound from table column.
(return status = 0) 
Object name has been changed.
(return status = 0) 
Rule bound to table column.
(return status = 0) 
Default bound to column.
(return status = 0) 
Default bound to column.
(return status = 0) 
Default bound to column.
(return status = 0) 
(56530 rows affected)
New primary key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
Object name has been changed.
(return status = 0) 
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the table 'MRK_Other', because it doesn't exist in the system
catalogs.
New primary key added.
(return status = 0) 
(6867 rows affected)
Default bound to column.
(return status = 0) 
Default bound to column.
(return status = 0) 
New foreign key added.
(return status = 0) 
New foreign key added.
(return status = 0) 
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
Non-clustered index (index id = 2) is being rebuilt.
Non-clustered index (index id = 3) is being rebuilt.
Non-clustered index (index id = 4) is being rebuilt.
Non-clustered index (index id = 5) is being rebuilt.
(return status = 0) 
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/18479.sql
cat
/opt/sybase/admin/dbo_sql /tmp/18479.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> revoke all on BIB_Books from progs
1> 
2> revoke all on BIB_Books from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on BIB_Books to progs
1> 
2> grant all on BIB_Books to rmb, wjb, djr, neb, jeo
1> 
2> grant select on BIB_Books to public
1> 
2> revoke all on BIB_Notes from progs
1> 
2> revoke all on BIB_Notes from editors
1> 
2> grant all on BIB_Notes to progs
1> 
2> grant all on BIB_Notes to editors 
1> 
2> grant all on BIB_Notes to rmb, wjb, djr, neb, jeo
1> 
2> grant select on BIB_Notes to public
1> 
2> revoke all on BIB_Refs from progs
1> 
2> revoke all on BIB_Refs from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on BIB_Refs to progs
1> 
2> /* add mlp see tr 375 */
3> /* jblake tr 1078 */
4> grant all on BIB_Refs to mlp, rmb, wjb, djr, neb, jeo, sr, ljm, apd, cml, jblake
1> 
2> grant update on BIB_Refs to editors
1> 
2> grant select on BIB_Refs to public
1> 
2> revoke all on BIB_ReviewStatus from progs
1>  
2> revoke all on BIB_ReviewStatus from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1>  
2> grant all on BIB_ReviewStatus to progs
1>  
2> grant all on BIB_ReviewStatus to rmb, wjb, djr, neb, jeo, sr, ljm
1>  
2> grant update on BIB_ReviewStatus to editors
1>  
2> grant select on BIB_ReviewStatus to public
1> 
2> checkpoint
rm /tmp/18479.sql
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/18489.sql
cat
/opt/sybase/admin/dbo_sql /tmp/18489.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> grant all on MRK_Alias to progs
1> 
2> grant all on MRK_Alias to djr, ljm, cgw
1> 
2> grant select on MRK_Alias to public
1> 
2> grant all on MRK_Allele to progs
1> 
2> grant all on MRK_Allele to djr
1> 
2> grant select on MRK_Allele to public
1> 
2> grant all on MRK_Anchors to progs
1> 
2> grant all on MRK_Anchors to djr
1> 
2> grant select on MRK_Anchors to public
1> 
2> grant all on MRK_Chromosome to progs
1> 
2> grant all on MRK_Chromosome to djr, plg, cgw
1> 
2> grant select on MRK_Chromosome to public
1> 
2> grant all on MRK_Class to progs
1> 
2> grant all on MRK_Class to djr, jblake, wjb, cgw
1> 
2> grant select on MRK_Class to public
1> 
2> grant all on MRK_Classes to progs
1> 
2> grant all on MRK_Classes to djr, jblake, wjb, cgw, rmb
1> 
2> grant select on MRK_Classes to public
1> 
2> grant all on MRK_Current to progs
1> 
2> grant all on MRK_Current to djr
1> 
2> grant select on MRK_Current to public
1> 
2> grant all on MRK_History to progs
1> 
2> grant all on MRK_History to djr
1> 
2> grant select on MRK_History to public
1> 
2> grant all on MRK_Marker to progs
1> 
2> grant all on MRK_Marker to djr, plg, ljm, cgw, jblake
1> 
2> grant update on MRK_Marker to lglass
1> 
2> grant select on MRK_Marker to public
1> 
2> grant all on MRK_Name to progs
1> 
2> grant all on MRK_Name to djr, cgw
1> 
2> grant select on MRK_Name to public
1> 
2> grant all on MRK_Notes to progs
1> 
2> grant all on MRK_Notes to djr, cgw
1> 
2> grant select on MRK_Notes to public
1> 
2> grant all on MRK_Offset to progs
1> 
2> /* add mlp see tr 375 */
3> grant all on MRK_Offset to mlp, djr, plg, cgw
1> 
2> grant select on MRK_Offset to public
1> 
2> grant all on MRK_Other to progs
1> 
2> /* see tr #800 */
3> grant all on MRK_Other to editors, jblake
1> 
2> grant select on MRK_Other to public
1> 
2> grant all on MRK_Reference to progs
1> 
2> grant all on MRK_Reference to djr, ljm, cgw, rmb, apd, jblake
1> 
2> grant select on MRK_Reference to public
1> 
2> grant all on MRK_Species to djr, plg, cgw
1> 
2> grant all on MRK_Species to progs
1> 
2> grant select on MRK_Species to public
1> 
2> grant all on MRK_Symbol to progs
1> 
2> grant all on MRK_Symbol to djr, cgw
1> 
2> grant select on MRK_Symbol to public
1> 
2> grant all on MRK_Types to progs
1> 
2> grant all on MRK_Types to djr, cgw
1> 
2> grant select on MRK_Types to public
1> 
2> checkpoint
rm /tmp/18489.sql
Schema triggers/stored procedures/views...
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view ACC_View
1> 
2> create view ACC_View
3> as
4> select a.*, MGIType = m.name,
5> LogicalDB = l.name, l.description, l._Species_key,
6> ActualDB = d.name, d.url, d.allowsMultiple, d.delimiter
7> from ACC_Accession a, ACC_MGIType m, ACC_LogicalDB l, ACC_ActualDB d
8> where a._MGIType_key = m._MGIType_key
9> and a._LogicalDB_Key = l._LogicalDB_key
10> and l._LogicalDB_key = d._LogicalDB_key
11> and d.active = 1
1> 
2> grant select on ACC_View to public
1>  
2> drop view ACC_LogicalDB_View
1> 
2> create view ACC_LogicalDB_View
3> as
4> select a.*, species = s.name
5> from ACC_LogicalDB a, MRK_Species s
6> where a._Species_key *= s._Species_key
1> 
2> grant select on ACC_LogicalDB_View to public
1>  
2> drop view ACC_Reference_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'ACC_Reference_View', because it doesn't exist in the
system catalogs.
1> 
2> create view ACC_Reference_View
3> as
4> select a.*, b.jnum, b.jnumID, b.short_citation
5> from ACC_View a, ACC_AccessionReference r, BIB_All_View b
6> where a._Accession_key = r._Accession_key
7> and r._Refs_key = b._Refs_key
1> 
2> grant select on ACC_Reference_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view BIB_Acc_View
1> 
2> create view BIB_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 1
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on BIB_Acc_View to public
1>  
2> /* BIB_All_View contains all BIB_Refs records, their J#s */
3> /* a long citation and a short citation */
4> 
5> drop view BIB_All_View
1>  
2> create view BIB_All_View
3> as
4> select r.*, 
5> reviewStatus = s.name,
6> jnumID = a.accID, jnum = a.numericPart,
7> citation = r.journal + " " + r.date + ";" + r.vol + "(" + r.issue + "):" + r.pgs,
8> short_citation = r._primary + ", " + r.journal + " " + r.date + ";" + 
9> r.vol + "(" + r.issue + "):" + r.pgs
10> from BIB_Refs r, BIB_ReviewStatus s, ACC_Accession a
11> where r._ReviewStatus_key = s._ReviewStatus_key
12> and r._Refs_key = a._Object_key
13> and a._MGIType_key = 1
14> and a.prefixPart =  "J:"
15> and a.preferred = 1
1>  
2> grant select on BIB_All_View to public
1>  
2> /* BIB_View contains all non-Submission BIB_Refs records, */
3> /* their J#s, a long citation and a short citation */
4> /* Submission references are not currently accessible on the Web */
5> 
6> drop view BIB_View
1> 
2> create view BIB_View
3> as
4> select r.*,
5> reviewStatus = s.name,
6> jnumID = a.accID, jnum = a.numericPart,
7> citation = r.journal + " " + r.date + ";" + r.vol + "(" + r.issue + "):" + r.pgs,
8> short_citation = r._primary + ", " + r.journal + " " + r.date + ";" + 
9> r.vol + "(" + r.issue + "):" + r.pgs
10> from BIB_Refs r, BIB_ReviewStatus s, ACC_Accession a
11> where r._ReviewStatus_key = s._ReviewStatus_key
12> and r._Refs_key = a._Object_key
13> and a._MGIType_key = 1
14> and a.prefixPart =  "J:"
15> and a.preferred = 1
16> and (journal != 'Submission' or journal is null)
1> 
2> grant select on BIB_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view CRS_Cross_View
1> 
2> create view CRS_Cross_View
3> as
4> select c.*, display = whoseCross + " [Type " + type + " (" + abbrevHO + "/" + abbrevHT + ")]",
5> femaleStrain = s1.strain, maleStrain = s2.strain,
6> strainHO = s3.strain, strainHT = s4.strain
7> from CRS_Cross c, PRB_Strain s1, PRB_Strain s2, PRB_Strain s3, PRB_Strain s4
8> where c._femaleStrain_key = s1._Strain_key
9> and c._maleStrain_key = s2._Strain_key
10> and c._StrainHO_key = s3._Strain_key
11> and c._StrainHT_key = s4._Strain_key
1> 
2> grant select on CRS_Cross_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view GXD_Antigen_Acc_View
1>  
2> create view GXD_Antigen_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 7
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on GXD_Antigen_Acc_View to public
1> 
2> drop view GXD_Antibody_Acc_View
1>  
2> create view GXD_Antibody_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 6
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on GXD_Antibody_Acc_View to public
1> 
2> drop view GXD_Assay_Acc_View
1>  
2> create view GXD_Assay_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 8
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on GXD_Assay_Acc_View to public
1> 
2> drop view GXD_Antigen_View
1> 
2> create view GXD_Antigen_View
3> as
4> select g.*, mgiID = a.accID, a.prefixPart, a.numericPart,
5> s.species, s.age, s.sex, s.cellLine, library = s.name,
6> s.description, s._Refs_key, s._Strain_key, s.strain, s._Tissue_key, s.tissue
7> from GXD_Antigen g, GXD_Antigen_Acc_View a, PRB_Source_View s
8> where g._Antigen_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and a.preferred = 1
11> and g._Source_key = s._Source_key
1> 
2> grant select on GXD_Antigen_View to public
1>  
2> drop view GXD_Antibody_View
1>  
2> create view GXD_Antibody_View
3> as
4> select ab.*, mgiID = a.accID, a.prefixPart, a.numericPart, 
5> ac.class, ap.antibodyType, ag.antigenName
6> from GXD_Antibody ab, GXD_Antibody_Acc_View a, GXD_AntibodyClass ac, GXD_AntibodyType ap, GXD_Antigen ag
7> where ab._Antibody_key = a._Object_key
8> and a.prefixPart = "MGI:"
9> and a.preferred = 1
10> and ab._AntibodyClass_key = ac._AntibodyClass_key
11> and ab._AntibodyType_key = ap._AntibodyType_key
12> and ab._Antigen_key *= ag._Antigen_key
1>  
2> grant select on GXD_Antibody_View to public
1>  
2> drop view GXD_AntibodyRef_View
1>  
2> create view GXD_AntibodyRef_View
3> as
4> select a._Antibody_key, a._Refs_key, c.jnumID, c.jnum, c.short_citation
5> from GXD_Antibody a, BIB_All_View c
6> where a._Refs_key = c._Refs_key
1>  
2> grant select on GXD_AntibodyRef_View to public
1>  
2> drop view GXD_AntibodyAntigen_View
1>  
2> create view GXD_AntibodyAntigen_View
3> as
4> select ab._Antibody_key, ab.antibodyName, ag.*
5> from GXD_Antibody ab, GXD_Antigen_View ag
6> where ab._Antigen_key = ag._Antigen_key
1>  
2> grant select on GXD_AntibodyAntigen_View to public
1>  
2> drop view GXD_AntibodyMarker_View
1>  
2> create view GXD_AntibodyMarker_View
3> as
4> select a._Antibody_key, a.antibodyName, am._Marker_key, m.symbol, m.chromosome
5> from GXD_Antibody a, GXD_AntibodyMarker am, MRK_Marker m
6> where a._Antibody_key = am._Antibody_key
7> and am._Marker_key = m._Marker_key
1>  
2> grant select on GXD_AntibodyMarker_View to public
1>  
2> drop view GXD_AntibodyAlias_View
1>  
2> create view GXD_AntibodyAlias_View
3> as
4> select a.antibodyName, aa.*
5> from GXD_Antibody a, GXD_AntibodyAlias aa
6> where a._Antibody_key = aa._Antibody_key
1>  
2> grant select on GXD_AntibodyAlias_View to public
1>  
2> drop view GXD_AntibodyAliasRef_View
1>  
2> create view GXD_AntibodyAliasRef_View
3> as
4> select a.antibodyName, aa.*, c.jnumID, c.jnum, c.short_citation
5> from GXD_Antibody a, GXD_AntibodyAlias aa, BIB_All_View c
6> where a._Antibody_key = aa._Antibody_key
7> and aa._Refs_key = c._Refs_key
1>  
2> grant select on GXD_AntibodyAliasRef_View to public
1>  
2> drop view GXD_Assay_View
1> 
2> create view GXD_Assay_View
3> as
4> select g.*, mgiID = ac.accID, ac.prefixPart, ac.numericPart,
5> aty.assayType, aty.isRNAAssay, aty.isGelAssay,
6> m.symbol, m.chromosome, m.name,
7> c.jnumID, c.jnum, c.short_citation
8> from GXD_Assay g, GXD_Assay_Acc_View ac, GXD_AssayType aty, MRK_Marker m, BIB_All_View c
9> where g._Assay_key = ac._Object_key
10> and ac.prefixPart = "MGI:"
11> and ac.preferred = 1
12> and g._AssayType_key = aty._AssayType_key
13> and g._Marker_key = m._Marker_key
14> and g._Refs_key = c._Refs_key
1> 
2> grant select on GXD_Assay_View to public
1> 
2> drop view GXD_AntibodyPrep_View
1> 
2> create view GXD_AntibodyPrep_View
3> as
4> select a._Assay_key, ap.*, s.secondary, l.label, ab.antibodyName, ac.accID
5> from GXD_Assay a, GXD_AntibodyPrep ap, GXD_Secondary s, GXD_Label l,
6> GXD_Antibody ab, ACC_Accession ac
7> where a._AntibodyPrep_key = ap._AntibodyPrep_key
8> and ap._Secondary_key = s._Secondary_key
9> and ap._Label_key = l._Label_key
10> and ap._Antibody_key = ab._Antibody_key
11> and ab._Antibody_key = ac._Object_key
12> and ac._MGIType_key = 6
13> and ac.prefixPart = "MGI:"
14> and ac.preferred = 1
1> 
2> grant select on GXD_AntibodyPrep_View to public
1> 
2> drop view GXD_ProbePrep_View
1>  
2> create view GXD_ProbePrep_View
3> as
4> select a._Assay_key, pp.*, s.sense, l.label, c.coverage, v.visualization, probeName = p.name, ac.accID
5> from GXD_Assay a, GXD_ProbePrep pp, GXD_ProbeSense s, GXD_Label l, GXD_LabelCoverage c, GXD_VisualizationMethod v,
6> PRB_Probe p, ACC_Accession ac
7> where a._ProbePrep_key = pp._ProbePrep_key
8> and pp._Sense_key = s._Sense_key
9> and pp._Label_key = l._Label_key
10> and pp._Coverage_key = c._Coverage_key
11> and pp._Visualization_key = v._Visualization_key
12> and pp._Probe_key = p._Probe_key
13> and p._Probe_key = ac._Object_key
14> and ac._MGIType_key = 3
15> and ac.prefixPart = "MGI:"
16> and ac.preferred = 1
1>  
2> grant select on GXD_ProbePrep_View to public
1>  
2> drop view GXD_Genotype_View
1>  
2> create view GXD_Genotype_View
3> as
4> select g.*, s.strain
5> from GXD_Genotype g, PRB_Strain s
6> where g._Strain_key = s._Strain_key
1>  
2> grant select on GXD_Genotype_View to public
1>  
2> drop view GXD_AllelePair_View
1> 
2> create view GXD_AllelePair_View
3> as
4> select a.*, m.symbol, allele1 = a1.symbol, allele2 = a2.symbol
5> from GXD_AllelePair a, MRK_Marker m, MRK_Allele a1, MRK_Allele a2
6> where a._Marker_key = m._Marker_key
7> and a._Allele_key_1 = a1._Allele_key
8> and a._Allele_key_2 *= a2._Allele_key
1> 
2> grant select on GXD_AllelePair_View to public
1> 
2> drop view GXD_Specimen_View
1> 
2> create view GXD_Specimen_View
3> as
4> select s.*, e.embeddingMethod, f.fixation, g.strain
5> from GXD_Specimen s, GXD_EmbeddingMethod e, GXD_FixationMethod f, GXD_Genotype_View g
6> where s._Embedding_key = e._Embedding_key
7> and s._Fixation_key = f._Fixation_key
8> and s._Genotype_key = g._Genotype_key
1> 
2> grant select on GXD_Specimen_View to public
1> 
2> drop view GXD_InSituResult_View
1> 
2> create view GXD_InSituResult_View
3> as
4> select r.*, s.strength, p.pattern
5> from GXD_InSituResult r, GXD_Strength s, GXD_Pattern p
6> where r._Strength_key = s._Strength_key
7> and r._Pattern_key = p._Pattern_key
1> 
2> grant select on GXD_InSituResult_View to public
1> 
2> drop view GXD_ISResultImage_View
1> 
2> create view GXD_ISResultImage_View
3> as
4> /* figurepaneLabel is the concatenation of figureLabel and paneLabel for display purposes */
5> select r._Specimen_key, r.sequenceNum, i.*, figurepaneLabel = m.figureLabel + convert(varchar(10), p.paneLabel), 
6> p._Image_key, p.paneLabel, m.figureLabel, m.xDim, m.yDim
7> from GXD_InSituResult r, GXD_InSituResultImage i, IMG_ImagePane p, IMG_Image m
8> where r._Result_key = i._Result_key
9> and i._ImagePane_key = p._ImagePane_key
10> and p._Image_key = m._Image_key
1> 
2> grant select on GXD_ISResultImage_View to public
1> 
2> drop view GXD_GelLane_View
1> 
2> create view GXD_GelLane_View
3> as
4> /* sampleAmount_str is a string version of sampleAmount without trailing zeroes for display purposes */
5> select l.*, t.rnaType, g.strain, c.gelLaneContent,
6> sampleAmount_str = ltrim(str(l.sampleAmount,10,2))
7> from GXD_GelLane l, GXD_GelRNAType t, GXD_Genotype_View g, GXD_GelControl c
8> where l._GelRNAType_key = t._GelRNAType_key
9> and l._Genotype_key = g._Genotype_key
10> and l._GelControl_key = c._GelControl_key
1> 
2> grant select on GXD_GelLane_View to public
1> 
2> drop view GXD_GelRow_View
1> 
2> create view GXD_GelRow_View
3> as
4> /* size_str is a string version of size without trailing zeroes for display purposes */
5> select l.*, size_str = ltrim(str(l.size,10,2)), u.units
6> from GXD_GelRow l, GXD_GelUnits u
7> where l._GelUnits_key = u._GelUnits_key
1> 
2> grant select on GXD_GelRow_View to public
1> 
2> drop view GXD_GelBand_View
1> 
2> create view GXD_GelBand_View
3> as
4> select b.*, s.strength, l._Assay_key, laneNum = l.sequenceNum, rowNum = r.sequenceNum
5> from GXD_GelBand b, GXD_Strength s, GXD_GelLane l, GXD_GelRow r
6> where b._Strength_key = s._Strength_key
7> and b._GelLane_key = l._GelLane_key
8> and b._GelRow_key = r._GelRow_key
1> 
2> grant select on GXD_GelBand_View to public
1> 
2> drop view GXD_GelLaneStructure_View
1> 
2> create view GXD_GelLaneStructure_View
3> as
4> select l._Assay_key, l.sequenceNum, g.*, s.printName, t.stage, t._Stage_key,
5> dbName = "[DB]:  Stage" + convert(varchar(5), t.stage) + ";" + s.printName
6> from GXD_GelLane l, GXD_GelLaneStructure g, GXD_Structure s, GXD_TheilerStage t
7> where l._GelLane_key = g._GelLane_key
8> and g._Structure_key = s._Structure_key
9> and s._Stage_key = t._Stage_key
1> 
2> grant select on GXD_GelLaneStructure_View to public
1> 
2> drop view GXD_ISResultStructure_View
1> 
2> create view GXD_ISResultStructure_View
3> as
4> select r._Specimen_key, r.sequenceNum, g.*, s.printName, t.stage, t._Stage_key,
5> dbName = "[DB]:  Stage" + convert(varchar(5), t.stage) + ";" + s.printName
6> from GXD_InSituResult r, GXD_ISResultStructure g, GXD_Structure s, GXD_TheilerStage t
7> where r._Result_key = g._Result_key
8> and g._Structure_key = s._Structure_key
9> and s._Stage_key = t._Stage_key
1> 
2> grant select on GXD_ISResultStructure_View to public
1> 
2> drop view GXD_Index_View
1> 
2> create view GXD_Index_View
3> as
4> select i.*, m.symbol, c.jnumID, c.jnum, c.short_citation
5> from GXD_Index i, MRK_Marker m, BIB_All_View c
6> where i._Marker_key = m._Marker_key
7> and i._Refs_key = c._Refs_key
1> 
2> grant select on GXD_Index_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view HMD_Homology_View
1> 
2> create view HMD_Homology_View
3> as
4> select r._Class_key, r._Refs_key, r.creation_date, r.modification_date,
5> classRef = convert(varchar(10), r._Class_key) + ':' + convert(varchar(10), r._Refs_key),
6> h._Homology_key, h._Marker_key,
7> m.symbol, m.name, m.chromosome, m.cytogeneticOffset,
8> m._Species_key, m.species, m.commonName, m.latinName,
9> b.jnumID, b.jnum, b.short_citation
10> from HMD_Homology r, HMD_Homology_Marker h, 
11> MRK_Marker_View m, BIB_View b
12> where r._Homology_key = h._Homology_key
13> and h._Marker_key = m._Marker_key
14> and r._Refs_key = b._Refs_key
1> 
2> grant select on HMD_Homology_View to public
1> 
2> drop view HMD_Homology_Assay_View
1> 
2> create view HMD_Homology_Assay_View
3> as
4> select h.*, a.assay
5> from HMD_Homology_Assay h, HMD_Assay a
6> where h._Assay_key = a._Assay_key
1> 
2> grant select on HMD_Homology_Assay_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view IMG_Image_Acc_View
1>  
2> create view IMG_Image_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 9
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on IMG_Image_Acc_View to public
1> 
2> drop view IMG_Image_View
1> 
2> create view IMG_Image_View
3> as
4> select i.*, mgiID = a.accID, a.prefixPart, a.numericPart,
5> c.jnumID, c.jnum, c.short_citation
6> from IMG_Image i, IMG_Image_Acc_View a, BIB_All_View c
7> where i._Image_key = a._Object_key
8> and a.prefixPart = "MGI:"
9> and a.preferred = 1
10> and i._Refs_key = c._Refs_key
1> 
2> grant select on IMG_Image_View to public
1> 
2> drop view IMG_ImagePane_View
1> 
2> create view IMG_ImagePane_View
3> as
4> select i.*, f.fieldType
5> from IMG_ImagePane i, IMG_FieldType f
6> where i._FieldType_key = f._FieldType_key
1> 
2> grant select on IMG_ImagePane_View to public
1> 
2> drop view IMG_ImagePaneRef_View
1> 
2> create view IMG_ImagePaneRef_View
3> as
4> select r._Image_key, r._Refs_key, i._ImagePane_key, paneLabel = r.figureLabel + i.paneLabel,
5> c.jnumID, c.jnum, c.short_citation
6> from IMG_Image r, IMG_ImagePane i, BIB_All_View c
7> where r._Image_key = i._Image_key
8> and r._Refs_key = c._Refs_key
1> 
2> grant select on IMG_ImagePaneRef_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view MGI_Table_Column_View
1> 
2> create view MGI_Table_Column_View
3> as 
4> SELECT _Table_id = t._Table_id, table_name = o.name, table_description = t.description,
5> column_name = c.name, _Column_id = cc._Column_id, column_description = cc.description,
6> example = cc.example, t.creation_date, t.modification_date
7> FROM
8> syscolumns c, MGI_Columns cc, sysobjects o, MGI_Tables t
9> WHERE
10> o.id = t._Table_id AND cc._Column_id = c.colid AND
11> o.id = c.id AND cc._Table_id = t._Table_id AND ((o.type='U'))
1> 
2> grant select on MGI_Table_Column_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view MLD_Acc_View
1>  
2> create view MLD_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 4
7> and a._LogicalDB_key = l._LogicalDB_key
1>  
2> grant select on MLD_Acc_View to public
1>  
2> drop view MLD_Marker_View
1> 
2> create view MLD_Marker_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, g.*, m.symbol, c._primary, c.authors
5> from BIB_View c, MLD_Marker g, MRK_Marker m
6> where g._Refs_key = c._Refs_key
7> and g._Marker_key = m._Marker_key
1> 
2> grant select on MLD_Marker_View to public
1> 
2> drop view MLD_Expt_View
1> 
2> create view MLD_Expt_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, x.*, c._primary, c.authors, 
5> mgiID = a.accID, a.prefixPart, a.numericPart
6> from BIB_View c, MLD_Expts x, MLD_Acc_View a
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and a.preferred = 1
1> 
2> grant select on MLD_Expt_View to public
1> 
2> drop view MLD_Expt_Marker_View
1> 
2> create view MLD_Expt_Marker_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, m.symbol, x.exptType, x.tag, e.*, 
5> allele = al.symbol, assay = a.description, c._primary, c.authors
6> from BIB_View c, MLD_Expts x, MLD_Expt_Marker e, MRK_Allele al, MLD_Assay_Types a, MRK_Marker m
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key = m._Marker_key
10> and e._Allele_key *= al._Allele_key
11> and e._Assay_Type_key = a._Assay_Type_key
1> 
2> grant select on MLD_Expt_Marker_View to public
1> 
2> drop view MLD_FISH_View
1> 
2> create view MLD_FISH_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, s.strain, c._primary, c.authors
5> from BIB_View c, MLD_Expts x, MLD_FISH e, PRB_Strain s
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Strain_key = s._Strain_key
1> 
2> grant select on MLD_FISH_View to public
1> 
2> drop view MLD_Hybrid_View
1> 
2> create view MLD_Hybrid_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, c._primary, c.authors 
5> from BIB_View c, MLD_Expts x, MLD_Hybrid e
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
1> 
2> grant select on MLD_Hybrid_View to public
1> 
2> drop view MLD_Concordance_View
1> 
2> create view MLD_Concordance_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, m.symbol, c._primary, c.authors 
5> from BIB_View c, MLD_Expts x, MLD_Concordance e, MRK_Marker m
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Marker_key *= m._Marker_key
1> 
2> grant select on MLD_Concordance_View to public
1> 
2> drop view MLD_InSitu_View
1> 
2> create view MLD_InSitu_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, s.strain, c._primary, c.authors
5> from BIB_View c, MLD_Expts x, MLD_InSitu e, PRB_Strain s
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Strain_key = s._Strain_key
1> 
2> grant select on MLD_InSitu_View to public
1> 
2> drop view MLD_Matrix_View
1> 
2> create view MLD_Matrix_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, x.tag,
5> e._Expt_key, e.female, e.female2, e.male, e.male2,
6> s.*,
7> femaleStrain = s1.strain, maleStrain = s2.strain,
8> strainHO = s3.strain, strainHT = s4.strain,
9> c._primary, c.authors
10> from BIB_View c, MLD_Expts x, MLD_Matrix e, CRS_Cross s,
11> PRB_Strain s1, PRB_Strain s2, PRB_Strain s3, PRB_Strain s4
12> where c._Refs_key = x._Refs_key
13> and x._Expt_key = e._Expt_key
14> and e._Cross_key = s._Cross_key
15> and s._femaleStrain_key = s1._Strain_key
16> and s._maleStrain_key = s2._Strain_key
17> and s._StrainHO_key = s3._Strain_key
18> and s._StrainHT_key = s4._Strain_key
1> 
2> grant select on MLD_Matrix_View to public
1> 
2> drop view MLD_MC2point_View
1> 
2> create view MLD_MC2point_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, c._primary, c.authors 
6> from BIB_View c, MLD_Expts x, MLD_MC2point e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_MC2point_View to public
1> 
2> drop view MLD_Statistics_View
1> 
2> create view MLD_Statistics_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, x.exptType, x.tag, c._primary, c.authors
6> from BIB_View c, MLD_Expts x, MLD_Statistics e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_Statistics_View to public
1> 
2> drop view MLD_Distance_View
1> 
2> create view MLD_Distance_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, c._primary, c.authors
6> from BIB_View c, MLD_Expts x, MLD_Distance e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_Distance_View to public
1> 
2> drop view MLD_RI_View
1> 
2> create view MLD_RI_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, x.tag, e._Expt_key, e.RI_IdList, 
5> s._RISet_key, s.origin, s.designation, abbrev1 = rtrim(s.abbrev1), abbrev2 = rtrim(s.abbrev2), 
6> c._primary, c.authors 
7> from BIB_View c, MLD_Expts x, MLD_RI e, RI_RISet s
8> where c._Refs_key = x._Refs_key
9> and x._Expt_key = e._Expt_key
10> and e._RISet_key *= s._RISet_key
1> 
2> grant select on MLD_RI_View to public
1> 
2> drop view MLD_RIData_View
1> 
2> create view MLD_RIData_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, m.symbol, c._primary, c.authors 
5> from BIB_View c, MLD_Expts x, MLD_RIData e, MRK_Marker m
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Marker_key = m._Marker_key
1> 
2> grant select on MLD_RIData_View to public
1> 
2> drop view MLD_RI2Point_View
1> 
2> create view MLD_RI2Point_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, c._primary, c.authors 
6> from BIB_View c, MLD_Expts x, MLD_RI2Point e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_RI2Point_View to public
1> 
2> drop view MLD_Hit_View
1>  
2> create view MLD_Hit_View
3> as
4> select x.*, probeKey = h._Probe_key, probe = p1.name, 
5> targetKey = h._Target_key, target = p2.name
6> from MLD_Expts x, MLD_Hit h, PRB_Probe p1, PRB_Probe p2
7> where x._Expt_key = h._Expt_key
8> and h._Probe_key = p1._Probe_key
9> and h._Target_key = p2._Probe_key
1>  
2> grant select on MLD_Hit_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view MRK_Acc_View
1> 
2> create view MRK_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 2
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on MRK_Acc_View to public
1>  
2> drop view MRK_Marker_View
1>  
2> create view MRK_Marker_View
3> as
4> select m.*, 
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species
7> from MRK_Marker m, MRK_Species s
8> where m._Species_key = s._Species_key
1> 
2> grant select on MRK_Marker_View to public
1>  
2> drop view MRK_Mouse_View
1>  
2> create view MRK_Mouse_View
3> as
4> select m.*, o.offset, offset_str = str(o.offset,10,2),
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> mgiID = a.accID, a.prefixPart, a.numericPart, a._Accession_key,
8> markerType = t.name
9> from MRK_Marker m, MRK_Offset o, MRK_Species s, MRK_Acc_View a, MRK_Types t
10> where m._Species_key = 1
11> and m._Marker_key = o._Marker_key
12> and o.source = 0
13> and m._Species_key = s._Species_key
14> and m._Marker_key = a._Object_key
15> and a.prefixPart = "MGI:"
16> and a.preferred = 1
17> and m._Marker_Type_key = t._Marker_Type_key
1> 
2> grant select on MRK_Mouse_View to public
1>  
2> drop view MRK_NonMouse_View
1> 
2> create view MRK_NonMouse_View
3> as
4> select m.*,
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> a.accID, a._Accession_key
8> from MRK_Marker m, MRK_Species s, MRK_Acc_View a
9> where m._Species_key != 1
10> and m._Species_key = s._Species_key
11> and m._Marker_key = a._Object_key
1> 
2> grant select on MRK_NonMouse_View to public
1> 
2> drop view MRK_Alias_View
1> 
2> create view MRK_Alias_View
3> as
4> select a.*, alias = m1.symbol, m2.symbol
5> from MRK_Alias a, MRK_Marker m1, MRK_Marker m2
6> where a._Marker_key = m2._Marker_key
7> and a._Alias_key = m1._Marker_key
1> 
2> grant select on MRK_Alias_View to public
1> 
2> drop view MRK_Classes_View
1> 
2> create view MRK_Classes_View
3> as
4> select c.*, m.symbol, l.name
5> from MRK_Classes c, MRK_Marker m, MRK_Class l
6> where c._Marker_key = m._Marker_key
7> and c._Class_key = l._Class_key
1> 
2> grant select on MRK_Classes_View to public
1> 
2> drop view MRK_History_View
1> 
2> create view MRK_History_View
3> as
4> select h.*, event_display = convert(char(10), h.event_date, 101), history = m1.symbol, m2.symbol
5> from MRK_History h, MRK_Marker m1, MRK_Marker m2
6> where h._Marker_key = m2._Marker_key
7> and h._History_key = m1._Marker_key
1> 
2> grant select on MRK_History_View to public
1> 
2> drop view MRK_History_Ref_View
1>  
2> create view MRK_History_Ref_View
3> as
4> select h.*, event_display = convert(char(10), h.event_date, 101), 
5> history = m1.symbol, m2.symbol,
6> b.jnumID, b.jnum, b.short_citation
7> from MRK_History h, MRK_Marker m1, MRK_Marker m2, BIB_View b
8> where h._Marker_key = m2._Marker_key
9> and h._History_key = m1._Marker_key
10> and h._Refs_key = b._Refs_key
1>  
2> grant select on MRK_History_Ref_View to public
1>  
2> drop view MRK_Current_View
1> 
2> create view MRK_Current_View
3> as
4> select c.*, current_symbol = m1.symbol, m2.symbol, m1.chromosome, m1._Marker_Type_key
5> from MRK_Current c, MRK_Marker m1, MRK_Marker m2
6> where c._Marker_key = m2._Marker_key
7> and c._Current_key = m1._Marker_key
1> 
2> grant select on MRK_Current_View to public
1> 
2> drop view MRK_Anchors_View
1> 
2> create view MRK_Anchors_View
3> as
4> select a.*, m.symbol
5> from MRK_Anchors a, MRK_Marker m
6> where a._Marker_key = m._Marker_key
1> 
2> grant select on MRK_Anchors_View to public
1> 
2> drop view MRK_Reference_View
1> 
2> create view MRK_Reference_View
3> as
4> select r.*, m.symbol, b.jnumID, b.jnum, b.short_citation, b.isReviewArticle
5> from MRK_Reference r, MRK_Marker m, BIB_View b
6> where r._Marker_key = m._Marker_key
7> and r._Refs_key = b._Refs_key
1> 
2> grant select on MRK_Reference_View to public
1> 
2> drop view MRK_AccRef_View
1>  
2> create view MRK_AccRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, ar._Refs_key, b.jnum, b.short_citation
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, BIB_All_View b
6> where a._MGIType_key = 2
7> and a._Accession_key = ar._Accession_key
8> and a._LogicalDB_key = l._LogicalDB_key
9> and a._MGIType_key = m._MGIType_key
10> and ar._Refs_key = b._Refs_key
1>  
2> grant select on MRK_AccRef_View to public
1> 
2> drop view MRK_AccNoRef_View
1>  
2> create view MRK_AccNoRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name,
5> subType = mt.name,
6> description = ma.symbol + ", " + ma.name + ", Chr " + ma.chromosome
7> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, MRK_Marker ma, MRK_Types mt
8> where a._MGIType_key = 2
9> and a._LogicalDB_key = l._LogicalDB_key
10> and a._MGIType_key = m._MGIType_key
11> and a._Object_key = ma._Marker_key
12> and ma._Marker_Type_key = mt._Marker_Type_key
13> and not exists (select r.* from ACC_AccessionReference r
14> where a._Accession_key = r._Accession_key)
1>  
2> grant select on MRK_AccNoRef_View to public
1>  
2> drop view MRK_Other_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'MRK_Other_View', because it doesn't exist in the system
catalogs.
1>  
2> create view MRK_Other_View
3> as
4> select o.*, b.jnumID, b.jnum, b.short_citation, b.isReviewArticle
5> from MRK_Other o, BIB_View b
6> where o._Refs_key = b._Refs_key
1>  
2> grant select on MRK_Other_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view PRB_Acc_View
1> 
2> create view PRB_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 3
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on PRB_Acc_View to public
1> 
2> drop view PRB_AccNoRef_View
1> 
2> create view PRB_AccNoRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, description = p.name
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, PRB_Probe p
6> where a._MGIType_key = 3
7> and a._LogicalDB_key = l._LogicalDB_key
8> and a._MGIType_key = m._MGIType_key
9> and a._Object_key = p._Probe_key
10> and not exists (select r.* from ACC_AccessionReference r
11> where a._Accession_key = r._Accession_key)
1> 
2> grant select on PRB_AccNoRef_View to public
1> 
2> drop view PRB_AccRef_View
1> 
2> create view PRB_AccRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, r._Reference_key
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, PRB_Reference r
6> where a._Accession_key = ar._Accession_key
7> and a._LogicalDB_key = l._LogicalDB_key
8> and a._MGIType_key = m._MGIType_key
9> and a._Object_key = r._Probe_key
10> and ar._Refs_key = r._Refs_key
1> 
2> grant select on PRB_AccRef_View to public
1> 
2> drop view PRB_AccRefNoSeq_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'PRB_AccRefNoSeq_View', because it doesn't exist in the
system catalogs.
1> 
2> create view PRB_AccRefNoSeq_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, r._Reference_key
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, PRB_Reference r
6> where a._Accession_key = ar._Accession_key
7> and a._LogicalDB_Key != 9
8> and a._LogicalDB_key = l._LogicalDB_key
9> and a._MGIType_key = m._MGIType_key
10> and a._Object_key = r._Probe_key
11> and ar._Refs_key = r._Refs_key
1> 
2> grant select on PRB_AccRefNoSeq_View to public
1> 
2> drop view PRB_Strain_Acc_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'PRB_Strain_Acc_View', because it doesn't exist in the
system catalogs.
1> 
2> create view PRB_Strain_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 10
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on PRB_Strain_Acc_View to public
1>  
2> drop view PRB_Source_View
1>  
2> create view PRB_Source_View
3> as
4> select p.*, s.strain, sStandard = s.standard, t.tissue, tStandard = t.standard
5> from PRB_Source p, PRB_Strain s, PRB_Tissue t
6> where p._Strain_key = s._Strain_key 
7> and p._Tissue_key = t._Tissue_key 
1> 
2> grant select on PRB_Source_View to public
1>  
2> drop view PRB_View
1> 
2> create view PRB_View
3> as
4> select p.*, v.vectorType, mgiID = a.accID, a.prefixPart, a.numericPart,
5> s.species, s.age, s.sex, s.cellLine, library = s.name,
6> s.description, s._Refs_key, s._Strain_key, s.strain, s._Tissue_key, s.tissue
7> from PRB_Probe p, PRB_Acc_View a, PRB_Source_View s, PRB_Vector_Types v
8> where p._Probe_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and a.preferred = 1
11> and p._Vector_key = v._Vector_key
12> and p._Source_key = s._Source_key
1> 
2> grant select on PRB_View to public
1> 
2> drop view PRB_Primer_View
1>  
2> create view PRB_Primer_View
3> as
4> select p._Probe_key, p.name,
5> p.regionCovered,
6> p.regionCovered2,
7> p.DNAtype, p.primer1sequence, p.primer2sequence,
8> p.repeatUnit, p.productSize, p.moreProduct,
9> p.creation_date, p.modification_date,
10> mgiID = a.accID, a.prefixPart, a.numericPart
11> from PRB_Probe p, PRB_Acc_View a
12> where p.DNAtype = "primer"
13> and p._Probe_key = a._Object_key
14> and a.prefixPart = "MGI:"
1>   
2> grant select on PRB_Primer_View to public
1>     
2> drop view PRB_Probe_View
1>  
2> create view PRB_Probe_View
3> as
4> select p._Probe_key, p.name,
5> p.regionCovered,
6> p.regionCovered2,
7> p.insertSize, p.DNAtype,
8> p.derivedFrom, parentClone = p2.name,
9> p._Vector_key, v.vectorType, p.insertSite,
10> p.creation_date, p.modification_date,
11> s._Source_key, sourceName = s.name, s._Refs_key,
12> s.species, s.age, s.sex, s.cellLine, s._Strain_key, s.strain, s._Tissue_key, s.tissue,
13> mgiID = a.accID, a.prefixPart, a.numericPart
14> from PRB_Probe p, PRB_Acc_View a, PRB_Source_View s, PRB_Vector_Types v, PRB_Probe p2
15> where p.DNAtype != "primer"
16> and p._Probe_key = a._Object_key
17> and a.prefixPart = "MGI:"
18> and p._Source_key = s._Source_key
19> and p._Vector_key = v._Vector_key
20> and p.derivedFrom *= p2._Probe_key
1> 
2> grant select on PRB_Probe_View to public
1>  
2> drop view PRB_Parent_View
1> 
2> create view PRB_Parent_View
3> as
4> select p._Probe_key, p.name, a.accID, accPrefix = a.prefixPart, accNumeric = a.numericPart,
5> parentKey = p2._Probe_key, parentClone = p2.name,
6> parentID = a2.accID, parentPrefix = a2.prefixPart, parentNumeric = a2.numericPart
7> from PRB_Probe p, PRB_Acc_View a, PRB_Probe p2, PRB_Acc_View a2
8> where p._Probe_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and p.derivedFrom = p2._Probe_key
11> and p2._Probe_key = a2._Object_key
12> and a2.prefixPart = "MGI:"
1> 
2> grant select on PRB_Parent_View to public
1> 
2> drop view PRB_Marker_View
1> 
2> create view PRB_Marker_View
3> as
4> select g._Probe_key, p.name, g._Marker_key, m.symbol, m.chromosome, g.relationship
5> from PRB_Probe p, PRB_Marker g, MRK_Marker m
6> where p._Probe_key = g._Probe_key
7> and g._Marker_key = m._Marker_key
1> 
2> grant select on PRB_Marker_View to public
1> 
2> drop view PRB_Reference_View
1> 
2> create view PRB_Reference_View
3> as
4> select c.jnum, c.jnumID, c.short_citation, r.*
5> from PRB_Reference r, BIB_All_View c
6> where r._Refs_key = c._Refs_key
1> 
2> grant select on PRB_Reference_View to public
1> 
2> drop view PRB_RFLV_View
1> 
2> create view PRB_RFLV_View
3> as
4> select r.*, a._Allele_key, a.allele, a.fragments, s.strain, m.symbol, s._Strain_key
5> from PRB_RFLV r, PRB_Allele a, PRB_Allele_Strain p, PRB_Strain s, MRK_Marker m
6> where r._RFLV_key = a._RFLV_key
7> and a._Allele_key = p._Allele_key
8> and p._Strain_key = s._Strain_key
9> and r._Marker_key = m._Marker_key
1> 
2> grant select on PRB_RFLV_View to public
1> 
2> drop view PRB_SourceRef_View
1>  
2> create view PRB_SourceRef_View
3> as
4> select p.*, c.jnumID, c.jnum, c.short_citation
5> from PRB_Source_View p, BIB_All_View c
6> where p._Refs_key = c._Refs_key
1> 
2> grant select on PRB_SourceRef_View to public
1> 
2> drop view PRB_Strain_Marker_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'PRB_Strain_Marker_View', because it doesn't exist in the
system catalogs.
1> 
2> create view PRB_Strain_Marker_View
3> as
4> select s.*, m.symbol
5> from PRB_Strain_Marker s, MRK_Marker m
6> where s._Marker_key = m._Marker_key
1> 
2> grant select on PRB_Strain_Marker_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view BIB_Summary_All_View
1> 
2> create view BIB_Summary_All_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
8> from ACC_Accession a, ACC_Accession a2, BIB_Refs b
9> where a._MGIType_key = 1
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 1
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = b._Refs_key
1> 
2> grant select on BIB_Summary_All_View to public
1>  
2> drop view BIB_Summary_View
1> 
2> create view BIB_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
8> from ACC_Accession a, ACC_Accession a2, BIB_Refs b
9> where a._MGIType_key = 1
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 1
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = b._Refs_key
17> and (b.journal != 'Submission' or b.journal is null)
1> 
2> grant select on BIB_Summary_View to public
1>  
2> drop view MRK_Summary_View
1>  
2> create view MRK_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = mt.name,
7> description = m.symbol + ", " + m.name + ", Chr " + m.chromosome
8> from ACC_Accession a, ACC_Accession a2, MRK_Marker m, MRK_Types mt
9> where a._MGIType_key = 2
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 2
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = m._Marker_key
17> and m._Species_key = 1
18> and m._Marker_Type_key = mt._Marker_Type_key
1>  
2> grant select on MRK_Summary_View to public
1>  
2> drop view HMD_Summary_View
1>  
2> create view HMD_Summary_View
3> as
4> select a.*,
5> mgiID = null,
6> subType = mt.name,
7> description = m.symbol + ", " + m.name + ", Chr " + m.chromosome
8> from ACC_Accession a, MRK_Marker m, MRK_Types mt
9> where a._MGIType_key = 2
10> and a.private = 0
11> and a._Object_key = m._Marker_key
12> and m._Species_key != 1
13> and m._Marker_Type_key = mt._Marker_Type_key
1>  
2> grant select on HMD_Summary_View to public
1> 
2> drop view PRB_Summary_View
1>  
2> create view PRB_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = p.DNAtype,
7> description = p.name
8> from ACC_Accession a, ACC_Accession a2, PRB_Probe p
9> where a._MGIType_key = 3
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 3
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = p._Probe_key
1>  
2> grant select on PRB_Summary_View to public
1>  
2> drop view MLD_Summary_View
1>  
2> create view MLD_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = e.exptType,
7> description = b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
8> from ACC_Accession a, ACC_Accession a2, MLD_Expts e, BIB_Refs b
9> where a._MGIType_key = 4
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 4
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = e._Expt_key
17> and e._Refs_key = b._Refs_key
1>  
2> grant select on MLD_Summary_View to public
1>  
2> drop view GXD_Antibody_Summary_View
1>  
2> create view GXD_Antibody_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = t.antibodyType,
7> description = g.antibodyName
8> from ACC_Accession a, ACC_Accession a2, GXD_Antibody g, GXD_AntibodyType t
9> where a._MGIType_key = 6
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 6
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = g._Antibody_key
17> and g._AntibodyType_key = t._AntibodyType_key
1>  
2> grant select on GXD_Antibody_Summary_View to public
1>  
2> drop view GXD_Antigen_Summary_View
1>  
2> create view GXD_Antigen_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = g.antigenName
8> from ACC_Accession a, ACC_Accession a2, GXD_Antigen g
9> where a._MGIType_key = 7
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 7
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = g._Antigen_key
1>  
2> grant select on GXD_Antigen_Summary_View to public
1> 
2> drop view GXD_Assay_Summary_View
1>  
2> create view GXD_Assay_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = t.assayType,
7> description = m.symbol
8> from ACC_Accession a, ACC_Accession a2, GXD_Assay g, GXD_AssayType t, MRK_Marker m
9> where a._MGIType_key = 8
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 8
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = g._Assay_key
17> and g._AssayType_key = t._AssayType_key
18> and g._Marker_key = m._Marker_key
1>   
2> grant select on GXD_Assay_Summary_View to public
1> 
2> drop view IMG_Image_Summary_View
1>  
2> create view IMG_Image_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = g.figureLabel + " " + 
8> b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
9> from ACC_Accession a, ACC_Accession a2, IMG_Image g, BIB_Refs b
10> where a._MGIType_key = 9
11> and a.private = 0
12> and a._Object_key = a2._Object_key
13> and a2._LogicalDB_key = 1
14> and a2._MGIType_key = 9
15> and a2.prefixPart = "MGI:"
16> and a2.preferred = 1
17> and a._Object_key = g._Image_key
18> and g._Refs_key = b._Refs_key
1>  
2> grant select on IMG_Image_Summary_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure ACC_resetMax
1> 
2> create procedure ACC_resetMax
3>   @objectKey int,
4>   @mgiType varchar(80),
5>   @prefixPart varchar(20) = "MGI:"
6> as
7> 
8> /* If deleting object which is using the maxNumericPart 
9>    from ACC_AccessionMax, then reset the maxNumericPart
10>    so there aren't so many holes.  During withdrawals,
11>    new Marker symbols may not receive MGI accession numbers,
12>    but the MRK_Marker insert trigger will always insert one
13> */
14> 
15> declare @numericPart int
16> select @numericPart = a.numericPart 
17> from ACC_Accession a, ACC_MGIType m
18> where a._Object_key = @objectKey
19> and a.prefixPart = @prefixPart
20> and a._MGIType_key = m._MGIType_key
21> and m.name = @mgiType
22> 
23> if (select maxNumericPart from ACC_AccessionMax where prefixPart = @prefixPart) = @numericPart
24> begin
25> 	update ACC_AccessionMax
26> 	set maxNumericPart = maxNumericPart - 1
27> 	where prefixPart = @prefixPart
28> end
29> 
1> 
2> grant execute on ACC_resetMax to progs
1> 
2> grant execute on ACC_resetMax to editors
1> 
2> drop procedure ACC_findMax
1> 
2> create procedure ACC_findMax
3>   @prefixPart varchar(20) = "MGI:"
4> as
5> 
6> /* Return maxNumericPart for given prefixPart */
7> 
8> select maxNumericPart
9> from ACC_AccessionMax
10> where prefixPart = @prefixPart
1> 
2> grant execute on ACC_findMax to progs
1> 
2> grant execute on ACC_findMax to editors
1> 
2> grant execute on ACC_findMax to public
1> 
2> drop procedure ACC_assignMGI
1> 
2> create procedure ACC_assignMGI
3>   @objectKey int,
4>   @mgiType varchar(80),
5>   @prefixPart varchar(20) = "MGI:",
6>   @nextMGI int = -1,
7>   @preferred int = 1
8> as
9> 
10> /* Assign MGI or J accession number
11>    Allow override of J accession number
12>    Increment ACC_AccessionMax.maxNumericPart
13> */
14> 
15> declare @nextACC int
16> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
17> 
18> declare @mgiTypeKey int
19> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
20> 
21> if @nextMGI = -1
22> begin
23> 	select @nextMGI = maxNumericPart + 1 
24> 	from ACC_AccessionMax where prefixPart = @prefixPart
25> end
26> else if @prefixPart != "J:"
27> begin
28>     rollback transaction
29>     raiserror 99999 "Cannot override generation of MGI accession number"
30>     return
31> end
32> 
33> declare @accID varchar(30)
34> select @accID = @prefixPart + convert(varchar(20), @nextMGI)
35> 
36> insert into ACC_Accession 
37> (_Accession_key, accID, prefixPart, numericPart, 
38> _LogicalDB_key, _Object_key, _MGIType_key, preferred)
39> values(@nextACC, @accID, @prefixPart, @nextMGI, 1, @objectKey, @mgiTypeKey, @preferred)
40> 
41> if (select maxNumericPart from ACC_AccessionMax
42>     where prefixPart = @prefixPart) <= @nextMGI
43> begin
44> 	update ACC_AccessionMax 
45> 	set maxNumericPart = @nextMGI 
46> 	where prefixPart = @prefixPart
47> end
48> 
1> 
2> grant execute on ACC_assignMGI to progs
1> 
2> grant execute on ACC_assignMGI to editors
1> 
2> drop procedure ACC_assignJ
1> 
2> create procedure ACC_assignJ
3>   @objectKey int,
4>   @nextMGI int = -1
5> as
6> 
7> if @nextMGI != -1
8> begin
9> 	declare @exists int
10> 	select @exists = count(*) from BIB_Acc_View
11>                where prefixPart = "J:" and 
12> 	       numericPart = @nextMGI
13> 	if @exists > 0
14> 	begin
15>   		rollback transaction
16>   		raiserror 99999 "This J Number is already in use"
17>   		return
18> 	end
19> end
20> 
21> exec ACC_assignMGI @objectKey, "Reference", "J:", @nextMGI
22> 
1> 
2> grant execute on ACC_assignJ to progs
1> 
2> grant execute on ACC_assignJ to editors
1> 
2> drop procedure ACCRef_insert
1>  
2> create procedure ACCRef_insert
3>   @accKey int,
4>   @refsKey int
5> as
6>  
7> /* Insert record into ACC_AccessionReference table */
8> 
9> insert into ACC_AccessionReference
10> (_Accession_key, _Refs_key)
11> values(@accKey, @refsKey)
12> 
1>  
2> grant execute on ACCRef_insert to progs
1>  
2> grant execute on ACCRef_insert to editors
1>  
2> drop procedure ACC_insert
1>  
2> create procedure ACC_insert
3>   @objectKey int,
4>   @accID varchar(30),
5>   @logicalDB int,
6>   @mgiType varchar(80),
7>   @refsKey int = -1,
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* Insert record into master Accession table. */
13> /* If reference is given, insert record into Accession Reference table. */
14> 
15> if @accID is null
16> 	return
17> 
18> declare @nextACC int
19> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
20>  
21> declare @mgiTypeKey int
22> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
23>  
24> declare @prefixPart varchar(20)
25> declare @numericPart int
26> exec ACC_split @accID, @prefixPart out, @numericPart out
27> 						      
28> insert into ACC_Accession
29> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
30> values(@nextACC, @accID, @prefixPart, @numericPart, @logicalDB, @objectKey, @mgiTypeKey, @private, @preferred)
31> 
32> if @refsKey != -1
33> begin
34> 	exec ACCRef_insert @nextACC, @refsKey
35> end
36> 
1>  
2> grant execute on ACC_insert to progs
1>  
2> grant execute on ACC_insert to editors
1>  
2> drop procedure ACC_insert_bySpecies
1>  
2> create procedure ACC_insert_bySpecies
3>   @objectKey int,
4>   @accID varchar(30),
5>   @speciesKey int
6> as
7>  
8> /* Insert record into master Accession table for a given species */
9> 
10> if @accID is null
11> 	return
12> 
13> declare @logicalDBKey int
14> select @logicalDBKey = _LogicalDB_key from ACC_LogicalDB 
15> where _Species_key = @speciesKey
16>  
17> declare @private int
18> select @private = 0
19> 
20> exec ACC_insert @objectKey, @accID, @logicalDBKey, "Marker", -1, 1, @private
21>  
1>  
2> grant execute on ACC_insert_bySpecies to progs
1>  
2> grant execute on ACC_insert_bySpecies to editors
1>  
2> drop procedure ACCRef_process
1>  
2> create procedure ACCRef_process
3>   @objectKey int,
4>   @refsKey int,
5>   @accID varchar(30),
6>   @logicalDB int,
7>   @mgiType varchar(80),
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* Disallow edits to WashU data - TR 611 */
13> 
14> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
15> 	   and
16> 	  (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
17> begin
18> 	rollback transaction
19> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
20> 	return
21> end
22> 
23> /* Disallow edits to UniGene data - TR 983 */
24> 
25> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
26> 	   and
27> 	  (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
28> begin
29> 	rollback transaction
30> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
31> 	return
32> end
33> 
34> /* If the Object/Acc ID pair already exists, then use that _Accession_key */
35> /* and simply insert a new ACC_AccessionReference record (ACCRef_insert) */
36> /* Else, create a new ACC_Accession and ACC_AccessionReference record (ACC_insert) */
37> 
38> declare @accKey integer
39> select @accKey = a._Accession_key 
40> from ACC_Accession a, ACC_MGIType m
41> where accID = @accID
42> and a._Object_key = @objectKey
43> and a._MGIType_key = m._MGIType_key
44> and m.name = @mgiType
45> and a._LogicalDB_key = @logicalDB
46> 
47> if @accKey is not null
48> 	exec ACCRef_insert @accKey, @refsKey
49> else
50> 	exec ACC_insert @objectKey, @accID, @logicalDB, @mgiType, @refsKey, @preferred, @private
51> 
1>  
2> grant execute on ACCRef_process to progs
1>  
2> grant execute on ACCRef_process to editors
1>  
2> drop procedure ACC_update
1>  
2> create procedure ACC_update
3>   @accKey int,
4>   @accID varchar(30),
5>   @origRefsKey int = -1,
6>   @refsKey int = -1
7> as
8>  
9> /* Disallow edits to WashU data - TR 611 */
10> 
11> if @refsKey > 0
12>    and
13>    (
14>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
15>    or
16>    exists (select * from BIB_All_View where _Refs_key = @origRefsKey and jnum = 57656)
17>    )
18>    and
19>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
20> begin
21> 	rollback transaction
22> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
23> 	return
24> end
25> 
26> /* Disallow edits to UniGene data - TR 983 */
27> 
28> if @refsKey > 0
29>    and
30>    (
31>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
32>    or
33>    exists (select * from BIB_All_View where _Refs_key = @origRefsKey and jnum = 57747)
34>    )
35>    and
36>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
37> begin
38> 	rollback transaction
39> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
40> 	return
41> end
42> 
43> /* Update the Accession record for a given Accession key */
44> 
45> if @accID is null
46> begin
47> 	exec ACC_delete_byAccKey @accKey
48> end
49> else
50> begin
51> 	declare @prefixPart varchar(20)
52> 	declare @numericPart int
53> 	exec ACC_split @accID, @prefixPart out, @numericPart out
54> 						      
55> 	if (@prefixPart = "J:" or substring(@prefixPart,1,4) = "MGD-")
56> 	begin
57> 		if (select count(*) from ACC_Accession
58> 	    	    where numericPart = @numericPart and
59> 			  prefixPart = @prefixPart) >= 1
60> 		begin
61> 			rollback transaction
62> 			raiserror 99999 "Duplicate MGI Accession Number"
63> 			return
64> 		end
65> 	end
66> 
67> /* Delete all ACC_AccessonReference records for a given Object/Reference */
68> 
69> 	update ACC_Accession
70>   	set accID = @accID, 
71>       	prefixPart = @prefixPart, 
72>       	numericPart = @numericPart,
73>       	modification_date = getdate()
74>   	where _Accession_key = @accKey
75> 
76> 	if @refsKey > 0
77> 	begin
78> 		update ACC_AccessionReference
79> 		set _Refs_key = @refsKey
80>   		where _Accession_key = @accKey and
81> 		      _Refs_key = @origRefsKey
82> 	end
83> end
84> 
1>  
2> grant execute on ACC_update to progs
1>  
2> grant execute on ACC_update to editors
1>  
2> drop procedure ACC_delete_byObject
1> 
2> create procedure ACC_delete_byObject
3>   @objectKey int,
4>   @mgiType varchar(80)
5> as
6> 
7> /* Delete all ACC_Accession/ACC_AccessionReference records for a given Object */
8> 
9> delete ACC_AccessionReference 
10> from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m
11> where a._Object_key = @objectKey
12> and a._MGIType_key = m._MGIType_key
13> and m.name = @mgiType
14> and a._Accession_key = ar._Accession_key
15> 
16> delete ACC_Accession 
17> from ACC_Accession a, ACC_MGIType m
18> where a._Object_key = @objectKey 
19> and a._MGIType_key = m._MGIType_key
20> and m.name = @mgiType
21> 
22> /* May have to reset the MGI or J: Max part */
23> 
24> exec ACC_resetMax @objectKey, @mgiType
25> exec ACC_resetMax @objectKey, @mgiType, "J:"
26> 
1>  
2> grant execute on ACC_delete_byObject to progs
1>  
2> grant execute on ACC_delete_byObject to editors
1>  
2> drop procedure ACC_delete_byAccKey
1> 
2> create procedure ACC_delete_byAccKey
3>   @accKey int,
4>   @refsKey int = -1
5> as
6> 
7> /* Disallow edits to WashU data - TR 611 */
8> 
9> if @refsKey > 0
10>    and
11>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
12>    and
13>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
14> begin
15> 	rollback transaction
16> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
17> 	return
18> end
19> 
20> /* Disallow edits to UniGene data - TR 983 */
21> 
22> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
23> 	   and
24> 	  (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
25> begin
26> 	rollback transaction
27> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
28> 	return
29> end
30> 
31> /* Delete ACC_Accession/ACC_AccessonReference records for a given _Accession_key */
32> 
33> if @refsKey = -1
34> begin
35> 	delete ACC_Accession where _Accession_key = @accKey
36> 	delete ACC_AccessionReference where _Accession_key = @accKey
37> end
38> else
39> begin
40> 	delete ACC_AccessionReference 
41> 	where _Accession_key = @accKey
42> 	and _Refs_key = @refsKey
43> end
44> 
1>  
2> grant execute on ACC_delete_byAccKey to progs
1>  
2> grant execute on ACC_delete_byAccKey to editors
1>  
2> drop procedure ACC_delete_byAccRef
1> 
2> create procedure ACC_delete_byAccRef
3>   @objectKey int,
4>   @refsKey int,
5>   @mgiType varchar(80) = "Segment"
6> as
7> 
8> delete ACC_AccessionReference 
9> from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m
10> where a._Object_key = @objectKey
11> and a._MGIType_key = m._MGIType_key
12> and m.name = @mgiType
13> and a._Accession_key = ar._Accession_key
14> and ar._Refs_key = @refsKey
15>  
1>  
2> grant execute on ACC_delete_byAccRef to progs
1>  
2> grant execute on ACC_delete_byAccRef to editors
1>  
2> /* 1> declare @prefixPart varchar(20) */
3> /* 2> declare @numericPart int */
4> /* 3> exec ACC_split "MGI:12345", @prefixPart out, @numericPart out */
5> /* 4> go */
6> /* (return status = 0) */
7> /* Return parameters: */
8> /* ---- -----------  */
9> /* MGI:       12345  */
10> 
11> drop procedure ACC_split
1> 
2> create procedure ACC_split
3>   @accID varchar(20),
4>   @prefixPart varchar(20) out,
5>   @numericPart integer out
6> as
7> 
8> declare @temp varchar(20) 
9> declare @suffix varchar(20)
10> declare @acclen integer
11> declare @idx integer
12> 
13> /* Remove trailing blanks */
14> select @accID = rtrim(@accID)
15> select @acclen = char_length(@accID)
16> select @temp = reverse(@accID)
17> select @idx  = patindex("%[^0-9]%",@temp)
18> 
19> /* If @idx = 0, then no prefix */
20> 
21> if @idx = 0
22> begin
23>   select @numericPart = convert(integer, @accID)
24>   select @prefixPart = NULL
25> end
26> 
27> else
28> 
29> begin
30>   select @prefixPart = reverse(substring(@temp,@idx,@acclen-@idx+1))
31>   select @suffix = substring(@accID,
32>                              char_length(@prefixPart)+1,
33>                              @acclen - char_length(@prefixPart))
34> 
35>   if @suffix is not NULL
36>      select @numericPart = convert(integer, @suffix)
37>   else
38>      select @numericPart = NULL
39> end
40> 
1> 
2> grant execute on ACC_split to progs
1>  
2> grant execute on ACC_split to editors
1>  
2> grant execute on ACC_split to public
1>  
2> drop procedure ACC_fetch_byLogical
1>  
2> create procedure ACC_fetch_byLogical
3>   @objectKey integer,
4>   @mgiType varchar(80),
5>   @logicalDB varchar(80) = "MGI"
6> as
7>  
8> select a.accID, a.prefixPart, a.numericPart
9> from ACC_Accession a, ACC_MGIType m, ACC_LogicalDB l
10> where a._Object_key = @objectKey
11> and a._MGIType_key = m._MGIType_key
12> and m.name = @mgiType
13> and a._LogicalDB_key = l._LogicalDB_key
14> and l.name = @logicalDB
15> 
1>  
2> grant execute on ACC_fetch_byLogical to progs
1>  
2> grant execute on ACC_fetch_byLogical to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure BIB_byJnum
1> 
2> create procedure BIB_byJnum
3>   @jnum	integer
4> as
5> 
6> /* Selects _Refs_key and short citation for given */
7> /* numeric J: (ex. BIB_byJnum 12345) */
8> 
9> select b._Refs_key, b.short_citation, b.isReviewArticle 
10> from BIB_View b, BIB_Acc_View ba
11> where ba.numericPart = @jnum
12> and ba.prefixPart = "J:"
13> and ba._Object_key = b._Refs_key
1> 
2> grant execute on BIB_byJnum to progs
1> 
2> grant execute on BIB_byJnum to public
1> 
2> drop procedure BIB_HMD_Exists
1> 
2> create procedure BIB_HMD_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of Homology records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from HMD_Homology where _Refs_key = @key
10> 
1> 
2> grant execute on BIB_HMD_Exists to public
1> 
2> drop procedure BIB_MLC_Exists
1> 
2> create procedure BIB_MLC_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of MLC records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from MLC_Reference where _Refs_key = @key
10> union
11> select count(*) from MLC_Reference_edit where _Refs_key = @key
12> 
1> 
2> grant execute on BIB_MLC_Exists to public
1> 
2> drop procedure BIB_MLD_Exists
1> 
2> create procedure BIB_MLD_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of Mapping records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from MLD_Marker where _Refs_key = @key
10> 
1> 
2> grant execute on BIB_MLD_Exists to public
1> 
2> drop procedure BIB_PRB_Exists
1> 
2> create procedure BIB_PRB_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of Molecular Segment records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from PRB_Reference where _Refs_key = @key
10> 
1> 
2> grant execute on BIB_PRB_Exists to public
1> 
2> drop procedure BIB_GXD_Exists
1> 
2> create procedure BIB_GXD_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of GXD index records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from GXD_Index where _Refs_key = @key
10> union
11> select count(*) from GXD_Assay where _Refs_key = @key
12> 
1> 
2> grant execute on BIB_GXD_Exists to public
1> 
2> drop procedure BIB_getYear
1> 
2> create procedure BIB_getYear
3>   @dateStr varchar(30)
4> as
5> 
6> /* Given input string of a date, split out the 4-digit year */
7> 
8> declare @year integer
9> declare @idx integer
10>  
11> select @idx = patindex("%[0-9][0-9][0-9][0-9]%", @dateStr)
12>  
13> if @idx = 0
14> begin
15>         select @year = NULL
16> end
17> else
18> begin
19>         select @year = convert(int, substring(@dateStr, @idx, 4))
20> end
21>  
22> select @year
23> 
1> 
2> grant execute on BIB_getYear to progs
1>  
2> grant execute on BIB_getYear to editors
1>  
2> grant execute on BIB_getYear to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure GXD_loadCacheByAssay
1> 
2> create procedure GXD_loadCacheByAssay
3>   @assayKey int
4> as
5> 
6> /*
7>  * Load the GXD_Expression (cache) table for the given Assay
8>  * Should be called after any modification to any table within
9>  * the GXD_Assay hierarchy.
10>  */
11> 
12> /* Delete any pre-existing cache results for given assay */
13> 
14> delete from GXD_Expression where _Assay_key = @assayKey
15> 
16> /* Retrieve values from GXD_Assay Table for given Assay */
17> 
18> declare @assayTypeKey int	/* Assay Type Key */
19> declare @markerKey int		/* Marker Key */
20> declare @isGelAssay int		/* Is Assay Type a Gel Assay? */
21> 
22> select @assayTypeKey = a._AssayType_key,
23>        @markerKey = a._Marker_key,
24>        @isGelAssay = t.isGelAssay
25> from GXD_Assay a, GXD_AssayType t
26> where a._Assay_key = @assayKey
27> and a._AssayType_key = t._AssayType_key
28> 
29> /* Variables to hold values needed for cache table from Gel/InSitu Results */
30> 
31> declare @laneKey int
32> declare @specimenKey int
33> declare @resultKey int
34> declare @structureKey int
35> declare @genotypeKey int
36> declare @controlKey int
37> declare @age varchar(50)
38> declare @ageMin float
39> declare @ageMax float
40> 
41> declare @isExpressed int	/* was any expression detected? */
42> 
43> /*
44>  * If Assay is a Gel:
45>  *   For each Gel Lane:
46>  *     If Gel Lane is not a Control:
47>  *       If any Gel Bands in the Gel Lane have strength != "Absent":
48>  *         expressed = yes
49>  *       Else:
50>  *         expressed = no
51>  *       For each Structure associated with Gel Lane:
52>  *	   Insert into cache table
53>  * Else If Assay is InSitu:
54>  *   For each Specimen:
55>  *     For each Specimen Result:
56>  *       For each Structure associated with Result:
57>  *         If any Result has strength != "Absent" and != "Not Applicable":
58>  *           expressed = yes
59>  *         Else:
60>  *           expressed = no
61>  *	   Insert into cache table
62>  */
63> 
64> /* If Assay is a Gel */
65> 
66> if (@isGelAssay = 1)
67> begin
68> 
69>   declare lane_cursor cursor for
70>   select _GelLane_key, _Genotype_key, _GelControl_key, age, ageMin, ageMax
71>   from GXD_GelLane
72>   where _Assay_key = @assayKey
73>   for read only
74>  
75>   open lane_cursor
76>   fetch lane_cursor into @laneKey, @genotypeKey, @controlKey, @age, @ageMin, @ageMax
77>  
78>   /* For each Gel Lane */
79> 
80>   while (@@sqlstatus = 0)
81>   begin
82> 
83>     /* If Gel Lane is not a Control (control = No) */
84> 
85>     if (@controlKey = 1)
86>     begin
87> 
88>       /* If any Gel Bands in the Gel Lane have strength != "Absent":
89>        *   expressed = yes
90>        * Else:
91>        *   expressed = no
92>       */
93> 
94>       if (select count(b._GelBand_key) 
95> 	  from GXD_GelBand b, GXD_GelLane l, GXD_Strength s
96> 	  where l._Assay_key = @assayKey
97> 	  and l._GelLane_key = @laneKey
98> 	  and l._GelLane_key = b._GelLane_key
99> 	  and b._Strength_key = s._Strength_key
100> 	  and s.strength != "Absent") > 0
101>       begin
102> 	select @isExpressed = 1
103>       end
104>       else
105>       begin
106> 	select @isExpressed = 0
107>       end
108> 
109>       declare structure_cursor cursor for
110>       select _Structure_key from GXD_GelLaneStructure where _GelLane_key = @laneKey
111>       for read only
112> 
113>       open structure_cursor
114>       fetch structure_cursor into @structureKey
115> 
116>       /* For each Structure associated with Gel Lane */
117> 
118>       while (@@sqlstatus = 0)
119>       begin
120> 
121>         /* Insert into cache table */
122> 
123> 	insert GXD_Expression 
124>         select max(_Expression_key) + 1, 
125> 	       @assayKey, @assayTypeKey, @genotypeKey, @markerKey, @structureKey,
126> 	       @isExpressed, @age, @ageMin, @ageMax, getdate(), getdate()
127> 	from GXD_Expression
128> 
129>         fetch structure_cursor into @structureKey
130>       end
131>       close structure_cursor
132>       deallocate cursor structure_cursor
133>     end
134>     fetch lane_cursor into @laneKey, @genotypeKey, @controlKey, @age, @ageMin, @ageMax
135>   end
136>  
137>   close lane_cursor
138>   deallocate cursor lane_cursor
139> end
140> 
141> /* If Assay is a InSitu */
142> 
143> else
144> begin
145>   declare specimen_cursor cursor for
146>   select _Specimen_key, _Genotype_key, age, ageMin, ageMax
147>   from GXD_Specimen
148>   where _Assay_key = @assayKey
149>   for read only
150> 
151>   open specimen_cursor
152>   fetch specimen_cursor into @specimenKey, @genotypeKey, @age, @ageMin, @ageMax
153> 
154>   /* For each Specimen */
155> 
156>   while (@@sqlstatus = 0)
157>   begin
158>     declare result_cursor cursor for
159>     select _Result_key
160>     from GXD_InSituResult
161>     where _Specimen_key = @specimenKey
162>     for read only
163> 
164>     open result_cursor
165>     fetch result_cursor into @resultKey
166> 
167>     /* For each Specimen Result */
168> 
169>     while (@@sqlstatus = 0)
170>     begin
171> 
172>       /* If Result has strength != "Absent" and != "Not Applicable":
173>        *   expressed = yes
174>        * Else:
175>        *   expressed = no
176>       */
177> 
178>       if (select count(r._Strength_key)
179> 	  from GXD_InSituResult r, GXD_Strength s
180> 	  where r._Result_key = @resultKey
181> 	  and r._Strength_key = s._Strength_key
182> 	  and s.strength != "Absent"
183> 	  and s.strength != "Not Applicable") = 1
184>       begin
185> 	select @isExpressed = 1
186>       end
187>       else
188>       begin
189> 	select @isExpressed = 0
190>       end
191> 
192>       declare structure_cursor cursor for
193>       select _Structure_key
194>       from GXD_ISResultStructure
195>       where _Result_key = @resultKey
196>       for read only
197> 
198>       open structure_cursor
199>       fetch structure_cursor into @structureKey
200> 
201>       /* For each Structure associated with a Result */
202> 
203>       while (@@sqlstatus = 0)
204>       begin
205> 
206>         /* Insert into cache table */
207> 
208> 	insert GXD_Expression 
209>         select max(_Expression_key) + 1, 
210> 	       @assayKey, @assayTypeKey, @genotypeKey, @markerKey, @structureKey,
211> 	       @isExpressed, @age, @ageMin, @ageMax, getdate(), getdate()
212> 	from GXD_Expression
213> 
214>         fetch structure_cursor into @structureKey
215>       end
216>       close structure_cursor
217>       deallocate cursor structure_cursor
218> 
219>       /* Retrieve next Result */
220> 
221>       fetch result_cursor into @resultKey
222>     end
223> 
224>     close result_cursor
225>     deallocate cursor result_cursor
226> 
227>     /* Retrieve next Specimen */
228> 
229>     fetch specimen_cursor into @specimenKey, @genotypeKey, @age, @ageMin, @ageMax
230>   end
231> 
232>   close specimen_cursor
233>   deallocate cursor specimen_cursor
234> end
235>  
1> 
2> grant execute on GXD_loadCacheByAssay to progs
1> 
2> grant execute on GXD_loadCacheByAssay to editors
1> 
2> drop procedure GXD_loadCacheAll
1> 
2> create procedure GXD_loadCacheAll
3> as
4> 
5> /*
6>  * Load the GXD_Expression (cache) table for all Assays
7>  */
8> 
9> declare @assaykey int
10> 
11> declare assay_cursor cursor for
12> select _Assay_key from GXD_Assay
13> for read only
14>  
15> open assay_cursor
16> fetch assay_cursor into @assaykey
17> 
18> while (@@sqlstatus = 0)
19> begin
20>   exec GXD_loadCacheByAssay @assayKey
21>   fetch assay_cursor into @assaykey
22> end
23> 
24> close assay_cursor
25> deallocate cursor assay_cursor
26> 
1> 
2> grant execute on GXD_loadCacheAll to progs
1> 
2> grant execute on GXD_loadCacheAll to editors
1> 
2> 
3> drop procedure IMG_setPDO
1> 
2> create procedure IMG_setPDO (
3> 	@pixID int = NULL, 
4> 	@xDim int, 
5> 	@yDim int, 
6> 	@image_key int
7> ) as 
8> /* If image_key is valid and a PIX foreign accession number
9>    doesnot already exist for the _Image_key and the PIX: accession
10>    ID doesnot already exist, the new ID is added to ACC_Accession
11>    and the x,y dim update the image record.
12>    ASSUMES:
13>    - _LogicalDB_key for "MGI Image Archive" is 19,
14>    - _MGIType_key for mgi Image objects is 9
15>    REQUIRES:
16>    - four integer inputs
17>    - _Image_key exists
18>    - _Image_key is not referenced by an existing PIX:#
19>    - PIX:# does not exist (referencing another _Image_key)
20> */
21> 
22> declare @accID varchar(80), @prefix varchar(4), @imageLDB int, @imageType int
23> 
24> select @prefix = 'PIX:', 
25> 	   @imageLDB = 19,
26> 	   @imageType = 9
27> 
28> if @pixID is NULL or @image_key is NULL or @xDim is NULL or @yDim is NULL
29>   BEGIN
30> 	rollback transaction
31> 	raiserror 99999 "All four arguments must be non-NULL."
32> 	return
33>   END
34> else
35> 	select @accID = @prefix + convert(varchar(10), @pixID)
36> 
37> /* ck for missing image rec */
38> if not exists (select 1 from IMG_Image where _Image_key = @image_key)
39>   BEGIN
40> 	rollback transaction
41> 	raiserror 99999 "%1! _Image_key does not exist.", @image_key
42> 	return
43>   END
44> 
45> /* check that this PIX:# does not already exist */
46> if exists (select 1 from ACC_Accession 
47>    where accID = @accID and _MGIType_key = @imageType
48>    and _LogicalDB_key = @imageLDB 
49>    )
50>   BEGIN
51> 	rollback transaction
52> 	raiserror 99999 "%1! accession already exists.", @accID
53> 	return
54>   END
55> 
56> /* check that image record is not referenced by another PIX:# */
57> if exists (select 1 from ACC_Accession
58>    where _Object_key = @image_key and prefixPart = @prefix
59>    and _LogicalDB_key = @imageLDB and _MGIType_key = @imageType
60>    )
61>   BEGIN
62> 	rollback transaction
63> 	raiserror 99999 "A PIX: accession already exists for _Image_key %1!.", @image_key
64> 	return
65>   END
66> 
67> 
68> /* insert the new PIX: accession record */
69> exec ACC_insert @image_key, 
70> 				@accID, 
71> 				@imageLDB, 
72> 				"Image", 
73> 				-1, 
74> 				1, 
75> 				1
76> 
77> if @@error != 0
78>   BEGIN
79> 	rollback transaction
80> 	raiserror 99999 "ACC_insert failed."
81> 	return	
82>   END
83> 
84> /* set the image dimensions */
85> update IMG_Image set xDim = @xDim, yDim = @yDim
86> where _Image_key = @image_key
87> 
88> if @@error != 0
89>   BEGIN
90> 	rollback transaction
91> 	raiserror 99999, "Update x,y Dimensions failed."
92> 	return
93>   END
94> 
1> 
2> grant execute on IMG_setPDO to progs
1> 
2> grant execute on IMG_setPDO to editors
1> 
2> 
3> /* Structure table stored procs.
4>    Note that these must be executed from within 
5>    a transaction block for rollbacks to work correctly */
6> 
7> drop procedure GXD_SetStructDescPrintName 
1> 
2> create procedure 
3>     GXD_SetStructDescPrintName @structure_key int, @path VARCHAR(255)
4> as
5>        /* Sets the printName of a Structure and all of the descendents 
6>         * that depend on this Structure's printStop status (those descendents
7>         * that do not have printStop set to 1).
8>         *
9>         * definition <current_structure> : 
10>         *          Structure w/_Structure_key = @structure_key  
11>         *
12>         * @structure_key : Structure key of the <current_structure> (the 
13>         *                  structure that might need printName updated)
14>         * @path          : The inclusive path from an ancestor of 
15>         *                  <current_structure> with printStop set to 1. 
16>         *                  This path does not include the <current_structure>'s 
17>         *                  preferred name.
18>         */
19> 
20>        declare @current_prefname VARCHAR(255)
21> 
22>        /* get the preferred name of the current structure */ 
23>        select @current_prefname = sn.structure
24>        from GXD_Structure s, GXD_StructureName sn
25>        where s._Structure_key = @structure_key
26>        and sn._StructureName_key = s._StructureName_key
27> 
28>        /* grow the path using the prefname */
29>        declare @pathlength int
30>        select @pathlength = char_length(@path) + 1 +   /* +1 for ; */
31>                             char_length(@current_prefname)
32>        if @pathlength > 255 
33>        begin
34>             /* truncate the path with an ellipsis. Look for one */
35>             declare @ellipsis int 
36>             declare @numchars_to_remove int
37> 
38>             /* number of characters to remove from @path so we have room
39>                for the ellipsis, ';', and current_prefname */
40>             select @numchars_to_remove = @pathlength - 255 + 3
41> 
42>             select @ellipsis = charindex("...", @path)
43>             if @ellipsis = 0  /* then no ellipsis yet, add one */
44>               begin
45>                  select @path = substring(@path,1,255-@numchars_to_remove)
46>                                 + "..."
47>               end
48>             else
49>               begin
50>                  /* find the ellipsis, and remove text to the right of it */
51>                  select @path = substring(@path,@ellipsis + 3,255) 
52>               end
53>        end
54> 
55>        if char_length(rtrim(@path)) > 0
56>            select @path = rtrim(@path) + ";" + @current_prefname
57>        else
58>            select @path = @current_prefname
59> 
60>        /* update the current node's printName */
61> 
62>        update GXD_Structure
63>        set printName = @path
64>        where _Structure_key = @structure_key 
65> 
66>        if @@error != 0  /* then update failed */ 
67>        begin
68>             raiserror 99999 "GXD_SetStructDescPrintName: Update of printName failed"
69>             rollback transaction
70>             return
71>        end
72>     
73>        /* Now fixup immediate descendent's printNames */
74> 
75>        declare @dek int
76> 
77>        declare desc_cursor cursor 
78>        for select s._Structure_key
79>            from GXD_Structure s
80>            where s._Parent_key = @structure_key 
81>              and s.printStop = 0     /* if printStop is 1, we can ignore it */
82>       
83> 
84>       open desc_cursor
85>       fetch desc_cursor into @dek
86> 
87>       while (@@sqlstatus = 0)
88>       begin 
89>          exec GXD_SetStructDescPrintName @dek, @path
90>          if @@error != 0  /* transaction failed for some reason */
91>          begin
92>             rollback transaction  /* rollback and return */
93>             raiserror 99999 "GXD_SetStructDescPrintName: Recursive call failed"
94>             close desc_cursor
95>             return
96>          end
97>          fetch desc_cursor into @dek 
98>       end
99> 
100>       close desc_cursor
1> 
2> 
3> grant execute on GXD_SetStructDescPrintName to progs
1> 
2> grant execute on GXD_SetStructDescPrintName to editors
1> 
2> 
3> drop procedure GXD_ComputePrintNamesFrom
1> 
2> 
3> create procedure
4>     GXD_ComputePrintNamesFrom  @structure_key int = null
5> as
6>    /* Changes printName for node with _Structure_key = @structure_key,
7>     * and all of its descendents, as appropriate.
8>     *
9>     * uses GXD_SetStructDescPrintName to set descendent's printNames.
10>     */
11> 
12>    if @structure_key is null
13>    begin
14>           rollback transaction
15>           raiserror 99999 "GXD_ComputePrintNamesFrom: Structure key not provided"
16>           return
17>    end
18>    else
19>    begin
20>        declare @printStop bit
21>        declare @path VARCHAR(255)
22>        
23>        /* get the printStop of the specified structure */
24> 
25>        select @printStop = s.printStop
26>               from GXD_Structure s
27>               where s._Structure_key = @structure_key
28> 
29>        /* path to the current node */ 
30>        select @path = ""
31> 
32>        if @printStop = 0 
33>        begin
34>             /* we must determine the path by moving up the tree until
35>                we find an ancestor with a printStop set, accumulating
36>                the path.
37>              */
38>             declare @ansk int  /* ancestor structure key */
39>             declare @aprintStop bit
40>             declare @aprefname VARCHAR(255)
41> 
42>             declare ancest_cursor cursor
43>             for select c._Structure_key
44>                 from GXD_Structure s, GXD_StructureClosure c
45>                 where c._Descendent_key = @structure_key
46>                 and c._Structure_key = s._Structure_key
47>                 order by s.treeDepth desc 
48> 
49>             open ancest_cursor
50>             fetch ancest_cursor into @ansk
51> 
52>             while (@@sqlstatus = 0)
53>             begin
54>                /* we have an ancestor, find out its printStop status */
55>                select @aprintStop = s.printStop, @aprefname = sn.structure
56>                from GXD_Structure s, GXD_StructureName sn
57>                where s._Structure_key = @ansk 
58>                and s._StructureName_key = sn._StructureName_key
59>                   
60>                select @path = ltrim(rtrim(@aprefname)) + @path 
61> 
62>                if @aprintStop = 1   /* found a printStop set */
63>                   break
64>                else                 /* we need to go higher */ 
65>                   select @path = ";" + @path
66> 
67>                fetch ancest_cursor into @ansk  /* get another key */
68>             end
69> 
70>             close ancest_cursor
71>        end
72> 
73>        /* @path is now set appropriately, downto the current node,
74>           but not inclusive of it. Now, fixup all the descendents */ 
75>           
76>        begin transaction
77> 
78>        exec GXD_SetStructDescPrintName @structure_key, @path
79>        if @@error != 0
80>        begin
81>           rollback transaction
82>           raiserror 99999 "GXD_ComputePrintNamesFrom: call to GXD_SetStructDescPrintName failed"
83>           return
84>        end
85>        else
86>           commit transaction
87>    end
1>        
2> grant execute on GXD_ComputePrintNamesFrom to progs
1> 
2> grant execute on GXD_ComputePrintNamesFrom to editors
1> 
2> 
3> drop procedure GXD_SetPreferredName
1> 
2> create procedure GXD_SetPreferredName 
3>      @structure_key int = null, @name varchar(255) = null
4> as
5>    /* 
6>     * Sets the preferred name of the structure whose _Structure_key = 
7>     * @structure_key.  Deletes the StructureName that *was* the preferred
8>     * name iff the current preferred name is different from the one being
9>     * set. Modifies the GXD_Structure and GXD_StructureName
10>     * tables.  Fails if node is not MGI-added (edinburghkey != NULL).
11>     *
12>     * If a StructureName doesn't exist where _Structure_key = @structure_key
13>     * and @name = structure, then a new StructureName record 
14>     * is created with _Structure_key = @structure_key, and structure = @name. 
15>     *
16>     * The _StructureName_key attribute of the structure with _Structure_key = 
17>     * @structure_key is set to point to either the existing or newly-created
18>     * StructureName record.  
19>     *
20>     * Always sets modification_date to getdate(), even if a new structurename
21>     * isn't created.  The ADI relies on this behavior.
22>     *
23>     */
24>    
25>    if @structure_key is null
26>    begin
27>        rollback transaction
28>        raiserror 99999 "GXD_SetPreferredName: Structure key not provided"
29>        return
30>    end
31>     
32>    if @name is null
33>    begin
34>        rollback transaction
35>        raiserror 99999 "GXD_SetPreferredName: Name not provided"
36>        return
37>    end
38> 
39>    if (select edinburghkey 
40>        from GXD_Structure s
41>        where s._Structure_key = @structure_key) != NULL
42>    begin
43>        rollback transaction
44>        raiserror 99999 "GXD_SetPreferredName: Cannot set preferred name for non MGI-added structures"
45>        return
46>    end
47>   
48>    /* determine the current preferred name key */
49>    declare @cpnk integer       /* current structure name key */
50> 
51>    select @cpnk = sn._StructureName_key
52>    from GXD_Structure s, GXD_StructureName sn
53>    where s._Structure_key = @structure_key
54>    and s._Structure_key = sn._Structure_key
55>    and s._StructureName_key = sn._StructureName_key
56> 
57>    declare @ctsn integer 
58>    declare @different integer  /* set to true if our set name !=
59>                                   current preferred name */ 
60>    select @different = 0       /* assume we are changing the 
61>                                   preferred name to the *same* name */
62>  
63>    /* find out how many StructureName entries match our desired preferred
64>       name */
65>    select @ctsn = count(*) 
66>                   from GXD_StructureName
67>                   where _Structure_key = @structure_key
68>                   and structure = @name
69> 
70>    if @ctsn = 0  /* if none, then we must create the StructureName */ 
71>    begin         /* and delete the old one */
72>        select @different = 1  /* set delete flag for current pref. name */
73> 
74>        declare @snk integer
75> 
76>        /* insert the new StructureName */
77>        select @snk = max(_StructureName_key) + 1 from GXD_StructureName
78>        insert into GXD_StructureName (_StructureName_key, _Structure_key,
79>                                       structure, mgiAdded) 
80>        values(@snk, @structure_key, @name, 1)
81> 
82>        if @@error != 0  /* then insert failed */ 
83>        begin
84>             rollback transaction
85> 	        raiserror 99999 "Insert into GXD_StructureName failed"
86>             return
87>        end
88>       
89>        /* set ctsn to 1, as if the StructureName had been there all along */
90>        select @ctsn = 1
91>    end
92> 
93>    if @ctsn = 1 /* then update GXD_Structure to reference this name */
94>    begin
95>         update GXD_Structure 
96>                   set _StructureName_key = (
97>                       select _StructureName_key 
98>                       from GXD_StructureName
99>                       where _Structure_key = @structure_key
100>                       and structure = @name )
101>                   where _Structure_key = @structure_key
102> 
103>        if @@error != 0  /* then insert failed */ 
104>        begin
105>           rollback transaction
106> 	      raiserror 99999 "GXD_SetPreferredName: Update of _StructureName_key in GXD_Structure failed"
107>           return
108>        end
109>       
110>        /* we update the structurename's modification date, regardless */ 
111> 
112>        update GXD_StructureName
113>               set modification_date = getdate()
114>               where _StructureName_key = @cpnk
115> 
116>        if @@error != 0  /* then update failed */ 
117>        begin
118>           rollback transaction
119> 	      raiserror 99999 "GXD_SetPreferredName: Update of modification_date in GXD_Structure failed"
120>           return
121>        end
122> 
123>        /* delete the current structureName, referenced by the structure's
124>           _StructureName_key, if we have a new structureName to point to */
125> 
126>        if @different = 1
127>        begin
128>            delete from GXD_StructureName
129>            where _Structure_key = @structure_key 
130>            and _StructureName_key = @cpnk
131>        
132>            if @@error != 0  /* then insert failed */ 
133>            begin
134>               rollback transaction
135> 	          raiserror 99999 "GXD_SetPreferredName: Could not delete previous preferred name"
136>               return
137>            end
138>        end
139> 
140>        /* recompute printNames, since the Update trigger cannot without
141>           causing infinite recursive calls */
142> 
143>        exec GXD_ComputePrintNamesFrom @structure_key
144>        if @@error != 0  /* then insert failed */ 
145>        begin
146>           rollback transaction
147> 	      raiserror 99999 "GXD_SetPreferredName: Call to GXD_ComputePrintNamesFrom failed"
148>           return
149>        end
150>    end
151>    else  /* then greater than 1, an error */
152>    begin
153> 	  rollback transaction
154> 	  raiserror 99999 "GXD_SetPreferredName: Duplicate names for structure in GXD_StructureName"
155> 	  return	
156>    end
157>              
158> 
1> 
2> grant execute on GXD_SetPreferredName to progs
1> 
2> grant execute on GXD_SetPreferredName to editors
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure HMD_getChromosomes
1> 
2> create procedure HMD_getChromosomes
3>                 @_Species_key int = NULL
4> as
5> /*
6>  * 	Procedure takes a species key and returns the ordered
7>  *	list of chromosomes.
8>  *
9>  *	DOW Jan 17, 1996
10>  */
11> select chromosome 
12> from MRK_Chromosome 
13> where _Species_key = @_Species_key 
14> order by sequenceNum
1> 
2> grant execute on HMD_getChromosomes to public
1> 
2> drop procedure HMD_getOxfordGrid
1> 
2> create procedure HMD_getOxfordGrid
3>                 @Species1 int = NULL,
4>                 @Species2 int = NULL
5> as
6> 
7> /* Return all Chromosome Pairs/Homology Classes involving Species 1 & Species 2 */
8> /* Include Chromosome UN. To exclude, add the following where clauses */
9> /*	    m1.chromosome != 'UN' and	*/
10> /*	    m2.chromosome != 'UN'	*/
11> 
12> select distinct c1 = m1.chromosome, c2 = m2.chromosome, h1._Class_key
13>                 from    MRK_Marker m1,
14>                         MRK_Marker m2,
15>                         HMD_Homology h1,
16>                         HMD_Homology h2,
17>                         HMD_Homology_Marker hm1,
18>                         HMD_Homology_Marker hm2
19>                 where   m1._Species_key = @Species1 and
20>                         m1._Marker_key = hm1._Marker_key and
21> 			hm1._Homology_key = h1._Homology_key and
22>                         h1._Class_key = h2._Class_key and
23> 			h2._Homology_key = hm2._Homology_key and
24>                         hm2._Marker_key = m2._Marker_key and
25>                         m2._Species_key = @Species2 
26> order by c1, c2
27>  
1> 
2> grant execute on HMD_getOxfordGrid to public
1>  
2> drop procedure HMD_hasHomology
1> 
2> create procedure HMD_hasHomology
3>                 @_Marker_key int = NULL,
4>                 @_Refs_key int = NULL
5> as
6> /*
7>  * 	Procedure takes either a Marker key or a Ref key,
8>  *	and determines whether not a homology will exists.
9>  *	For a homology to be returned, for a _Class_key,
10>  *	there must be more than one marker.
11>  *
12>  *	DOW Jan 10, 1996
13>  */
14> declare @count int
15> declare @has_Homology int
16> create table #classes
17>         (_Class_key int)
18> 
19> /*
20>  *	has_Homology is the value to be returned.
21>  *	Default is "no homology" 
22>  */	
23> select @has_Homology = 0
24> 
25> /*	Do with a query using a _Marker_key...	*/
26> if (@_Marker_key != NULL and @_Refs_key = NULL)
27>         insert #classes
28>         select h._Class_key
29>         from HMD_Homology h, HMD_Homology_Marker m
30>         where m._Marker_key = @_Marker_key and
31> 	      m._Homology_key = h._Homology_key
32> /*	...or a _Refs_key...	*/
33> else if (@_Refs_key != NULL and @_Marker_key = NULL)
34>         insert #classes
35>         select _Class_key
36>         from HMD_Homology
37>         where _Refs_key = @_Refs_key
38> /*	...but not both!!	*/
39> else
40> begin
41> 	print 'Cannot process with both _Refs_key AND _Marker_key!'
42> 	select @has_Homology
43> 	return 
44> end
45> 
46> /*
47>  *	Cursor simply does a count of distinct markers(species) in a class
48>  */
49> declare classCount cursor for
50> select count(distinct m._Marker_key)
51> from HMD_Homology h, HMD_Homology_Marker m, #classes c
52> where h._Class_key = c._Class_key
53>       and h._Homology_key = m._Homology_key
54> group by h._Class_key
55> for read only
56> 
57> open classCount
58> 
59> /*	Pull out classes, one by one...	*/
60> fetch classCount
61>         into @count
62> 
63> /*	Nothing here... bail out!	*/
64> if (@@sqlstatus = 2)
65> begin
66> 	print 'Nothing found'
67> 	select @has_Homology
68>         return 
69> end
70> /*
71>  * 	If cursor result is not empty, then process
72>  * 	each row to determine if class has a homology
73>  * 	including more than one species (marker).
74>  */
75> while (@@sqlstatus = 0)
76> begin
77>         if (@count > 1)
78> /*	There is a valid homology within this class.	*/
79>                 select @has_Homology = 1
80> 
81> /*	Fetch next row.	*/
82>         fetch classCount
83>                 into @count
84> end
85> /*	This select will return the value of @has_Homology as a row of data */
86> select @has_Homology
87> 
88> close classCount
89> 
90> deallocate cursor classCount
1> 
2> grant execute on HMD_hasHomology to public
1>  
2> checkpoint
1> 
2> drop procedure HMD_updateClass
1> 
2> create procedure HMD_updateClass
3>   @_Class_key integer,
4>   @_Refs_key integer,
5>   @isNewClass integer = 1
6> as
7> 
8> /* Merge classes of Homologies which, due to a new Homology record */
9> /* should really be one class (due to transitivity nature of Homology) */
10> 
11> /* For each Class which exists which contains Markers from New Class... */
12> 
13> select _Class_key = @_Class_key
14> into #classes
15> union
16> select distinct h2._Class_key 
17> from HMD_Homology h1, HMD_Homology_Marker hm1, 
18>      HMD_Homology h2, HMD_Homology_Marker hm2
19> where h1._Class_key = @_Class_key and
20>       h1._Homology_key = hm1._Homology_key and
21>       hm1._Marker_key = hm2._Marker_key and
22>       hm2._Homology_key = h2._Homology_key and
23>       h2._Class_key != @_Class_key
24> 
25> /* Select all Species/Symbol pairs from the New Class */
26> 
27> select distinct hm._Marker_key, m._Species_key
28> into #markers
29> from #classes c, HMD_Homology h, HMD_Homology_Marker hm, MRK_Marker m
30> where c._Class_key = h._Class_key and
31>       h._Homology_key = hm._Homology_key and
32>       hm._Marker_key = m._Marker_key
33> 
34> declare @speciesKey integer
35> declare @dupspeciesKey integer
36> declare @do_update integer
37> select @do_update = 1
38> 
39> /* Fetch counts for Species/Symbol pairs */
40> 
41> declare classCount cursor for select _Species_key from #markers group by _Species_key having count(*) > 1
42> open classCount
43> fetch classCount into @speciesKey
44> 
45> while (@@sqlstatus = 0)
46> begin
47> 	select @do_update = 0
48> 	select @dupspeciesKey = @speciesKey
49> 	fetch classCount into @speciesKey
50> end
51> 
52> close classCount
53> deallocate cursor classCount
54> 
55> if (@do_update = 1) /* Merge Classes */
56> begin
57>         update HMD_Homology
58> 	set _Class_key = @_Class_key
59> 	from #classes c, HMD_Homology h
60> 	where c._Class_key = h._Class_key
61> 
62> 	/* Return the @_Class_key:@_Refs_key */
63> 	select convert(varchar(10), @_Class_key) + ':' + convert(varchar(10), @_Refs_key)
64> end
65> else
66> begin
67> 	declare @species varchar(255)
68> 	select @species = name from MRK_Species where _Species_key = @dupspeciesKey
69> 
70> 	/* Return the @_Class_key:@_Refs_key */
71> 	select convert(varchar(10), @_Class_key) + ':' + convert(varchar(10), @_Refs_key)
72> 
73> 	/* If this is a new class record, then delete it if there is a conflict */
74> 	if (@isNewClass = 1)
75> 	begin
76> 		delete from HMD_Class where _Class_key = @_Class_key
77> 	end
78> 
79> 	raiserror 99999 "Another Homology has been detected which conflicts with Species:  %1!", @species
80> 
81> end
82> 
1> 
2> grant execute on HMD_updateClass to progs
1> 
2> grant execute on HMD_updateClass to editors
1> 
2> checkpoint
1> 
2> drop procedure HMD_Cleanup
1> 
2> create procedure HMD_Cleanup
3>   @_Class_key integer,
4>   @_Homology_key integer
5> as
6> 
7> /* Clean up any orphan HMD_Class or HMD_Homology records after deletions */
8> 
9> if (select count(*) from HMD_Homology_Marker where _Homology_key = @_Homology_key) = 0
10> begin
11> 	delete HMD_Homology where _Homology_key = @_Homology_key
12> end
13> 
14> if (select count(*) from HMD_Homology where _Class_key = @_Class_key) = 0
15> begin
16> 	delete HMD_Class where _Class_key = @_Class_key
17> end
18> 
19> /* Delete all non-mouse, non-human Markers no longer referenced in Homology */
20> 
21> delete MRK_Marker from MRK_Marker m
22> where m._Species_key != 1 and m._Species_key != 2
23>       and not exists 
24>       (select h.* from HMD_Homology_Marker h where m._Marker_key = h._Marker_key)
25> 
1> 
2> grant execute on HMD_Cleanup to progs
1> 
2> grant execute on HMD_Cleanup to editors
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure MGI_Table_Column_Cleanup
1> 
2> CREATE PROCEDURE MGI_Table_Column_Cleanup
3> /*
4> JCG: Jan. 7, 1999
5> This procedure attempts to get MGI_Tables and MGI_Columns in sync with
6> sysobjects and syscolumns
7> */
8> 
9> as
10> 
11> /* Make sure that an old temp table with this name doesn't exists */
12> if exists (select name from sysobjects
13>            where name = '#temp_add_table'
14>            and type = 'U')
15>    drop table #temp_add_table
16> 
17> /*
18> NEW TABLE ADDED TO SCHEMA
19> */
20> /* Find tables in sysobjects which are not in MGI_Tables and insert them
21> into a temp table */
22> SELECT
23> MGI_Tables._Table_id, sysobjects.name
24> into #temp_add_table
25> FROM
26> MGI_Tables MGI_Tables, sysobjects sysobjects
27> WHERE
28> MGI_Tables._Table_id =* sysobjects.id
29> AND
30> sysobjects.type='U'
31> ORDER BY
32> sysobjects.name
33> 
34> /* From the temp table, select only those values where the table name is not
35> found in MGI_Tables. */
36> insert into MGI_Tables
37> SELECT object_id(name), NULL, getDate(), getDate()
38> FROM
39> #temp_add_table
40> WHERE
41> _Table_id is NULL
42> 
43> /* Also, find the appropriate columns and put into MGI_Columns so
44> that MGI_Tables and MGI_Columns are in sync */
45> insert into MGI_Columns
46> SELECT object_id(t.name), colid, NULL, NULL, getDate(), getDate()
47> FROM
48> #temp_add_table t, syscolumns c
49> WHERE
50> _Table_id is NULL
51> AND
52> object_id(t.name) = id
53> 
54> if exists (select name from sysobjects
55>            where name = '#temp_add_table'
56>            and type = 'U')
57>    drop table #temp_add_table
58> 
59> /*
60> WHAT IF YOU BCP IN A TRUNCATED COLUMN LIST?
61> THIS SECTION ADDS COLUMN DEFINITIONS FOR TABLES THAT ARE IN MGI_TABLES
62> BUT NOT MGI_COLUMNS - SYNCS COLUMNS WITH TABLES
63> */
64> 
65> if exists (select name from sysobjects
66>            where name = '#temp_update_table'
67>            and type = 'U')
68>    drop table #temp_update_table
69> 
70> SELECT
71> MGI_Columns._Table_id, syscolumns.id, syscolumns.colid
72> into #temp_update_table
73> FROM
74> MGI_Columns MGI_Columns,
75> syscolumns syscolumns,
76> sysobjects sysobjects
77> WHERE
78> syscolumns.id *= MGI_Columns._Table_id
79> and
80> syscolumns.id = sysobjects.id
81> and
82> sysobjects.type = 'U'
83> 
84> insert into MGI_Columns
85> SELECT
86> id, colid, NULL, NULL, getDate(), getDate()
87> FROM
88> #temp_update_table
89> WHERE
90> _Table_id is NULL
91> 
92> if exists (select name from sysobjects
93>            where name = '#temp_update_table'
94>            and type = 'U')
95>    drop table #temp_update_table
96> 
97> /*
98> THIS SECTION DELETES TABLES DEFINITION WHEN A TABLE IS DELETED
99> */
100> 
101> /*Algorithm:
102> 
103> If table not found in sysobjects, delete from MGI_Tables and
104> remove all column entries. Do a join to find _Table_id with no id
105> */
106> 
107> DELETE from MGI_Tables
108> where _Table_id in
109> (select DISTINCT _Table_id
110> from
111> MGI_Tables t, sysobjects o
112> WHERE
113> _Table_id NOT in (select id from sysobjects where type = 'U'))
114> 
115> if exists (select name from sysobjects
116>            where name = '#temp_delete_table'
117>            and type = 'U')
118>    drop table #temp_delete_table
119> 
120> 
121> SELECT DISTINCT _Table_id, id
122> into #temp_delete_table
123> FROM
124> MGI_Columns, sysobjects
125> WHERE
126> _Table_id *= id
127> 
128> /* If there is an id in MGI_Columns which is not in syscolumns then delete its entri
129> es */
130> delete from MGI_Columns
131> WHERE
132> _Table_id in (select _Table_id from #temp_delete_table where id is NULL)
133> 
134> if exists (select name from sysobjects
135>            where name = '#temp_delete_table'
136>            and type = 'U')
137>    drop table #temp_delete_table
138> 
139> RETURN
1> 
2> grant execute on MGI_Table_Column_Cleanup to public
1> 
2> drop procedure MGI_resetSequenceNum
1> 
2> create procedure MGI_resetSequenceNum
3>   @table varchar(255),		/* Table Name */
4>   @key int			/* Primary key */
5> as
6> 
7> /* Re-order the sequenceNum field so that they are 
8>    continuous and there are no gaps.
9> 
10>    ex. 1,2,5,6,7 would be reordered to 1,2,3,4,5
11> */
12> 
13> declare @pkey int	/* primary key of records to update */
14> declare @oldSeq int	/* current sequence number */
15> declare @newSeq int	/* new sequence number */
16> select @newSeq = 1
17>  
18> if (@table = "GXD_GelLane")
19> begin
20>   declare seq_cursor cursor for
21>   select _GelLane_key, sequenceNum
22>   from GXD_GelLane
23>   where _Assay_key = @key
24>   order by sequenceNum
25>   for read only
26> end
27> else if (@table = "GXD_GelRow")
28> begin
29>   declare seq_cursor cursor for
30>   select _GelRow_key, sequenceNum
31>   from GXD_GelRow
32>   where _Assay_key = @key
33>   order by sequenceNum
34>   for read only
35> end
36> else if (@table = "GXD_Specimen")
37> begin
38>   declare seq_cursor cursor for
39>   select _Specimen_key, sequenceNum
40>   from GXD_Specimen
41>   where _Assay_key = @key 
42>   order by sequenceNum 
43>   for read only
44> end
45> else if (@table = "GXD_InSituResult")
46> begin
47>   declare seq_cursor cursor for
48>   select _Result_key, sequenceNum
49>   from GXD_InSituResult
50>   where _Specimen_key = @key
51>   order by sequenceNum
52>   for read only
53> end
54> else if (@table = "MRK_History")
55> begin
56>   declare seq_cursor cursor for
57>   select _Marker_key, sequenceNum
58>   from MRK_History
59>   where _Marker_key = @key
60>   order by sequenceNum
61>   for read only
62> end
63> else if (@table = "MLD_Marker")
64> begin
65>   declare seq_cursor cursor for
66>   select _Refs_key, sequenceNum
67>   from MLD_Marker
68>   where _Refs_key = @key
69>   order by sequenceNum
70>   for read only
71> end
72> else if (@table = "MLD_Expt_Marker")
73> begin
74>   declare seq_cursor cursor for
75>   select _Expt_key, sequenceNum
76>   from MLD_Expt_Marker
77>   where _Expt_key = @key
78>   order by sequenceNum
79>   for read only
80> end
81> else if (@table = "MLD_MCDataList")
82> begin
83>   declare seq_cursor cursor for
84>   select _Expt_key, sequenceNum
85>   from MLD_MCDataList
86>   where _Expt_key = @key
87>   order by sequenceNum
88>   for read only
89> end
90> else if (@table = "MLD_MC2point")
91> begin
92>   declare seq_cursor cursor for
93>   select _Expt_key, sequenceNum
94>   from MLD_MC2point
95>   where _Expt_key = @key
96>   order by sequenceNum
97>   for read only
98> end
99> else if (@table = "MLD_RIData")
100> begin
101>   declare seq_cursor cursor for
102>   select _Expt_key, sequenceNum
103>   from MLD_RIData
104>   where _Expt_key = @key
105>   order by sequenceNum
106>   for read only
107> end
108> else if (@table = "MLD_RI2Point")
109> begin
110>   declare seq_cursor cursor for
111>   select _Expt_key, sequenceNum
112>   from MLD_RI2Point
113>   where _Expt_key = @key
114>   order by sequenceNum
115>   for read only
116> end
117> else if (@table = "MLD_FISH_Region")
118> begin
119>   declare seq_cursor cursor for
120>   select _Expt_key, sequenceNum
121>   from MLD_FISH_Region
122>   where _Expt_key = @key
123>   order by sequenceNum
124>   for read only
125> end
126> else if (@table = "MRK_Chromosome")
127> begin
128>   declare seq_cursor cursor for
129>   select _Species_key, sequenceNum
130>   from MRK_Chromosome
131>   where _Species_key = @key
132>   order by sequenceNum
133>   for read only
134> end
135> else if (@table = "MLD_Statistics")
136> begin
137>   declare seq_cursor cursor for
138>   select _Expt_key, sequenceNum
139>   from MLD_Statistics
140>   where _Expt_key = @key
141>   order by sequenceNum
142>   for read only
143> end
144> else
145> begin
146>   return
147> end
148> 
149> open seq_cursor
150> fetch seq_cursor into @pkey, @oldSeq
151>  
152> while (@@sqlstatus = 0)
153> begin
154>   if (@table = "GXD_GelLane")
155>   begin
156>     update GXD_GelLane set sequenceNum = @newSeq
157>       where _GelLane_key = @pkey
158>   end
159>   else if (@table = "GXD_GelRow")
160>   begin
161>     update GXD_GelRow set sequenceNum = @newSeq
162>       where _GelRow_key = @pkey
163>   end
164>   else if (@table = "GXD_Specimen")
165>   begin
166>     update GXD_Specimen set sequenceNum = @newSeq
167>       where _Specimen_key = @pkey
168>   end
169>   else if (@table = "GXD_InSituResult")
170>   begin
171>     update GXD_InSituResult set sequenceNum = @newSeq
172>       where _Result_key = @pkey
173>   end
174>   else if (@table = "MRK_History")
175>   begin
176>     update MRK_History set sequenceNum = @newSeq
177>       where _Marker_key = @pkey and sequenceNum = @oldSeq
178>   end
179>   else if (@table = "MLD_Marker")
180>   begin
181>     update MLD_Marker set sequenceNum = @newSeq
182>       where _Refs_key = @pkey and sequenceNum = @oldSeq
183>   end
184>   else if (@table = "MLD_Expt_Marker")
185>   begin
186>     update MLD_Expt_Marker set sequenceNum = @newSeq
187>       where _Expt_key = @pkey and sequenceNum = @oldSeq
188>   end
189>   else if (@table = "MLD_MCDataList")
190>   begin
191>     update MLD_MCDataList set sequenceNum = @newSeq
192>       where _Expt_key = @pkey and sequenceNum = @oldSeq
193>   end
194>   else if (@table = "MLD_MC2point")
195>   begin
196>     update MLD_MC2point set sequenceNum = @newSeq
197>       where _Expt_key = @pkey and sequenceNum = @oldSeq
198>   end
199>   else if (@table = "MLD_RIData")
200>   begin
201>     update MLD_RIData set sequenceNum = @newSeq
202>       where _Expt_key = @pkey and sequenceNum = @oldSeq
203>   end
204>   else if (@table = "MLD_RI2Point")
205>   begin
206>     update MLD_RI2Point set sequenceNum = @newSeq
207>       where _Expt_key = @pkey and sequenceNum = @oldSeq
208>   end
209>   else if (@table = "MLD_FISH_Region")
210>   begin
211>     update MLD_FISH_Region set sequenceNum = @newSeq
212>       where _Expt_key = @pkey and sequenceNum = @oldSeq
213>   end
214>   else if (@table = "MRK_Chromosome")
215>   begin
216>     update MRK_Chromosome set sequenceNum = @newSeq
217>       where _Species_key = @pkey and sequenceNum = @oldSeq
218>   end
219>   else if (@table = "MLD_Statistics")
220>   begin
221>     update MLD_Statistics set sequenceNum = @newSeq
222>       where _Expt_key = @pkey and sequenceNum = @oldSeq
223>   end
224>   select @newSeq = @newSeq + 1
225>   fetch seq_cursor into @pkey, @oldSeq
226> end
227>  
228> close seq_cursor
229> deallocate cursor seq_cursor
230>  
1> 
2> grant execute on MGI_resetSequenceNum to progs
1> 
2> grant execute on MGI_resetSequenceNum to editors
1> 
2> drop procedure GEN_rowcount
1>  
2> create procedure GEN_rowcount
3>   @table varchar(30)
4> as
5> 
6> select convert(char(10),rowcnt(MAX(doampg)))
7> from sysobjects o, sysindexes i
8> where o.name = @table
9> and o.id = i.id
1> 
2> grant execute on GEN_rowcount to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure Current_Symbol
1> 
2> create procedure Current_Symbol 
3>   @symbol varchar(25)
4> as
5> 
6> 
7> declare item cursor for
8>    select m._Marker_key, m.symbol 
9>    from MRK_Marker m 
10>    where m.symbol = @symbol
11>    and _Species_key = 1
12> 
13> declare @mk int
14> declare @sym varchar(25) 
15> open item 
16> 
17> while (@@sqlstatus = 0)
18> begin
19>    fetch item into @mk, @sym
20>    if (@@sqlstatus = 2) break
21>    select _Current_key = c._Current_key, 
22>           _Marker_key =  c._Marker_key,
23>           current_symbol = m.symbol, 
24> 		  symbol = @sym
25>    from MRK_Current c, MRK_Marker m
26>    where c._Current_key = m._Marker_key
27>    and m._Species_key = 1
28>    and c._Marker_key = @mk
29> end
30> 
31> close item
32> 			
1> 
2> grant execute on Current_Symbol to public
3> grant execute on Current_Symbol to progs
1> 
2> checkpoint
1> 
2> drop procedure MLC_transfer
1> 
2> create procedure MLC_transfer
3>     @_Marker_key int
4> as
5> /* This proc transfers rows with primary_key = @_Marker_key from the MLC 
6>  * edit tables to the Production MLC tables.  If the MLC_Text_edit table
7>  * does not contain a row with _Marker_key = @_Marker_key, then this is
8>  * a delete that will be propagated to the Production MLC tables.
9>  */
10> 
11> begin transaction
12> 
13> declare @doinsert bit
14> select @doinsert = 1  /* assume we are copying, not deleting */
15> 
16> 
17> /* determine if this is a copy or delete */
18> 
19> if (select count(*) 
20>     from MLC_Text_edit
21>     where _Marker_key = @_Marker_key) = 0
22> begin  /* then we must propagate a delete */
23>     select @doinsert = 0
24> end
25> 
26> 
27> /* make sure to set the textsize to avoid truncation during selects
28>    when copying data between MLC_Text_edit and MLC_Text */
29> 
30> set textsize 500000
31> 
32> /* MLC_Text */
33> 
34> /* delete the rows from the Production table that will be replaced
35>    with rows from the corresponding _edit table */ 
36> 
37> delete from MLC_Text where _Marker_key = @_Marker_key
38> if @@error != 0
39> begin
40>    rollback transaction
41>    raiserror 99999 "Delete from MLC_Text failed, mk = %1!", @_Marker_key
42>    return
43> end
44> 
45> if @doinsert = 1
46> begin
47>    /* insert the updated rows into production tables */ 
48>    insert MLC_Text 
49>    select * from MLC_Text_edit where _Marker_key = @_Marker_key
50> 
51>    if @@error != 0
52>    begin
53>       rollback transaction
54>       raiserror 99999 "Insert into MLC_Text failed, mk = %1!", @_Marker_key
55>       return
56>    end
57> end
58> 
59> /* MLC_Marker */
60> 
61> /* delete the rows from the Production table that will be replaced
62>    with rows from the corresponding _edit table */ 
63> 
64> delete from MLC_Marker where _Marker_key = @_Marker_key
65> if @@error != 0
66> begin
67>    rollback transaction
68>    raiserror 99999 "Delete from MLC_Marker failed, mk = %1!", @_Marker_key
69>    return
70> end
71> 
72> if @doinsert = 1
73> begin
74>    /* insert the updated rows into production tables */ 
75>    insert MLC_Marker 
76>    select * from MLC_Marker_edit where _Marker_key = @_Marker_key
77> 
78>    if @@error != 0
79>    begin
80>       rollback transaction
81>       raiserror 99999 "Insert into MLC_Marker failed, mk = %1!", @_Marker_key
82>       return
83>    end
84> end
85> 
86> 
87> /* MLC_Reference */
88> 
89> /* delete the rows from the Production table that will be replaced
90>    with rows from the corresponding _edit table */ 
91> 
92> delete from MLC_Reference where _Marker_key = @_Marker_key
93> if @@error != 0
94> begin
95>    rollback transaction
96>    raiserror 99999 "Delete from MLC_Reference failed, mk = %1!", @_Marker_key
97>    return
98> end
99> 
100> if @doinsert = 1
101> begin
102>    /* insert the updated rows into production tables */ 
103>    insert MLC_Reference 
104>    select * from MLC_Reference_edit where _Marker_key = @_Marker_key
105> 
106>    if @@error != 0
107>    begin
108>       rollback transaction
109>       raiserror 99999 "Insert into MLC_Reference failed, mk = %1!", @_Marker_key
110>       return
111>    end
112> end
113> 
114> commit transaction
1> 
2> grant execute on MLC_transfer to progs
3> grant execute on MLC_transfer to apd, cml, djr, jblake, plg, rmb, wjb
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure MRK_convertAllele
1>  
2> create procedure MRK_convertAllele
3>   @oldKey integer,
4>   @new_symbol varchar(25) = null,
5>   @old_symbol varchar(25) = null,
6>   @alleleOf integer
7> as
8>  
9> /* Remove all Allele symbols from MRK_Symbol table */
10> 
11> delete from MRK_Symbol where _Marker_key = @oldKey and _Marker_Type_key = 5
12> 
13> /* If Old Symbol is NOT allele of New Symbol... */
14> /* Convert new alleles:  */
15> /*	+<oldsymbol>	  --> +<newsymbol> */
16> /*	oldallele<allele> --> newsymbol<allele> */
17> /*      oldallele         --> newsymbol         */
18> 
19> if @alleleOf = 0
20> begin
21> 
22> /* Non-Wild Type Allele */
23> /*	oldallele<allele> --> newsymbol<allele> */
24> 
25> update MRK_Allele
26> set symbol = @new_symbol + "<" + substring(symbol, charindex("<", symbol) + 1, char_length(symbol))
27> where _Marker_key = @oldKey and symbol like '%<%' and symbol not like '+%'
28> 
29> /*      oldallele         --> newsymbol         */
30> 
31> update MRK_Allele set symbol = @new_symbol
32> where _Marker_key = @oldKey and symbol = @old_symbol
33> 
34> /* Wild Type Allele */
35> /*	+<oldsymbol>	  --> +<newsymbol> */
36> 
37> update MRK_Allele
38> set symbol = '+<' + @new_symbol + '>'
39> where _Marker_key = @oldKey and symbol like '+<' + @old_symbol + '>'
40> 
41> end
42> else
43> begin
44> 
45> /* If Old Symbol is an Allele of New Symbol... */
46> /* Convert new alleles:  */
47> /*	+<oldsymbol>	  --> newsymbol<oldsymbol>        */
48> /*	oldallele<allele> --> newsymbol<oldallele-allele> */
49> /*      oldallele         --> newsymbol<oldallele>        */
50> 
51> /* Non Wild Type */
52> /*	oldallele<allele> --> newsymbol<oldallele-allele> */
53> 
54> update MRK_Allele
55> set symbol = @new_symbol + "<" + substring(symbol, 1, charindex("<", symbol) - 1) + "-" + 
56> 	     substring(symbol, charindex("<", symbol) + 1, char_length(symbol))
57> where _Marker_key = @oldKey and symbol like '%<%' and symbol not like '+%'
58> 
59> /*      oldallele         --> newsymbol<oldallele>        */
60> 
61> update MRK_Allele
62> set symbol = @new_symbol + "<" + symbol + ">"
63> where _Marker_key = @oldKey and symbol not like '%<%' and symbol not like '+%'
64> 
65> /* Wild Type Allele */
66> /*	+<oldsymbol>	  --> newsymbol<oldsymbol>        */
67> 
68> update MRK_Allele
69> set symbol = @new_symbol + "<" + substring(symbol, charindex("<", symbol) + 1, char_length(symbol))
70> where _Marker_key = @oldKey and symbol like '+%'
71> 
72> end
73> 
74> /* Insert Allele symbols into MRK_Symbol table */
75> 
76> insert into MRK_Symbol (_Marker_key, _Marker_Type_key, symbol)
77> select _Marker_key, 5, symbol from MRK_Allele where _Marker_key = @oldKey
78> 
1> 
2> grant execute on MRK_convertAllele to djr
1>  
2> grant execute on MRK_convertAllele to progs
1>  
2> drop procedure MRK_copyAcc
1>  
2> create procedure MRK_copyAcc
3>   @oldKey integer,
4>   @newKey integer
5> as
6>  
7> declare @accID varchar(30),
8> 	@logicalDB int,
9> 	@prefixPart varchar(20)
10> 
11> /* Copy Old non-MGI Accession Number from Old Key to new New Key */
12> /* For each Marker non-MGI Accession number which exists for Old Symbol, */
13> /* Insert the Accession number as non-preferred for the New symbol */
14>  
15> declare acc_cursor cursor for
16> select accID, _LogicalDB_key, prefixPart
17> from ACC_Accession
18> where _Object_key = @oldKey
19> and _MGIType_key = 2
20> for read only
21>  
22> open acc_cursor
23>  
24> fetch acc_cursor into @accID, @logicalDB, @prefixPart
25> 
26> while (@@sqlstatus = 0)
27> begin
28> 	/* For MGI Accession numbers, set preferred = 0 */
29> 
30> 	if (@logicalDB = 1 and @prefixPart != "MGI:")
31> 	begin
32> 		execute ACC_insert @newKey, @accID, @logicalDB, "Marker", -1, 0
33> 	end
34> 
35> 	/* For non-MGI Accession numbers, set preferred = 1 */
36> 
37> 	else if (@logicalDB != 1)
38> 	begin
39> 		execute ACC_insert @newKey, @accID, @logicalDB, "Marker", -1
40> 	end
41> 
42>         fetch acc_cursor into @accID, @logicalDB, @prefixPart
43> end
44>  
45> close acc_cursor
46> 
47> deallocate cursor acc_cursor
48> 
1> 
2> grant execute on MRK_copyAcc to djr
1>  
2> grant execute on MRK_copyAcc to progs
1>  
2> drop procedure MRK_copyHistory
1>  
2> create procedure MRK_copyHistory
3>   @oldKey integer,
4>   @newKey integer
5> as
6>  
7> /* Copy Old History into MRK_History for New Key */
8>  
9> declare @maxSeq int
10> select @maxSeq = max(sequenceNum) from MRK_History where _Marker_key = @newKey
11> 
12> if @maxSeq is null
13> begin
14> 	select @maxSeq = 0
15> end
16> 
17> select _Marker_key, _History_key, _Refs_key, seq = identity(5), name, note, 
18> event_date, creation_date, modification_date
19> into #historyTemp from MRK_History where _Marker_key = @oldKey
20> order by sequenceNum
21>  
22> insert into MRK_History 
23> (_Marker_key, _History_key, _Refs_key, sequenceNum, name, note, 
24> event_date, creation_date, modification_date)
25> select distinct @newKey, _History_key, _Refs_key, @maxSeq + seq, name, note, 
26> event_date, creation_date, modification_date
27> from #historyTemp
28> 
1>  
2> grant execute on MRK_copyHistory to djr
1>  
2> grant execute on MRK_copyHistory to progs
1>  
2> drop procedure MRK_insertAllele
1>  
2> create procedure MRK_insertAllele
3>   @markerKey integer,
4>   @symbol varchar(20) = null,
5>   @name varchar(255) = null,
6>   @oldSymbol varchar(20) = null
7> as
8> 
9> declare @alleleKey integer
10> select @alleleKey = max(_Allele_key) + 1 from MRK_Allele
11> 
12> /* Insert New Allele into MRK_Allele */
13> 
14> insert MRK_Allele (_Allele_key, _Marker_key, symbol, name)
15> values(@alleleKey, @markerKey, @symbol, @name)
16> 
17> if @oldSymbol is not null
18> begin
19> 	update MLD_Expt_Marker set _Allele_key = @alleleKey
20> 	where _Marker_key = @markerKey and gene = @oldSymbol
21> end
22> 
1> 
2> grant execute on MRK_insertAllele to djr
1>  
2> grant execute on MRK_insertAllele to progs
1>  
2> drop procedure MRK_insertHistory
1>  
2> create procedure MRK_insertHistory
3>   @oldKey integer,
4>   @newKey integer,
5>   @refKey integer,
6>   @name varchar(255) = null,
7>   @note varchar(255)
8> as
9>  
10> /* Insert New History into MRK_History */
11>  
12> declare @maxSeq int
13> select @maxSeq = max(sequenceNum) from MRK_History where _Marker_key = @newKey
14> 
15> if @maxSeq is null
16> begin
17> 	select @maxSeq = 0
18> end
19> 
20> insert MRK_History 
21> (_Marker_key, _History_key, _Refs_key, sequenceNum, name, note, event_date)
22> values(@newKey, @oldKey, @refKey, @maxSeq + 1, @name, @note, getdate())
23> 
1>  
2> grant execute on MRK_insertHistory to djr
1>  
2> grant execute on MRK_insertHistory to progs
1>  
2> drop procedure MRK_updateKeys
1> 
2> create procedure MRK_updateKeys
3>   @oldKey integer,
4>   @newKey integer
5> as
6> 
7> /* Executed during w/drawal process if only 1 new symbol is designated */
8> 
9> /*
10>    Set the preferred bit to 0 for all MGI Acc# brought over from old symbol if
11>    the new symbol already contains a preferred MGI Acc#.
12>    Associate all Accession numbers w/ new symbol.
13> */
14> 
15> if (select count(*) 
16>     from ACC_Accession 
17>     where _MGIType_key = 2 and 
18> 	  prefixPart = "MGI:" and
19> 	  _Object_key = @newKey and
20> 	  preferred = 1) > 0
21> begin
22> 	update ACC_Accession 
23> 	set _Object_key = @newKey, preferred = 0
24> 	where _LogicalDB_key = 1 and _MGIType_key = 2 and _Object_key = @oldKey
25> end
26> 
27> update ACC_Accession 
28> set _Object_key = @newKey
29> where _MGIType_key = 2 and _Object_key = @oldKey
30> 
31> /* Associate aliases, classes, other names, references w/ new symbol */
32> 
33> /* Remove reflexive Alias records, if they exist */
34> 
35> delete from MRK_Alias where _Marker_key = @oldKey and _Alias_key = @newKey
36> delete from MRK_Alias where _Alias_key = @oldKey and _Marker_key = @newKey
37> 
38> update MRK_Alias set _Marker_key = @newKey where _Marker_key = @oldKey
39> update MRK_Alias set _Alias_key = @newKey where _Alias_key = @oldKey
40> update MRK_Allele set _Marker_key = @newKey where _Marker_key = @oldKey
41> update MRK_Anchors set _Marker_key = @newKey where _Marker_key = @oldKey
42> update MRK_Other set _Marker_key = @newKey where _Marker_key = @oldKey
43> 
44> /* MRK_Classes may contain potential duplicates */
45> 
46> insert into MRK_Classes
47> select @newKey, m._Class_key, m.creation_date, m.modification_date
48> from MRK_Classes m
49> where m._Marker_key = @oldKey
50> and not exists (select m2.* from MRK_Classes m2
51> where m2._Marker_key = @newKey
52> and m2._Class_key = m._Class_key)
53> 
54> delete from MRK_Classes where _Marker_key = @oldKey
55> 
56> /* MRK_Name may contain potential duplicates */
57> 
58> insert into MRK_Name
59> select @newKey, m._Marker_Type_key, m.name, m.creation_date, m.modification_date
60> from MRK_Name m
61> where m._Marker_key = @oldKey
62> and not exists (select m2.* from MRK_Name m2
63> where m2._Marker_key = @newKey
64> and m2._Marker_Type_key = m._Marker_Type_key
65> and m2.name = m.name)
66> 
67> delete from MRK_Name where _Marker_key = @oldKey
68> 
69> /* MRK_Reference may contain potential duplicates */
70> 
71> insert into MRK_Reference
72> select @newKey, m._Refs_key, m.auto, m.creation_date, m.modification_date
73> from MRK_Reference m
74> where m._Marker_key = @oldKey
75> and not exists (select m2.* from MRK_Reference m2
76> where m2._Marker_key = @newKey
77> and m2._Refs_key = m._Refs_key)
78> 
79> delete from MRK_Reference where _Marker_key = @oldKey
80> 
81> /* Update all auxiliary references to old symbol w/ new symbol */
82> 
83> update HMD_Homology_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
84> update GXD_AllelePair set _Marker_key = @newKey where _Marker_key = @oldKey
85> update GXD_AntibodyMarker set _Marker_key = @newKey where _Marker_key = @oldKey
86> update GXD_Assay set _Marker_key = @newKey where _Marker_key = @oldKey
87> update GXD_Expression set _Marker_key = @newKey where _Marker_key = @oldKey
88> update GXD_Index set _Marker_key = @newKey where _Marker_key = @oldKey
89> 
90> /* Include MLD_Marker and MLD_Expt_Marker because sometimes Markers are */
91> /* mentioned in one table and not the other */
92> 
93> update MLD_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
94> update MLD_Expt_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
95> update MLD_Concordance set _Marker_key = @newKey where _Marker_key = @oldKey
96> update MLD_Distance set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
97> update MLD_Distance set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
98> update MLD_MC2point set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
99> update MLD_MC2point set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
100> update MLD_RI2Point set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
101> update MLD_RI2Point set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
102> update MLD_Statistics set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
103> update MLD_Statistics set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
104> 
105> update PRB_Strain 
106> set s.needsReview = 1
107> from PRB_Strain s, PRB_Strain_Marker m
108> where m._Marker_key = @oldKey
109> and m._Strain_key = s._Strain_key
110>  
111> update PRB_Strain_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
112> 
113> /* PRB_Marker may contain potential duplicates */
114> 
115> insert into PRB_Marker
116> select m._Probe_key, @newKey, m.relationship, m.creation_date, m.modification_date
117> from PRB_Marker m
118> where m._Marker_key = @oldKey
119> and not exists (select m2.* from PRB_Marker m2
120> where m2._Marker_key = @newKey
121> and m2._Probe_key = m._Probe_key)
122>   
123> delete from PRB_Marker where _Marker_key = @oldKey
124> update PRB_RFLV set _Marker_key = @newKey where _Marker_key = @oldKey
125> 
126> /* Update MLC tables iff New Symbol entry doesn't exist in MLC */
127> /* Nomenclature updates are propagated to the non-edit tables immediately */
128> 
129> if not exists (select * from MLC_Marker_edit where _Marker_key = @newKey)
130> begin
131>   update MLC_Marker_edit set _Marker_key = @newKey where _Marker_key = @oldKey
132>   update MLC_Reference_edit set _Marker_key = @newKey where _Marker_key = @oldKey
133>   update MLC_Text_edit set _Marker_key = @newKey where _Marker_key = @oldKey
134>   update MLC_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
135>   update MLC_Reference set _Marker_key = @newKey where _Marker_key = @oldKey
136>   update MLC_Text set _Marker_key = @newKey where _Marker_key = @oldKey
137> end
138> 
1> 
2> grant execute on MRK_updateKeys to djr
1> 
2> grant execute on MRK_updateKeys to progs
1> 
2> drop procedure MRK_updateCurrent
1> 
2> create procedure MRK_updateCurrent
3>   @oldKey integer,
4>   @newKey integer
5> as
6> 
7> /* Associate current symbols for all past symbols w/ new symbol */
8> /* Associate alias symbols in MRK_Symbol w/ new symbol */
9> /* Associate allele symbols in MRK_Symbol w/ new symbol */
10> 
11> update MRK_Current set _Current_key = @newKey where _Current_key = @oldKey
12> update MRK_Symbol set _Marker_key = @newKey where _Marker_key = @oldKey and _Marker_Type_key = 4
13> update MRK_Symbol set _Marker_key = @newKey where _Marker_key = @oldKey and _Marker_Type_key = 5
14> 
1> 
2> grant execute on MRK_updateCurrent to djr
1> 
2> grant execute on MRK_updateCurrent to progs
1> 
2> drop procedure MRK_updateOffset
1> 
2> create procedure MRK_updateOffset
3>   @oldKey integer,
4>   @newKey integer
5> as
6> 
7> declare @oldCyto varchar(20)
8> declare @newCyto varchar(20)
9> 
10> declare @oldMGD float
11> declare @newMGD float
12> 
13> declare @oldCC float
14> declare @newCC float
15> 
16> declare @oldMIT float
17> declare @newMIT float
18> 
19> select @oldCyto = cytogeneticOffset from MRK_Marker where _Marker_key = @oldKey
20> select @newCyto = cytogeneticOffset from MRK_Marker where _Marker_key = @newKey
21> 
22> select @oldMGD = offset from MRK_Offset where _Marker_key = @oldKey and source = 0
23> select @oldCC = offset from MRK_Offset where _Marker_key = @oldKey and source = 1
24> select @oldMIT = offset from MRK_Offset where _Marker_key = @oldKey and source = 2
25> 
26> select @newMGD = offset from MRK_Offset where _Marker_key = @newKey and source = 0
27> select @newCC = offset from MRK_Offset where _Marker_key = @newKey and source = 1
28> select @newMIT = offset from MRK_Offset where _Marker_key = @newKey and source = 2
29> 
30> -- If the new symbol lacks an Cytogenetic offset, then use the old symbols' offset
31> 
32> if @newCyto is null
33> begin
34>   update MRK_Marker set cytogeneticOffset = @oldCyto where _Marker_key = @newKey
35> end
36> 
37> -- If the new symbol lacks an MGD offset, then use the old symbols' offset
38> 
39> if @newMGD < 0
40> begin
41>   update MRK_Offset set offset = @oldMGD where _Marker_key = @newKey and source = 0
42> end
43> 
44> -- If the new symbol lacks a CC offset, then use the old symbol's CC offset
45> 
46> if @newCC < 0 and @oldCC > 0
47> begin
48>   update MRK_Offset set offset = @oldCC where _Marker_key = @newKey and source = 1
49> end
50> else if @newCC is null and @oldCC is not null
51> begin
52>   insert MRK_Offset (_Marker_key, source, offset) values(@newKey, 1, @oldCC)
53> end
54> 
55> -- If the new symbol lacks an MIT offset, then use the old symbol's MIT offset
56> 
57> if @newMIT < 0 and @oldMIT > 0
58> begin
59>   update MRK_Offset set offset = @oldMIT where _Marker_key = @newKey and source = 2
60> end
61> else if @newMIT is null and @oldMIT is not null
62> begin
63>   insert MRK_Offset (_Marker_key, source, offset) values(@newKey, 2, @oldMIT)
64> end
65> 
1> 
2> grant execute on MRK_updateOffset to djr
1> 
2> grant execute on MRK_updateOffset to progs
1> 
2> 
3> drop procedure MRK_MaxOffset
1> 
2> create procedure MRK_MaxOffset
3> @chromosome varchar(2),
4> @source int 
5> as
6> select maxOffset = max(o.offset)
7> from MRK_Offset o, MRK_Marker m
8> where o._Marker_key = m._Marker_key
9> and o.source = @source 
10> and m.chromosome = @chromosome 
11> and m._Species_key = 1
1> 
2> grant execute on MRK_MaxOffset to public
1> 
2> 
3> drop procedure MRK_MiniMapMarkers
1> 
2> create procedure MRK_MiniMapMarkers
3> @_Marker_key int,
4> @source int 
5> as
6> /* retrieve data for all anchor markers on the chromosome */
7> select distinct
8> m._Marker_key,
9> m.symbol,
10> m.name,
11> m.chromosome,
12> o.offset,
13> m.cytogeneticOffset
14> from MRK_Marker m, 
15> MRK_Offset o, 
16> MRK_Anchors a
17> where
18> m._Marker_key = a._Marker_key
19> and o.source = @source
20> and o._Marker_key = m._Marker_key
21> and o.offset > -1.0
22> and a.chromosome = (select m.chromosome 
23> from MRK_Marker m
24> where m._Marker_key = @_Marker_key)
25> union
26> /* get the data for the marker itself */
27> select distinct
28> m._Marker_key,
29> m.symbol,
30> m.name,
31> m.chromosome,
32> o.offset,
33> m.cytogeneticOffset
34> from MRK_Marker m,
35> MRK_Offset o
36> where
37> m._Marker_key = @_Marker_key
38> and o.source = @source
39> and o._Marker_key = m._Marker_key
40> and o.offset > -1.0
1> 
2> grant execute on MRK_MiniMapMarkers to public
1> 
2> drop procedure MRK_mergeAllele
1>  
2> create procedure MRK_mergeAllele
3>   @oldAlleleKey int,
4>   @newAlleleKey int
5> as
6> 
7> /*
8>  * Update old Allele key to new Allele key
9>  * in all relevant tables which contain an Allele key.
10>  * When finished, remove the Allele record for the old
11>  * Allele key.
12> */
13> 
14> update GXD_AllelePair
15> set _Allele_key_1 = @newAlleleKey
16> where _Allele_key_1 = @oldAlleleKey
17> 
18> update GXD_AllelePair
19> set _Allele_key_2 = @newAlleleKey
20> where _Allele_key_2 = @oldAlleleKey
21> 
22> update MLD_Expt_Marker
23> set _Allele_key = @newAlleleKey
24> where _Allele_key = @oldAlleleKey
25> 
26> delete from MRK_Allele
27> where _Allele_key = @oldAlleleKey
28> 
1> 
2> grant execute on MRK_mergeAllele to editors
1>  
2> grant execute on MRK_mergeAllele to progs
1>  
2> drop procedure MRK_isAnchor
1>  
2> create procedure MRK_isAnchor
3>   @key int
4> as
5> 
6> /* Determine if Marker key exists in MRK_Anchors table */
7> 
8> declare @found int
9> select @found = count(*) from MRK_Anchors where _Marker_key = @key
10> select @found
11> 
1> 
2> grant execute on MRK_isAnchor to public
1>  
2> drop procedure MRK_breakpointSplit
1> 
2> create procedure MRK_breakpointSplit
3>   @markerKey integer,
4>   @distalCytoBand varchar(20) = null
5> as
6> 
7> /* See TR#120; procedure to split cytogenetic marker into 2 distinct markers */
8> 
9> declare @band varchar(20)
10> declare @symbol varchar(25)
11> declare @name varchar(255)
12> declare @markerType integer
13> declare @idx integer
14> 
15> select @symbol = symbol, @band = cytogeneticOffset, @name = name, @markerType = _Marker_Type_key
16> from MRK_Marker where _Marker_key = @markerKey
17> 
18> if @markerType != 3
19> begin
20> 	rollback transaction
21> 	raiserror 99999 "Invalid Marker for Breakpoint Split: %1!", @symbol
22> 	return
23> end
24> 
25> select @idx = charindex(" & ", @band)
26> 
27> declare @proximalBand varchar(20)
28> declare @distalBand varchar(20)
29> 
30> declare @proximalSymbol varchar(25)
31> declare @distalSymbol varchar(25)
32> 
33> declare @proximalName varchar(255)
34> declare @distalName varchar(255)
35> 
36> declare @proximalKey integer
37> declare @distalKey integer
38> 
39> /* If symbol band is not in the format 'X & Y', then distal band remains NULL */
40> 
41> if @idx = 0
42> begin
43> 	select @proximalBand = @band
44> 	/* distal band is null */
45> end
46> else
47> begin
48> 	select @proximalBand = substring(@band, 1, @idx - 1)
49> 	select @distalBand = substring(@band, @idx + 3, char_length(@band))
50> end
51> 
52> /* If caller supplies a distal band, use it */
53> 
54> if @distalCytoBand is not null
55> begin
56> 	select @distalBand = @distalCytoBand
57> end
58> 
59> select @proximalSymbol = @symbol + "-p"
60> select @proximalName = @name + ", proximal"
61> select @proximalKey = @markerKey
62> 
63> select @distalSymbol = @symbol + "-d"
64> select @distalName = @name + ", distal"
65> select @distalKey = max(_Marker_key) + 1 from MRK_Marker
66> 
67> /* Update the symbol, name and cytogenetic offset for the current Marker to the proximal symbol */
68> 
69> update MRK_Marker
70> set symbol = @proximalSymbol,
71>     name = @proximalName,
72>     cytogeneticOffset = @proximalBand
73> where _Marker_key = @proximalKey
74> 
75> update MRK_History
76> set name = @proximalName
77> where _Marker_key = @proximalKey
78> and name = @name
79> 
80> /* Copy proximal symbol info to a new distal symbol */
81> 
82> insert into MRK_Marker 
83> (_Marker_key, _Species_key, _Marker_Type_key, symbol, name, chromosome, cytogeneticOffset)
84> select @distalKey, _Species_key, _Marker_Type_key, @distalSymbol, @distalName, chromosome, @distalBand
85> from MRK_Marker where _Marker_key = @proximalKey
86> 
87> /* Notes */
88> insert into MRK_Notes
89> (_Marker_key, sequenceNum, note)
90> select @distalKey, sequenceNum, note
91> from MRK_Notes where _Marker_key = @proximalKey
92> 
93> /* Offset */
94> insert into MRK_Offset
95> (_Marker_key, source, offset)
96> select @distalKey, source, offset
97> from MRK_Offset where _Marker_key = @proximalKey
98> 
99> /* References */
100> insert into MRK_Reference
101> (_Marker_key, _Refs_key, auto)
102> select @distalKey, _Refs_key, auto
103> from MRK_Reference where _Marker_key = @proximalKey
104> 
105> /* History */
106> insert into MRK_History
107> (_Marker_key, _History_key, _Refs_key, sequenceNum, name, note, event_date)
108> select @distalKey, _History_key, _Refs_key, sequenceNum, name, note, event_date
109> from MRK_History where _Marker_key = @proximalKey and _History_key != @proximalKey
110> 
111> insert into MRK_History
112> (_Marker_key, _History_key, _Refs_key, sequenceNum, name, note, event_date)
113> select @distalKey, @distalKey, _Refs_key, sequenceNum, @distalName, note, event_date
114> from MRK_History where _Marker_key = @proximalKey and _History_key = @proximalKey
115> 
116> /* Other Names */
117> select seq = identity(5), name, _Refs_key
118> into #otherTmp
119> from MRK_Other where _Marker_key = @proximalKey
120> 
121> declare @maxOther int
122> select @maxOther = max(_Other_key) from MRK_Other
123> 
124> insert into MRK_Other
125> (_Other_key, _Marker_key, _Refs_key, name)
126> select @maxOther + seq, @distalKey, _Refs_key, name
127> from #otherTmp
128>  
129> /* Accession Numbers */
130> /* Copy all nonMGI preferred Accession numbers of proximal symbol to distal symbol */
131> 
132> select seq = identity(5), a.*
133> into #accTmp
134> from ACC_Accession a where a._Object_key = @proximalKey
135> and a._MGIType_key = 2
136> 
137> declare @maxAcc int
138> select @maxAcc = max(_Accession_key) from ACC_Accession
139> 
140> insert into ACC_Accession
141> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
142> select @maxAcc + seq, accID, prefixPart, numericPart, _LogicalDB_key, @distalKey, _MGIType_key,
143> private, preferred
144> from #accTmp
145> where prefixPart != "MGI:" and preferred != 1
146>  
147> /* Insert Other Name entries for both proximal and distal symbols */
148> 
149> declare @otherKey int
150> select @otherKey = max(_Other_key) + 1 from MRK_Other
151> insert into MRK_Other values(@otherKey, @proximalKey, NULL, @symbol, getdate(), getdate())
152> insert into MRK_Other values(@otherKey + 1, @distalKey, NULL, @symbol, getdate(), getdate())
153> 
154> select @proximalKey, @proximalSymbol
155> select @distalKey, @distalSymbol
156> 
1> 
2> grant execute on MRK_breakpointSplit to djr
1> 
2> grant execute on MRK_breakpointSplit to progs
1> 
2> drop procedure MRK_addChromosome
1> 
2> create procedure MRK_addChromosome
3>   @speciesKey integer,
4>   @chromosome varchar(8)
5> as
6> 
7> /* If Chromosome for given Species does not exist in MRK_Chromosome, */
8> /* then insert the chromosome into MRK_Chromosome. */
9> /* MRK_Chromosome is used to sequentially order the Chromosome values within */
10> /* a given Species for sorting in Homology, reports, Oxford Grids, etc. */
11> 
12> if (select count(*) from MRK_Chromosome
13>     where _Species_key = @speciesKey and chromosome = @chromosome) = 0
14> begin
15>         /* Get next available sequence number */
16>         declare @nextseq integer
17> 
18>         select @nextseq = max(sequenceNum) + 1 
19>         	from MRK_Chromosome
20>         	where _Species_key = @speciesKey
21> 
22>         if @nextseq is NULL or @nextseq = 0
23>         begin
24>         	select @nextseq = 1
25>         end
26> 
27>         insert into MRK_Chromosome (_Species_key, chromosome, sequenceNum)
28> 	values(@speciesKey, @chromosome, @nextseq)
29> 
30> end
1> 
2> grant execute on MRK_addChromosome to editors
1> 
2> grant execute on MRK_addChromosome to progs
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure MRKXfer_count_MLD
1>  
2> create procedure MRKXfer_count_MLD
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Markers in MLDP for marker/reference pair */
8> 
9> select count(*) from MLD_Marker
10> where _Marker_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_MLD to public
1>  
2> drop procedure MRKXfer_MLD
1>  
2> create procedure MRKXfer_MLD
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return MGI Experiment Accession numbers for marker/reference pair */
8> 
9> select distinct e._Expt_key 
10> into #expts
11> from MLD_Marker m, MLD_Expts e
12> where m._Marker_key = @markerKey and
13>       m._Refs_key = @refKey and
14>       m._Refs_key = e._Refs_key
15> 
16> select distinct a.mgiID
17> from #expts t, MLD_Summary_View a
18> where t._Expt_key = a._Object_key
19> 
1> 
2> grant execute on MRKXfer_MLD to public
1>  
2> drop procedure MRKXfer_count_HMD
1>  
2> create procedure MRKXfer_count_HMD
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Homology records for marker/reference pair */
8> 
9> select count(r._Refs_key) from HMD_Homology_Marker m, HMD_Homology r
10> where m._Marker_key = @markerKey and
11>       m._Homology_Key = r._Homology_key and
12>       r._Refs_key = @refKey
13> 
1> 
2> grant execute on MRKXfer_count_HMD to public
1>  
2> drop procedure MRKXfer_count_GXDIndex
1>  
2> create procedure MRKXfer_count_GXDIndex
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Index records for marker/reference pair */
8> 
9> select count(_Refs_key) from GXD_Index
10> where _Marker_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_GXDIndex to public
1>  
2> drop procedure MRKXfer_count_GXDAntibody
1>  
2> create procedure MRKXfer_count_GXDAntibody
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Antibody records for marker/reference pair */
8> 
9> select a._Refs_key
10> into #count
11> from GXD_Antibody a, GXD_AntibodyMarker am
12> where a._Refs_key = @refKey and 
13>       a._Antibody_key = am._Antibody_key and
14>       am._Marker_key = @markerKey
15> union
16> select a._Refs_key
17> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
18> where a._Antibody_key = am._Antibody_key and 
19>       am._Marker_key = @markerKey and 
20>       a._Antibody_key = aa._Antibody_key and 
21>       aa._Refs_key = @refKey
22> 
23> select count(*) from #count
24> 
1> 
2> grant execute on MRKXfer_count_GXDAntibody to public
1>  
2> drop procedure MRKXfer_count_GXDAntibodyAssay
1>  
2> create procedure MRKXfer_count_GXDAntibodyAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Assay records which use the Antibody for marker/reference pair
8>    to detect the Marker.
9> */
10>  
11> select a._Antibody_key 
12> into #antibody
13> from GXD_Antibody a, GXD_AntibodyMarker am
14> where a._Refs_key = @refKey and
15>       a._Antibody_key = am._Antibody_key and
16>       am._Marker_key = @markerKey
17> union
18> select a._Antibody_key
19> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
20> where a._Antibody_key = am._Antibody_key and
21>       am._Marker_key = @markerKey and
22>       a._Antibody_key = aa._Antibody_key and
23>       aa._Refs_key = @refKey
24>  
25> select count(a._Assay_key)
26> from #antibody p, GXD_AntibodyPrep xa, GXD_Assay a
27> where p._Antibody_key = xa._Antibody_key and
28>       xa._AntibodyPrep_key = a._AntibodyPrep_key and
29>       a._Marker_key = @markerKey
30> 
1>  
2> grant execute on MRKXfer_count_GXDAntibodyAssay to public
1>  
2> drop procedure MRKXfer_GXDAntibodyAssay
1>  
2> create procedure MRKXfer_GXDAntibodyAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Assay records which use the Antibody for marker/reference pair
8>    to detect the Marker.
9> */
10>  
11> select a._Antibody_key
12> into #antibody
13> from GXD_Antibody a, GXD_AntibodyMarker am
14> where a._Refs_key = @refKey and
15>       a._Antibody_key = am._Antibody_key and
16>       am._Marker_key = @markerKey
17> union
18> select a._Antibody_key
19> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
20> where a._Antibody_key = am._Antibody_key and
21>       am._Marker_key = @markerKey and
22>       a._Antibody_key = aa._Antibody_key and
23>       aa._Refs_key = @refKey
24>  
25> select a._Assay_key
26> into #assay
27> from #antibody p, GXD_AntibodyPrep xa, GXD_Assay a
28> where p._Antibody_key = xa._Antibody_key and
29>       xa._AntibodyPrep_key = a._AntibodyPrep_key and
30>       a._Marker_key = @markerKey
31>  
32> select a.mgiID
33> from #assay t, GXD_Assay_Summary_View a
34> where t._Assay_key = a._Object_key
35> 
1>  
2> grant execute on MRKXfer_GXDAntibodyAssay to public
1>  
2> drop procedure MRKXfer_GXDAntibody
1>  
2> create procedure MRKXfer_GXDAntibody
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return MGI Antibody Accession numbers for marker/reference pair */
8> 
9> select a._Antibody_key 
10> into #antibody
11> from GXD_Antibody a, GXD_AntibodyMarker am
12> where a._Refs_key = @refKey and
13>       a._Antibody_key = am._Antibody_key and
14>       am._Marker_key = @markerKey
15> union
16> select a._Antibody_key
17> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
18> where a._Antibody_key = am._Antibody_key and
19>       am._Marker_key = @markerKey and
20>       a._Antibody_key = aa._Antibody_key and
21>       aa._Refs_key = @refKey
22>  
23> select a.mgiID
24> from #antibody t, GXD_Antibody_Summary_View a
25> where t._Antibody_key = a._Object_key
26> 
1>  
2> grant execute on MRKXfer_GXDAntibody to public
1>  
2> drop procedure MRKXfer_count_GXDAssay
1>  
2> create procedure MRKXfer_count_GXDAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Assay records for marker/reference pair */
8> 
9> select count(_Refs_key) from GXD_Assay
10> where _Marker_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_GXDAssay to public
1>  
2> drop procedure MRKXfer_GXDAssay
1>  
2> create procedure MRKXfer_GXDAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return MGI Assay Accession numbers for marker/reference pair */
8> 
9> select _Assay_key
10> into #assay
11> from GXD_Assay
12> where _Marker_key = @markerKey and
13>       _Refs_key = @refKey
14> 
15> select a.mgiID
16> from #assay t, GXD_Assay_Summary_View a
17> where t._Assay_key = a._Object_key
18> 
1>  
2> grant execute on MRKXfer_GXDAssay to public
1>  
2> drop procedure MRKXfer_count_MLC
1>  
2> create procedure MRKXfer_count_MLC
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of MLC Text records for marker/reference pair */
8> 
9> select count(m._Marker_key) 
10> from MLC_Text_edit m, MLC_Reference_edit r
11> where m._Marker_key = @markerKey
12> and m._Marker_key = r._Marker_key
13> and r._Refs_key = @refKey
14> 
1> 
2> grant execute on MRKXfer_count_MLC to public
1>  
2> drop procedure MRKXfer_count_PRB
1>  
2> create procedure MRKXfer_count_PRB
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Probe records for marker/reference pair */
8> 
9> select count(distinct p.name) from PRB_Probe p, PRB_Marker m, PRB_Reference r
10> where m._Marker_key = @markerKey and
11>       m._Probe_key = r._Probe_key and
12>       r._Refs_key = @refKey and
13>       m._Probe_key = p._Probe_key
14> 
1> 
2> grant execute on MRKXfer_count_PRB to public
1>  
2> drop procedure MRKXfer_PRB
1>  
2> create procedure MRKXfer_PRB
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for marker/reference pair */
8> 
9> select distinct p.name, p._Probe_key
10> from PRB_Probe p, PRB_Marker m, PRB_Reference r
11> where m._Marker_key = @markerKey and
12>       m._Probe_key = r._Probe_key and
13>       r._Refs_key = @refKey and
14>       m._Probe_key = p._Probe_key
15>  
1>  
2> grant execute on MRKXfer_PRB to public
1> 
2> drop procedure MRKXfer_count_PRBAssay
1>  
2> create procedure MRKXfer_count_PRBAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for Assays which use Probe to detect Marker */
8> 
9> select distinct p.name, p._Probe_key
10> into #probe
11> from PRB_Probe p, PRB_Marker m, PRB_Reference r
12> where m._Marker_key = @markerKey and
13>       m._Probe_key = r._Probe_key and
14>       r._Refs_key = @refKey and
15>       m._Probe_key = p._Probe_key
16>  
17> select count(a._Assay_key)
18> from #probe p, GXD_ProbePrep xp, GXD_Assay a
19> where p._Probe_key = xp._Probe_key and
20>       xp._ProbePrep_key = a._ProbePrep_key and
21>       a._Marker_key = @markerKey
22> 
1> 
2> grant execute on MRKXfer_count_PRBAssay to public
1> 
2> drop procedure MRKXfer_PRBAssay
1>  
2> create procedure MRKXfer_PRBAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for Assays which use Probe to detect Marker */
8> 
9> select distinct p.name, p._Probe_key
10> into #probe
11> from PRB_Probe p, PRB_Marker m, PRB_Reference r
12> where m._Marker_key = @markerKey and
13>       m._Probe_key = r._Probe_key and
14>       r._Refs_key = @refKey and
15>       m._Probe_key = p._Probe_key
16>  
17> select a._Assay_key
18> into #assay
19> from #probe p, GXD_ProbePrep xp, GXD_Assay a
20> where p._Probe_key = xp._Probe_key and
21>       xp._ProbePrep_key = a._ProbePrep_key and
22>       a._Marker_key = @markerKey
23> 
24> select a.mgiID
25> from #assay t, GXD_Assay_Summary_View a
26> where t._Assay_key = a._Object_key
27> 
1> 
2> grant execute on MRKXfer_PRBAssay to public
1> 
2> drop procedure MRKXfer_count_PRBReference
1>  
2> create procedure MRKXfer_count_PRBReference
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Probes for marker/reference pair */
8> /* which contain more than one reference */
9>  
10> select distinct p._Probe_key, p.name
11> into #probe
12> from PRB_Probe p, PRB_Marker m, PRB_Reference r
13> where m._Marker_key = @markerKey and
14>       m._Probe_key = r._Probe_key and
15>       r._Refs_key = @refKey and
16>       m._Probe_key = p._Probe_key
17>  
18> select distinct t._Probe_key
19> into #count
20> from #probe t, PRB_Reference r
21> where t._Probe_key = r._Probe_key
22> group by t._Probe_key
23> having count(*) > 1
24>  
25> select count(*) from #count
26> 
1>  
2> grant execute on MRKXfer_count_PRBReference to public
1>  
2> drop procedure MRKXfer_PRBReference
1>  
2> create procedure MRKXfer_PRBReference
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for marker/reference pair */
8> /* which contain more than one reference */
9> 
10> 
11> select distinct p._Probe_key, p.name
12> into #probe
13> from PRB_Probe p, PRB_Marker m, PRB_Reference r
14> where m._Marker_key = @markerKey and
15>       m._Probe_key = r._Probe_key and
16>       r._Refs_key = @refKey and
17>       m._Probe_key = p._Probe_key
18>  
19> select t.name, t._Probe_key
20> from #probe t, PRB_Reference r
21> where t._Probe_key = r._Probe_key
22> group by t._Probe_key
23> having count(*) > 1
24> 
1>  
2> grant execute on MRKXfer_PRBReference to public
1> 
2> drop procedure MRKXfer_count_PRBNote
1>  
2> create procedure MRKXfer_count_PRBNote
3>   @probeKey integer,
4>   @marker varchar(25)
5> as
6>  
7> /* Return number of Probe Notes for probe/marker pair */
8> 
9> select count(_Probe_key) 
10> from PRB_Notes
11> where _Probe_key = @probeKey and
12>       note like "%" + @marker + "%"
13> 
1>  
2> grant execute on MRKXfer_count_PRBNote to public
1> 
2> drop procedure MRKXfer_count_MRKAccession
1>  
2> create procedure MRKXfer_count_MRKAccession
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Markers with accession/reference pair */
8> 
9> select count(*) from MRK_AccRef_View
10> where _Object_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_MRKAccession to public
1>  
2> drop procedure MRKXfer_MRKAccession
1>  
2> create procedure MRKXfer_MRKAccession
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Accession numbers for marker/reference pair */
8>  
9> select distinct accID
10> from MRK_AccRef_View
11> where _Object_key = @markerKey and
12>       _Refs_key = @refKey
13>  
1>  
2> grant execute on MRKXfer_MRKAccession to public
1>  
2> drop procedure MRKXfer_update
1> 
2> create procedure MRKXfer_update
3>   @oldMarkerKey integer,
4>   @newMarkerKey integer,
5>   @refKey integer
6> as
7> 
8> /* Update Mapping */
9> 
10> update MLD_Marker 
11> set _Marker_key = @newMarkerKey,
12>     modification_date = getdate()
13> where _Marker_key = @oldMarkerKey and 
14>       _Refs_key = @refKey
15>  
16> /* Select Probes which contain Marker/Reference pair */
17> 
18> select m._Probe_key, m._Marker_key
19> into #probe
20> from PRB_Marker m, PRB_Reference r
21> where m._Marker_key = @oldMarkerKey and 
22>       m._Probe_key = r._Probe_key and 
23>       r._Refs_key = @refKey
24> 
25> /* Select the Antibodies which contain the Marker/Reference pair */
26> 
27> select a._Antibody_key 
28> into #antibody
29> from GXD_Antibody a, GXD_AntibodyMarker am
30> where a._Refs_key = @refKey and
31>       a._Antibody_key = am._Antibody_key and
32>       am._Marker_key = @oldMarkerKey
33> union
34> select a._Antibody_key
35> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
36> where a._Antibody_key = am._Antibody_key and
37>       am._Marker_key = @oldMarkerKey and
38>       a._Antibody_key = aa._Antibody_key and
39>       aa._Refs_key = @refKey
40>  
41> /* Select GXD Assays which contain Probes/Markers involved in update */
42> /* Union */
43> /* Select GXD Assays which contain Antibodys/Markers involved in update */
44> /* Union */
45> /* Select GXD Assays which contain Marker/Reference pair */
46> 
47> select a._Assay_key
48> into #assay
49> from #probe p, GXD_ProbePrep xp, GXD_Assay a
50> where p._Probe_key = xp._Probe_key and
51>       xp._ProbePrep_key = a._ProbePrep_key and
52>       a._Marker_key = @oldMarkerKey
53> union
54> select a._Assay_key
55> from #antibody p, GXD_AntibodyPrep xa, GXD_Assay a
56> where p._Antibody_key = xa._Antibody_key and
57>       xa._AntibodyPrep_key = a._AntibodyPrep_key and
58>       a._Marker_key = @oldMarkerKey
59> union
60> select a._Assay_key
61> from GXD_Assay a
62> where a._Marker_key = @oldMarkerKey and
63>       a._Refs_key = @refKey
64> 
65> /* Update the GXD Assay records */
66> 
67> update GXD_Assay
68> set _Marker_key = @newMarkerKey,
69>     modification_date = getdate()
70> from #assay a, GXD_Assay gxd
71> where a._Assay_key = gxd._Assay_key
72> 
73> /* Update the GXD_Expression records */
74> 
75> declare @assayKey integer
76> declare assay_cursor cursor for
77> 	select _Assay_key from #assay 
78> 	for read only
79>  
80> open assay_cursor
81> fetch assay_cursor into @assayKey
82>  
83> while (@@sqlstatus = 0)
84> begin
85>   exec GXD_loadCacheByAssay @assayKey
86>   fetch assay_cursor into @assayKey
87> end
88>  
89> close assay_cursor
90> deallocate cursor assay_cursor
91> 
92> /* Update the Probes */
93> 
94> update PRB_Marker 
95> set _Marker_key = @newMarkerKey,
96>     modification_date = getdate()
97> from #probe p, PRB_Marker m
98> where p._Probe_key = m._Probe_key and 
99>       p._Marker_key = m._Marker_key
100>  
101> /* Update the GXD Antibodies */
102> 
103> update GXD_AntibodyMarker
104> set _Marker_key = @newMarkerKey,
105>     modification_date = getdate()
106> from #antibody a, GXD_AntibodyMarker am
107> where a._Antibody_key = am._Antibody_key
108> 
109> /* Update the GXD Antibody Aliases */
110> 
111> update GXD_AntibodyMarker
112> set _Marker_key = @newMarkerKey,
113>     modification_date = getdate()
114> from #antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
115> where a._Antibody_key = am._Antibody_key and 
116>       am._Marker_key = @oldMarkerKey and 
117>       a._Antibody_key = aa._Antibody_key and 
118>       aa._Refs_key = @refKey
119> 
120> /* Update the GXD Index */
121> 
122> update GXD_Index 
123> set _Marker_key = @newMarkerKey,
124>     modification_date = getdate()
125> where _Marker_key = @oldMarkerKey and 
126>       _Refs_key = @refKey
127>  
1> 
2> grant execute on MRKXfer_update to djr
1> 
2> grant execute on MRKXfer_update to progs
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure PRB_mergeStrain
1>  
2> drop procedure PRB_mergeStandardStrain
1>  
2> drop procedure PRB_getStrainReferences
1>  
2> create procedure PRB_getStrainReferences
3>   @strainKey int,
4>   @countOnly int = 0
5> as
6> 
7> /* Select all References and Data Sets for given Strain */
8>  
9> select distinct e._Refs_key, dataSet = 'Mapping'
10> into #references
11> from MLD_Expts e, MLD_InSitu m
12> where e._Expt_key = m._Expt_key
13> and m._Strain_key = @strainKey
14> union
15> select distinct e._Refs_key, dataSet = 'Mapping'
16> from MLD_Expts e, MLD_FISH m
17> where e._Expt_key = m._Expt_key
18> and m._Strain_key = @strainKey
19> union
20> select distinct e._Refs_key, dataSet = 'Mapping'
21> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
22> where e._Expt_key = m._Expt_key
23> and m._Cross_key = c._Cross_key
24> and c._femaleStrain_key = @strainKey
25> union
26> select distinct e._Refs_key, dataSet = 'Mapping'
27> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
28> where e._Expt_key = m._Expt_key
29> and m._Cross_key = c._Cross_key
30> and c._maleStrain_key = @strainKey
31> union
32> select distinct e._Refs_key, dataSet = 'Mapping'
33> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
34> where e._Expt_key = m._Expt_key
35> and m._Cross_key = c._Cross_key
36> and c._StrainHO_key = @strainKey
37> union
38> select distinct e._Refs_key, dataSet = 'Mapping'
39> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
40> where e._Expt_key = m._Expt_key
41> and m._Cross_key = c._Cross_key
42> and c._StrainHT_key = @strainKey
43> union
44> select distinct a._Refs_key, dataSet = 'Expression'
45> from GXD_Genotype s, GXD_Expression x, GXD_Assay a
46> where s._Strain_key = @strainKey
47> and s._Genotype_key = x._Genotype_key
48> and x._Assay_key = a._Assay_key
49> union
50> select distinct r._Refs_key, dataSet = 'RFLP'
51> from PRB_Reference r, PRB_RFLV v, PRB_Allele a, PRB_Allele_Strain s
52> where r._Reference_key = v._Reference_key
53> and v._RFLV_key = a._RFLV_key
54> and a._Allele_key = s._Allele_key
55> and s._Strain_key = @strainKey
56>  
57> if @countOnly = 1
58> begin
59> 	select count(*) from #references
60> end
61> else
62> begin
63> 	select a.jnumID, r.dataSet
64> 	from #references r, BIB_View a
65> 	where r._Refs_key = a._Refs_key
66> 	order by a.jnum
67> end
68> 
1> 
2> grant execute on PRB_getStrainReferences to public
1>  
2> drop procedure PRB_getStrainDataSets
1>  
2> create procedure PRB_getStrainDataSets
3>   @strainKey int,
4>   @countOnly int = 0
5> as
6> 
7> /* Select all Probes and Data Sets for given Strain */
8>  
9> select _Source_key into #source from PRB_Source
10> where _Strain_key = @strainKey
11> order by _Source_key
12> 
13> if (select count(*) from #source) = 0
14> begin
15> 	return
16> end
17> 
18> create unique clustered index index_Source_key on #source(_Source_key) with sorted_data
19> 
20> select p._Probe_key, dataSet = 'Molecular Segment'
21> into #probes
22> from PRB_Probe p, #source s
23> where p._Source_key = s._Source_key
24> union
25> select a._Antigen_key, dataSet = 'Antigen'
26> from GXD_Antigen a, #source s
27> where a._Source_key = s._Source_key
28> 
29> if @countOnly = 1
30> begin
31> 	select count(*) from #probes
32> end
33> else
34> begin
35> 	select a.accID, p.dataSet
36> 	from #probes p, PRB_Acc_View a
37> 	where p.dataSet = 'Molecular Segment'
38> 	and p._Probe_key = a._Object_key
39> 	and a.prefixPart = 'MGI:'
40> 	and a.preferred = 1
41> 	union
42> 	select a.accID, p.dataSet
43> 	from #probes p, GXD_Antigen_Acc_View a
44> 	where p.dataSet = 'Antigen'
45> 	and p._Probe_key = a._Object_key
46> 	and a.prefixPart = 'MGI:'
47> 	and a.preferred = 1
48> 	order by a.accID
49> end
50> 
1> 
2> grant execute on PRB_getStrainDataSets to public
1>  
2> drop procedure PRB_mergeTissue
1>  
2> create procedure PRB_mergeTissue
3>   @oldTissueKey int,
4>   @newTissueKey int
5> as
6> 
7> /*
8>  * Update old Tissue key to new Tissue key
9>  * in all relevant tables which contain a Tissue key.
10>  * When finished, remove the Tissue record for the old
11>  * Tissue key.
12> */
13> 
14> update PRB_Source
15> set _Tissue_key = @newTissueKey
16> where _Tissue_key = @oldTissueKey
17> 
18> delete from PRB_Tissue
19> where _Tissue_key = @oldTissueKey
20> 
1> 
2> grant execute on PRB_mergeTissue to editors
1>  
2> grant execute on PRB_mergeTissue to progs
1>  
2> drop procedure PRB_mergeStandardTissue
1>  
2> create procedure PRB_mergeStandardTissue
3>   @tissue varchar(255),
4>   @fromStandard int = 0,
5>   @toStandard int = 1
6> as
7>  
8> /* Given a Tissue, merge all of the records into one Tissue.
9>  *
10>  * Merge all Non-Standard Tissues into the Standard Tissue (default)
11>  * (exec PRB_mergeStandardTissue "Tissue")
12>  *
13>  * OR
14>  *
15>  * Merge all Standard Tissues into the Non-Standard Tissue
16>  * (exec PRB_mergeStandardTissue "Tissue", 1, 0)
17>  *
18> */
19> 
20> declare @newTissueKey integer
21> declare @oldTissueKey integer
22> 
23> if (select count(_Tissue_key) from PRB_Tissue
24>     where tissue = @tissue and standard = @toStandard) > 1
25> begin
26> 	rollback transaction
27> 	raiserror 99999 "More than one designation exists for Tissue: %1!", @tissue
28> 	return
29> end
30> 
31> if (select count(_Tissue_key) from PRB_Tissue
32>     where tissue = @tissue and standard = @toStandard) = 0
33> begin
34> 	rollback transaction
35> 	raiserror 99999 "No correct designation exists for Tissue: %1!", @tissue
36> 	return
37> end
38> 
39> select @newTissueKey = _Tissue_key from PRB_Tissue
40> where tissue = @tissue and standard = @toStandard
41> 
42> declare tissue_cursor cursor for
43> select _Tissue_key
44> from PRB_Tissue
45> where tissue = @tissue and standard = @fromStandard
46> for read only
47>  
48> open tissue_cursor
49>  
50> fetch tissue_cursor into @oldTissueKey
51>  
52> while (@@sqlstatus = 0)
53> begin
54> 	exec PRB_mergeTissue @oldTissueKey, @newTissueKey
55>         fetch tissue_cursor into @oldTissueKey
56> end
57>  
58> close tissue_cursor
59>  
60> deallocate cursor tissue_cursor
61>  
1> 
2> grant execute on PRB_mergeStandardTissue to editors
1>  
2> grant execute on PRB_mergeStandardTissue to progs
1>  
2> drop procedure PRB_getTissueDataSets
1>  
2> create procedure PRB_getTissueDataSets
3>   @tissueKey int,
4>   @countOnly int = 0
5> as
6> 
7> /* Select all Data Sets for given Tissue */
8>  
9> select _Source_key into #source from PRB_Source
10> where _Tissue_key = @tissueKey
11> order by _Source_key
12> 
13> if (select count(*) from #source) = 0
14> begin
15> 	return
16> end
17> 
18> create unique clustered index index_Source_key on #source(_Source_key) with sorted_data
19> 
20> select dataKey = p._Probe_key, dataSet = 'Molecular Segment'
21> into #datasets
22> from PRB_Probe p, #source s
23> where p._Source_key = s._Source_key
24> union
25> select dataKey = a._Antigen_key, dataSet = 'Antigen'
26> from GXD_Antigen a, #source s
27> where a._Source_key = s._Source_key
28> 
29> if @countOnly = 1
30> begin
31> 	select count(*) from #datasets
32> end
33> else
34> begin
35> 	select a.accID, d.dataSet, a.numericPart
36> 	from #datasets d, PRB_Acc_View a
37> 	where d.datakey = a._Object_key
38> 	and a.prefixPart = 'MGI:'
39> 	and a.preferred = 1
40> 	union
41> 	select a.accID, d.dataSet, a.numericPart
42> 	from #datasets d, GXD_Antigen_Acc_View a
43> 	where d.datakey = a._Object_key
44> 	and a.prefixPart = 'MGI:'
45> 	and a.preferred = 1
46> 	order by a.numericPart
47> end
48> 
1> 
2> grant execute on PRB_getTissueDataSets to public
1>  
2> checkpoint
1> 
2> drop procedure PRB_insertReference
1> 
2> create procedure PRB_insertReference
3> 	@refKey integer,
4> 	@probeKey integer,
5> 	@holder varchar(40)
6> as
7> 
8> /* Insert record into PRB_Reference if _Refs_key/_Probe_key pair does not already exist */
9> 
10> if (select count(*) from PRB_Reference 
11> 	where _Refs_key = @refKey and _Probe_key = @probeKey) > 0
12> begin
13> 	return
14> end
15> 
16> declare @maxReferenceKey integer
17> select @maxReferenceKey = max(_Reference_key) + 1 from PRB_Reference
18> 
19> insert into PRB_Reference
20> values (@maxReferenceKey, @probeKey, @refKey, @holder, 0, 0, getdate(), getdate())
21> 
1> 
2> grant execute on PRB_insertReference to editors
1> 
2> grant execute on PRB_insertReference to progs
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger ACC_Accession_Insert
1> 
2> create trigger ACC_Accession_Insert
3> on ACC_Accession
4> for insert
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   /* For SWISS-PROT, only allow specific users to edit Accession numbers */
10> 
11>   if (select _LogicalDB_key from inserted) = 13 and
12>      (select user_name()) not in ("mgd_dbo", "dbo", "rpp", "djr", "cgw", "dph")
13>   begin
14> 	rollback transaction
15> 	raiserror 99999 "You do not have permission to edit SWISS-PROT Accession numbers."
16> 	return
17>   end
18> 
19>   declare @accID varchar(30)
20>   select @accID = accID from inserted
21> 
22>   /* If adding Sequence ID for Molecular Segment */
23>   /* and the Sequence ID does not exist for one of the encoding Markers */
24>   if (select _LogicalDB_key from inserted) = 9 and
25>       (select _MGIType_key from inserted) = 3
26>   begin
27> 	/* test to see if any markers are specified to encode this segment
28>        (set within the Mol Probes EI's "Chr Marker Relationship" table) */
29>       if exists (select *
30>          from ACC_Accession a, PRB_Marker pm, inserted i
31>          where i._Object_key = pm._Probe_key and
32>          a._Object_key = pm._Marker_key and
33>          a._MGIType_key = 2 and
34>          a._LogicalDB_key = 9 and
35>          pm.relationship = 'E')
36>       begin
37>       /* if so, see if all of them have associated Sequence IDs entered
38>          for the encoding markers (from the Marker EI)*/
39>         if exists (select * 
40>                  from ACC_Accession a2, inserted i
41>                  where i._Object_key = a2._Object_key and
42>                  a2.accID = i.accID and
43>                  a2._MGIType_key = 3 and
44>                  a2.accID not in (select a.accID
45>                                from ACC_Accession a, PRB_Marker pm, inserted i
46>                                where i._Object_key = pm._Probe_key and 
47>                                a._Object_key = pm._Marker_key and
48> 		                       a._MGIType_key = 2 and
49>                                a._LogicalDB_key = 9 and
50>                                pm.relationship = 'E'))
51>         begin
52>            /* No. one or more encodes relationships are missing seq ids */ 
53>      	   print "Sequence IDs for Marker(s) encoding this segment do 
54> not exist for all encodes relationships specified. 
55> Some Sequence ids might need to be added."
56>         end
57>      end
58>   end
59> 
60>   /* If inserting the Sequence or SWISS-PROT ID for a Marker */
61>   /* and the same ID exists for another Marker...*/
62> 
63>   if (select _LogicalDB_key from inserted) in (9, 13) and
64>       (select _MGIType_key from inserted) = 2 and
65>       exists (select a._Accession_key
66>               from ACC_Accession a, inserted i
67>               where i.accID = a.accID and
68> 		    i._Object_key != a._Object_key and
69> 	            a._MGIType_key = 2)
70>   begin
71> 	print "The Accession ID '%1!' is associated with another Marker.", @accID
72>   end
73> 
74> end
75> 
1> 
2> drop trigger ACC_Accession_Update
1> 
2> create trigger ACC_Accession_Update
3> on ACC_Accession
4> for update
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   /* For SWISS-PROT, only allow specific users to edit Accession numbers */
10>  
11>   if (select _LogicalDB_key from inserted) = 13 and
12>      (select user_name()) not in ("mgd_dbo", "dbo", "rpp", "djr", "cgw", "dph")
13>   begin
14>         rollback transaction
15>         raiserror 99999 "You do not have permission to edit SWISS-PROT Accession numbers."
16>         return
17>   end
18>  
19>   declare @accID varchar(30)
20>   select @accID = accID from deleted
21> 
22>   /* If updating Sequence ID for Molecular Segment */
23>   /* and the same Sequence ID exists for one of the Segment's Markers... */
24> 
25>   if (select _LogicalDB_key from inserted) = 9 and
26>       (select _MGIType_key from inserted) = 3 and
27>       exists (select a._Accession_key
28>               from ACC_Accession a, PRB_Marker pm, deleted d
29>               where d.accID = a.accID and
30> 		    d._Object_key = pm._Probe_key and
31> 		    pm._Marker_key = a._Object_key and
32> 	            a._MGIType_key = 2)
33>   begin
34> 	print "Please review the relationship(s) between the Sequence ID '%1!' and the Molecular Segment's Marker(s).  These relationships may no longer be appropriate.", @accID
35>   end
36> 
37>   /* If updating the Sequence ID for a Marker */
38>   /* and the same Sequence ID exists for one of the Marker's Segments...*/
39> 
40>   if (select _LogicalDB_key from inserted) = 9 and
41>       (select _MGIType_key from inserted) = 2 and
42>       exists (select a._Accession_key
43>               from ACC_Accession a, PRB_Marker pm, deleted d
44>               where d.accID = a.accID and
45> 		    d._Object_key = pm._Marker_key and
46> 		    pm._Probe_key = a._Object_key and
47> 	            a._MGIType_key = 3)
48>   begin
49> 	print "Please review the relationship(s) between the Sequence ID '%1!' and its Molecular Segments.  These relationships may no longer be appropriate.", @accID
50>   end
51> 
52>   /* If updating the Sequence or SWISS-PROT ID for a Marker */
53>   /* and the same ID exists for another Marker...*/
54> 
55>   if (select _LogicalDB_key from inserted) in (9, 13) and
56>       (select _MGIType_key from inserted) = 2 and
57>       exists (select a._Accession_key
58>               from ACC_Accession a, inserted i
59>               where i.accID = a.accID and
60> 		    i._Object_key != a._Object_key and
61> 	            a._MGIType_key = 2)
62>   begin
63> 	print "The Accession ID '%1!' is associated with another Marker.", @accID
64>   end
65> end
66> 
67> /* If max J: in Acc table does not equal max J: in max table, then re-set max J: in max table */
68> 
69> if exists (select * from inserted where prefixPart = "J:")
70> begin
71>   declare @maxJ int
72>   select @maxJ = max(numericPart) from ACC_Accession(index index_prefixPart) where prefixPart = "J:"
73>   if @maxJ != (select maxNumericPart from ACC_AccessionMax where prefixPart = "J:")
74>   begin
75>     update ACC_AccessionMax
76>     set maxNumericPart = @maxJ
77>     where prefixPart = "J:"
78>   end
79> end
80> 
1> 
2> drop trigger ACC_Accession_Delete
1> 
2> create trigger ACC_Accession_Delete
3> on ACC_Accession
4> for delete
5> as
6> 
7> if @@rowcount = 1
8> begin
9> 
10>   /* For SWISS-PROT, only allow specific users to edit Accession numbers */
11>  
12>   if (select _LogicalDB_key from deleted) = 13 and
13>      (select user_name()) not in ("mgd_dbo", "dbo", "rpp", "djr", "cgw", "dph")
14>   begin
15>         rollback transaction
16>         raiserror 99999 "You do not have permission to edit SWISS-PROT Accession numbers."
17>         return
18>   end
19>  
20>   /* If deleting MGI Image Pixel number, then nullify X/Y Dimensions of IMG_Image record TR#134 */
21> 
22>   if (select _LogicalDB_key from deleted) = 19
23>   begin
24> 	update IMG_Image
25> 	set IMG_Image.xDim = null, 
26> 	    IMG_Image.yDim = null
27> 	from deleted, IMG_Image
28> 	where deleted._Object_key = IMG_Image._Image_key
29>   end
30> 
31>   /* If deleting Sequence ID from Molecular Segment */
32>   /* and the same Sequence ID exists for one of the Segment's Markers... */
33> 
34>   declare @accID varchar(30)
35>   select @accID = accID from deleted
36> 
37>   if (select _LogicalDB_key from deleted) = 9 and
38>       (select _MGIType_key from deleted) = 3 and
39>       exists (select a._Accession_key
40>               from ACC_Accession a, PRB_Marker pm, deleted d
41>               where d.accID = a.accID and
42> 		    d._Object_key = pm._Probe_key and
43> 		    pm._Marker_key = a._Object_key and
44> 	            a._MGIType_key = 2)
45>   begin
46> 	print "Please review the relationship(s) between the Sequence ID '%1!' and the Molecular Segment's Marker(s).  These relationships may no longer be appropriate.", @accID
47>   end
48> 
49>   /* If deleting the Sequence ID from a Marker */
50>   /* and the same Sequence ID exists for one of the Marker's Segments...*/
51> 
52>   if (select _LogicalDB_key from deleted) = 9 and
53>       (select _MGIType_key from deleted) = 2 and
54>       exists (select a._Accession_key
55>               from ACC_Accession a, PRB_Marker pm, deleted d
56>               where d.accID = a.accID and
57> 		    d._Object_key = pm._Marker_key and
58> 		    pm._Probe_key = a._Object_key and
59> 	            a._MGIType_key = 3)
60>   begin
61> 	print "Please review the relationship(s) between the Sequence ID '%1!' and its Molecular Segments.  These relationships may no longer be appropriate.", @accID
62>   end
63> end
64> 
65> /* If max J: in Acc table does not equal max J: in max table, then re-set max J: in max table */
66> 
67> if exists (select * from deleted where prefixPart = "J:")
68> begin
69>   declare @maxJ int
70>   select @maxJ = max(numericPart) from ACC_Accession(index index_prefixPart) where prefixPart = "J:"
71>   if @maxJ != (select maxNumericPart from ACC_AccessionMax where prefixPart = "J:")
72>   begin
73>     update ACC_AccessionMax
74>     set maxNumericPart = @maxJ
75>     where prefixPart = "J:"
76>   end
77> end
78> 
1> 
2> drop trigger ACC_AccessionReference_Insert
1> 
2> create trigger ACC_AccessionReference_Insert
3> on ACC_AccessionReference
4> for insert
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   if (select a._MGIType_key from ACC_Accession a, inserted i
10>       where a._Accession_key = i._Accession_key) = 2
11>   begin
12>         /* Insert entry in Marker Reference bucket if it doesn't already exist */
13> 
14>         if not exists (select * from MRK_Reference r, inserted i, ACC_Accession a
15>             where i._Accession_key = a._Accession_key and
16>                   a._Object_key = r._Marker_key and
17>                   r._Refs_key = i._Refs_key)
18>         begin
19>                 insert MRK_Reference (_Marker_key, _Refs_key, auto) 
20>                 select _Object_key, _Refs_key, 1 from inserted i, ACC_Accession a
21>                 where i._Accession_key = a._Accession_key
22>         end
23>   end
24> end
25> 
1> 
2> drop trigger ACC_AccessionReference_Update
1> 
2> create trigger ACC_AccessionReference_Update
3> on ACC_AccessionReference
4> for update
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   if update(_Refs_key) and
10>      (select a._MGIType_key from ACC_Accession a, inserted i
11>       where a._Accession_key = i._Accession_key) = 2
12>   begin
13>         /* Insert entry in Marker Reference bucket if it doesn't already exist */
14> 
15>         if not exists (select * from MRK_Reference r, inserted i, ACC_Accession a
16>             where i._Accession_key = a._Accession_key and
17>                   a._Object_key = r._Marker_key and
18>                   r._Refs_key = i._Refs_key)
19>         begin
20>                 insert MRK_Reference (_Marker_key, _Refs_key, auto) 
21>                 select _Object_key, _Refs_key, 1 from inserted i, ACC_Accession a
22>                 where i._Accession_key = a._Accession_key
23>         end
24>   end
25> end
26> 
1> 
2> drop trigger ACC_AccessionReference_Delete
1> 
2> create trigger ACC_AccessionReference_Delete
3> on ACC_AccessionReference
4> for delete
5> as
6> 
7> /* If AccID is not referenced by other References in ACC_AccessionReference,
8>    then delete AccID from ACC_Accesion table too.
9> */
10>  
11> if not exists (select * from ACC_AccessionReference a, deleted d
12>     where a._Accession_key = d._Accession_key)
13> begin
14> 	delete ACC_Accession 
15> 	from ACC_Accession a, deleted d
16> 	where a._Accession_key = d._Accession_key
17> end
18> 
1> 
2> checkpoint
1> 
2> drop trigger ACC_LogicalDB_Delete 
1> 
2> create trigger ACC_LogicalDB_Delete 
3> on ACC_LogicalDB
4> for delete
5> as
6> 
7> if exists (select * from deleted, ACC_Accession
8>         where ACC_Accession._LogicalDB_key = deleted._LogicalDB_key)
9>  
10> begin
11> 	rollback transaction
12> 	raiserror 99999 "Logical DB is referenced in Accession Record(s)"
13> 	return
14> end
15> 
16> delete ACC_ActualDB from ACC_ActualDB, deleted
17> where ACC_ActualDB._LogicalDB_key = deleted._LogicalDB_key
18> 
1>  
2>  
3> drop trigger ACC_LogicalDB_Update 
1> 
2> create trigger  ACC_LogicalDB_Update
3> on ACC_LogicalDB
4> for update
5> as
6> 
7> if update(_Species_key) and
8>    (select _Species_key from deleted) != (select _Species_key from inserted) and
9>    exists (select * from ACC_Accession, inserted
10>     where ACC_Accession._LogicalDB_key = inserted._LogicalDB_key)
11> begin
12> 	rollback transaction
13> 	raiserror 99999 "Cannot update Species because Accession numbers exist for this Logical DB."
14> 	return
15> end
16>  
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger BIB_Refs_Insert
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'BIB_Refs_Insert', because it doesn't exist in the
system catalogs.
1>  
2> create trigger BIB_Refs_Insert
3> on BIB_Refs
4> for insert
5> as
6>  
7> declare @pgs varchar(30)
8> select @pgs = pgs from inserted
9> 
10> /* Determine if new record constitutes a duplicate record */
11> /* within the Reference (BIB_Refs) table. */
12> /* Parameters to check are journal, year, volume and pages */
13>  
14> /* Mouse News Letter references are ignored because more than one */
15> /* reference can appear on the same page within this journal. */
16>   
17> if (select journal from inserted) != 'Mouse News Lett'
18> begin
19> 
20>   /* If pages in format "x", check for pages = x and pages like "x-%" */
21>   /* If pages in format "x-y", check for pages = x and pages like "x-%" */
22> 
23>   /* Strip off first page */
24>   if charindex("-", @pgs) > 0
25>   begin
26>     select @pgs = substring(@pgs, 1, charindex("-", @pgs) - 1)
27>   end
28> 
29>   if (select count(BIB_Refs._Refs_key) from BIB_Refs, inserted
30>       where BIB_Refs.journal = inserted.journal and
31>             BIB_Refs.year = inserted.year and
32>             BIB_Refs.vol = inserted.vol and
33>             (BIB_Refs.pgs = @pgs or BIB_Refs.pgs like @pgs + "-%")) > 1
34>   begin
35>     rollback transaction
36>     raiserror 99999 "Reference Already Exists"
37>     return
38>   end
39> end
40> 
41> declare @key integer
42> select @key = _Refs_key from inserted
43> exec ACC_assignMGI @key, "Reference"
44> 
45> if (@@error != 0)
46> begin
47>   rollback transaction
48>   return
49> end
50> 
1> 
2> drop trigger BIB_Refs_Update
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'BIB_Refs_Update', because it doesn't exist in the
system catalogs.
1>  
2> create trigger BIB_Refs_Update
3> on BIB_Refs
4> for update
5> as
6>  
7> update BIB_Refs 
8> set modification_date = getdate()
9> from BIB_Refs, inserted
10> where BIB_Refs._Refs_key = inserted._Refs_key
11>  
1>  
2> drop trigger BIB_Refs_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'BIB_Refs_Delete', because it doesn't exist in the
system catalogs.
1> 
2> create trigger BIB_Refs_Delete
3> on BIB_Refs
4> for delete
5> as
6> 
7> /* Before deleting a record, verify that the J# is not being */
8> /* referenced elsewhere in the database. */
9> 
10> if exists (select * from deleted
11>     where deleted.dbs like "%Nomen%")
12> begin
13>         rollback transaction
14>         raiserror 99999 "J# is referenced in Nomenclature Record(s)"
15> 	return
16> end
17> 
18> if exists (select * from MRK_History, deleted
19>     where MRK_History._Refs_key = deleted._Refs_key)
20> begin
21>         rollback transaction
22>         raiserror 99999 "J# is referenced in Marker History Record(s)"
23> 	return
24> end
25> 
26> if exists (select * from MRK_Other, deleted
27>     where MRK_Other._Refs_key = deleted._Refs_key)
28> begin
29>         rollback transaction
30>         raiserror 99999 "J# is referenced in Marker Other Name Record(s)"
31> 	return
32> end
33> 
34> if exists (select * from HMD_Homology, deleted
35>          where HMD_Homology._Refs_key = deleted._Refs_key)
36> begin
37>         rollback transaction
38>         raiserror 99999 "J# is referenced in Homology Record(s)"
39> 	return
40> end
41> 
42> if exists (select * from MLC_Reference, deleted
43>          where MLC_Reference._Refs_key = deleted._Refs_key)
44> begin
45>         rollback transaction
46>         raiserror 99999 "J# is referenced in MLC Record(s)"
47> 	return
48> end
49> 
50> if exists (select * from MLC_Reference_edit, deleted
51>          where MLC_Reference_edit._Refs_key = deleted._Refs_key)
52> begin
53>         rollback transaction
54>         raiserror 99999 "J# is referenced in MLC Edit Record(s)"
55> 	return
56> end
57> 
58> if exists (select * from MLD_Expts, deleted
59>          where MLD_Expts._Refs_key = deleted._Refs_key)
60> begin
61>         rollback transaction
62>         raiserror 99999 "J# is referenced in Mapping Record(s)"
63> 	return
64> end
65> 
66> if exists (select * from PRB_Reference, deleted
67>          where PRB_Reference._Refs_key = deleted._Refs_key)
68> begin
69>         rollback transaction
70>         raiserror 99999 "J# is referenced in Probe Record(s)"
71> 	return
72> end
73> 
74> if exists (select * from PRB_Source, deleted
75>          where PRB_Source._Refs_key = deleted._Refs_key)
76> begin
77>         rollback transaction
78>         raiserror 99999 "J# is referenced in Probe Source Record(s)"
79> 	return
80> end
81> 
82> if exists (select * from GXD_Index, deleted
83>          where GXD_Index._Refs_key = deleted._Refs_key)
84> begin
85>         rollback transaction
86>         raiserror 99999 "J# is referenced in GXD Index Record(s)"
87> 	return
88> end
89> 
90> if exists (select * from GXD_Antibody, deleted
91>          where GXD_Antibody._Refs_key = deleted._Refs_key)
92> begin
93>         rollback transaction
94>         raiserror 99999 "J# is referenced in GXD Antibody Record(s)"
95> 	return
96> end
97> 
98> if exists (select * from GXD_AntibodyAlias, deleted
99>          where GXD_AntibodyAlias._Refs_key = deleted._Refs_key)
100> begin
101>         rollback transaction
102>         raiserror 99999 "J# is referenced in GXD Antibody Alias Record(s)"
103> 	return
104> end
105> 
106> if exists (select * from GXD_Assay, deleted
107>          where GXD_Assay._Refs_key = deleted._Refs_key)
108> begin
109>         rollback transaction
110>         raiserror 99999 "J# is referenced in GXD Assay Record(s)"
111> 	return
112> end
113> 
114> if exists (select * from IMG_Image, deleted
115>          where IMG_Image._Refs_key = deleted._Refs_key)
116> begin
117>         rollback transaction
118>         raiserror 99999 "J# is referenced in GXD Image Record(s)"
119> 	return
120> end
121> 
122> if exists (select * from MRK_Reference, deleted
123>     where MRK_Reference._Refs_key = deleted._Refs_key)
124> begin
125>         rollback transaction
126>         raiserror 99999 "J# is referenced in Marker Reference Record(s)"
127> 	return
128> end
129> 
130> delete BIB_Books from BIB_Books, deleted
131> where BIB_Books._Refs_key = deleted._Refs_key
132> 
133> delete BIB_Notes from BIB_Notes, deleted
134> where BIB_Notes._Refs_key = deleted._Refs_key
135> 
136> delete ACC_Accession
137> from ACC_Accession a, ACC_MGIType m, deleted
138> where a._Object_key = deleted._Refs_key
139> and a._MGIType_key = m._MGIType_key
140> and m.name = "Reference"
141> 
1> 
2> drop trigger BIB_ReviewStatus_Delete
1> 
2> create trigger BIB_ReviewStatus_Delete
3> on BIB_ReviewStatus
4> for delete
5> as
6> 
7> /* Before deleting a record, verify that the Status is not being */
8> /* referenced elsewhere in the database. */
9> 
10> if exists (select * from BIB_Refs, deleted
11>     where BIB_Refs._ReviewStatus_key = deleted._ReviewStatus_key)
12> begin
13>         rollback transaction
14>         raiserror 99999 "Review Status is referenced in Reference Record(s)"
15> 	return
16> end
17> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger CRS_Cross_Delete
1> 
2> create trigger CRS_Cross_Delete
3> on CRS_Cross
4> for delete
5> as
6> 
7> /* Disallow removal of a record if the Cross is referenced in MLDP */
8> 
9> if (select count(*) from MLD_Matrix, deleted
10>     where MLD_Matrix._Cross_key = deleted._Cross_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Cross is referenced in MLDP Record(s)"
14> 	return
15> end
16> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger GXD_Genotype_Delete
1> 
2> create trigger GXD_Genotype_Delete
3> on GXD_Genotype
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> /*if (select count(*) from GXD_GelLane, deleted */
10> /*    where GXD_GelLane._Genotype_key = deleted._Genotype_key) > 0 */
11> /*begin */
12> /*        rollback transaction */
13> /*        raiserror 99999 "Genotype is referenced in Gel Lane Record(s)" */
14> /*	return */
15> /*end */
16> 
17> /*if (select count(*) from GXD_Specimen, deleted */
18> /*    where GXD_Specimen._Genotype_key = deleted._Genotype_key) > 0 */
19> /*begin */
20> /*        rollback transaction */
21> /*        raiserror 99999 "Genotype is referenced in Specimen Record(s)" */
22> /*	return */
23> /*end */
24> 
25> /*if (select count(*) from GXD_Expression, deleted */
26> /*    where GXD_Expression._Genotype_key = deleted._Genotype_key) > 0 */
27> /*begin */
28> /*        rollback transaction */
29> /*        raiserror 99999 "Genotype is referenced in Expression Results (cache) Record(s)" */
30> /*	return */
31> /*end */
32> 
33> delete GXD_AllelePair from GXD_AllelePair, deleted
34> where GXD_AllelePair._Genotype_key = deleted._Genotype_key
35>  
1> 
2> drop trigger GXD_Antigen_Insert
1>  
2> create trigger GXD_Antigen_Insert
3> on GXD_Antigen
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Antigen */
8>  
9> declare @key integer
10> select @key = _Antigen_key from inserted
11> exec ACC_assignMGI @key, "Antigen"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18> 
1>  
2> drop trigger GXD_Antigen_Delete
1> 
2> create trigger GXD_Antigen_Delete
3> on GXD_Antigen
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Antibody, deleted
10>     where GXD_Antibody._Antigen_key = deleted._Antigen_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antigen is referenced in Antibody Record(s)"
14> 	return
15> end
16> 
17> /* If Probe Source Name is null, then Anonymous Source */
18> /* If Anonymous Source, delete upon deletion of Antigen */
19>  
20> if not exists (select * from GXD_Antigen, deleted
21>     where GXD_Antigen._Source_key = deleted._Source_key)
22> begin
23>         delete PRB_Source from PRB_Source, deleted
24>         where PRB_Source._Source_key = deleted._Source_key
25>               and PRB_Source.name is null
26> end
27>  
28> delete ACC_Accession 
29> from ACC_Accession a, ACC_MGIType m, deleted
30> where a._Object_key = deleted._Antigen_key
31> and a._MGIType_key = m._MGIType_key
32> and m.name = "Antigen"
33>   
1> 
2> drop trigger GXD_Antibody_Insert
1>  
2> create trigger GXD_Antibody_Insert
3> on GXD_Antibody
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Antibody */
8>  
9> declare @key integer
10> select @key = _Antibody_key from inserted
11> exec ACC_assignMGI @key, "Antibody"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1>  
2> drop trigger GXD_Antibody_Delete
1> 
2> create trigger GXD_Antibody_Delete
3> on GXD_Antibody
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_AntibodyPrep, deleted
10>     where GXD_AntibodyPrep._Antibody_key = deleted._Antibody_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody is referenced in Antibody Prep Record(s)"
14> 	return
15> end
16> 
17> delete GXD_AntibodyMarker from GXD_AntibodyMarker, deleted
18> where GXD_AntibodyMarker._Antibody_key = deleted._Antibody_key
19>  
20> delete ACC_Accession
21> from ACC_Accession a, ACC_MGIType m, deleted
22> where a._Object_key = deleted._Antibody_key
23> and a._MGIType_key = m._MGIType_key
24> and m.name = "Antibody"
25>  
1> 
2> /* GXD_Structure */
3> 
4> 
5> drop trigger GXD_Structure_Insert
1> 
2> create trigger GXD_Structure_Insert
3> on GXD_Structure
4> for insert
5> as
6> 
7> /* Ensure that _Parent_key of inserted exists as a _Structure_key and
8>    that parent has the same _Stage_key as inserted, if _Parent_key != NULL */
9> 
10> if (select _Parent_key from inserted) != NULL
11> begin
12>     if not exists (select *
13>         from GXD_Structure s, inserted
14>         where inserted._Parent_key = s._Structure_key
15>         and inserted._Stage_key = s._Stage_key)
16>     begin
17>        rollback transaction
18>        raiserror 99999 "GXD_Structure_Insert: Specified parent Structure does not exist"
19>        return
20>     end
21> end
22> 
23> declare @treeDepth integer
24> select @treeDepth = 1  /* assume that we are adding a child of a Stage node */
25> 
26> /* if the assumption doesn't hold, then the following query will set the
27>    current child's treeDepth */ 
28> 
29> 
30> /* find out the depth of the parent structure */
31> select @treeDepth = s.treeDepth + 1
32> from GXD_Structure s, inserted
33> where s._Structure_key = inserted._Parent_key 
34> 
35> /* update the inserted node */
36> update GXD_Structure
37> set treeDepth = @treeDepth
38> from GXD_Structure s, inserted
39> where s._Structure_key = inserted._Structure_key
40> 
41> if @@error != 0
42> begin
43>   rollback transaction
44>   raiserror 99999 "GXD_Structure_Insert: Update of treeDepth failed"
45>   return
46> end
47> 
48> /* incrementally modify the closure */
49> 
50> declare @inp integer  /* inserted node's parent */
51> select @inp = _Parent_key from inserted
52> 
53> /* _Parent_key will be null for an immediate child of a stage root,
54>    this node, by definition will not have any entries in the closure table,
55>    since it is a root node as far as the database is concerned */ 
56> 
57> if @inp != NULL
58> begin
59>    
60>    declare ancest_cursor cursor
61>    for select c._Structure_key
62>        from GXD_StructureClosure c
63>        where c._Descendent_key = @inp
64>    
65>    declare @sk integer
66>    declare @isk integer
67>    select @isk = _Structure_key from inserted  
68>    
69>    open ancest_cursor
70>    fetch ancest_cursor into @sk
71>    while (@@sqlstatus = 0)
72>    begin
73>       /* for each ancestor, insert ancestor's _Structure_key, inserted's 
74>          _Structure_key in GXD_StructureClosure */ 
75>       insert into GXD_StructureClosure (_Structure_key, _Descendent_key) 
76>              values (@sk, @isk)
77>       if @@error != 0
78>       begin
79>          rollback transaction
80>          raiserror 99999 "GXD_Structure_Insert: Incremental insert on closure table failed"
81>          close ancest_cursor
82>          return
83>       end
84>       fetch ancest_cursor into @sk
85>    end
86>    close ancest_cursor
87>    
88>    /* finally, insert the inserted node's _Parent_key and the inserted node's
89>       _Structure_key into the closure table */
90>    
91>    insert into GXD_StructureClosure (_Structure_key, _Descendent_key)
92>        values (@inp, @isk)
93>    if @@error != 0
94>    begin
95>       rollback transaction
96>       raiserror 99999 "GXD_Structure_Insert: Incremental insert on closure table failed"
97>       return
98>    end
99> end
100> 
101> /* Do not compute the printName for the inserted structure here!
102>    this will be taken care of by the GXD_StructureName triggers.
103>    The name records must be in place before a printName recomputation
104>    can be done. */ 
105> 
106> 
1> 
2> drop trigger GXD_Structure_Update
1> 
2> create trigger GXD_Structure_Update
3> on GXD_Structure
4> for update
5> as
6>    update GXD_Structure
7>    set s.modification_date = getdate()  
8>    from GXD_Structure s, inserted
9>    where s._Structure_key = inserted._Structure_key 
10> 
11>    /* make certain that printStop bits don't get cleared on Structures
12>       that are children of the Stage root nodes */
13> 
14>    if exists (select printStop 
15>               from inserted
16>               where printStop = 0 
17>               and _Parent_key = NULL)
18>    begin
19>         rollback transaction
20>         raiserror 99999 "GXD_Structure_Update: Cannot clear printStop on child of stage root"
21>         return
22>    end
23> 
24>    /* recalculate printnames on those structures where printStop has
25>       been changed */
26>  
27>    declare pstop_cursor cursor
28>    for select inserted._Structure_key
29>        from deleted, inserted
30>        where deleted.printStop != inserted.printStop
31>        and deleted._Structure_key = inserted._Structure_key
32>  
33>    declare @sk integer
34>    open pstop_cursor
35>    fetch pstop_cursor into @sk
36>    while (@@sqlstatus = 0)
37>    begin
38>        exec GXD_ComputePrintNamesFrom @sk
39>        if @@error != 0
40>        begin
41>            rollback transaction
42>            raiserror 99999 "GXD_Structure_Update: GXD_ComputePrintNamesFrom fail
43> ed"
44>            close pstop_cursor
45>            return
46>        end
47>        fetch pstop_cursor into @sk
48>    end
49>    close pstop_cursor
50> 
1> 
2> drop trigger GXD_Structure_Delete
1> 
2> create trigger GXD_Structure_Delete
3> on GXD_Structure
4> for delete
5> as
6> 
7> /* Disallow deletion if record is not an MGI-added record, but
8>    only if the user does not have the sa_role */
9> 
10> if exists (select * from deleted where edinburghkey != NULL)
11> begin
12> 	if (select proc_role("sa_role")) != 1
13>         begin
14>            rollback transaction
15>            raiserror 99999 "GXD_Structure_Delete: Structure is not an MGI-added record"
16> 	       return
17>         end
18> end
19> 
20> /* Disallow deletion if record is not a leaf node, i.e. it has descendents */
21> 
22> if exists (select * from GXD_StructureClosure, deleted
23>     where GXD_StructureClosure._Structure_key = deleted._Structure_key)
24> begin
25>         rollback transaction
26>         raiserror 99999 "GXD_Structure_Delete: Structure is not a leaf node; it has descendents"
27>         return
28> end
29> 
30> /* Disallow deletion if record is referenced elsewhere */
31> 
32> if exists (select * from GXD_ISResultStructure, deleted
33>     where GXD_ISResultStructure._Structure_key = deleted._Structure_key)
34> begin
35>         rollback transaction
36>         raiserror 99999 "GXD_Structure_Delete: Structure is referenced in InSitu Result Record(s)"
37>         return
38> end
39>  
40> if exists (select * from GXD_GelLaneStructure, deleted
41>     where GXD_GelLaneStructure._Structure_key = deleted._Structure_key)
42> begin
43>         rollback transaction
44>         raiserror 99999 "GXD_Structure_Delete: Structure is referenced in Gel Lane Structure Record(s)"
45>         return
46> end
47> 
48> if exists (select * from GXD_Expression, deleted
49>     where GXD_Expression._Structure_key = deleted._Structure_key)
50> begin
51>         rollback transaction
52>         raiserror 99999 "GXD_Structure_Delete: Structure is referenced in Expression Results (cache) Record(s)"
53> 	    return
54> end
55> 
56> /* incrementally modify the closure */
57> delete GXD_StructureClosure 
58> from GXD_StructureClosure sc, deleted
59> where sc._Descendent_key = deleted._Structure_key
60> 
61> if @@error != 0
62> begin
63>     rollback transaction
64>     raiserror 99999 "GXD_Structure_Delete: Delete of closure records failed"
65>     return
66> end
67> 
68> /* cascade deletes into the StructureName table */
69> delete GXD_StructureName
70> from GXD_StructureName sn, deleted
71> where sn._Structure_key = deleted._Structure_key
72> 
73> if @@error != 0
74> begin
75>     rollback transaction
76>     raiserror 99999 "GXD_Structure_Delete: Cascaded delete of StructureNames failed"
77>     return
78> end
79> 
1> 
2> /* GXD_StructureName */
3> 
4> drop trigger GXD_StructureName_Insert
1> 
2> create trigger GXD_StructureName_Insert
3> on GXD_StructureName
4> for insert
5> as
6> 
7> /* ensure that the structure specified exists */
8> if not exists(select * 
9>               from GXD_Structure s, inserted
10>               where s._Structure_key = inserted._Structure_key)
11> begin
12>     rollback transaction
13>     raiserror 99999 "GXD_StructureName_Insert: Inserted StructureName specifies a non-existent Structure"
14>     return
15> end
16> 
17> /* look for duplicate (structure key, structure) tuples */
18> 
19> if (select count(*) from 
20>    GXD_StructureName sn, inserted
21>    where sn._Structure_key = inserted._Structure_key
22>    and sn.structure = inserted.structure) >  1
23> begin
24>     rollback transaction
25>     raiserror 99999 "GXD_StructureName_Insert: Inserted StructureName has duplicate structure attribute"
26>     return
27> end
28> 
29> /* Prevent two children from having the same preferred name */
30> 
31> 
32> if (select count(*)
33>     from GXD_Structure s1, GXD_Structure s2, GXD_StructureName sn2, inserted
34>     where s1._Parent_key = s2._Parent_key
35>     and sn2._StructureName_key = s2._StructureName_key
36>     and inserted._StructureName_key = s1._StructureName_key 
37>     and inserted.structure = sn2.structure) > 1
38> begin
39>     rollback transaction
40>     raiserror 99999 "GXD_StructureName_Insert: Parent node cannot have two children with the same preferred name"
41>     return
42> end
43> 
44> /* call stored procedure that recalculates printNames, if a preferred
45>    structure name is changed.  Preferred StructureNames are those
46>    that are referred to by a record in GXD_Structure */
47> 
48> declare updatesk_cursor cursor
49> for select s._Structure_key 
50>     from GXD_Structure s, inserted
51>     where s._StructureName_key = inserted._StructureName_key
52> 
53> declare @isk integer
54> 
55> open updatesk_cursor
56> fetch updatesk_cursor into @isk
57> 
58> while (@@sqlstatus = 0)
59> begin
60>    exec GXD_ComputePrintNamesFrom @isk 
61>    if @@error != 0
62>    begin
63>         rollback transaction
64>         raiserror 99999 "GXD_StructureName_Insert: GXD_ComputePrintNamesFrom failed"
65>         close updatesk_cursor
66>         return
67>    end
68>    fetch updatesk_cursor into @isk
69> end
70> 
71> close updatesk_cursor
72> 
1> 
2> drop trigger GXD_StructureName_Update
1> 
2> create trigger GXD_StructureName_Update
3> on GXD_StructureName
4> for update
5> as
6> 
7> if (select count(*) from GXD_Structure s, inserted
8>     where s._Structure_key = inserted._Structure_key) !=
9>    (select count(*) from inserted)
10> begin
11>     rollback transaction
12>     raiserror 99999 "GXD_StructureName_Update: Non-existent Structure in StructureName record"
13>     return
14> end
15> 
16> 
17> if (select count(*) from 
18>     GXD_StructureName sn, inserted
19>     where sn._Structure_key = inserted._Structure_key
20>     and sn.structure = inserted.structure) > 
21>    (select count(*) from inserted)
22> begin
23>     rollback transaction
24>     raiserror 99999 "GXD_StructureName_Update: Inserted StructureName has duplicate structure attribute"
25>     return
26> end
27> 
28> update GXD_StructureName
29> set sn.modification_date = getdate()  
30> from GXD_StructureName sn, inserted
31> where sn._Structure_key = inserted._Structure_key 
32> 
33> /* call stored procedure that recalculates printNames, if a preferred
34>    structure name is changed.  Preferred StructureNames are those
35>    that are referred to by a record in GXD_Structure */
36> 
37> declare updatesk_cursor cursor
38> for select s._Structure_key 
39>     from GXD_Structure s, inserted
40>     where s._StructureName_key = inserted._StructureName_key
41> 
42> declare @isk integer
43> 
44> open updatesk_cursor
45> fetch updatesk_cursor into @isk
46> 
47> while (@@sqlstatus = 0)
48> begin
49>    exec GXD_ComputePrintNamesFrom @isk 
50>    if @@error != 0
51>    begin
52>         rollback transaction
53>         raiserror 99999 "GXD_StructureName_Update: GXD_ComputePrintNamesFrom failed"
54>         close updatesk_cursor
55>         return
56>    end
57>    fetch updatesk_cursor into @isk
58> end
59> 
60> close updatesk_cursor
61> 
1> 
2> drop trigger GXD_StructureName_Delete
1> 
2> create trigger GXD_StructureName_Delete
3> on GXD_StructureName
4> for delete
5> as
6> 
7> /* check to see if a Structure references the StructureNames being deleted */
8> 
9> if exists (select * from GXD_Structure, deleted
10>     where GXD_Structure._StructureName_key = deleted._StructureName_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "GXD_StructureName_Delete: Structure Name is referenced in Structure Record(s)"
14> 	return
15> end
16> 
1> 
2> /* GXD_StructureClosure */
3> 
4> drop trigger GXD_StructureClosure_Insert
1> 
2> create trigger GXD_StructureClosure_Insert
3> on GXD_StructureClosure
4> for insert
5> as
6> 
7> /* check to see if a Structure exists for the inserted structure keys */
8> if not exists(select * 
9>               from GXD_Structure s, inserted
10>               where s._Structure_key = inserted._Structure_key)
11> begin
12>     rollback transaction
13>     raiserror 99999 "GXD_StructureClosure_Insert: Non-existent Structure in StructureClosure record"
14>     return
15> end
1> 
2> drop trigger GXD_StructureClosure_Update
1> 
2> create trigger GXD_StructureClosure_Update
3> on GXD_StructureClosure
4> for update 
5> as
6> 
7> /* check to see if a Structure exists for the updated structure keys */
8> 
9> if (select count(*) 
10>     from GXD_Structure s, inserted 
11>     where s._Structure_key = inserted._Structure_key) !=
12>    (select count(*) from inserted)
13> begin
14>     rollback transaction
15>     raiserror 99999 "GXD_StructureClosure_Update: Non-existent Structure in StructureClosure record"
16>     return
17> end
1> drop trigger GXD_StructureClosure_Delete
1> 
2> create trigger GXD_StructureClosure_Delete
3> on GXD_StructureClosure
4> for delete
5> as
6> 
7> if exists (select * from GXD_Structure, deleted
8>     where GXD_Structure._Structure_key = deleted._Descendent_key)
9> begin
10>         rollback transaction
11>         raiserror 99999 "GXD_StructureClosure_Delete: Structure is referenced in GXD_Structure"
12>         return
13> end
14> 
1> 
2> /* GXD_TheilerStage */
3> 
4> drop trigger GXD_TheilerStage_Delete
1> 
2> create trigger GXD_TheilerStage_Delete
3> on GXD_TheilerStage
4> for delete
5> as
6> 
7> /* Totally disallow deletions of these records ??? */
8> 
9> rollback transaction
10> raiserror 99999 "Cannot delete Theiler Stage Record(s)"
11> return
12> 
13> if exists (select * from GXD_Structure, deleted
14>     where GXD_Structure._Stage_key = deleted._Stage_key)
15> begin
16>         rollback transaction
17>         raiserror 99999 "Theiler Stage is referenced in Structure Record(s)"
18>         return
19> end
20> 
1> 
2> drop trigger GXD_ProbePrep_Delete
1> 
2> create trigger GXD_ProbePrep_Delete
3> on GXD_ProbePrep
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Assay, deleted
10>     where GXD_Assay._ProbePrep_key = deleted._ProbePrep_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Probe Prep is referenced in Assay Record(s)"
14>         return
15> end
16> 
1> 
2> drop trigger GXD_AntibodyPrep_Delete
1> 
2> create trigger GXD_AntibodyPrep_Delete
3> on GXD_AntibodyPrep
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Assay, deleted
10>     where GXD_Assay._AntibodyPrep_key = deleted._AntibodyPrep_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody Prep is referenced in Assay Record(s)"
14>         return
15> end
16> 
1> 
2> drop trigger GXD_Assay_Insert
1>  
2> create trigger GXD_Assay_Insert
3> on GXD_Assay
4> for insert
5> as
6>  
7> declare @key integer
8> select @key = _Assay_key from inserted
9> 
10> /* Assign MGI Accession number for Assay */
11> exec ACC_assignMGI @key, "Assay"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
19> /* Insert entry in Reference bucket if it doesn't already exist */
20>  
21> if not exists (select * from MRK_Reference, inserted
22>     where MRK_Reference._Marker_key = inserted._Marker_key and
23>           MRK_Reference._Refs_key = inserted._Refs_key)
24> begin
25>   insert MRK_Reference (_Marker_key, _Refs_key, auto) 
26>   select _Marker_key, _Refs_key, 1 from inserted
27>   where _Refs_key is not null
28> end
29> 
1>  
2> drop trigger GXD_Assay_Update
1>  
2> create trigger GXD_Assay_Update
3> on GXD_Assay
4> for update
5> as
6>  
7> /* Insert entry in Reference bucket if it doesn't already exist */
8>  
9> if @@rowcount = 1
10>    and
11>    (update(_Refs_key) or update(_Marker_key))
12>    and
13>    not exists (select * from MRK_Reference, inserted
14>     where MRK_Reference._Marker_key = inserted._Marker_key and
15>           MRK_Reference._Refs_key = inserted._Refs_key)
16> begin
17>         insert MRK_Reference (_Marker_key, _Refs_key, auto) 
18>         select _Marker_key, _Refs_key, 1 from inserted
19>         where _Refs_key is not null
20> end
21>  
22> declare @key integer
23> select @key = _Assay_key from inserted
24> 
25> /* Update Expression Cache for Assay */
26> /* The update of a GXD_Assay record should be called AFTER any updates to GXD detail records */
27> 
28> exec GXD_loadCacheByAssay @key
29> 
1>  
2> drop trigger GXD_Assay_Delete
1> 
2> create trigger GXD_Assay_Delete
3> on GXD_Assay
4> for delete
5> as
6> 
7> delete GXD_Specimen from GXD_Specimen, deleted
8> where GXD_Specimen._Assay_key = deleted._Assay_key
9>  
10> delete GXD_GelLane from GXD_GelLane, deleted
11> where GXD_GelLane._Assay_key = deleted._Assay_key
12>  
13> delete GXD_GelRow from GXD_GelRow, deleted
14> where GXD_GelRow._Assay_key = deleted._Assay_key
15>  
16> delete GXD_AssayNote from GXD_AssayNote, deleted
17> where GXD_AssayNote._Assay_key = deleted._Assay_key
18>  
19> delete GXD_Expression from GXD_Expression, deleted
20> where GXD_Expression._Assay_key = deleted._Assay_key
21>  
22> delete GXD_ProbePrep from GXD_ProbePrep, deleted
23> where GXD_ProbePrep._ProbePrep_key = deleted._ProbePrep_key
24> 
25> delete GXD_AntibodyPrep from GXD_AntibodyPrep, deleted
26> where GXD_AntibodyPrep._AntibodyPrep_key = deleted._AntibodyPrep_key
27> 
28> delete ACC_Accession
29> from ACC_Accession a, ACC_MGIType m, deleted
30> where a._Object_key = deleted._Assay_key
31> and a._MGIType_key = m._MGIType_key
32> and m.name = "Assay"
33>  
1> 
2> drop trigger GXD_GelLane_Delete
1> 
2> create trigger GXD_GelLane_Delete
3> on GXD_GelLane
4> for delete
5> as
6> 
7> delete GXD_GelLaneStructure from GXD_GelLaneStructure, deleted
8> where GXD_GelLaneStructure._GelLane_key = deleted._GelLane_key
9>  
10> delete GXD_GelBand from GXD_GelBand, deleted
11> where GXD_GelBand._GelLane_key = deleted._GelLane_key
12> 
13> /* If Genotypes are specific to each specimen... */
14> 
15> if not exists (select * from GXD_GelLane, deleted
16> 	where GXD_GelLane._Genotype_key = deleted._Genotype_key)
17> begin
18> 	delete GXD_Genotype from GXD_Genotype, deleted
19> 	where GXD_Genotype._Genotype_key = deleted._Genotype_key
20> 	      and GXD_Genotype._Genotype_key >= 0
21> end
22> 
1> 
2> drop trigger GXD_GelRow_Insert
1> 
2> create trigger GXD_GelRow_Insert
3> on GXD_GelRow
4> for insert
5> as
6> 
7> if (select size from inserted) is not null and
8>    (select _GelUnits_key from inserted) < 0
9> begin
10>   rollback transaction
11>   raiserror 99999 "If Gel Row Size is entered, Gel Row Units must be specified."
12>   return
13> end
14> 
1> 
2> drop trigger GXD_GelRow_Update
1> 
2> create trigger GXD_GelRow_Update
3> on GXD_GelRow
4> for update
5> as
6> 
7> if (select size from inserted) is not null and
8>    (select _GelUnits_key from inserted) < 0
9> begin
10>   rollback transaction
11>   raiserror 99999 "If Gel Row Size is entered, Gel Row Units must be specified."
12>   return
13> end
14> 
1> 
2> drop trigger GXD_GelRow_Delete
1> 
2> create trigger GXD_GelRow_Delete
3> on GXD_GelRow
4> for delete
5> as
6> 
7> delete GXD_GelBand from GXD_GelBand, deleted
8> where GXD_GelBand._GelRow_key = deleted._GelRow_key
9> 
1> 
2> drop trigger GXD_Specimen_Delete
1> 
2> create trigger GXD_Specimen_Delete
3> on GXD_Specimen
4> for delete
5> as
6> 
7> /* If Genotypes are specific to each specimen... */
8> 
9> if not exists (select * from GXD_Specimen, deleted
10> 	where GXD_Specimen._Genotype_key = deleted._Genotype_key)
11> begin
12> 	delete GXD_Genotype from GXD_Genotype, deleted
13> 	where GXD_Genotype._Genotype_key = deleted._Genotype_key
14> 	      and GXD_Genotype._Genotype_key >= 0
15> end
16> 
17> delete GXD_InSituResult from GXD_InSituResult, deleted
18> where GXD_InSituResult._Specimen_key = deleted._Specimen_key
19> 
1> 
2> drop trigger GXD_InSituResult_Delete
1> 
2> create trigger GXD_InSituResult_Delete
3> on GXD_InSituResult
4> for delete
5> as
6> 
7> delete GXD_InSituResultImage from GXD_InSituResultImage, deleted
8> where GXD_InSituResultImage._Result_key = deleted._Result_key
9> 
10> delete GXD_ISResultStructure from GXD_ISResultStructure, deleted
11> where GXD_ISResultStructure._Result_key = deleted._Result_key
12> 
1> 
2> drop trigger GXD_Index_Delete
1> 
2> create trigger GXD_Index_Delete
3> on GXD_Index
4> for delete
5> as
6> 
7> delete GXD_Index_Stages from GXD_Index_Stages, deleted
8> where GXD_Index_Stages.index_id = deleted.index_id
9> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger GXD_AntibodyClass_Delete
1> 
2> create trigger GXD_AntibodyClass_Delete
3> on GXD_AntibodyClass
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Antibody, deleted
10>     where GXD_Antibody._AntibodyClass_key = deleted._AntibodyClass_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody Class is referenced in Antibody Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger GXD_AntibodyType_Delete
1>  
2> create trigger GXD_AntibodyType_Delete
3> on GXD_AntibodyType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_Antibody, deleted
10>     where GXD_Antibody._AntibodyType_key = deleted._AntibodyType_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody Type is referenced in Antibody Record(s)"
14>         return
15> end
16>  
1> 
2> drop trigger GXD_AssayType_Delete
1>  
2> create trigger GXD_AssayType_Delete
3> on GXD_AssayType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_Assay, deleted
10>     where GXD_Assay._AssayType_key = deleted._AssayType_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Assay Type is referenced in Assay Record(s)"
14>         return
15> end
16>  
17> if exists (select * from GXD_Expression, deleted
18>     where GXD_Expression._AssayType_key = deleted._AssayType_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Assay Type is referenced in Expression Results (cache) Record(s)"
22>         return
23> end
24>  
1>  
2> drop trigger GXD_EmbeddingMethod_Delete
1>  
2> create trigger GXD_EmbeddingMethod_Delete
3> on GXD_EmbeddingMethod
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_Specimen, deleted
10>     where GXD_Specimen._Embedding_key = deleted._Embedding_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Embedding Method is referenced in Specimen Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_FixationMethod_Delete
1>  
2> create trigger GXD_FixationMethod_Delete
3> on GXD_FixationMethod
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_Specimen, deleted
10>     where GXD_Specimen._Fixation_key = deleted._Fixation_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Fixation Method is referenced in Specimen Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_GelRNAType_Delete
1>  
2> create trigger GXD_GelRNAType_Delete
3> on GXD_GelRNAType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_GelLane, deleted
10>     where GXD_GelLane._GelRNAType_key = deleted._GelRNAType_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Gel RNA Type is referenced in Gel Lane Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_GelUnits_Delete
1>  
2> create trigger GXD_GelUnits_Delete
3> on GXD_GelUnits
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_GelRow, deleted
10>     where GXD_GelRow._GelUnits_key = deleted._GelUnits_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Gel Unit is referenced in Gel Row Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_GelControl_Delete
1>  
2> create trigger GXD_GelControl_Delete
3> on GXD_GelControl
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_GelLane, deleted
10>     where GXD_GelLane._GelControl_key = deleted._GelControl_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Gel Control is referenced in Gel Lane Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_LabelCoverage_Delete
1>  
2> create trigger GXD_LabelCoverage_Delete
3> on GXD_LabelCoverage
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_ProbePrep, deleted
10>     where GXD_ProbePrep._Coverage_key = deleted._Coverage_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Label Coverage is referenced in Probe Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Pattern_Delete
1>  
2> create trigger GXD_Pattern_Delete
3> on GXD_Pattern
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_InSituResult, deleted
10>     where GXD_InSituResult._Pattern_key = deleted._Pattern_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Expression Pattern is referenced in InSitu Result Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Label_Delete
1>  
2> create trigger GXD_Label_Delete
3> on GXD_Label
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_AntibodyPrep, deleted
10>     where GXD_AntibodyPrep._Label_key = deleted._Label_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Label is referenced in Antibody Prep Record(s)"
14> 	return
15> end
16> 
17> if exists (select * from GXD_ProbePrep, deleted
18>     where GXD_ProbePrep._Label_key = deleted._Label_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Label is referenced in Probe Prep Record(s)"
22>         return
23> end
24>  
1>  
2> drop trigger GXD_ProbeSense_Delete
1>  
2> create trigger GXD_ProbeSense_Delete
3> on GXD_ProbeSense
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_ProbePrep, deleted
10>     where GXD_ProbePrep._Sense_key = deleted._Sense_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Probe Sense is referenced in Probe Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Secondary_Delete
1>  
2> create trigger GXD_Secondary_Delete
3> on GXD_Secondary
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_AntibodyPrep, deleted
10>     where GXD_AntibodyPrep._Secondary_key = deleted._Secondary_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Secondary is referenced in Antibody Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Strength_Delete
1>  
2> create trigger GXD_Strength_Delete
3> on GXD_Strength
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_InSituResult, deleted
10>     where GXD_InSituResult._Strength_key = deleted._Strength_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Strength is referenced in InSitu Result Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_VisualizationMethod_Delete
1>  
2> create trigger GXD_VisualizationMethod_Delete
3> on GXD_VisualizationMethod
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_ProbePrep, deleted
10>     where GXD_ProbePrep._Visualization_key = deleted._Visualization_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Visualization Method is referenced in Probe Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger IMG_FieldType_Delete
1>  
2> create trigger IMG_FieldType_Delete
3> on IMG_FieldType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from IMG_ImagePane, deleted
10>     where IMG_ImagePane._FieldType_key = deleted._FieldType_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Image Field Type is referenced in Image Pane Record(s)"
14>         return
15> end
16>  
1>  
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger HMD_Homology_Marker_Insert
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'HMD_Homology_Marker_Insert', because it doesn't exist
in the system catalogs.
1> 
2> drop trigger HMD_Class_Delete
1> 
2> create trigger HMD_Class_Delete
3> on HMD_Class
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete HMD_Homology from HMD_Homology, deleted
10> where HMD_Homology._Class_key = deleted._Class_key
11> 
1> 
2> drop trigger HMD_Homology_Delete
1> 
2> create trigger HMD_Homology_Delete
3> on HMD_Homology
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete HMD_Homology_Marker from HMD_Homology_Marker, deleted
10> where HMD_Homology_Marker._Homology_key = deleted._Homology_key
11> 
12> delete HMD_Homology_Assay from HMD_Homology_Assay, deleted
13> where HMD_Homology_Assay._Homology_key = deleted._Homology_key
14> 
15> delete HMD_Notes from HMD_Notes, deleted
16> where HMD_Notes._Homology_key = deleted._Homology_key
17> 
1> 
2> /* TR 104 - moved logic to MRK_Marker_Insert */
3> 
4> /* drop trigger HMD_Homology_Marker_Insert */
5> 
6> drop trigger HMD_Assay_Delete
1> 
2> create trigger HMD_Assay_Delete
3> on HMD_Assay
4> for delete
5> as
6> 
7> /* Disallow removal of the homology assay if it is being referenced in homology */
8> 
9> if exists (select * from HMD_Homology_Assay, deleted
10>     where HMD_Homology_Assay._Assay_key = deleted._Assay_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Assay is referenced in Homology Record(s)"
14> 	return
15> end
16>  
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger IMG_Image_Insert
1>  
2> create trigger IMG_Image_Insert
3> on IMG_Image
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Image */
8>  
9> declare @key integer
10> select @key = _Image_key from inserted
11> exec ACC_assignMGI @key, "Image"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1>  
2> drop trigger IMG_Image_Delete
1> 
2> create trigger IMG_Image_Delete
3> on IMG_Image
4> for delete
5> as
6> 
7> delete IMG_ImageNote from IMG_ImageNote, deleted
8> where IMG_ImageNote._Image_key = deleted._Image_key
9>  
10> delete IMG_ImagePane from IMG_ImagePane, deleted
11> where IMG_ImagePane._Image_key = deleted._Image_key
12>  
13> delete ACC_Accession
14> from ACC_Accession a, ACC_MGIType m, deleted
15> where a._Object_key = deleted._Image_key
16> and a._MGIType_key = m._MGIType_key
17> and m.name = "Image"
18>  
1> 
2> drop trigger IMG_ImagePane_Delete
1> 
2> create trigger IMG_ImagePane_Delete
3> on IMG_ImagePane
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Assay, deleted
10>     where GXD_Assay._ImagePane_key = deleted._ImagePane_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Image Pane is referenced in Assay Record(s)"
14> 	return
15> end
16> 
17> if exists (select * from GXD_InSituResultImage, deleted
18>     where GXD_InSituResultImage._ImagePane_key = deleted._ImagePane_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Image Pane is referenced in InSitu Result Record(s)"
22> 	return
23> end
24> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger MLD_Marker_Update
1> 
2> create trigger MLD_Marker_Update
3> on MLD_Marker
4> for update
5> as
6> 
7> /* If updating the Reference, propagate update to appropriate tables */
8> 
9> if update(_Refs_key)
10> begin
11> 	update MLD_Expts
12> 	  set _Refs_key = inserted._Refs_key
13> 	  from MLD_Expts, inserted, deleted
14> 	  where MLD_Expts._Refs_key = deleted._Refs_key
15> 
16> 	update MLD_Notes
17> 	  set _Refs_key = inserted._Refs_key
18> 	  from MLD_Notes, inserted, deleted
19> 	  where MLD_Notes._Refs_key = deleted._Refs_key
20> end
21> 
22> /* If the Marker in the Primary list is modified, then propagate */
23> /* the changes to the gene list of each experiment of the reference */
24> 
25> if update(_Marker_key)
26> begin
27> 	update MLD_Expt_Marker
28>           set _Marker_key = inserted._Marker_key
29> 	  from MLD_Expt_Marker, MLD_Expts, inserted, deleted
30> 	  where MLD_Expts._Refs_key = inserted._Refs_key and
31> 		MLD_Expts._Expt_key = MLD_Expt_Marker._Expt_key and
32> 		MLD_Expt_Marker._Marker_key = deleted._Marker_key
33> end
34> 
1> 
2> drop trigger MLD_Expts_Insert
1> 
2> create trigger MLD_Expts_Insert
3> on MLD_Expts
4> for insert
5> as
6> 
7> /* Assign MGI Accession number for each Experiment */
8> 
9> declare @key integer
10> select @key = _Expt_key from inserted
11> exec ACC_assignMGI @key, "Experiment"
12> 
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1> 
2> drop trigger MLD_Expts_Delete
1> 
2> create trigger MLD_Expts_Delete
3> on MLD_Expts
4> for delete
5> as
6> 
7> /* Re-order the tag numbers for experiments if one is deleted */
8> 
9> update MLD_Expts
10> set MLD_Expts.tag = MLD_Expts.tag - 1
11> from MLD_Expts, deleted
12> where MLD_Expts._Refs_key = deleted._Refs_key
13> and MLD_Expts.exptType = deleted.exptType
14> and MLD_Expts.tag > deleted.tag
15> 
16> /* Delete entries in all dependent experiment tables */
17> 
18> delete MLD_Expt_Marker from MLD_Expt_Marker, deleted
19> where MLD_Expt_Marker._Expt_key = deleted._Expt_key
20> 
21> delete MLD_Expt_Notes from MLD_Expt_Notes, deleted
22> where MLD_Expt_Notes._Expt_key = deleted._Expt_key
23> 
24> delete MLD_FISH from MLD_FISH, deleted
25> where MLD_FISH._Expt_key = deleted._Expt_key
26> 
27> delete MLD_FISH_Region from MLD_FISH_Region, deleted
28> where MLD_FISH_Region._Expt_key = deleted._Expt_key
29> 
30> delete MLD_Hybrid from MLD_Hybrid, deleted
31> where MLD_Hybrid._Expt_key = deleted._Expt_key
32> 
33> delete MLD_Concordance from MLD_Concordance, deleted
34> where MLD_Concordance._Expt_key = deleted._Expt_key
35> 
36> delete MLD_InSitu from MLD_InSitu, deleted
37> where MLD_InSitu._Expt_key = deleted._Expt_key
38> 
39> delete MLD_ISRegion from MLD_ISRegion, deleted
40> where MLD_ISRegion._Expt_key = deleted._Expt_key
41> 
42> delete MLD_Matrix from MLD_Matrix, deleted
43> where MLD_Matrix._Expt_key = deleted._Expt_key
44> 
45> delete MLD_MC2point from MLD_MC2point, deleted
46> where MLD_MC2point._Expt_key = deleted._Expt_key
47> 
48> delete MLD_MCDataList from MLD_MCDataList, deleted
49> where MLD_MCDataList._Expt_key = deleted._Expt_key
50> 
51> delete MLD_RI from MLD_RI, deleted
52> where MLD_RI._Expt_key = deleted._Expt_key
53> 
54> delete MLD_RIData from MLD_RIData, deleted
55> where MLD_RIData._Expt_key = deleted._Expt_key
56> 
57> delete MLD_RI2Point from MLD_RI2Point, deleted
58> where MLD_RI2Point._Expt_key = deleted._Expt_key
59> 
60> delete MLD_Hit from MLD_Hit, deleted
61> where MLD_Hit._Expt_key = deleted._Expt_key
62> 
63> delete MLD_Contig from MLD_Contig, deleted
64> where MLD_Contig._Expt_key = deleted._Expt_key
65> 
66> delete MLD_Statistics from MLD_Statistics, deleted
67> where MLD_Statistics._Expt_key = deleted._Expt_key
68> 
69> delete ACC_Accession
70> from ACC_Accession a, ACC_MGIType m, deleted
71> where a._Object_key = deleted._Expt_key
72> and a._MGIType_key = m._MGIType_key
73> and m.name = "Experiment"
74>  
1> 
2> drop trigger MLD_Expt_Marker_Insert
1>  
2> create trigger MLD_Expt_Marker_Insert
3> on MLD_Expt_Marker
4> for insert
5> as
6>  
7> /* If the chromosome in the Marker table is UN, then...  */
8>  
9> if exists (select * from MRK_Marker, MLD_Expts, inserted
10>     where MLD_Expts._Expt_key = inserted._Expt_key and
11>     MRK_Marker._Marker_key = inserted._Marker_key and
12>     MRK_Marker.chromosome = "UN")
13> begin
14>  
15>     /* Update the chromosome to the MLDP chromosome assignment */
16>  
17>     update MRK_Marker
18>     set chromosome = MLD_Expts.chromosome
19>     from MRK_Marker, MLD_Expts, inserted
20>     where MLD_Expts._Expt_key = inserted._Expt_key and
21>           MRK_Marker._Marker_key = inserted._Marker_key
22> end
23>  
1> 
2> drop trigger MLD_Expt_Marker_Update
1> 
2> create trigger MLD_Expt_Marker_Update
3> on MLD_Expt_Marker
4> for update
5> as
6> 
7> /* If modifying Assay type and this is the only instance of the */
8> /* Assay type in MGD, then remove it from the Assay table */
9> 
10> if update(_Assay_Type_key) and 
11>    not exists (select * from MLD_Expt_Marker, deleted
12>     where MLD_Expt_Marker._Assay_Type_key = deleted._Assay_Type_key)
13> begin
14>   delete MLD_Assay_Types from MLD_Assay_Types, deleted
15>   where MLD_Assay_Types._Assay_Type_key = deleted._Assay_Type_key
16> end
17> 
18> if update(_Marker_key)
19> begin
20> 	/* If the chromosome in the Marker table is UN, then...  */
21> 
22>   	if exists (select * from MRK_Marker, MLD_Expts, inserted
23>             where MLD_Expts._Expt_key = inserted._Expt_key and
24> 	    MRK_Marker._Marker_key = inserted._Marker_key and 
25> 	    MRK_Marker.chromosome = "UN")
26> 	begin
27> 
28> 	  /* Update the chromosome to the MLDP chromosome assignment */
29> 
30>   	  update MRK_Marker 
31>   	  set chromosome = MLD_Expts.chromosome
32>   	  from MRK_Marker, MLD_Expts, inserted
33>           where MLD_Expts._Expt_key = inserted._Expt_key and
34> 	        MRK_Marker._Marker_key = inserted._Marker_key
35> 	end
36> 
37> 	/* Propagate modification of Marker to experiment tables */
38> 
39> 	update MLD_Concordance 
40>           set _Marker_key = inserted._Marker_key
41> 	  from MLD_Concordance, inserted, deleted
42> 	  where MLD_Concordance._Expt_key = inserted._Expt_key and
43> 		MLD_Concordance._Marker_key = deleted._Marker_key
44> 
45> 	update MLD_MC2point 
46>           set _Marker_key_1 = inserted._Marker_key
47> 	  from MLD_MC2point, inserted, deleted
48> 	  where MLD_MC2point._Expt_key = inserted._Expt_key and
49> 		MLD_MC2point._Marker_key_1 = deleted._Marker_key
50> 
51> 	update MLD_MC2point 
52>           set _Marker_key_2 = inserted._Marker_key
53> 	  from MLD_MC2point, inserted, deleted
54> 	  where MLD_MC2point._Expt_key = inserted._Expt_key and
55> 		MLD_MC2point._Marker_key_2 = deleted._Marker_key
56> 
57> 	update MLD_RIData 
58>           set _Marker_key = inserted._Marker_key
59> 	  from MLD_RIData, inserted, deleted
60> 	  where MLD_RIData._Expt_key = inserted._Expt_key and
61> 		MLD_RIData._Marker_key = deleted._Marker_key
62> 
63> 	update MLD_RI2Point 
64>           set _Marker_key_1 = inserted._Marker_key
65> 	  from MLD_RI2Point, inserted, deleted
66> 	  where MLD_RI2Point._Expt_key = inserted._Expt_key and
67> 		MLD_RI2Point._Marker_key_1 = deleted._Marker_key
68> 
69> 	update MLD_RI2Point 
70>           set _Marker_key_2 = inserted._Marker_key
71> 	  from MLD_RI2Point, inserted, deleted
72> 	  where MLD_RI2Point._Expt_key = inserted._Expt_key and
73> 		MLD_RI2Point._Marker_key_2 = deleted._Marker_key
74> 
75>         update MLD_Statistics
76>           set _Marker_key_1 = inserted._Marker_key
77>           from MLD_Statistics, inserted, deleted
78>           where MLD_Statistics._Expt_key = inserted._Expt_key and
79>                 MLD_Statistics._Marker_key_1 = deleted._Marker_key
80> 
81>         update MLD_Statistics
82>           set _Marker_key_2 = inserted._Marker_key
83>           from MLD_Statistics, inserted, deleted
84>           where MLD_Statistics._Expt_key = inserted._Expt_key and
85>                 MLD_Statistics._Marker_key_2 = deleted._Marker_key
86> 
87>         update MLD_Distance
88>           set _Marker_key_1 = inserted._Marker_key
89>           from MLD_Distance, inserted, deleted
90>           where MLD_Distance._Expt_key = inserted._Expt_key and
91>                 MLD_Distance._Marker_key_1 = deleted._Marker_key
92> 
93>         update MLD_Distance
94>           set _Marker_key_2 = inserted._Marker_key
95>           from MLD_Distance, inserted, deleted
96>           where MLD_Distance._Expt_key = inserted._Expt_key and
97>                 MLD_Distance._Marker_key_2 = deleted._Marker_key
98> 
99> end
100> 
1> 
2> drop trigger MLD_Matrix_Delete
1> 
2> create trigger MLD_Matrix_Delete
3> on MLD_Matrix
4> for delete
5> as
6> 
7> /* Remove entries from Cross table upon deletion of Matrix */
8> /* record, if the cross is not a named (i.e. specific) Cross */
9> 
10> if exists (select * from CRS_Cross, deleted 
11>     where CRS_Cross._Cross_key = deleted._Cross_key and CRS_Cross.whoseCross is null)
12> begin
13> 	delete CRS_Cross from CRS_Cross, deleted
14> 	where CRS_Cross._Cross_key = deleted._Cross_key
15> end
16> 
1> 
2> drop trigger MLD_Contig_Delete
1> 
2> create trigger MLD_Contig_Delete
3> on MLD_Contig
4> for delete
5> as
6> 
7> /* Delete records in dependent tables */
8> 
9> delete MLD_ContigProbe from MLD_ContigProbe, deleted
10> where MLD_ContigProbe._Contig_key = deleted._Contig_key
11> 
1> 
2> drop trigger MLD_RI_Insert
1> 
2> create trigger MLD_RI_Insert
3> on MLD_RI
4> for insert
5> as
6> 
7> update MLD_RI
8> set designation = RI_RISet.designation,
9>     origin = RI_RISet.origin,
10>     abbrev1 = RI_RISet.abbrev1,
11>     abbrev2 = RI_RISet.abbrev2
12> from MLD_RI, RI_RISet, inserted
13> where MLD_RI._Expt_key = inserted._Expt_key and
14>       inserted._RISet_key = RI_RISet._RISet_key
1> 
2> drop trigger MLD_RI_Update
1> 
2> create trigger MLD_RI_Update
3> on MLD_RI
4> for update
5> as
6> 
7> /* If modifying RI key in MLDP table, then */
8> /* set appropriate column values in MLDP table */
9> /* as they appear in the RI table */
10> 
11> if update (_RISet_key)
12> begin
13>   update MLD_RI
14>   set designation = RI_RISet.designation,
15>       origin = RI_RISet.origin,
16>       abbrev1 = RI_RISet.abbrev1,
17>       abbrev2 = RI_RISet.abbrev2
18>   from MLD_RI, RI_RISet, inserted
19>   where MLD_RI._Expt_key = inserted._Expt_key and
20> 	inserted._RISet_key = RI_RISet._RISet_key
21> end
22> 
1> 
2> drop trigger MLD_Assay_Types_Delete
1> 
2> create trigger MLD_Assay_Types_Delete
3> on MLD_Assay_Types
4> for delete
5> as
6> 
7> /* Disallow removal of an Assay which is referenced in MLDP */
8> 
9> if exists (select * from MLD_Expt_Marker, deleted
10>     where MLD_Expt_Marker._Assay_Type_key = deleted._Assay_Type_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Assay is referenced in MLDP Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger MLD_InSitu_Insert
1> 
2> create trigger MLD_InSitu_Insert
3> on MLD_InSitu
4> for insert
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if (select MRK_Marker.cytogeneticOffset 
13>     from MRK_Marker, MLD_Expt_Marker, inserted
14>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key
15> 	  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
16> begin
17> 	update MRK_Marker
18> 	set cytogeneticOffset = inserted.band
19> 	from MRK_Marker, MLD_Expt_Marker, inserted
20>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
21> 	      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
22> end
23> 
1> 
2> drop trigger MLD_InSitu_Update
1> 
2> create trigger MLD_InSitu_Update
3> on MLD_InSitu
4> for update
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if update(band)
13> begin
14> 	if (select MRK_Marker.cytogeneticOffset 
15> 	    from MRK_Marker, MLD_Expt_Marker, inserted
16> 	    where inserted._Expt_key = MLD_Expt_Marker._Expt_key
17> 		  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
18> 	begin
19> 		update MRK_Marker
20> 		set cytogeneticOffset = inserted.band
21> 		from MRK_Marker, MLD_Expt_Marker, inserted
22> 	        where inserted._Expt_key = MLD_Expt_Marker._Expt_key
23> 		      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
24> 	end
25> end
26> 
1> 
2> drop trigger MLD_FISH_Insert
1> 
2> create trigger MLD_FISH_Insert
3> on MLD_FISH
4> for insert
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> /* If more than one Marker is defined in the experiment, then we can't */
13> /* assign any cytogenetic band information because we don't know which */
14> /* Marker is the relevant Marker */
15> 
16> if (select count(*) from MLD_Expt_Marker, inserted
17>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key) > 1
18> begin
19> 	return
20> end
21> 
22> if (select MRK_Marker.cytogeneticOffset 
23>     from MRK_Marker, MLD_Expt_Marker, inserted
24>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key
25> 	  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
26> begin
27> 	update MRK_Marker
28> 	set cytogeneticOffset = inserted.band
29> 	from MRK_Marker, MLD_Expt_Marker, inserted
30>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
31> 	      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
32> end
33> 
1> 
2> drop trigger MLD_FISH_Update
1> 
2> create trigger MLD_FISH_Update
3> on MLD_FISH
4> for update
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if update(band)
13> begin
14> 	/* If more than one Marker is defined in the experiment, then we can't */
15> 	/* assign any cytogenetic band information because we don't know which */
16> 	/* Marker is the relevant Marker */
17> 
18> 	if (select count(*) from MLD_Expt_Marker, inserted
19>     	    where inserted._Expt_key = MLD_Expt_Marker._Expt_key) > 1
20> 	begin
21> 		return
22> 	end
23> 
24> 	if (select MRK_Marker.cytogeneticOffset 
25> 	    from MRK_Marker, MLD_Expt_Marker, inserted
26> 	    where inserted._Expt_key = MLD_Expt_Marker._Expt_key
27> 		  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
28> 	begin
29> 		update MRK_Marker
30> 		set cytogeneticOffset = inserted.band
31> 		from MRK_Marker, MLD_Expt_Marker, inserted
32> 	        where inserted._Expt_key = MLD_Expt_Marker._Expt_key
33> 		      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
34> 	end
35> end
36> 
1> 
2> drop trigger MLD_Hybrid_Insert
1> 
2> create trigger MLD_Hybrid_Insert
3> on MLD_Hybrid
4> for insert
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if (select MRK_Marker.cytogeneticOffset 
13>     from MRK_Marker, MLD_Expt_Marker, inserted
14>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key
15> 	  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
16> begin
17> 	update MRK_Marker
18> 	set cytogeneticOffset = inserted.band
19> 	from MRK_Marker, MLD_Expt_Marker, inserted
20>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
21> 	      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
22> end
23> 
1> 
2> drop trigger MLD_Hybrid_Update
1> 
2> create trigger MLD_Hybrid_Update
3> on MLD_Hybrid
4> for update
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if update(band)
13> begin
14> 	if (select MRK_Marker.cytogeneticOffset 
15> 	    from MRK_Marker, MLD_Expt_Marker, inserted
16> 	    where inserted._Expt_key = MLD_Expt_Marker._Expt_key
17> 		  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
18> 	begin
19> 		update MRK_Marker
20> 		set cytogeneticOffset = inserted.band
21> 		from MRK_Marker, MLD_Expt_Marker, inserted
22> 	        where inserted._Expt_key = MLD_Expt_Marker._Expt_key
23> 		      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
24> 	end
25> end
26> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger MRK_Marker_Insert
1> 
2> create trigger MRK_Marker_Insert
3> on MRK_Marker
4> for insert
5> as
6> 
7> /* For Mouse Species, insert records for Accession #, Name bucket, Symbol bucket, Current Symbol */
8> /* For Other Species, insert record for Accession # */
9> 
10> if (select _Species_key from inserted) = 1
11> begin
12> 	insert MRK_Name (_Marker_key, _Marker_Type_key, name) 
13> 		select _Marker_key, _Marker_Type_key, name from inserted
14> 	insert MRK_Symbol (_Marker_key, _Marker_Type_key, symbol) 
15> 		select _Marker_key, _Marker_Type_key, symbol from inserted
16> 	insert MRK_Current (_Current_key, _Marker_key) 
17> 		select _Marker_key, _Marker_key from inserted
18> 
19> 	declare @key integer
20> 	select @key = _Marker_key from inserted
21> 	exec ACC_assignMGI @key, "Marker"
22> 
23> 	if (@@error != 0)
24> 	begin
25>   	  rollback transaction
26>   	  return
27> 	end
28> end
29> 
30> /* For non-mouse species, update MRK_Chromosome table */
31> 
32> if (select _Species_key from inserted) != 1
33> begin
34>         declare @speciesKey integer
35>         declare @chromosome varchar(8)
36>         select @speciesKey = _Species_key from inserted
37>         select @chromosome = chromosome from inserted
38>         exec MRK_addChromosome @speciesKey, @chromosome
39> end
40> 
1> 
2> drop trigger MRK_Marker_Update
1> 
2> create trigger MRK_Marker_Update
3> on MRK_Marker
4> for update
5> as
6> 
7> /* If not Mouse, disallow duplicate Species/Symbol records */
8> 
9> if (select _Species_key from inserted) != 1
10> begin
11> 	if update(symbol) and
12>            (select count(*) from MRK_Marker, inserted 
13> 	    where inserted._Species_key = MRK_Marker._Species_key and
14> 		  inserted.symbol = MRK_Marker.symbol) > 1
15> 	begin
16> 		rollback transaction
17> 		raiserror 99999 "Marker Symbol For This Species Already Exists.\nDelete Existing Row And Add A New Row For This Symbol."
18> 		return
19> 	end
20> end
21> 
22> /* If updating chromosome and changing from unknown to known, update offset to -1 */
23> 
24> if (select _Species_key from inserted) = 1 and update (chromosome)
25> begin
26>        if ((select chromosome from deleted) = "RE" or
27>            (select chromosome from deleted) = "UN") and
28>            (select chromosome from inserted) != "RE" and
29>            (select chromosome from inserted) != "UN" and
30>            (select chromosome from inserted) != "W"
31> 	begin
32>         	update MRK_Offset set offset = -1
33>         	from inserted
34>         	where inserted._Marker_key = MRK_Offset._Marker_key and MRK_Offset.source = 0
35> 	end
36> end
37> 
38> /* If updating symbol or Marker Type, check for duplicates and update Symbol bucket */
39> 
40> if (select _Species_key from inserted) = 1 and
41>    (update (symbol) or update(_Marker_Type_key)) and
42>    not exists (select s.symbol from MRK_Symbol s, inserted i
43> 	       where s._Marker_key = i._Marker_key and
44> 		     s._Marker_Type_key = i._Marker_Type_key and
45> 		     s.symbol = i.symbol)
46> begin
47> 	update MRK_Symbol 
48> 	set symbol = inserted.symbol, _Marker_Type_key = inserted._Marker_Type_key
49> 	from MRK_Symbol, inserted, deleted
50> 	where MRK_Symbol._Marker_key = inserted._Marker_key and 
51> 	      MRK_Symbol._Marker_Type_key = deleted._Marker_Type_key and
52> 	      MRK_Symbol.symbol = deleted.symbol
53> end
54> 
55> /* If updating name, update Name bucket */
56> 
57> if (select _Species_key from inserted) = 1 and
58>    update (name) and 
59>    not exists (select n.name from MRK_Name n, inserted i
60> 	       where n._Marker_key = i._Marker_key and
61> 		     n._Marker_Type_key = i._Marker_Type_key and
62> 		     n.name = i.name)
63> begin
64> 	if (select chromosome from inserted) != "W"
65> 	begin
66>         	update MRK_Name set name = inserted.name
67> 	  	from MRK_Name, inserted, deleted
68> 	  	where MRK_Name._Marker_key = inserted._Marker_key and
69> 		      MRK_Name._Marker_Type_key = deleted._Marker_Type_key and
70> 		      MRK_Name.name = deleted.name
71> 	end
72> end
73> 
74> /* For non-mouse species, update MRK_Chromosome table */
75> 
76> if (select _Species_key from inserted) != 1 and update(chromosome)
77> begin
78>         declare @speciesKey integer
79>         declare @chromosome varchar(8)
80>         select @speciesKey = _Species_key from inserted
81>         select @chromosome = chromosome from inserted
82>         exec MRK_addChromosome @speciesKey, @chromosome
83> end
84> 
1> 
2> drop trigger MRK_Marker_Delete
1> 
2> create trigger MRK_Marker_Delete
3> on MRK_Marker
4> for delete
5> as
6> 
7> /* Disallow deletion if Marker is currently referenced elsewhere */
8> 
9> if exists (select * from MRK_Alias, deleted
10>     where MRK_Alias._Alias_key = deleted._Marker_key)
11> begin
12> 	rollback transaction
13> 	raiserror 99999 "Marker Symbol is referenced in Alias Record(s)"
14> 	return
15> end
16> 
17> /* Symbol is a Current Symbol of itself */
18> 
19> if exists (select * from MRK_Current, deleted
20>          where MRK_Current._Current_key = deleted._Marker_key)
21> begin
22> 	rollback transaction
23> 	raiserror 99999 "Marker Symbol is referenced in Current Symbol Record(s)"
24> 	return
25> end
26> 
27> if exists (select * from MRK_History, deleted
28>          where MRK_History._History_key = deleted._Marker_key and
29>                MRK_History._Marker_key != deleted._Marker_key)
30> begin
31> 	rollback transaction
32> 	raiserror 99999 "Marker Symbol is referenced in History Record(s)"
33> 	return
34> end
35> 
36> if exists (select * from PRB_Marker, deleted
37>          where PRB_Marker._Marker_key = deleted._Marker_key)
38> begin
39> 	rollback transaction
40> 	raiserror 99999 "Marker Symbol is referenced in Probe Marker Record(s)"
41> 	return
42> end
43> 
44> if exists (select * from PRB_RFLV, deleted
45>          where PRB_RFLV._Marker_key = deleted._Marker_key)
46> begin
47> 	rollback transaction
48> 	raiserror 99999 "Marker Symbol is referenced in Probe RFLV Record(s)"
49> 	return
50> end
51> 
52> if exists (select * from MLD_Marker, deleted
53>          where MLD_Marker._Marker_key = deleted._Marker_key)
54> begin
55> 	rollback transaction
56> 	raiserror 99999 "Marker Symbol is referenced in MLDP Marker Record(s)"
57> 	return
58> end
59> 
60> if exists (select * from MLD_Expt_Marker, deleted
61>          where MLD_Expt_Marker._Marker_key = deleted._Marker_key)
62> begin
63> 	rollback transaction
64> 	raiserror 99999 "Marker Symbol is referenced in MLDP Experiment Marker Record(s)"
65> 	return
66> end
67> 
68> if exists (select * from MLD_Concordance, deleted
69>          where MLD_Concordance._Marker_key = deleted._Marker_key)
70> begin
71> 	rollback transaction
72> 	raiserror 99999 "Marker Symbol is referenced in MLDP Hybrid Concordance Record(s)"
73> 	return
74> end
75> 
76> if exists (select * from MLD_MC2point, deleted
77>          where MLD_MC2point._Marker_key_1 = deleted._Marker_key)
78> begin
79> 	rollback transaction
80> 	raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
81> 	return
82> end
83> 
84> if exists (select * from MLD_MC2point, deleted
85>          where MLD_MC2point._Marker_key_2 = deleted._Marker_key)
86> begin
87> 	rollback transaction
88> 	raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
89> 	return
90> end
91> 
92> if exists (select * from MLD_RIData, deleted
93>          where MLD_RIData._Marker_key = deleted._Marker_key)
94> begin
95> 	rollback transaction
96> 	raiserror 99999 "Marker Symbol is referenced in MLDP RI Data Record(s)"
97> 	return
98> end
99> 
100> if exists (select * from MLD_RI2Point, deleted
101>          where MLD_RI2Point._Marker_key_1 = deleted._Marker_key)
102> begin
103> 	rollback transaction
104> 	raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
105> 	return
106> end
107> 
108> if exists (select * from MLD_RI2Point, deleted
109>          where MLD_RI2Point._Marker_key_2 = deleted._Marker_key)
110> begin
111> 	rollback transaction
112> 	raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
113> 	return
114> end
115> 
116> if exists (select * from MLD_Distance, deleted
117>          where MLD_Distance._Marker_key_1 = deleted._Marker_key)
118> begin
119> 	rollback transaction
120> 	raiserror 99999 "Marker Symbol is referenced in Physical Mapping Record(s)"
121> 	return
122> end
123> 
124> if exists (select * from MLD_Distance, deleted
125>          where MLD_Distance._Marker_key_2 = deleted._Marker_key)
126> begin
127> 	rollback transaction
128> 	raiserror 99999 "Marker Symbol is referenced in Physical Mapping Record(s)"
129> 	return
130> end
131> 
132> if exists (select * from HMD_Homology_Marker, deleted
133>          where HMD_Homology_Marker._Marker_key = deleted._Marker_key)
134> begin
135> 	rollback transaction
136> 	raiserror 99999 "Marker Symbol is referenced in Homology Record(s)"
137> 	return
138> end
139> 
140> if exists (select * from MLC_Text_edit, deleted
141>          where MLC_Text_edit._Marker_key = deleted._Marker_key)
142> begin
143> 	rollback transaction
144> 	raiserror 99999 "Marker Symbol is referenced in MLC Edit Record(s)"
145> 	return
146> end
147> 
148> if exists (select * from MLC_Marker_edit, deleted
149>          where MLC_Marker_edit._Marker_key_2 = deleted._Marker_key)
150> begin
151> 	rollback transaction
152> 	raiserror 99999 "Marker Symbol is referenced in MLC Edit Record(s)"
153> 	return
154> end
155> 
156> if exists (select * from CRS_Matrix, deleted
157>          where CRS_Matrix._Marker_key = deleted._Marker_key)
158> begin
159> 	rollback transaction
160> 	raiserror 99999 "Marker Symbol is referenced in Cross Matrix Record(s)"
161> 	return
162> end
163> 
164> if exists (select * from GXD_Index, deleted
165>          where GXD_Index._Marker_key = deleted._Marker_key)
166> begin
167> 	rollback transaction
168> 	raiserror 99999 "Marker Symbol is referenced in GXD Index Record(s)"
169> 	return
170> end
171> 
172> if exists (select * from GXD_AllelePair, deleted
173>          where GXD_AllelePair._Marker_key = deleted._Marker_key)
174> begin
175> 	rollback transaction
176> 	raiserror 99999 "Marker Symbol is referenced in GXD Allele Pair Record(s)"
177> 	return
178> end
179> 
180> if exists (select * from GXD_AntibodyMarker, deleted
181>          where GXD_AntibodyMarker._Marker_key = deleted._Marker_key)
182> begin
183> 	rollback transaction
184> 	raiserror 99999 "Marker Symbol is referenced in GXD Antibody Marker Record(s)"
185> 	return
186> end
187> 
188> if exists (select * from GXD_Assay, deleted
189>          where GXD_Assay._Marker_key = deleted._Marker_key)
190> begin
191> 	rollback transaction
192> 	raiserror 99999 "Marker Symbol is referenced in GXD Assay Record(s)"
193> 	return
194> end
195> 
196> if exists (select * from PRB_Strain_Marker, deleted
197>     where PRB_Strain_Marker._Marker_key = deleted._Marker_key)
198> begin
199> 	rollback transaction
200> 	raiserror 99999 "Marker Symbol is referenced in Strain Record(s)"
201> 	return
202> end
203> 
204> delete MRK_Alias from MRK_Alias, deleted
205> where MRK_Alias._Marker_key = deleted._Marker_key
206> 
207> delete MRK_Allele from MRK_Allele, deleted
208> where MRK_Allele._Marker_key = deleted._Marker_key
209> 
210> delete MRK_Classes from MRK_Classes, deleted
211> where MRK_Classes._Marker_key = deleted._Marker_key
212> 
213> delete MRK_Current from MRK_Current, deleted
214> where MRK_Current._Marker_key = deleted._Marker_key
215> 
216> delete MRK_History from MRK_History, deleted
217> where MRK_History._Marker_key = deleted._Marker_key
218> 
219> delete MRK_Notes from MRK_Notes, deleted
220> where MRK_Notes._Marker_key = deleted._Marker_key
221> 
222> delete MRK_Offset from MRK_Offset, deleted
223> where MRK_Offset._Marker_key = deleted._Marker_key
224> 
225> delete MRK_Other from MRK_Other, deleted
226> where MRK_Other._Marker_key = deleted._Marker_key
227> 
228> delete MRK_Reference from MRK_Reference, deleted
229> where MRK_Reference._Marker_key = deleted._Marker_key
230> 
231> delete MRK_Name from MRK_Name, deleted
232> where MRK_Name._Marker_key = deleted._Marker_key
233> 
234> delete MRK_Symbol from MRK_Symbol, deleted
235> where MRK_Symbol._Marker_key = deleted._Marker_key
236> 
237> delete ACC_Accession
238> from ACC_Accession a, ACC_MGIType m, deleted
239> where a._Object_key = deleted._Marker_key
240> and a._MGIType_key = m._MGIType_key
241> and m.name = "Marker"
242> 
1> 
2> drop trigger MRK_Alias_Insert
1> 
2> create trigger MRK_Alias_Insert
3> on MRK_Alias
4> for insert
5> as
6> 
7> if exists (select * from MRK_Marker, inserted
8>          where inserted._Marker_key = inserted._Alias_key)
9> begin
10>         rollback transaction
11>         raiserror 99999 "Symbol cannot use itself as an Alias"
12> 	return
13> end
14> 
15> /* Append Alias to Symbol bucket */
16> 
17> if not exists (select * from MRK_Symbol, inserted, MRK_Marker
18>     where MRK_Symbol._Marker_key = inserted._Marker_key and
19> 	  inserted._Marker_key = MRK_Marker._Marker_key and
20> 	  MRK_Symbol.symbol = MRK_Marker.symbol and
21> 	  MRK_Symbol._Marker_Type_key = 4)
22> begin
23>   insert MRK_Symbol (_Marker_key, _Marker_Type_key, symbol) 
24>   select inserted._Marker_key, 4, MRK_Marker.symbol
25>   from inserted, MRK_Marker
26>   where inserted._Alias_key = MRK_Marker._Marker_key
27> end
28> 
1> 
2> drop trigger MRK_Alias_Delete
1> 
2> create trigger MRK_Alias_Delete
3> on MRK_Alias
4> for delete
5> as
6> 
7> /* Delete Alias from Symbol Bucket */
8> 
9> delete MRK_Symbol from MRK_Symbol, MRK_Marker, deleted
10> where MRK_Symbol._Marker_key = deleted._Marker_key and
11>       MRK_Symbol._Marker_Type_key = 4 and
12>       deleted._Alias_key = MRK_Marker._Marker_key and
13>       MRK_Marker.symbol = MRK_Symbol.symbol
14> 
1> 
2> drop trigger MRK_Allele_Insert
1>  
2> create trigger MRK_Allele_Insert
3> on MRK_Allele
4> for insert
5> as
6>  
7> /* Append Allele Symbol to Symbol Bucket */
8> 
9> if not exists (select * from MRK_Symbol, inserted
10>     where MRK_Symbol._Marker_key = inserted._Marker_key and
11> 	  MRK_Symbol.symbol = inserted.symbol and
12> 	  MRK_Symbol._Marker_Type_key = 5)
13> begin
14>   insert MRK_Symbol (_Marker_key, _Marker_Type_key, symbol)
15>   select inserted._Marker_key, 5, inserted.symbol
16>   from inserted
17> end
18>  
19> /* Append Allele Name to Name Bucket */
20> 
21> if not exists (select * from MRK_Name, inserted
22>     where MRK_Name._Marker_key = inserted._Marker_key and
23> 	  MRK_Name.name = inserted.name and
24> 	  MRK_Name._Marker_Type_key = 5)
25> begin
26>   insert MRK_Name (_Marker_key, _Marker_Type_key, name)
27>   select inserted._Marker_key, 5, inserted.name 
28>   from inserted
29> end
30>  
1>  
2> drop trigger MRK_Allele_Update
1>  
2> create trigger MRK_Allele_Update
3> on MRK_Allele
4> for update
5> as
6>  
7> /* Update entries in Symbol/Name Buckets */
8> 
9> if update(symbol)
10> begin
11> 	update MRK_Symbol set symbol = inserted.symbol
12> 	from MRK_Symbol, inserted, deleted
13> 	where MRK_Symbol._Marker_key = inserted._Marker_key and 
14> 	      MRK_Symbol._Marker_Type_key = 5 and
15> 	      MRK_Symbol.symbol = deleted.symbol
16> end
17> 
18> if update(name)
19> begin
20> 	update MRK_Name set name = inserted.name
21> 	from MRK_Name, inserted, deleted
22> 	where MRK_Name._Marker_key = inserted._Marker_key and 
23> 	      MRK_Name._Marker_Type_key = 5 and
24> 	      MRK_Name.name = deleted.name
25> end
26> 
1>  
2> drop trigger MRK_Allele_Delete
1>  
2> create trigger MRK_Allele_Delete
3> on MRK_Allele
4> for delete
5> as
6> 
7> /* If Allele is referenced in MLDP, disallow deletion */
8> 
9> if exists (select * from MLD_Expt_Marker, deleted
10>     where MLD_Expt_Marker._Allele_key = deleted._Allele_key)
11> begin
12> 	rollback transaction
13> 	raiserror 99999 "Allele Symbol is referenced in MLDP Record(s)"
14> 	return
15> end
16> 
17> /* If Allele is referenced in GXD, disallow deletion */
18> 
19> if exists (select * from GXD_AllelePair, deleted
20>     where GXD_AllelePair._Allele_key_1 = deleted._Allele_key)
21> begin
22> 	rollback transaction
23> 	raiserror 99999 "Allele Symbol is referenced in GXD Allele Pair Record(s)"
24> 	return
25> end
26> 
27> if exists (select * from GXD_AllelePair, deleted
28>     where GXD_AllelePair._Allele_key_2 = deleted._Allele_key)
29> begin
30> 	rollback transaction
31> 	raiserror 99999 "Allele Symbol is referenced in GXD Allele Pair Record(s)"
32> 	return
33> end
34> 
35> /* Remove entries from Symbol/Name buckets */
36> 
37> delete MRK_Symbol from MRK_Symbol, deleted
38> where MRK_Symbol._Marker_key = deleted._Marker_key and
39> MRK_Symbol._Marker_Type_key = 5 and
40> MRK_Symbol.symbol = deleted.symbol
41>  
42> delete MRK_Name from MRK_Name, deleted
43> where MRK_Name._Marker_key = deleted._Marker_key and
44> MRK_Name._Marker_Type_key = 5 and
45> MRK_Name.name = deleted.name
46> 
1>  
2> drop trigger MRK_Class_Delete
1>  
2> create trigger MRK_Class_Delete
3> on MRK_Class
4> for delete
5> as
6> 
7> /* Disallow deletion if Class is referenced by a Marker */
8>  
9> if exists (select * from MRK_Classes, deleted
10>     where MRK_Classes._Class_key = deleted._Class_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Class is referenced in Marker Record(s)"
14> 	return
15> end
16>  
1>  
2> drop trigger MRK_History_Insert
1>  
2> create trigger MRK_History_Insert
3> on MRK_History
4> for insert
5> as
6>  
7> if @@rowcount = 1
8> begin
9> 	/* Insert entry in Name bucket if it doesn't already exist */
10> 
11> 	if not exists (select * from MRK_Name, inserted, MRK_Marker
12>     	    where MRK_Name._Marker_key = inserted._Marker_key and
13> 	  	  MRK_Name.name = inserted.name and
14>           	  MRK_Name._Marker_key = MRK_Marker._Marker_key and
15> 	  	  MRK_Name._Marker_Type_key = MRK_Marker._Marker_Type_key)
16> 	   and (select name from inserted) != NULL
17> 	begin
18>         	insert MRK_Name (_Marker_key, _Marker_Type_key, name)
19>         	select inserted._Marker_key, MRK_Marker._Marker_Type_key, inserted.name 
20>         	from inserted, MRK_Marker
21>         	where inserted._Marker_key = MRK_Marker._Marker_key
22> 	end
23> 
24> 	/* Insert entry in Reference bucket if it doesn't already exist */
25> 
26> 	if not exists (select * from MRK_Reference, inserted
27>     	    where MRK_Reference._Marker_key = inserted._Marker_key and
28> 	  	  MRK_Reference._Refs_key = inserted._Refs_key)
29> 	   and (select _Refs_key from inserted) != NULL
30> 	begin
31> 		insert MRK_Reference (_Marker_key, _Refs_key, auto) 
32> 		select _Marker_key, _Refs_key, 1 from inserted
33> 		where _Refs_key is not null
34> 	end
35> end
36> 
1>  
2> drop trigger MRK_History_Update
1>  
2> create trigger MRK_History_Update
3> on MRK_History
4> for update
5> as
6>  
7> if @@rowcount = 1
8> begin
9> 
10>   /* Update entry in Name bucket if it doesn't already exist */
11> 
12>   if update(name)
13>      and
14>      not exists (select * from MRK_Name, inserted, MRK_Marker
15>       where MRK_Name._Marker_key = inserted._Marker_key and
16> 	    MRK_Name.name = inserted.name and
17>             MRK_Name._Marker_key = MRK_Marker._Marker_key and
18> 	    MRK_Name._Marker_Type_key = MRK_Marker._Marker_Type_key)
19>      and (select name from inserted) != NULL
20>   begin
21>           update MRK_Name set name = inserted.name
22>           from MRK_Name, inserted, deleted
23>           where MRK_Name._Marker_key = inserted._Marker_key and 
24> 	        MRK_Name._Marker_Type_key is null and
25> 	        MRK_Name.name = deleted.name
26>   end
27> 
28>   /* Update entry in Reference bucket if it doesn't already exist */
29> 
30>   if update(_Refs_key)
31>      and
32>      not exists (select * from MRK_Reference, inserted
33>       where MRK_Reference._Marker_key = inserted._Marker_key and
34> 	    MRK_Reference._Refs_key = inserted._Refs_key)
35>      and (select _Refs_key from inserted) != NULL
36>   begin
37> 	  insert MRK_Reference (_Marker_key, _Refs_key, auto) 
38> 	  select _Marker_key, _Refs_key, 1 from inserted
39> 	  where _Refs_key is not null
40>   end
41> end
42> 
1> 
2> drop trigger MRK_History_Delete
1>  
2> create trigger MRK_History_Delete
3> on MRK_History
4> for delete
5> as
6>  
7> /* Remove entry from Name bucket */
8> 
9> delete MRK_Name from MRK_Name, deleted
10> where MRK_Name._Marker_key = deleted._Marker_key and
11>       MRK_Name._Marker_Type_key is null and
12>       MRK_Name.name = deleted.name
13>  
1>  
2> drop trigger MRK_Other_Insert
1>  
2> create trigger MRK_Other_Insert
3> on MRK_Other
4> for insert
5> as
6>  
7> if @@rowcount = 1
8> begin
9> 	/* Insert entry in Name bucket if it doesn't already exist */
10> 
11> 	if not exists (select * from MRK_Name, inserted, MRK_Marker
12>     	    where MRK_Name._Marker_key = inserted._Marker_key and
13> 	  	  MRK_Name.name = inserted.name and
14>           	  MRK_Name._Marker_key = MRK_Marker._Marker_key and
15> 	  	  MRK_Name._Marker_Type_key = MRK_Marker._Marker_Type_key)
16> 	   and (select name from inserted) != NULL
17> 	begin
18>         	insert MRK_Name (_Marker_key, _Marker_Type_key, name)
19>         	select inserted._Marker_key, MRK_Marker._Marker_Type_key, inserted.name 
20>         	from inserted, MRK_Marker
21>         	where inserted._Marker_key = MRK_Marker._Marker_key
22> 	end
23> 
24> 	/* Insert entry in Reference bucket if it doesn't already exist */
25> 
26> 	if not exists (select * from MRK_Reference, inserted
27>     	    where MRK_Reference._Marker_key = inserted._Marker_key and
28> 	  	  MRK_Reference._Refs_key = inserted._Refs_key)
29> 	   and (select _Refs_key from inserted) != NULL
30> 	begin
31> 		insert MRK_Reference (_Marker_key, _Refs_key, auto) 
32> 		select _Marker_key, _Refs_key, 1 from inserted
33> 		where _Refs_key is not null
34> 	end
35> end
36> 
1>  
2> drop trigger MRK_Other_Update
1>  
2> create trigger MRK_Other_Update
3> on MRK_Other
4> for update
5> as
6>  
7> if @@rowcount = 1
8> begin
9> 	/* Update entry in Name bucket */
10> 
11> 	if update(name)
12>            and
13>            not exists (select * from MRK_Name, inserted, MRK_Marker
14>             where MRK_Name._Marker_key = inserted._Marker_key and
15> 	          MRK_Name.name = inserted.name and
16>                   MRK_Name._Marker_key = MRK_Marker._Marker_key and
17> 	          MRK_Name._Marker_Type_key = MRK_Marker._Marker_Type_key)
18> 	   and (select name from inserted) != NULL
19> 	begin
20>         	update MRK_Name set name = inserted.name
21>         	from MRK_Name, inserted, deleted
22>         	where MRK_Name._Marker_key = inserted._Marker_key and 
23>               	MRK_Name._Marker_Type_key is null and
24> 	      	MRK_Name.name = deleted.name
25> 	end
26> 
27>   	/* Update entry in Reference bucket if it doesn't already exist */
28> 
29>   	if update(_Refs_key)
30>      	   and
31>      	   not exists (select * from MRK_Reference, inserted
32>       	   where MRK_Reference._Marker_key = inserted._Marker_key and
33> 	    	 MRK_Reference._Refs_key = inserted._Refs_key)
34>      	   and (select _Refs_key from inserted) != NULL
35>   	begin
36> 	  	insert MRK_Reference (_Marker_key, _Refs_key, auto) 
37> 	  	select _Marker_key, _Refs_key, 1 from inserted
38> 	  	where _Refs_key is not null
39>   	end
40> end
41> 
1> 
2> drop trigger MRK_Other_Delete
1>  
2> create trigger MRK_Other_Delete
3> on MRK_Other
4> for delete
5> as
6>  
7> /* Delete entry from Name bucket */
8> 
9> delete MRK_Name from MRK_Name, deleted
10> where MRK_Name._Marker_key = deleted._Marker_key and
11>       MRK_Name._Marker_Type_key is null and
12>       MRK_Name.name = deleted.name
13>  
14> /* Delete entry from Reference bucket if explicitly declare (auto = 0) */
15> 
16> delete MRK_Reference from MRK_Reference, deleted
17> where MRK_Reference._Marker_key = deleted._Marker_key and
18>       MRK_Reference._Refs_key = deleted._Refs_key and
19>       MRK_Reference.auto = 0
20> 
1>  
2> drop trigger MRK_Species_Delete
1> 
2> create trigger MRK_Species_Delete
3> on MRK_Species
4> for delete
5> as
6> 
7> /* Disallow deletion of species which is referenced in MRK_Marker table */
8> 
9> if exists (select * from MRK_Marker, deleted
10>          where MRK_Marker._Species_key = deleted._Species_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Species is referenced in Marker Record(s)"
14> 	return
15> end
16> 
17> /* Delete records in dependent tables */
18> 
19> delete MRK_Chromosome from MRK_Chromosome, deleted
20> where MRK_Chromosome._Species_key = deleted._Species_key
21> 
1> 
2> drop trigger MRK_Types_Delete
1> 
2> create trigger MRK_Types_Delete
3> on MRK_Types
4> for delete
5> as
6> 
7> /* Disallow deletion of Type which is referenced in MRK_Marker table */
8> 
9> if exists (select * from MRK_Marker, deleted
10>          where MRK_Marker._Marker_Type_key = deleted._Marker_Type_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Marker Type is referenced in Marker Record(s)"
14> 	return
15> end
16> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger PRB_Probe_Insert
1>  
2> create trigger PRB_Probe_Insert
3> on PRB_Probe
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Molecular Segment */
8> 
9> declare @key integer
10> select @key = _Probe_key from inserted
11> exec ACC_assignMGI @key, "Segment"
12> 
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1>  
2> drop trigger PRB_Probe_Update
1>  
2> create trigger PRB_Probe_Update
3> on PRB_Probe
4> for update
5> as
6>  
7> if update (_Source_key)
8> begin
9> 	/* Disallow edits to WashU data - TR 611 */
10> 
11>    	if exists (select * from PRB_Reference_View r, inserted i
12> 		where r._Probe_key = i._Probe_key and
13> 	      	      r.jnum = 57656)
14>    	    and
15>    	    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
16> 	begin
17>         	rollback transaction
18>         	raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot modify the Source information."
19> 		return
20> 	end
21> 
22> 	/* Delete orphan Anonymous _Source_keys */
23> 
24> 	if (select PRB_Source.name from PRB_Source, deleted
25> 	    where PRB_Source._Source_key = deleted._Source_key) is null
26> 	    and
27> 	   not exists (select * from PRB_Probe, deleted
28>             where PRB_Probe._Source_key = deleted._Source_key)
29> 	begin
30> 		delete PRB_Source from PRB_Source, deleted
31> 		where PRB_Source._Source_key = deleted._Source_key
32> 	end
33> 
34> 	/* Update _Source_key for all children of Parent */
35> 
36> 	update PRB_Probe set _Source_key = inserted._Source_key
37> 	from PRB_Probe, inserted
38> 	where PRB_Probe.derivedFrom = inserted._Probe_key
39> end
40> 
41> /* Disallow edits to WashU data - TR 611 */
42> 
43> if update (name)
44>    and
45>    exists (select * from PRB_Reference_View r, inserted i
46> 	where r._Probe_key = i._Probe_key and
47> 	      r.jnum = 57656)
48>    and
49>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
50> begin
51>         rollback transaction
52>         raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot modify the name."
53> 	return
54> end
55> 
1>  
2> drop trigger PRB_Probe_Delete
1> 
2> create trigger PRB_Probe_Delete
3> on PRB_Probe
4> for delete
5> as
6> 
7> /* Disallow deletion if Molecular Segment is referenced elsewhere */
8> 
9> if exists (select * from PRB_Probe, deleted
10>     where PRB_Probe.derivedFrom = deleted._Probe_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Molecular Segment is referenced as a Parent in Molecular Segment record(s)"
14> 	return
15> end
16>  
17> if exists (select * from MLD_Hit, deleted
18>          where MLD_Hit._Probe_key = deleted._Probe_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Molecular Segment is referenced in MLDP Hit record(s)"
22> 	return
23> end
24>  
25> if exists (select * from MLD_Hit, deleted
26>          where MLD_Hit._Target_key = deleted._Probe_key)
27> begin
28>         rollback transaction
29>         raiserror 99999 "Molecular Segment is referenced as a Target in MLDP Hit record(s)"
30> 	return
31> end
32>  
33> if exists (select * from MLD_ContigProbe, deleted
34>          where MLD_ContigProbe._Probe_key = deleted._Probe_key)
35> begin
36>         rollback transaction
37>         raiserror 99999 "Molecular Segment is referenced in MLDP Contig/Probe record(s)"
38> 	return
39> end
40>  
41> if exists (select * from GXD_ProbePrep, deleted
42>          where GXD_ProbePrep._Probe_key = deleted._Probe_key)
43> begin
44>         rollback transaction
45>         raiserror 99999 "Molecular Segment is referenced in GXD Probe Prep record(s)"
46> 	return
47> end
48> 
49> /* Disallow edits to WashU data - TR 611 */
50> 
51> if exists (select * from PRB_Reference_View r, deleted d
52> 	where r._Probe_key = d._Probe_key and
53> 	      r.jnum = 57656)
54>    and
55>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
56> begin
57>         rollback transaction
58>         raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot delete record."
59> 	return
60> end
61> 
62> delete PRB_Marker from PRB_Marker, deleted
63> where PRB_Marker._Probe_key = deleted._Probe_key
64> 
65> delete PRB_Notes from PRB_Notes, deleted
66> where PRB_Notes._Probe_key = deleted._Probe_key
67> 
68> delete PRB_Reference from PRB_Reference, deleted
69> where PRB_Reference._Probe_key = deleted._Probe_key
70> 
71> /* If Probe Source Name is null, then Anonymous Source */
72> /* If Anonymous Source, delete upon deletion of Probe */
73> 
74> if exists (select * from PRB_Probe, deleted
75>     where PRB_Probe._Source_key = deleted._Source_key)
76> begin
77>   	delete PRB_Source from PRB_Source, deleted
78>   	where PRB_Source._Source_key = deleted._Source_key
79> 	      and PRB_Source.name is null
80> end
81> 
82> delete ACC_AccessionReference 
83> from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m, deleted
84> where a._Object_key = deleted._Probe_key
85> and a._MGIType_key = m._MGIType_key
86> and m.name = "Segment"
87> and a._Accession_key = ar._Accession_key
88>  
89> delete ACC_Accession 
90> from ACC_Accession a, ACC_MGIType m, deleted
91> where a._Object_key = deleted._Probe_key
92> and a._MGIType_key = m._MGIType_key
93> and m.name = "Segment"
94>  
1> 
2> drop trigger PRB_Allele_Delete
1> 
2> create trigger PRB_Allele_Delete
3> on PRB_Allele
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete PRB_Allele_Strain from PRB_Allele_Strain, deleted
10> where PRB_Allele_Strain._Allele_key = deleted._Allele_key
11> 
1> 
2> drop trigger PRB_Marker_Insert
1> 
2> create trigger PRB_Marker_Insert
3> on PRB_Marker
4> for insert
5> as
6> 
7> if @@rowcount = 1
8> begin
9> 	/* Relationship must be 'H' for Probes of non-mouse source */
10> 
11> 	if exists (select * from inserted i, PRB_Probe p, PRB_Source s
12>     		where i._Probe_key = p._Probe_key
13> 	  	and p.DNAtype != 'primer'
14> 	  	and p._Source_key = s._Source_key
15> 	  	and s.species not in ('mouse, laboratory')
16> 	  	and (i.relationship != 'H' or i.relationship is null))
17> 	begin
18>         	rollback transaction
19>         	raiserror 99999 "Relationship Must be 'H'"
20> 		return
21> 	end
22> 
23> 	/* Relationship 'P' can only be used during an EST bulk load */
24> 
25> 	if (select relationship from inserted) = 'P'
26> 	begin
27>         	rollback transaction
28>         	raiserror 99999 "Relationship 'P' can only be used during EST load"
29> 		return
30> 	end
31> 
32>   	/* If adding encoding Marker to a Molecular Segment and */
33> 	/* Molecular Segment contains a Seq ID and */
34> 	/* the Marker is not associated with the Seq ID */
35> 
36> 	if (select relationship from inserted) = 'E'
37> 	begin
38> 		if exists (select a1.accID
39> 		   from ACC_Accession a1, ACC_Accession a2, inserted i
40> 		   where a1._MGIType_key = 3 and 
41> 		         a1. _LogicalDB_key = 9 and 
42> 		         a1._Object_key = i._Probe_key)
43> 		   and
44> 		   not exists (select a1.accID
45> 		   from ACC_Accession a1, ACC_Accession a2, inserted i
46> 		   where a1._MGIType_key = 3 and 
47> 		         a1. _LogicalDB_key = 9 and 
48> 		         a1._Object_key = i._Probe_key and
49> 			 a1.accID = a2.accID and
50> 			 a2._MGIType_key = 2 and
51> 			 a2._LogicalDB_key = 9 and
52> 			 a2._Object_key = i._Marker_key)
53> 
54>   		begin
55>         		print "The Sequence ID(s) for this Molecular Segment should probably be added to the encoding, updated Marker."
56>   		end
57> 
58> 	end
59> end
60> 
1> 
2> drop trigger PRB_Marker_Update
1>  
2> create trigger PRB_Marker_Update
3> on PRB_Marker
4> for update
5> as
6>  
7> if @@rowcount = 1
8> begin
9> 
10> 	/* Relationship must be 'H' for Probes of non-mouse source */
11> 
12> 	if exists (select * from inserted i, PRB_Probe p, PRB_Source s
13>     		where i._Probe_key = p._Probe_key
14> 	  	and p.DNAtype != 'primer'
15> 	  	and p._Source_key = s._Source_key
16> 	  	and s.species not in ('mouse, laboratory')
17> 	  	and (i.relationship != 'H' or i.relationship is null))
18> 	begin
19>         	rollback transaction
20>         	raiserror 99999 "Relationship Must be 'H'"
21> 		return
22> 	end
23> 
24> 	/* Allow update of 'P' to other relationship */
25> 	/* Disallow update of other relationship to 'P' */
26> 	/* Only check on individual inserts */
27> 
28> 	if ((select relationship from inserted) = 'P'
29> 	    and (select _Marker_key from inserted) = (select _Marker_key from deleted))
30> 	   or
31> 	   ((select _Marker_key from inserted) != (select _Marker_key from deleted)
32> 	    and (select relationship from inserted) = 'P'
33> 	    and (select relationship from deleted) != 'P')
34> 	begin
35>         	rollback transaction
36>         	raiserror 99999 "Relationship 'P' can only be used during EST load"
37> 		return
38> 	end
39> 
40>         /* If updating to an encoding Marker for a Molecular Segment and */
41>         /* Molecular Segment contains a Seq ID and */
42>         /* the Marker is not associated with the Seq ID */
43>  
44>         if update(relationship) and (select relationship from inserted) = 'E'
45>         begin
46>                 if not exists (select a1.accID
47>                    from ACC_Accession a1, ACC_Accession a2, inserted i
48>                    where a1._MGIType_key = 3 and
49>                          a1. _LogicalDB_key = 9 and
50>                          a1._Object_key = i._Probe_key and
51>                          a1.accID = a2.accID and
52>                          a2._MGIType_key = 2 and
53>                          a2._LogicalDB_key = 9 and
54>                          a2._Object_key = i._Marker_key)
55>  
56>                 begin
57>                         print "The Sequence ID(s) for this Molecular Segment should probably be added to the encoding, updated Marker."
58>                 end
59> 	end 
60> 
61>         /* If updating to an non-encoding Marker for a Molecular Segment and */
62>         /* Molecular Segment contains a Seq ID and */
63>         /* the Marker is associated with the Seq ID */
64>  
65>         if update(relationship) and 
66> 	   (select relationship from deleted) = 'E' and
67>            (select relationship from inserted) != 'E'
68>         begin
69>                 if exists (select a1.accID
70>                    from ACC_Accession a1, ACC_Accession a2, inserted i
71>                    where a1._MGIType_key = 3 and
72>                          a1. _LogicalDB_key = 9 and
73>                          a1._Object_key = i._Probe_key and
74>                          a1.accID = a2.accID and
75>                          a2._MGIType_key = 2 and
76>                          a2._LogicalDB_key = 9 and
77>                          a2._Object_key = i._Marker_key)
78>  
79>                 begin
80>                         print "Please review the relationship(s) between the updated Marker and its Seq IDs.  These relationships may no longer be appropriate."
81>                 end
82> 	end 
83> end
84> 
85> if update(_Marker_key)
86> begin
87> 	update PRB_RFLV
88> 	set _Marker_key = inserted._Marker_key
89> 	from PRB_RFLV, PRB_Reference, inserted, deleted
90> 	where inserted._Probe_key = PRB_Reference._Probe_key
91> 	      and PRB_Reference._Reference_key = PRB_RFLV._Reference_key
92> 	      and PRB_RFLV._Marker_key = deleted._Marker_key
93> end
94> 
1> 
2> drop trigger PRB_Marker_Delete
1>  
2> create trigger PRB_Marker_Delete
3> on PRB_Marker
4> for delete
5> as
6> 
7> if @@rowcount = 1
8> begin
9>         /* If deleting an encoding Marker from a Molecular Segment and */
10>         /* Molecular Segment contains a Seq ID and */
11>         /* the Marker is associated with the Seq ID */
12>  
13>         if (select relationship from deleted) = 'E'
14>         begin
15>                 if exists (select a1.accID
16>                    from ACC_Accession a1, ACC_Accession a2, deleted d
17>                    where a1._MGIType_key = 3 and
18>                          a1. _LogicalDB_key = 9 and
19>                          a1._Object_key = d._Probe_key and
20>                          a1.accID = a2.accID and
21>                          a2._MGIType_key = 2 and
22>                          a2._LogicalDB_key = 9 and
23>                          a2._Object_key = d._Marker_key)
24>  
25>                 begin
26>                         print "Please review the relationship(s) between the deleted Marker and its Seq IDs.  These relationships may no longer be appropriate."
27>                 end
28> 	end 
29> 
30> end
31> 
1>  
2> drop trigger PRB_Reference_Update
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'PRB_Reference_Update', because it doesn't exist in the
system catalogs.
1> 
2> create trigger PRB_Reference_Update
3> on PRB_Reference
4> for update
5> as
6> 
7> /* Disallow edits to WashU data - TR 611 */
8> 
9> if exists (select * from BIB_All_View b, inserted d
10> 	where d._Refs_key = b._Refs_key and
11> 	      b.jnum = 57656)
12>    and
13>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
14> begin
15>         rollback transaction
16>         raiserror 99999 "J:57656, WashU-HHMI Database Download.  Cannot update record."
17> 	return
18> end
19> 
1> 
2> drop trigger PRB_Reference_Delete
1> 
2> create trigger PRB_Reference_Delete
3> on PRB_Reference
4> for delete
5> as
6> 
7> /* Disallow edits to WashU data - TR 611 */
8> 
9> if exists (select * from BIB_All_View b, deleted d
10> 	where d._Refs_key = b._Refs_key and
11> 	      b.jnum = 57656)
12>    and
13>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
14> begin
15>         rollback transaction
16>         raiserror 99999 "J:57656, WashU-HHMI Database Download.  Cannot delete record."
17> 	return
18> end
19> 
20> /* Delete dependent records */
21> 
22> delete PRB_Alias from PRB_Alias, deleted
23> where PRB_Alias._Reference_key = deleted._Reference_key
24> 
25> delete PRB_Ref_Notes from PRB_Ref_Notes, deleted
26> where PRB_Ref_Notes._Reference_key = deleted._Reference_key
27> 
28> delete PRB_RFLV from PRB_RFLV, deleted
29> where PRB_RFLV._Reference_key = deleted._Reference_key
30> 
31> delete ACC_AccessionReference 
32> from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m, deleted
33> where a._Object_key = deleted._Probe_key
34> and a._MGIType_key = m._MGIType_key
35> and m.name = "Segment"
36> and a._Accession_key = ar._Accession_key
37> and ar._Refs_key = deleted._Refs_key
38>  
1> 
2> drop trigger PRB_RFLV_Delete
1> 
2> create trigger PRB_RFLV_Delete
3> on PRB_RFLV
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete PRB_Allele from PRB_Allele, deleted
10> where PRB_Allele._RFLV_key = deleted._RFLV_key
11> 
1> 
2> drop trigger PRB_Source_Insert
1> 
2> create trigger PRB_Source_Insert
3> on PRB_Source
4> for insert
5> as
6> 
7> /* The same exact logic to prevent invalid Age values must */
8> /* be used in the update trigger as well */
9> 
10> /* Ignore multi-row data */
11> 
12> if @@rowcount > 1
13> begin
14> 	return
15> end
16> 
17> /* Disallow edits to WashU data - TR 611 */
18> 
19> if exists (select * from PRB_Probe p, PRB_Reference_View r, inserted i
20> 	where i._Source_key = p._Source_key and
21> 	      p._Probe_key = r._Probe_key and
22>       	      r.jnum = 57656)
23>     and
24>     (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
25> begin
26>        	rollback transaction
27>        	raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot modify the Source information."
28> 	return
29> end
30> 
31> declare @age varchar(50)
32> select @age = inserted.age from inserted
33> 
34> /* If tissue = 'unfertilized egg', then age must be 'Not Applicable' */
35> 
36> if (select PRB_Tissue.tissue
37> 	from PRB_Tissue, inserted
38> 	where inserted._Tissue_key = PRB_Tissue._Tissue_key) = "unfertilized egg"
39>    and @age != "Not Applicable"
40> begin
41>         rollback transaction
42>         raiserror 99999 "Age for this tissue MUST be Not Applicable"
43> 	return
44> end
45> 
46> /* If age is 'Not Applicable', then tissue must be 'unfertilized egg' */
47> 
48> if @age = "Not Applicable"
49>    and
50>    (select PRB_Tissue.tissue
51> 	from PRB_Tissue, inserted
52> 	where inserted._Tissue_key = PRB_Tissue._Tissue_key) != "unfertilized egg"
53> begin
54>         rollback transaction
55>         raiserror 99999 "Age for this tissue CANNOT be Not Applicable"
56> 	return
57> end
58> 
59> /* Separate agePrefix from ageSuffix (numerics) */
60> 
61> declare @agePrefix varchar(50)
62> declare @ageSuffix varchar(50)
63> declare @idx integer
64> 
65> select @agePrefix = @age
66> select @idx = patindex("%[0-9]%", @age)
67> 
68> if @idx > 0
69> begin
70> 	select @agePrefix = substring(@age, 1, @idx - 1)
71> 	select @ageSuffix = substring(@age, @idx, char_length(@age))
72> end
73> 
74> /* If age is one of the following prefixes, then there can be no numeric values */
75> 
76> if @agePrefix in ('Not Specified', 'Not Applicable', 'embryonic', 'perinatal',
77> 	'postnatal', 'postnatal newborn', 'postnatal immature', 'postnatal adult')
78>    and @ageSuffix is not null
79> begin
80>         rollback transaction
81>         raiserror 99999 "The Age value specified CANNOT contain numeric values"
82> 	return
83> end
84> 
85> /* If age is one of the following prefixes, then there must be numeric values */
86> 
87> if @agePrefix in ('embryonic day', 'postnatal day', 'postnatal week',
88> 	'postnatal month', 'postnatal year')
89>    and @ageSuffix is null
90> begin
91>         rollback transaction
92>         raiserror 99999 "The Age value specified MUST contain numeric values"
93> 	return
94> end
95> 
1> 
2> drop trigger PRB_Source_Update
1> 
2> create trigger PRB_Source_Update
3> on PRB_Source
4> for update
5> as
6> 
7> /* The same exact logic to prevent invalid Age values must */
8> /* be used in the insert trigger as well */
9> 
10> /* Ignore multi-row data */
11> 
12> if @@rowcount > 1
13> begin
14> 	return
15> end
16> 
17> /* Disallow edits to WashU data - TR 611 */
18> 
19> if exists (select * from PRB_Probe p, PRB_Reference_View r, inserted i
20> 	where i._Source_key = p._Source_key and
21> 	      p._Probe_key = r._Probe_key and
22>       	      r.jnum = 57656)
23>     and
24>     (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
25> begin
26>        	rollback transaction
27>        	raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot modify the Source information."
28> 	return
29> end
30> 
31> declare @age varchar(50)
32> select @age = inserted.age from inserted
33> 
34> /* If tissue = 'unfertilized egg', then age must be 'Not Applicable' */
35> 
36> if (select PRB_Tissue.tissue
37> 	from PRB_Tissue, inserted
38> 	where inserted._Tissue_key = PRB_Tissue._Tissue_key) = "unfertilized egg"
39>    and @age != "Not Applicable"
40> begin
41>         rollback transaction
42>         raiserror 99999 "Age for this tissue MUST be Not Applicable"
43> 	return
44> end
45> 
46> /* If age is 'Not Applicable', then tissue must be 'unfertilized egg' */
47> 
48> if @age = "Not Applicable"
49>    and
50>    (select PRB_Tissue.tissue
51> 	from PRB_Tissue, inserted
52> 	where inserted._Tissue_key = PRB_Tissue._Tissue_key) != "unfertilized egg"
53> begin
54>         rollback transaction
55>         raiserror 99999 "Age for this tissue CANNOT be Not Applicable"
56> 	return
57> end
58> 
59> /* Separate agePrefix from ageSuffix (numerics) */
60> 
61> declare @agePrefix varchar(50)
62> declare @ageSuffix varchar(50)
63> declare @idx integer
64> 
65> select @agePrefix = @age
66> select @idx = patindex("%[0-9]%", @age)
67> 
68> if @idx > 0
69> begin
70> 	select @agePrefix = substring(@age, 1, @idx - 1)
71> 	select @ageSuffix = substring(@age, @idx, char_length(@age))
72> end
73> 
74> /* If age is one of the following prefixes, then there can be no numeric values */
75> 
76> if @agePrefix in ('Not Specified', 'Not Applicable', 'embryonic', 'perinatal',
77> 	'postnatal', 'postnatal newborn', 'postnatal immature', 'postnatal adult')
78>    and @ageSuffix is not null
79> begin
80>         rollback transaction
81>         raiserror 99999 "The Age value specified CANNOT contain numeric values"
82> 	return
83> end
84> 
85> /* If age is one of the following prefixes, then there must be numeric values */
86> 
87> if @agePrefix in ('embryonic day', 'postnatal day', 'postnatal week',
88> 	'postnatal month', 'postnatal year')
89>    and @ageSuffix is null
90> begin
91>         rollback transaction
92>         raiserror 99999 "The Age value specified MUST contain numeric values"
93> 	return
94> end
95> 
1> 
2> drop trigger PRB_Source_Delete
1> 
2> create trigger PRB_Source_Delete
3> on PRB_Source
4> for delete
5> as
6> 
7> /* Disallow deletion if Source is referenced elsewhere */
8> 
9> if exists (select * from PRB_Probe, deleted
10>          where PRB_Probe._Source_key = deleted._Source_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Molecular Segment Library is referenced in Probe Record(s)"
14> 	return
15> end
16>  
17> if exists (select * from GXD_Antigen, deleted
18>          where GXD_Antigen._Source_key = deleted._Source_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Molecular Segment Library is referenced in GXD Antigen Record(s)"
22> 	return
23> end
24>  
1> 
2> drop trigger PRB_Strain_Insert
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'PRB_Strain_Insert', because it doesn't exist in the
system catalogs.
1> 
2> create trigger PRB_Strain_Insert
3> on PRB_Strain
4> for insert
5> as
6> 
7> if (select count(*) from PRB_Strain, inserted
8>          where PRB_Strain.strain = inserted.strain) > 1
9> begin
10>         print "Potential Duplicate Strain Found"
11> end
12>  
1> 
2> drop trigger PRB_Strain_Update
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'PRB_Strain_Update', because it doesn't exist in the
system catalogs.
1> 
2> create trigger PRB_Strain_Update
3> on PRB_Strain
4> for update
5> as
6> 
7> if (select count(*) from PRB_Strain, inserted
8>          where PRB_Strain.strain = inserted.strain) > 1
9> begin
10>         print "Potential Duplicate Strain Found"
11> end
12>  
13> update PRB_Strain 
14> set modification_date = getdate()
15> from PRB_Strain, inserted
16> where PRB_Strain._Strain_key = inserted._Strain_key
17> 
1> 
2> drop trigger PRB_Strain_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'PRB_Strain_Delete', because it doesn't exist in the
system catalogs.
1> 
2> create trigger PRB_Strain_Delete
3> on PRB_Strain
4> for delete
5> as
6> 
7> /* Disallow deletion if Strain is referenced elsewhere */
8> 
9> if exists (select * from PRB_Source, deleted
10>     where PRB_Source._Strain_key = deleted._Strain_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Strain is referenced in Molecular Segment Library Record(s)"
14> 	return
15> end
16> 
17> if exists (select * from PRB_Allele_Strain, deleted
18>          where PRB_Allele_Strain._Strain_key = deleted._Strain_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Strain is referenced in RFLP Record(s)"
22> 	return
23> end
24> 
25> if exists (select * from MLD_FISH, deleted
26>          where MLD_FISH._Strain_key = deleted._Strain_key)
27> begin
28>         rollback transaction
29>         raiserror 99999 "Strain is referenced in FISH Record(s)"
30> 	return
31> end
32>  
33> if exists (select * from MLD_InSitu, deleted
34>          where MLD_InSitu._Strain_key = deleted._Strain_key)
35> begin
36>         rollback transaction
37>         raiserror 99999 "Strain is referenced in InSitu Record(s)"
38> 	return
39> end
40>  
41> if exists (select * from CRS_Cross, deleted
42>          where CRS_Cross._femaleStrain_key = deleted._Strain_key)
43> begin
44>         rollback transaction
45>         raiserror 99999 "Strain is referenced in Cross Record(s)"
46> 	return
47> end
48>  
49> if exists (select * from CRS_Cross, deleted
50>          where CRS_Cross._maleStrain_key = deleted._Strain_key)
51> begin
52>         rollback transaction
53>         raiserror 99999 "Strain is referenced in Cross Record(s)"
54> 	return
55> end
56>  
57> if exists (select * from CRS_Cross, deleted
58>          where CRS_Cross._StrainHO_key = deleted._Strain_key)
59> begin
60>         rollback transaction
61>         raiserror 99999 "Strain is referenced in Cross Record(s)"
62> 	return
63> end
64>  
65> if exists (select * from CRS_Cross, deleted
66>          where CRS_Cross._StrainHT_key = deleted._Strain_key)
67> begin
68>         rollback transaction
69>         raiserror 99999 "Strain is referenced in Cross Record(s)"
70> 	return
71> end
72>  
73> if exists (select * from GXD_Genotype, deleted
74>          where GXD_Genotype._Strain_key = deleted._Strain_key)
75> begin
76>         rollback transaction
77>         raiserror 99999 "Strain is referenced in GXD Genotype Record(s)"
78> 	return
79> end
80>  
81> delete PRB_Strain_Marker from PRB_Strain_Marker, deleted
82> where PRB_Strain_Marker._Strain_key = deleted._Strain_key
83> 
1> 
2> drop trigger PRB_Tissue_Delete
1> 
2> create trigger PRB_Tissue_Delete
3> on PRB_Tissue
4> for delete
5> as
6> 
7> /* Disallow deletion if Tissue is referenced elsewhere */
8> 
9> if exists (select * from PRB_Source, deleted
10>     where PRB_Source._Tissue_key = deleted._Tissue_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Tissue is referenced in Molecular Segment Library Record(s)"
14> 	return
15> end
16>  
1> 
2> drop trigger PRB_Vector_Types_Delete
1> 
2> create trigger PRB_Vector_Types_Delete
3> on PRB_Vector_Types
4> for delete
5> as
6> 
7> /* Disallow deletion if Vector_Types is referenced elsewhere */
8> 
9> if exists (select * from PRB_Probe, deleted
10>     where PRB_Probe._Vector_key = deleted._Vector_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Vector Type is referenced in Molecular Segment Record(s)"
14> 	return
15> end
16>  
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger RI_RISet_Update
1> 
2> create trigger RI_RISet_Update
3> on RI_RISet
4> for update
5> as
6> 
7> /* Update origin, designation, abbreviation values in individual */
8> /* experiment records whenever the "master" RI record is changed. */
9> /* The fields in the MLD_RI table are actually obsolete and should */
10> /* be removed from this table. */
11> 
12> update MLD_RI
13> set origin = inserted.origin, 
14>     designation = inserted.designation,
15>     abbrev1 = inserted.abbrev1,
16>     abbrev2 = inserted.abbrev2
17> from MLD_RI, inserted
18> where MLD_RI._RISet_key = inserted._RISet_key
19> 
1> 
2> drop trigger RI_RISet_Delete
1> 
2> create trigger RI_RISet_Delete
3> on RI_RISet
4> for delete
5> as
6> 
7> /* Disallow deletion if RI Set is referenced elsewhere */
8> 
9> if exists (select * from MLD_RI, deleted
10>     where MLD_RI._RISet_key = deleted._RISet_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "RI is referenced in MLDP Record(s)"
14> 	return
15> end
16> 
1> 
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> drop view MGI_Table_Column_View
1> 
2> create view MGI_Table_Column_View
3> as 
4> SELECT _Table_id = t._Table_id, table_name = o.name, table_description = t.description,
5> column_name = c.name, _Column_id = cc._Column_id, column_description = cc.description,
6> example = cc.example, t.creation_date, t.modification_date
7> FROM
8> syscolumns c, MGI_Columns cc, sysobjects o, MGI_Tables t
9> WHERE
10> o.id = t._Table_id AND cc._Column_id = c.colid AND
11> o.id = c.id AND cc._Table_id = t._Table_id AND ((o.type='U'))
1> 
2> grant select on MGI_Table_Column_View to public
1>  
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> drop view MRK_Nomen_View
1> 
2> create view MRK_Nomen_View
3> as
4> select n.*, s.status, e.event, markerType = t.name, userName = u.name
5> from MRK_Nomen n, MRK_Status s, MRK_Event e, mgd..MRK_Types t, sysusers u
6> where n._Marker_Status_key = s._Marker_Status_key
7> and n._Marker_Event_key = e._Marker_Event_key
8> and n._Marker_Type_key = t._Marker_Type_key
9> and n._Suid_key = u.suid
1> 
2> grant select on MRK_Nomen_View to public
1> 
2> drop view MRK_Nomen_Reference_View
1> 
2> create view MRK_Nomen_Reference_View
3> as
4> select r.*, b.jnumID, b.jnum, b.short_citation, firstAuthor = b._primary
5> from MRK_Nomen_Reference r, mgd..BIB_All_View b
6> where r._Refs_key = b._Refs_key
1> 
2> grant select on MRK_Nomen_Reference_View to public
1>  
2> drop view MRK_Nomen_GeneFamily_View
1> 
2> create view MRK_Nomen_GeneFamily_View
3> as
4> select n.*, g.name
5> from MRK_Nomen_GeneFamily n, MRK_GeneFamily g
6> where n._Marker_Family_key = g._Marker_Family_key
1> 
2> grant select on MRK_Nomen_GeneFamily_View to public
1>  
2> drop view MRK_Nomen_Marker_View
1> 
2> create view MRK_Nomen_Marker_View
3> as
4> select distinct m.current_symbol, a.accID, m.symbol
5> from MRK_Nomen n, mgd..MRK_Current_View m, mgd..MRK_Acc_View a
6> where n.approvedSymbol = m.symbol
7> and n._Marker_Type_key = m._Marker_Type_key
8> and m._Current_key = a._Object_key
9> and a.preferred = 1
1> 
2> grant select on MRK_Nomen_Marker_View to public
1> 
2> drop view MRK_Nomen_Homology_View
1> 
2> create view MRK_Nomen_Homology_View
3> as
4> select n.*
5> from MRK_Nomen n, mgd..MRK_Marker m, mgd..HMD_Homology_Marker h
6> where n.humanSymbol = m.symbol
7> and m._Species_key = 2
8> and m._Marker_key = h._Marker_key
1> 
2> grant select on MRK_Nomen_Homology_View to public
1> 
2> drop view MRK_Nomen_User_View
1> 
2> create view MRK_Nomen_User_View
3> as
4> select l.suid, l.name, l.fullname, l.status
5> from master..syslogins l, nomen..sysusers u, nomen..sysusers g
6> where l.suid = u.suid
7> and u.gid = g.gid
8> and g.name = 'editors'
9> and l.name not in ('jeo', 'plg', 'neb', 'lglass', 'mirror_site')
10> and (l.status = 0 or l.name = 'retired_editors')
1> 
2> grant select on MRK_Nomen_User_View to public
1> 
2> drop view MRK_Nomen_CoordNotes_View
1> 
2> create view MRK_Nomen_CoordNotes_View
3> as
4> select * from MRK_Nomen_Notes where noteType = 'C'
1> 
2> grant all on MRK_Nomen_CoordNotes_View to ljm, rmb
1> 
2> grant all on MRK_Nomen_CoordNotes_View to progs
1> 
2> grant select on MRK_Nomen_CoordNotes_View to public
1> 
2> drop view MRK_Nomen_EditorNotes_View
1> 
2> create view MRK_Nomen_EditorNotes_View
3> as
4> select * from MRK_Nomen_Notes where noteType = 'E'
1> 
2> grant all on MRK_Nomen_EditorNotes_View to editors
1> 
2> grant all on MRK_Nomen_EditorNotes_View to progs
1> 
2> grant select on MRK_Nomen_EditorNotes_View to public
1> 
2> drop view MRK_Nomen_AccRef_View
1>  
2> create view MRK_Nomen_AccRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, ar._Refs_key, b.jnumID, b.jnum, b.short_citation
5> from ACC_Accession a, mgd..ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, mgd..BIB_All_View b
6> where a._MGIType_key = 1
7> and a._Accession_key = ar._Accession_key
8> and a._LogicalDB_key = l._LogicalDB_key
9> and a._MGIType_key = m._MGIType_key
10> and ar._Refs_key = b._Refs_key
1>  
2> grant select on MRK_Nomen_AccRef_View to public
1> 
2> drop view MRK_Nomen_AccNoRef_View
1>  
2> create view MRK_Nomen_AccNoRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name,
5> subType = mt.name,
6> description = ma.approvedSymbol + ", " + ma.approvedName
7> from ACC_Accession a, mgd..ACC_LogicalDB l, ACC_MGIType m, MRK_Nomen ma, mgd..MRK_Types mt
8> where a._MGIType_key = 1
9> and a._LogicalDB_key = l._LogicalDB_key
10> and a._MGIType_key = m._MGIType_key
11> and a._Object_key = ma._Nomen_key
12> and ma._Marker_Type_key = mt._Marker_Type_key
13> and not exists (select r.* from ACC_AccessionReference r
14> where a._Accession_key = r._Accession_key)
1>  
2> grant select on MRK_Nomen_AccNoRef_View to public
1>  
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> /* 1> declare @prefixPart varchar(20) */
3> /* 2> declare @numericPart int */
4> /* 3> exec ACC_split "MGI:12345", @prefixPart out, @numericPart out */
5> /* 4> go */
6> /* (return status = 0) */
7> /* Return parameters: */
8> /* ---- -----------  */
9> /* MGI:       12345  */
10> 
11> drop procedure ACC_split
1> 
2> create procedure ACC_split
3>   @accID varchar(20),
4>   @prefixPart varchar(20) out,
5>   @numericPart integer out
6> as
7> 
8> declare @temp varchar(20) 
9> declare @suffix varchar(20)
10> declare @acclen integer
11> declare @idx integer
12> 
13> /* Remove trailing blanks */
14> select @accID = rtrim(@accID)
15> select @acclen = char_length(@accID)
16> select @temp = reverse(@accID)
17> select @idx  = patindex("%[^0-9]%",@temp)
18> 
19> /* If @idx = 0, then no prefix */
20> 
21> if @idx = 0
22> begin
23>   select @numericPart = convert(integer, @accID)
24>   select @prefixPart = NULL
25> end
26> 
27> else
28> 
29> begin
30>   select @prefixPart = reverse(substring(@temp,@idx,@acclen-@idx+1))
31>   select @suffix = substring(@accID,
32>                              char_length(@prefixPart)+1,
33>                              @acclen - char_length(@prefixPart))
34> 
35>   if @suffix is not NULL
36>      select @numericPart = convert(integer, @suffix)
37>   else
38>      select @numericPart = NULL
39> end
40> 
1> 
2> grant execute on ACC_split to progs
1>  
2> grant execute on ACC_split to editors
1>  
2> grant execute on ACC_split to public
1>  
2> drop procedure ACCRef_insert
1>  
2> create procedure ACCRef_insert
3>   @accKey int,
4>   @refsKey int
5> as
6>  
7> /* Insert record into ACC_AccessionReference table */
8> 
9> insert into ACC_AccessionReference
10> (_Accession_key, _Refs_key)
11> values(@accKey, @refsKey)
12> 
1>  
2> grant execute on ACCRef_insert to progs
1>  
2> grant execute on ACCRef_insert to editors
1>  
2> drop procedure ACC_insert
1>  
2> create procedure ACC_insert
3>   @objectKey int,
4>   @accID varchar(30),
5>   @logicalDB int,
6>   @mgiType varchar(80),
7>   @refsKey int = -1,
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* Insert record into master Accession table. */
13> /* If reference is given, insert record into Accession Reference table. */
14> 
15> if @accID is null
16> 	return
17> 
18> declare @nextACC int
19> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
20> 
21> if @nextACC is null
22> begin
23> 	select @nextACC = 1
24> end
25> 
26> declare @mgiTypeKey int
27> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
28>  
29> declare @prefixPart varchar(20)
30> declare @numericPart int
31> exec ACC_split @accID, @prefixPart out, @numericPart out
32> 						      
33> insert into ACC_Accession
34> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
35> values(@nextACC, @accID, @prefixPart, @numericPart, @logicalDB, @objectKey, @mgiTypeKey, @private, @preferred)
36> 
37> if @refsKey != -1
38> begin
39> 	exec ACCRef_insert @nextACC, @refsKey
40> end
41> 
1>  
2> grant execute on ACC_insert to progs
1>  
2> grant execute on ACC_insert to editors
1>  
2> drop procedure ACCRef_process
1>  
2> create procedure ACCRef_process
3>   @objectKey int,
4>   @refsKey int,
5>   @accID varchar(30),
6>   @logicalDB int,
7>   @mgiType varchar(80)
8> as
9>  
10> /* If the Object/Acc ID pair already exists, then use that _Accession_key */
11> /* and simply insert a new ACC_AccessionReference record (ACCRef_insert) */
12> /* Else, create a new ACC_Accession and ACC_AccessionReference record (ACC_insert) */
13> 
14> declare @accKey integer
15> select @accKey = a._Accession_key 
16> from ACC_Accession a, ACC_MGIType m
17> where accID = @accID
18> and a._Object_key = @objectKey
19> and a._MGIType_key = m._MGIType_key
20> and m.name = @mgiType
21> and a._LogicalDB_key = @logicalDB
22> 
23> if @accKey is not null
24> 	exec ACCRef_insert @accKey, @refsKey
25> else
26> 	exec ACC_insert @objectKey, @accID, @logicalDB, @mgiType, @refsKey
27> 
1>  
2> grant execute on ACCRef_process to progs
1>  
2> grant execute on ACCRef_process to editors
1>  
2> drop procedure ACC_delete_byAccKey
1> 
2> create procedure ACC_delete_byAccKey
3>   @accKey int,
4>   @refsKey int = -1
5> as
6> 
7> /* Delete ACC_Accession/ACC_AccessonReference records for a given _Accession_key */
8> 
9> if @refsKey = -1
10> begin
11> 	delete ACC_Accession where _Accession_key = @accKey
12> 	delete ACC_AccessionReference where _Accession_key = @accKey
13> end
14> else
15> begin
16> 
17> 	delete ACC_AccessionReference 
18> 	where _Accession_key = @accKey
19> 	and _Refs_key = @refsKey
20> end
21> 
1>  
2> grant execute on ACC_delete_byAccKey to progs
1>  
2> grant execute on ACC_delete_byAccKey to editors
1>  
2> drop procedure ACC_update
1>  
2> create procedure ACC_update
3>   @accKey int,
4>   @accID varchar(30),
5>   @origRefsKey int = -1,
6>   @refsKey int = -1
7> as
8>  
9> /* Update the Accession record for a given Accession key */
10> 
11> if @accID is null
12> begin
13> 	exec ACC_delete_byAccKey @accKey
14> end
15> else
16> begin
17> 	declare @prefixPart varchar(20)
18> 	declare @numericPart int
19> 	exec ACC_split @accID, @prefixPart out, @numericPart out
20> 						      
21> 	if (@prefixPart = "J:" or substring(@prefixPart,1,4) = "MGD-")
22> 	begin
23> 		if (select count(*) from ACC_Accession
24> 	    	    where numericPart = @numericPart and
25> 			  prefixPart = @prefixPart) >= 1
26> 		begin
27> 			rollback transaction
28> 			raiserror 99999 "Duplicate MGI Accession Number"
29> 			return
30> 		end
31> 	end
32> 
33> 	update ACC_Accession
34>   	set accID = @accID, 
35>       	prefixPart = @prefixPart, 
36>       	numericPart = @numericPart,
37>       	modification_date = getdate()
38>   	where _Accession_key = @accKey
39> 
40> 	if @refsKey > 0
41> 	begin
42> 		update ACC_AccessionReference
43> 		set _Refs_key = @refsKey
44>   		where _Accession_key = @accKey and
45> 		      _Refs_key = @origRefsKey
46> 	end
47> end
48> 
1>  
2> grant execute on ACC_update to progs
1>  
2> grant execute on ACC_update to editors
1>  
2> drop procedure ACC_delete_byObject
1> 
2> create procedure ACC_delete_byObject
3>   @objectKey int,
4>   @mgiType varchar(80)
5> as
6> 
7> /* Delete all ACC_Accession/ACC_AccessionReference records for a given Object */
8> 
9> delete ACC_AccessionReference 
10> from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m
11> where a._Object_key = @objectKey
12> and a._MGIType_key = m._MGIType_key
13> and m.name = @mgiType
14> and a._Accession_key = ar._Accession_key
15> 
16> delete ACC_Accession 
17> from ACC_Accession a, ACC_MGIType m
18> where a._Object_key = @objectKey 
19> and a._MGIType_key = m._MGIType_key
20> and m.name = @mgiType
21> 
1>  
2> grant execute on ACC_delete_byObject to progs
1>  
2> grant execute on ACC_delete_byObject to editors
1>  
2> drop procedure ACC_delete_byAccRef
1> 
2> create procedure ACC_delete_byAccRef
3>   @objectKey int,
4>   @refsKey int,
5>   @mgiType varchar(80) = "Segment"
6> as
7> 
8> /* Delete all ACC_AccessonReference records for a given Object/Reference */
9> 
10> delete ACC_AccessionReference 
11> from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m
12> where a._Object_key = @objectKey
13> and a._MGIType_key = m._MGIType_key
14> and m.name = @mgiType
15> and a._Accession_key = ar._Accession_key
16> and ar._Refs_key = @refsKey
17>  
1>  
2> grant execute on ACC_delete_byAccRef to progs
1>  
2> grant execute on ACC_delete_byAccRef to editors
1>  
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> drop procedure MGI_Table_Column_Cleanup
1> 
2> CREATE PROCEDURE MGI_Table_Column_Cleanup
3> /*
4> JCG: Jan. 7, 1999
5> This procedure attempts to get MGI_Tables and MGI_Columns in sync with
6> sysobjects and syscolumns
7> */
8> 
9> as
10> 
11> /* Make sure that an old temp table with this name doesn't exists */
12> if exists (select name from sysobjects
13>            where name = '#temp_add_table'
14>            and type = 'U')
15>    drop table #temp_add_table
16> 
17> /*
18> NEW TABLE ADDED TO SCHEMA
19> */
20> /* Find tables in sysobjects which are not in MGI_Tables and insert them
21> into a temp table */
22> SELECT
23> MGI_Tables._Table_id, sysobjects.name
24> into #temp_add_table
25> FROM
26> MGI_Tables MGI_Tables, sysobjects sysobjects
27> WHERE
28> MGI_Tables._Table_id =* sysobjects.id
29> AND
30> sysobjects.type='U'
31> ORDER BY
32> sysobjects.name
33> 
34> /* From the temp table, select only those values where the table name is not
35> found in MGI_Tables. */
36> insert into MGI_Tables
37> SELECT object_id(name), NULL, getDate(), getDate()
38> FROM
39> #temp_add_table
40> WHERE
41> _Table_id is NULL
42> 
43> /* Also, find the appropriate columns and put into MGI_Columns so
44> that MGI_Tables and MGI_Columns are in sync */
45> insert into MGI_Columns
46> SELECT object_id(t.name), colid, NULL, NULL, getDate(), getDate()
47> FROM
48> #temp_add_table t, syscolumns c
49> WHERE
50> _Table_id is NULL
51> AND
52> object_id(t.name) = id
53> 
54> if exists (select name from sysobjects
55>            where name = '#temp_add_table'
56>            and type = 'U')
57>    drop table #temp_add_table
58> 
59> /*
60> WHAT IF YOU BCP IN A TRUNCATED COLUMN LIST?
61> THIS SECTION ADDS COLUMN DEFINITIONS FOR TABLES THAT ARE IN MGI_TABLES
62> BUT NOT MGI_COLUMNS - SYNCS COLUMNS WITH TABLES
63> */
64> 
65> if exists (select name from sysobjects
66>            where name = '#temp_update_table'
67>            and type = 'U')
68>    drop table #temp_update_table
69> 
70> SELECT
71> MGI_Columns._Table_id, syscolumns.id, syscolumns.colid
72> into #temp_update_table
73> FROM
74> MGI_Columns MGI_Columns,
75> syscolumns syscolumns,
76> sysobjects sysobjects
77> WHERE
78> syscolumns.id *= MGI_Columns._Table_id
79> and
80> syscolumns.id = sysobjects.id
81> and
82> sysobjects.type = 'U'
83> 
84> insert into MGI_Columns
85> SELECT
86> id, colid, NULL, NULL, getDate(), getDate()
87> FROM
88> #temp_update_table
89> WHERE
90> _Table_id is NULL
91> 
92> if exists (select name from sysobjects
93>            where name = '#temp_update_table'
94>            and type = 'U')
95>    drop table #temp_update_table
96> 
97> /*
98> THIS SECTION DELETES TABLES DEFINITION WHEN A TABLE IS DELETED
99> */
100> 
101> /*Algorithm:
102> 
103> If table not found in sysobjects, delete from MGI_Tables and
104> remove all column entries. Do a join to find _Table_id with no id
105> */
106> 
107> DELETE from MGI_Tables
108> where _Table_id in
109> (select DISTINCT _Table_id
110> from
111> MGI_Tables t, sysobjects o
112> WHERE
113> _Table_id NOT in (select id from sysobjects where type = 'U'))
114> 
115> if exists (select name from sysobjects
116>            where name = '#temp_delete_table'
117>            and type = 'U')
118>    drop table #temp_delete_table
119> 
120> 
121> SELECT DISTINCT _Table_id, id
122> into #temp_delete_table
123> FROM
124> MGI_Columns, sysobjects
125> WHERE
126> _Table_id *= id
127> 
128> /* If there is an id in MGI_Columns which is not in syscolumns then delete its entri
129> es */
130> delete from MGI_Columns
131> WHERE
132> _Table_id in (select _Table_id from #temp_delete_table where id is NULL)
133> 
134> if exists (select name from sysobjects
135>            where name = '#temp_delete_table'
136>            and type = 'U')
137>    drop table #temp_delete_table
138> 
139> RETURN
1> 
2> grant execute on MGI_Table_Column_Cleanup to public
1> 
2> drop procedure GEN_rowcount
1>  
2> create procedure GEN_rowcount
3>   @table varchar(30)
4> as
5> 
6> select convert(char(10),rowcnt(MAX(doampg)))
7> from sysobjects o, sysindexes i
8> where o.name = @table
9> and o.id = i.id
1> 
2> grant execute on GEN_rowcount to public
1> 
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> drop procedure NOMEN_verifyMarker
1> 
2> create procedure NOMEN_verifyMarker
3>   @symbol varchar(25)
4> as
5> 
6> /* Verify if marker symbol exists in Nomen or MGD master Marker list */
7> 
8> declare @status varchar(255)
9> 
10> if (select count(*) 
11>     from mgd..MRK_Marker m, mgd..MRK_Species s
12>     where m.symbol = @symbol
13>     and m._Species_key = s._Species_key
14>     and s.name = "mouse, laboratory") > 0
15> begin
16> 	select @status = "Symbol '" + @symbol + "' exists in MGD\n"
17> end
18> 
19> if (select count(*) from MRK_Nomen where proposedSymbol = @symbol) > 0
20> begin
21> 	select @status = @status + "Symbol '" + @symbol + "' exists in Nomen as a Proposed Symbol\n"
22> end
23> 
24> if (select count(*) from MRK_Nomen where approvedSymbol = @symbol) > 0
25> begin
26> 	select @status = @status + "Symbol '" + @symbol + "' exists in Nomen as an Approved Symbol\n"
27> end
28> 
29> if @status is not null
30> begin
31> 	raiserror 99999 @status
32> end
33> 
1> 
2> grant execute on NOMEN_verifyMarker to public
1> 
2> drop procedure NOMEN_updateBroadcastStatus
1> 
2> create procedure NOMEN_updateBroadcastStatus
3>   @nomenKey integer,
4>   @broadcastDate datetime
5> as
6> 
7> /* Update the Status to 'Broadcast' and the broadcast date for given Marker */
8> 
9> declare @bkey integer
10> select @bKey = _Marker_Status_key from MRK_Status where status = 'Broadcast'
11> 
12> update MRK_Nomen
13> set _Marker_Status_key = @bkey, broadcast_date = @broadcastDate
14> where _Nomen_key = @nomenKey
15> 
1> 
2> grant execute on NOMEN_updateBroadcastStatus to ljm, djr, mgm
1> 
2> grant execute on NOMEN_updateBroadcastStatus to progs
1> 
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> drop trigger ACC_Accession_Insert
1> 
2> create trigger ACC_Accession_Insert
3> on ACC_Accession
4> for insert
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   declare @accID varchar(30)
10>   select @accID = accID from inserted
11> 
12>   /* If inserting the Sequence ID for a Marker */
13>   /* and the same ID exists for another Marker...*/
14> 
15>   if (select _LogicalDB_key from inserted) in (9) and
16>       (select _MGIType_key from inserted) = 1 and
17>       exists (select a._Accession_key
18>               from ACC_Accession a, inserted i
19>               where i.accID = a.accID and
20> 		    i._Object_key != a._Object_key and
21> 	            a._MGIType_key = 1)
22>   begin
23> 	print "The Accession ID '%1!' is associated with another Symbol.", @accID
24>   end
25> 
26> end
27> 
1> 
2> drop trigger ACC_Accession_Update
1> 
2> create trigger ACC_Accession_Update
3> on ACC_Accession
4> for update
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   declare @accID varchar(30)
10>   select @accID = accID from inserted
11> 
12>   /* If updating the Sequence ID for a Marker */
13>   /* and the same ID exists for another Marker...*/
14> 
15>   if (select _LogicalDB_key from inserted) in (9) and
16>       (select _MGIType_key from inserted) = 1 and
17>       exists (select a._Accession_key
18>               from ACC_Accession a, inserted i
19>               where i.accID = a.accID and
20> 		    i._Object_key != a._Object_key and
21> 	            a._MGIType_key = 1)
22>   begin
23> 	print "The Accession ID '%1!' is associated with another Symbol.", @accID
24>   end
25> end
26> 
1> 
2> drop trigger ACC_AccessionReference_Delete
1> 
2> create trigger ACC_AccessionReference_Delete
3> on ACC_AccessionReference
4> for delete
5> as
6> 
7> /* If AccID is not referenced by other References in ACC_AccessionReference,
8>    then delete AccID from ACC_Accesion table too.
9> */
10>  
11> if (select count(*) from ACC_AccessionReference a, deleted d
12>     where a._Accession_key = d._Accession_key) = 0
13> begin
14> 	delete ACC_Accession 
15> 	from ACC_Accession a, deleted d
16> 	where a._Accession_key = d._Accession_key
17> end
18> 
1> 
2> checkpoint
Password: 
1> 
2> use nomen
1> 
2> checkpoint
1> 
2> drop trigger MRK_Nomen_Update
1> 
2> create trigger MRK_Nomen_Update
3> on MRK_Nomen
4> for update
5> as
6> 
7> if @@rowcount > 1
8> begin
9> 	return
10> end
11> 
12> declare @bKey integer
13> declare @dKey integer
14> select @bKey = _Marker_Status_key from MRK_Status where status = 'Broadcast'
15> select @dKey = _Marker_Status_key from MRK_Status where status = 'Deleted'
16> 
17> /* Set Broadcast Date to NULL automatically, if user changes Status from Broadcast */
18> 
19> if (select _Marker_Status_key from deleted) = @bKey and
20>    (select _Marker_Status_key from inserted) != @bKey and
21>    (select broadcast_date from inserted) != null
22> begin
23> 	update MRK_Nomen
24> 	set broadcast_date = NULL
25> 	from MRK_Nomen n, inserted i
26> 	where n._Nomen_key = i._Nomen_key
27> end
28> 
29> /* If Broadcast date is entered and Status is not Broadcast or Deleted, */
30> /* then update Status to Broadcast */
31> 
32> else if (select broadcast_date from inserted) != null and
33>         (select _Marker_Status_key from inserted) != @bKey and
34>         (select _Marker_Status_key from inserted) != @dKey
35> begin
36> 	update MRK_Nomen
37> 	set _Marker_Status_key = @bKey
38> 	from MRK_Nomen n, inserted i
39> 	where n._Nomen_key = i._Nomen_key
40> end
41> 
42> /* If Broadcast date is removed and Status is still Broadcast, deny update */
43> 
44> else if (select broadcast_date from inserted) = null and
45>         (select _Marker_Status_key from inserted) = @bKey
46> begin
47> 	rollback transaction
48> 	raiserror 99999 "Cannot remove Broadcast Date if status is Broadcast."
49> 	return
50> end
51> 
1> 
2> drop trigger MRK_Nomen_Delete
1> 
2> create trigger MRK_Nomen_Delete
3> on MRK_Nomen
4> for delete
5> as
6> 
7> delete MRK_Nomen_GeneFamily from MRK_Nomen_GeneFamily, deleted
8> where MRK_Nomen_GeneFamily._Nomen_key = deleted._Nomen_key
9>  
10> delete MRK_Nomen_Notes from MRK_Nomen_Notes, deleted
11> where MRK_Nomen_Notes._Nomen_key = deleted._Nomen_key
12>  
13> delete MRK_Nomen_Other from MRK_Nomen_Other, deleted
14> where MRK_Nomen_Other._Nomen_key = deleted._Nomen_key
15>  
16> delete MRK_Nomen_Reference from MRK_Nomen_Reference, deleted
17> where MRK_Nomen_Reference._Nomen_key = deleted._Nomen_key
18>  
1> 
2> drop trigger MRK_Nomen_Reference_Insert
1> 
2> create trigger MRK_Nomen_Reference_Insert
3> on MRK_Nomen_Reference
4> for insert, update
5> as
6> 
7> if @@rowcount > 1
8> begin
9> 	return
10> end
11> 
12> /* Whenever a Reference is added to Nomen, make sure the Nomen database */
13> /* is selected in the BIB_Refs table */
14> 
15> declare @dbs varchar(60)
16> 
17> select @dbs = b.dbs
18> from mgd..BIB_Refs b, inserted i
19> where i._Refs_key = b._Refs_key
20> 
21> if (charindex("Nomen", @dbs) = 0)
22> begin
23> 	if substring(@dbs, char_length(@dbs), char_length(@dbs)) = "/"
24> 	begin
25> 		select @dbs = @dbs + "Nomen/"
26> 	end
27> 	else
28> 	begin
29> 		select @dbs = @dbs + "/Nomen/"
30> 	end
31> 	update mgd..BIB_Refs
32> 	set b.dbs = @dbs
33> 	from mgd..BIB_Refs b, inserted i
34> 	where b._Refs_key = i._Refs_key
35> end
36> 
1> 
2> checkpoint
TR 204...
TR 375 load...
Invalid Marker  Nos3
Invalid Reference J:51523
Invalid Marker Ppp1r2-pending
Invalid Marker Tie
Invalid Marker Spock
Invalid Marker Ifga7
Invalid Marker Ftsf1
Invalid Marker Ddrt1
MLC conversion...
-------------------- Saved: 50 of 5144 in MLC_Text --------------------
3 7 10 11 14 15 16 17 18 20 21 22 23 24 25 26 27 29 30 31 32 33 35 36 41 43 47 48 51 52 53 54 55 60 61 62 63 64 67 68 69 70 71 73 78 79 81 82 83 85
-----------------------------------------------------------------------

-------------------- Saved: 100 of 5144 in MLC_Text --------------------
86 88 90 91 92 93 96 97 99 102 103 104 105 107 111 121 122 123 124 125 126 127 128 129 130 131 141 142 143 147 148 149 152 153 154 160 161 162 163 165 166 171 173 174 177 178 179 181 182 188
------------------------------------------------------------------------

-------------------- Saved: 150 of 5144 in MLC_Text --------------------
189 190 191 192 193 196 197 198 202 203 204 205 236 237 239 240 245 246 253 254 255 256 257 258 267 271 272 274 276 279 280 283 288 291 292 293 295 296 298 299 300 301 302 303 304 305 306 312 316 317
------------------------------------------------------------------------

-------------------- Saved: 200 of 5144 in MLC_Text --------------------
318 321 324 328 329 330 332 334 335 336 337 339 340 343 344 345 346 348 352 353 356 357 358 361 362 364 368 369 370 371 373 374 375 376 377 378 379 381 382 383 386 387 388 395 396 397 405 406 407 408
------------------------------------------------------------------------

-------------------- Saved: 250 of 5144 in MLC_Text --------------------
409 410 413 414 419 420 421 422 427 428 429 433 434 435 440 441 442 443 445 447 448 452 453 454 459 460 461 462 463 465 466 467 468 469 470 478 481 482 485 486 487 488 489 490 491 492 494 495 514 518
------------------------------------------------------------------------

-------------------- Saved: 300 of 5144 in MLC_Text --------------------
523 524 529 530 531 533 534 535 536 537 539 542 544 545 549 550 551 552 554 555 556 557 561 562 576 579 580 584 589 590 592 594 595 596 597 604 605 606 607 609 610 619 620 621 623 636 651 652 653 654
------------------------------------------------------------------------

-------------------- Saved: 350 of 5144 in MLC_Text --------------------
655 656 657 658 659 660 661 662 674 676 677 678 679 680 681 683 685 686 687 688 689 690 696 699 700 701 702 703 704 705 711 712 713 714 715 716 717 718 719 721 723 725 727 730 734 735 737 742 743 744
------------------------------------------------------------------------

-------------------- Saved: 400 of 5144 in MLC_Text --------------------
745 746 747 748 750 752 765 766 767 769 773 774 776 777 778 779 782 786 789 790 791 792 794 795 796 797 798 807 813 814 815 816 817 818 819 820 821 822 823 824 825 826 828 829 830 831 832 834 836 840
------------------------------------------------------------------------

-------------------- Saved: 450 of 5144 in MLC_Text --------------------
841 842 843 848 853 855 856 857 860 861 866 868 869 870 871 872 873 874 875 876 877 880 881 882 883 884 885 886 887 888 889 896 897 899 902 903 918 920 921 943 947 960 961 963 964 966 967 970 971 972
------------------------------------------------------------------------

-------------------- Saved: 500 of 5144 in MLC_Text --------------------
973 981 984 985 986 987 988 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1012 1013 1022 1023 1024 1025 1026 1027 1029 1031 1032 1034 1035 1041 1044 1046 1047 1048 1049 1050 1055 1056 1057 1058 1059 1060 1061 1066 1068 1071
------------------------------------------------------------------------

-------------------- Saved: 550 of 5144 in MLC_Text --------------------
1072 1073 1074 1075 1079 1080 1081 1082 1084 1085 1088 1089 1092 1093 1100 1101 1102 1103 1105 1106 1107 1108 1114 1117 1118 1122 1124 1128 1131 1132 1139 1141 1143 1144 1145 1146 1147 1154 1156 1157 1158 1161 1162 1165 1166 1167 1170 1171 1180 1181
------------------------------------------------------------------------

-------------------- Saved: 600 of 5144 in MLC_Text --------------------
1182 1183 1184 1185 1186 1187 1188 1198 1202 1203 1204 1205 1206 1207 1208 1210 1211 1215 1220 1235 1236 1244 1246 1247 1248 1249 1250 1251 1252 1253 1254 1256 1257 1260 1261 1264 1265 1266 1267 1293 1295 1299 1300 1304 1305 1306 1307 1308 1311 1312
------------------------------------------------------------------------

-------------------- Saved: 650 of 5144 in MLC_Text --------------------
1314 1315 1317 1318 1320 1321 1322 1325 1326 1327 1328 1329 1331 1333 1335 1336 1338 1339 1341 7798 7799 7803 7808 7809 7810 7811 7814 7815 7816 7820 7823 7824 7826 7828 7829 7830 7833 7837 7838 7842 7848 7849 7850 7851 7854 7858 7861 7864 7865 7870
------------------------------------------------------------------------

-------------------- Saved: 700 of 5144 in MLC_Text --------------------
7871 7872 7873 7874 7875 7876 7877 7878 7882 7886 7887 7889 7891 7896 7898 7899 7900 7906 7907 7908 7909 7910 7912 7914 7915 7917 7918 7921 7922 7923 7924 7925 7926 7927 7930 8272 8287 8288 8289 8290 8291 8292 8293 8294 8295 8296 8297 8298 8301 8303
------------------------------------------------------------------------

-------------------- Saved: 750 of 5144 in MLC_Text --------------------
8304 8305 8306 8307 8308 8309 8316 8317 8326 8330 8331 8332 8333 8337 8338 8339 8341 8344 8345 8348 8350 8359 8360 8364 8365 8368 8372 8373 8374 8376 8379 8442 8443 8444 8445 8446 8447 8448 8449 8450 8451 8452 8453 8454 8455 8456 8457 8458 8459 8460
------------------------------------------------------------------------

-------------------- Saved: 800 of 5144 in MLC_Text --------------------
8461 8462 8463 8464 8465 8466 8473 8484 8495 8499 8500 8501 8506 8507 8510 8511 8512 8517 8562 8563 8565 8566 8568 8569 8570 8572 8573 8576 8577 8578 8579 8584 8585 8589 8590 8591 8592 8598 8632 8633 8634 8635 8636 8637 8638 8639 8640 8641 8642 8643
------------------------------------------------------------------------

-------------------- Saved: 850 of 5144 in MLC_Text --------------------
8645 8646 8649 8650 8651 8652 8653 8654 8655 8656 8657 8658 8659 8660 8661 8663 8664 8671 8673 8676 8677 8681 8682 8683 8684 8687 8688 8689 8691 8693 8694 8697 8698 8701 8702 8703 8704 8706 8707 8712 8715 8716 8717 8719 8720 8721 8722 8725 8726 8727
------------------------------------------------------------------------

-------------------- Saved: 900 of 5144 in MLC_Text --------------------
8728 8729 8732 8733 8734 8739 8740 8741 8742 8743 8746 8753 8756 8757 8758 8759 8760 8761 8762 8763 8764 8765 8766 8770 8778 8779 8780 8781 8782 8783 8784 8793 8794 8795 8796 8798 8799 8802 8803 8806 8807 8808 8812 8813 8815 8816 8818 8819 8823 8824
------------------------------------------------------------------------

-------------------- Saved: 950 of 5144 in MLC_Text --------------------
8826 8827 8828 8830 8832 8833 8834 8835 8837 8848 8849 8851 8852 8853 8856 8858 8860 8865 8868 8869 8874 8875 8876 8877 8878 8879 8883 8884 8885 8886 8887 8888 8889 8890 8891 8893 8894 8895 8896 8902 8903 8906 8915 8916 8917 8918 8919 8920 8921 8923
------------------------------------------------------------------------

-------------------- Saved: 1000 of 5144 in MLC_Text --------------------
8924 8925 8927 8928 8931 8932 8941 8942 8943 8944 8945 8946 8950 8951 8952 8953 8956 8957 8958 8959 8961 8962 8963 8964 8971 8972 8973 8974 8976 8978 8980 8981 8982 8983 8984 8985 8986 8987 8988 8989 8990 8991 8992 8993 8995 8998 9006 9007 9008 9009
-------------------------------------------------------------------------

-------------------- Saved: 1050 of 5144 in MLC_Text --------------------
9010 9011 9016 9017 9018 9019 9021 9023 9028 9032 9033 9034 9035 9037 9038 9041 9042 9045 9046 9050 9053 9055 9056 9059 9061 9064 9065 9067 9069 9072 9073 9076 9080 9081 9082 9083 9084 9087 9088 9091 9092 9099 9100 9101 9102 9103 9104 9110 9111 9112
-------------------------------------------------------------------------

-------------------- Saved: 1100 of 5144 in MLC_Text --------------------
9113 9114 9115 9116 9119 9120 9121 9122 9123 9124 9125 9126 9127 9128 9129 9131 9132 9133 9138 9144 9145 9146 9147 9148 9149 9150 9152 9179 9181 9182 9184 9185 9187 9188 9189 9190 9191 9192 9193 9197 9198 9199 9200 9201 9202 9203 9206 9207 9208 9214
-------------------------------------------------------------------------

-------------------- Saved: 1150 of 5144 in MLC_Text --------------------
9215 9216 9217 9218 9219 9220 9221 9222 9223 9229 9230 9231 9240 9245 9246 9247 9248 9251 9253 9255 9256 9260 9261 9262 9263 9264 9265 9266 9267 9268 9269 9270 9271 9272 9273 9274 9275 9277 9278 9279 9280 9281 9282 9283 9286 9287 9288 9289 9290 9292
-------------------------------------------------------------------------

-------------------- Saved: 1200 of 5144 in MLC_Text --------------------
9293 9294 9295 9297 9303 9304 9305 9307 9311 9312 9313 9316 9326 9327 9337 9339 9342 9344 9347 9348 9349 9350 9351 9354 9355 9491 9492 9493 9494 9495 9496 9497 9498 9499 9500 9501 9503 9504 9510 9511 9512 9521 9525 9538 9539 9540 9542 9543 9544 9545
-------------------------------------------------------------------------

-------------------- Saved: 1250 of 5144 in MLC_Text --------------------
9546 9547 9548 9560 9577 9578 9579 9580 9581 9582 9583 9584 9585 9586 9587 9588 9589 9590 9591 9592 9593 9594 9595 9596 9597 9598 9599 9600 9601 9602 9603 9604 9607 9608 9609 9610 9611 9612 9614 9615 9616 9617 9618 9619 9625 9632 9633 9636 9637 9640
-------------------------------------------------------------------------

-------------------- Saved: 1300 of 5144 in MLC_Text --------------------
9641 9643 9644 9645 9646 9647 9648 9649 9650 9651 9652 9653 9654 9658 9659 9660 9661 9662 9663 9664 9665 9666 9667 9668 9669 9670 9671 9672 9673 9674 9675 9676 9677 9678 9679 9680 9685 9686 9688 9689 9690 9691 9692 9696 9697 9698 9699 9700 9701 9704
-------------------------------------------------------------------------

-------------------- Saved: 1350 of 5144 in MLC_Text --------------------
9705 9706 9708 9709 9711 9712 9714 9715 9716 9718 9722 9723 9724 9727 9728 9729 9730 9731 9732 9733 9739 9743 9745 9748 9750 9751 9753 9754 9755 9756 9757 9758 9759 9761 9762 9764 9765 9766 9767 9768 9769 9770 9771 9772 9773 9774 9775 9776 9777 9778
-------------------------------------------------------------------------

-------------------- Saved: 1400 of 5144 in MLC_Text --------------------
9779 9780 9781 9782 9783 9784 9785 9786 9787 9788 9789 9790 9791 9792 9793 9794 9795 9796 9797 9798 9799 9800 9801 9802 9803 9804 9805 9806 9807 9809 9810 9811 9812 9814 9822 9826 9827 9885 9886 9887 9888 9889 9890 9891 9892 9893 9894 9895 9897 9898
-------------------------------------------------------------------------

-------------------- Saved: 1450 of 5144 in MLC_Text --------------------
9899 9900 9901 9902 9903 9904 9905 9907 9908 9909 9910 9911 9912 9913 9914 9915 9916 9917 9918 9919 9920 9922 9923 9924 9925 9926 9927 9928 9932 9933 9934 9936 9937 9938 9939 9940 9942 9943 9945 9946 9947 9950 9951 9953 9955 9956 9960 9961 9962 9963
-------------------------------------------------------------------------

-------------------- Saved: 1500 of 5144 in MLC_Text --------------------
9965 9966 9967 9968 9969 9971 9973 9974 9977 9978 9979 9980 9983 9984 9985 9986 9987 9989 9990 9995 9997 9998 9999 10000 10003 10009 10010 10011 10013 10014 10017 10018 10019 10020 10022 10023 10025 10026 10028 10029 10032 10033 10034 10035 10037 10041 10042 10043 10044 10047
-------------------------------------------------------------------------

-------------------- Saved: 1550 of 5144 in MLC_Text --------------------
10050 10051 10068 10074 10075 10079 10080 10081 10082 10083 10086 10092 10094 10095 10099 10100 10101 10102 10103 10104 10105 10106 10107 10108 10109 10110 10112 10115 10116 10117 10118 10119 10120 10121 10122 10123 10124 10125 10126 10127 10128 10129 10130 10131 10132 10133 10134 10135 10139 10141
-------------------------------------------------------------------------

-------------------- Saved: 1600 of 5144 in MLC_Text --------------------
10144 10145 10146 10147 10148 10149 10158 10159 10162 10163 10164 10165 10167 10168 10169 10170 10181 10182 10185 10186 10187 10188 10189 10190 10191 10192 10193 10197 10198 10199 10200 10201 10202 10203 10209 10210 10211 10212 10231 10232 10233 10234 10235 10236 10238 10239 10242 10243 10244 10245
-------------------------------------------------------------------------

-------------------- Saved: 1650 of 5144 in MLC_Text --------------------
10247 10248 10249 10250 10251 10252 10253 10254 10255 10256 10257 10258 10259 10260 10261 10267 10289 10305 10306 10307 10309 10311 10314 10321 10324 10328 10346 10349 10351 10353 10356 10357 10358 10375 10377 10378 10379 10380 10381 10385 10386 10387 10388 10390 10391 10392 10393 10395 10399 10401
-------------------------------------------------------------------------

-------------------- Saved: 1700 of 5144 in MLC_Text --------------------
10403 10405 10407 10408 10409 10411 10412 10414 10417 10420 10421 10422 10427 10428 10430 10431 10442 10443 10445 10460 10461 10470 10471 10472 10473 10474 10475 10480 10481 10491 10492 10493 10494 10495 10496 10497 10498 10499 10500 10501 10502 10503 10504 10505 10506 10507 10508 10509 10510 10511
-------------------------------------------------------------------------

-------------------- Saved: 1750 of 5144 in MLC_Text --------------------
10515 10516 10517 10519 10520 10523 10524 10527 10528 10529 10531 10532 10533 10534 10535 10537 10539 10540 10541 10544 10547 10548 10549 10550 10552 10553 10554 10557 10558 10559 10560 10567 10573 10574 10575 10576 10577 10578 10579 10580 10581 10582 10583 10584 10585 10586 10587 10588 10589 10590
-------------------------------------------------------------------------

-------------------- Saved: 1800 of 5144 in MLC_Text --------------------
10591 10592 10598 10600 10602 10603 10609 10615 10616 10618 10619 10621 10655 10657 10659 10660 10661 10662 10663 10664 10669 10672 10673 10674 10676 10679 10680 10682 10683 10711 10712 10715 10716 10722 10737 10745 10746 10747 10748 10753 10754 10759 10762 10767 10768 10769 10770 10775 10776 10777
-------------------------------------------------------------------------

-------------------- Saved: 1850 of 5144 in MLC_Text --------------------
10785 10786 10787 10788 10789 10790 10791 10794 10795 10796 10797 10800 10803 10804 10808 10809 10810 10813 10814 10815 10816 10817 10819 10820 10821 10822 10823 10824 10825 10827 10831 10834 10835 10836 10837 10849 10850 10851 10856 10868 10871 10873 10874 10875 10876 10877 10878 10879 10880 10883
-------------------------------------------------------------------------

-------------------- Saved: 1900 of 5144 in MLC_Text --------------------
10884 10887 10888 10892 10893 10894 10901 10903 10904 10906 10907 10910 10912 10914 10915 10919 10920 10921 10924 10930 10931 10932 10933 10934 10941 10942 10944 10946 10947 10948 10952 10963 11034 11035 11036 11037 11038 11039 11040 11041 11042 11044 11045 11046 11047 11048 11049 11050 11051 11058
-------------------------------------------------------------------------

-------------------- Saved: 1950 of 5144 in MLC_Text --------------------
11059 11062 11066 11067 11068 11078 11079 11080 11081 11082 11085 11088 11089 11097 11098 11099 11101 11102 11103 11104 11105 11106 11108 11109 11110 11112 11117 11118 11119 11120 11122 11123 11125 11128 11129 11132 11135 11136 11137 11138 11139 11143 11146 11147 11148 11149 11152 11153 11154 11157
-------------------------------------------------------------------------

-------------------- Saved: 2000 of 5144 in MLC_Text --------------------
11158 11168 11169 11170 11171 11172 11173 11174 11175 11176 11177 11178 11179 11183 11184 11188 11189 11190 11192 11196 11199 11202 11205 11207 11208 11209 11214 11215 11217 11218 11219 11220 11224 11225 11235 11236 11237 11238 11239 11242 11247 11248 11249 11251 11252 11253 11254 11255 11256 11257
-------------------------------------------------------------------------

-------------------- Saved: 2050 of 5144 in MLC_Text --------------------
11258 11264 11270 11272 11279 11280 11281 11282 11284 11289 11290 11292 11293 11294 11295 11296 11297 11298 11299 11326 11327 11328 11329 11330 11331 11332 11333 11334 11335 11336 11337 11338 11339 11340 11344 11345 11346 11347 11348 11349 11350 11351 11352 11353 11355 11363 11364 11366 11367 11370
-------------------------------------------------------------------------

-------------------- Saved: 2100 of 5144 in MLC_Text --------------------
11373 11375 11394 11395 11396 11397 11399 11400 11401 11402 11403 11404 11405 11406 11407 11408 11409 11410 11411 11417 11422 11424 11426 11488 11489 11490 11491 11492 11493 11494 11495 11496 11497 11498 11499 11500 11501 11502 11503 11504 11505 11506 11507 11508 11509 11510 11511 11512 11513 11514
-------------------------------------------------------------------------

-------------------- Saved: 2150 of 5144 in MLC_Text --------------------
11515 11516 11517 11518 11521 11522 11523 11524 11525 11526 11532 11543 11545 11546 11547 11548 11550 11552 11553 11554 11555 11562 11563 11564 11565 11566 11567 11568 11569 11570 11571 11572 11573 11574 11576 11582 11584 11585 11589 11590 11591 11595 11596 11597 11603 11604 11605 11607 11608 11609
-------------------------------------------------------------------------

-------------------- Saved: 2200 of 5144 in MLC_Text --------------------
11673 11674 11675 11676 11677 11678 11679 11680 11681 11682 11683 11684 11685 11686 11687 11688 11689 11690 11691 11692 11693 11694 11695 11696 11697 11698 11699 11700 11701 11702 11703 11704 11705 11706 11707 11708 11709 11712 11715 11716 11717 11718 11720 11721 11723 11731 11736 11738 11741 11742
-------------------------------------------------------------------------

-------------------- Saved: 2250 of 5144 in MLC_Text --------------------
11743 11747 11748 11749 11750 11752 11753 11754 11755 11756 11757 11758 11762 11763 11769 11770 11771 11783 11784 11785 11786 11787 11788 11789 11790 11791 11793 11794 11795 11796 11799 11805 11811 11812 11813 11814 11815 11816 11817 11818 11819 11820 11825 11826 11829 11830 11832 11833 11834 11835
-------------------------------------------------------------------------

-------------------- Saved: 2300 of 5144 in MLC_Text --------------------
11837 11839 11841 11842 11844 11845 11846 11847 11848 11850 11851 11853 11854 11855 11856 11858 11859 11860 11861 11863 11880 11881 11882 11883 11884 11885 11886 11887 11888 11889 11890 11891 11892 11893 11894 11895 11900 11901 11905 11906 11911 11912 11913 11914 11915 11923 11924 11927 11928 11929
-------------------------------------------------------------------------

-------------------- Saved: 2350 of 5144 in MLC_Text --------------------
11934 11935 11937 11938 11942 11943 11944 11945 11947 11949 11950 11952 11954 11955 11956 11962 11963 11964 11965 11966 11967 11971 11972 11974 11979 11985 11986 11989 11990 11991 11993 11995 11996 11997 11998 12004 12020 12021 12022 12023 12024 12025 12026 12027 12031 12034 12035 12036 12037 12038
-------------------------------------------------------------------------

-------------------- Saved: 2400 of 5144 in MLC_Text --------------------
12039 12040 12042 12043 12044 12045 12053 12054 12055 12056 12057 12058 12060 12063 12064 12065 12066 12076 12077 12078 12079 12080 12084 12110 12111 12112 12114 12121 12123 12127 12128 12129 12130 12131 12132 12133 12134 12140 12141 12143 12144 12145 12147 12149 12150 12152 12158 12159 12160 12162
-------------------------------------------------------------------------

-------------------- Saved: 2450 of 5144 in MLC_Text --------------------
12166 12167 12168 12169 12179 12180 12181 12182 12183 12184 12185 12186 12187 12188 12190 12193 12197 12199 12201 12202 12204 12205 12206 12207 12211 12212 12213 12216 12217 12218 12219 12220 12221 12222 12223 12224 12225 12227 12228 12229 12233 12234 12235 12236 12237 12238 12239 12242 12243 12245
-------------------------------------------------------------------------

-------------------- Saved: 2500 of 5144 in MLC_Text --------------------
12246 12253 12255 12263 12264 12265 12266 12267 12269 12272 12273 12276 12277 12278 12281 12282 12283 12293 12294 12295 12296 12297 12298 12299 12300 12301 12305 12306 12307 12309 12313 12314 12315 12316 12317 12322 12323 12324 12325 12328 12329 12337 12338 12339 12340 12342 12343 12344 12349 12354
-------------------------------------------------------------------------

-------------------- Saved: 2550 of 5144 in MLC_Text --------------------
12355 12356 12357 12358 12359 12360 12361 12362 12364 12365 12368 12369 12371 12373 12374 12375 12378 12379 12382 12383 12384 12385 12386 12387 12388 12389 12390 12391 12392 12393 12394 12395 12396 12397 12398 12479 12480 12481 12482 12483 12484 12485 12486 12487 12488 12489 12490 12491 12492 12493
-------------------------------------------------------------------------

-------------------- Saved: 2600 of 5144 in MLC_Text --------------------
12494 12495 12496 12497 12498 12499 12500 12501 12502 12503 12504 12505 12506 12507 12508 12509 12510 12511 12512 12513 12514 12515 12516 12517 12518 12519 12520 12521 12522 12523 12524 12525 12526 12527 12528 12529 12530 12531 12532 12534 12536 12537 12538 12539 12540 12543 12545 12556 12558 12559
-------------------------------------------------------------------------

-------------------- Saved: 2650 of 5144 in MLC_Text --------------------
12561 12562 12571 12572 12573 12574 12590 12591 12592 12593 12594 12595 12596 12597 12598 12599 12600 12601 12602 12603 12605 12606 12609 12611 12612 12613 12616 12617 12618 12619 12620 12624 12631 12633 12635 12636 12637 12638 12639 12640 12641 12642 12645 12646 12648 12652 12655 12656 12659 12660
-------------------------------------------------------------------------

-------------------- Saved: 2700 of 5144 in MLC_Text --------------------
12667 12668 12669 12670 12672 12673 12676 12677 12678 12679 12682 12683 12685 12686 12687 12688 12689 12690 12691 12692 12693 12695 12696 12699 12700 12702 12703 12704 12705 12706 12707 12708 12709 12710 12711 12712 12713 12715 12717 12719 12720 12722 12723 12725 12727 12728 12729 12730 12731 12732
-------------------------------------------------------------------------

-------------------- Saved: 2750 of 5144 in MLC_Text --------------------
12734 12761 12762 12763 12766 12767 12768 12769 12771 12773 12774 12775 12776 12777 12780 12783 12784 12786 12789 12794 12795 12796 12797 12798 12799 12800 12801 12802 12803 12804 12805 12806 12807 12808 12809 12810 12811 12813 12820 12821 12822 12823 12830 12833 12841 12843 12847 12848 12851 12858
-------------------------------------------------------------------------

-------------------- Saved: 2800 of 5144 in MLC_Text --------------------
12859 12860 12866 12867 12871 12872 12874 12878 12883 12884 12885 12886 12889 12890 12891 12893 12894 12897 12898 12902 12903 12905 12910 12915 12918 12919 12920 12921 12922 12924 12927 12928 12932 12933 12934 12935 12940 12941 12942 12943 12944 12947 12948 12949 12950 12951 12952 12966 12967 12968
-------------------------------------------------------------------------

-------------------- Saved: 2850 of 5144 in MLC_Text --------------------
12969 12970 12973 12974 12975 12976 12977 12978 12980 12981 12982 12983 12984 12985 12987 12989 12990 12991 12992 12995 12996 12999 13000 13001 13004 13005 13010 13011 13012 13013 13014 13015 13022 13023 13024 13025 13026 13029 13034 13035 13037 13040 13041 13053 13054 13055 13056 13057 13058 13059
-------------------------------------------------------------------------

-------------------- Saved: 2900 of 5144 in MLC_Text --------------------
13061 13062 13063 13064 13065 13066 13067 13068 13069 13070 13071 13072 13073 13074 13075 13076 13077 13078 13079 13080 13081 13082 13083 13084 13085 13086 13087 13088 13089 13090 13091 13092 13093 13094 13095 13096 13097 13098 13099 13100 13103 13104 13105 13106 13107 13108 13109 13110 13111 13112
-------------------------------------------------------------------------

-------------------- Saved: 2950 of 5144 in MLC_Text --------------------
13113 13114 13115 13116 13117 13118 13119 13120 13121 13122 13123 13124 13125 13126 13127 13128 13129 13130 13131 13132 13133 13134 13135 13138 13139 13140 13141 13142 13143 13145 13147 13148 13149 13150 13151 13152 13153 13154 13155 13156 13157 13158 13159 13160 13161 13162 13163 13164 13166 13167
-------------------------------------------------------------------------

-------------------- Saved: 3000 of 5144 in MLC_Text --------------------
13168 13169 13170 13171 13172 13173 13174 13175 13176 13177 13178 13179 13180 13181 13182 13183 13184 13185 13186 13187 13188 13189 13190 13191 13192 13193 13194 13195 13196 13197 13198 13200 13201 13202 13204 13205 13206 13207 13208 13209 13210 13211 13212 13213 13214 13215 13216 13218 13219 13220
-------------------------------------------------------------------------

-------------------- Saved: 3050 of 5144 in MLC_Text --------------------
13221 13222 13223 13224 13225 13226 13227 13228 13229 13230 13231 13232 13233 13237 13239 13240 13241 13242 13243 13244 13245 13247 13248 13251 13274 13275 13278 13279 13281 13282 13283 13284 13288 13289 13290 13292 13293 13294 13295 13296 13299 13300 13301 13308 13309 13310 13311 13313 13314 13315
-------------------------------------------------------------------------

-------------------- Saved: 3100 of 5144 in MLC_Text --------------------
13316 13318 13324 13325 13326 13329 13331 13332 13334 13337 13338 13340 13341 13346 13347 13349 13350 13351 13352 13353 13354 13355 13356 13357 13358 13359 13361 13362 13363 13364 13365 13366 13367 13369 13371 13375 13376 13377 13378 13381 13382 13383 13384 13385 13387 13388 13390 13398 13400 13401
-------------------------------------------------------------------------

-------------------- Saved: 3150 of 5144 in MLC_Text --------------------
13402 13403 13416 13419 13420 13425 13430 13431 13432 13433 13435 13437 13438 13439 13440 13442 13452 13455 13458 13461 13462 13463 13467 13468 13471 13472 13473 13477 13478 13481 13482 13483 13487 13488 13489 13490 13491 13492 13494 13495 13496 13497 13498 13499 13500 13501 13502 13503 13505 13506
-------------------------------------------------------------------------

-------------------- Saved: 3200 of 5144 in MLC_Text --------------------
13507 13508 13509 13512 13513 13516 13517 13520 13521 13527 13528 13529 13530 13531 13532 13533 13534 13535 13536 13537 13538 13539 13540 13541 13545 13546 13550 13556 13557 13558 13559 13561 13565 13568 13569 13572 13573 13576 13577 13578 13581 13582 13583 13584 13586 13587 13590 13592 13611 13612
-------------------------------------------------------------------------

-------------------- Saved: 3250 of 5144 in MLC_Text --------------------
13613 13614 13615 13616 13617 13618 13619 13620 13621 13622 13623 13624 13625 13626 13627 13628 13629 13631 13632 13634 13638 13642 13645 13647 13648 13649 13650 13658 13663 13667 13669 13670 13671 13672 13683 13684 13685 13686 13687 13695 13696 13697 13698 13700 13702 13703 13706 13713 13715 13716
-------------------------------------------------------------------------

-------------------- Saved: 3300 of 5144 in MLC_Text --------------------
13717 13718 13720 13721 13722 13723 13727 13733 13735 13737 13739 13740 13741 13743 13746 13747 13750 13751 13753 13755 13758 13765 13766 13767 13785 13786 13790 13791 13793 13794 13795 13797 13798 13818 13838 13840 13858 13860 13861 13867 13877 13878 13879 13880 13902 13903 13904 13905 13906 13935
-------------------------------------------------------------------------

-------------------- Saved: 3350 of 5144 in MLC_Text --------------------
13936 13937 13938 13947 13948 13953 13954 13978 13979 13980 13995 13996 13997 13998 14000 14001 14002 14003 14007 14008 14013 14016 14017 14018 14021 14022 14023 14024 14025 14026 14027 14028 14029 14030 14031 14032 14033 14034 14035 14036 14037 14038 14039 14040 14041 14042 14043 14044 14045 14046
-------------------------------------------------------------------------

-------------------- Saved: 3400 of 5144 in MLC_Text --------------------
14047 14048 14049 14050 14051 14052 14053 14054 14055 14056 14057 14058 14059 14060 14061 14062 14067 14068 14070 14073 14075 14091 14094 14099 14100 14101 14102 14103 14104 14105 14106 14107 14110 14118 14119 14120 14121 14122 14123 14126 14130 14131 14134 14136 14138 14141 14142 14145 14146 14147
-------------------------------------------------------------------------

-------------------- Saved: 3450 of 5144 in MLC_Text --------------------
14148 14149 14150 14152 14154 14155 14156 14161 14162 14168 14169 14170 14171 14172 14175 14176 14178 14179 14180 14181 14182 14190 14191 14192 14196 14199 14200 14201 14202 14203 14204 14209 14211 14222 14223 14224 14225 14226 14227 14228 14229 14230 14231 14233 14238 14241 14242 14245 14251 14252
-------------------------------------------------------------------------

-------------------- Saved: 3500 of 5144 in MLC_Text --------------------
14256 14257 14258 14259 14267 14272 14279 14280 14283 14286 14287 14292 14293 14294 14295 14302 14303 14304 14306 14307 14310 14311 14313 14314 14315 14316 14317 14318 14319 14320 14321 14323 14325 14326 14328 14330 14331 14335 14337 14338 14343 14344 14345 14346 14347 14348 14351 14352 14353 14354
-------------------------------------------------------------------------

-------------------- Saved: 3550 of 5144 in MLC_Text --------------------
14355 14357 14358 14359 14363 14367 14368 14369 14371 14377 14379 14384 14385 14389 14390 14391 14395 14396 14398 14399 14400 14401 14403 14404 14406 14407 14408 14409 14410 14411 14413 14415 14417 14418 14419 14424 14425 14426 14427 14430 14432 14433 14444 14445 14446 14447 14450 14451 14458 14459
-------------------------------------------------------------------------

-------------------- Saved: 3600 of 5144 in MLC_Text --------------------
14460 14461 14462 14463 14464 14465 14466 14467 14468 14480 14481 14482 14483 14484 14485 14486 14487 14488 14489 14490 14491 14492 14494 14497 14498 14500 14501 14502 14506 14508 14509 14512 14513 14515 14516 14517 14518 14519 14599 14600 14601 14602 14603 14604 14605 14606 14607 14608 14609 14610
-------------------------------------------------------------------------

-------------------- Saved: 3650 of 5144 in MLC_Text --------------------
14611 14612 14613 14614 14615 14616 14617 14618 14619 14620 14621 14622 14623 14624 14625 14626 14627 14628 14629 14630 14632 14633 14634 14635 14636 14637 14638 14639 14640 14641 14642 14643 14644 14645 14646 14647 14648 14649 14650 14651 14652 14653 14654 14655 14656 14657 14658 14659 14660 14661
-------------------------------------------------------------------------

-------------------- Saved: 3700 of 5144 in MLC_Text --------------------
14663 14666 14667 14668 14749 14750 14751 14752 14753 14754 14755 14756 14757 14758 14759 14760 14761 14762 14763 14764 14765 14766 14767 14768 14769 14770 14771 14772 14773 14774 14775 14776 14777 14778 14779 14780 14781 14782 14783 14784 14785 14787 14788 14790 14791 14792 14793 14794 14795 14797
-------------------------------------------------------------------------

-------------------- Saved: 3750 of 5144 in MLC_Text --------------------
14798 14799 14800 14801 14804 14805 14806 14807 14808 14809 14815 14826 14828 14829 14861 14863 14865 14866 14869 14871 14872 14873 14874 14875 14876 14878 14883 14938 14939 14940 14941 14942 14943 14944 14945 14946 14947 14948 14949 14950 14951 14952 14953 14954 14955 14956 14957 14958 14959 14960
-------------------------------------------------------------------------

-------------------- Saved: 3800 of 5144 in MLC_Text --------------------
14961 14962 14963 14964 14965 14966 14967 14968 14969 14970 14971 14976 14980 14981 14982 14983 14984 14985 14986 14987 14988 14989 14990 14991 14992 14993 14994 14995 14998 14999 15002 15003 15005 15006 15007 15044 15047 15049 15051 15054 15197 15198 15199 15200 15216 15217 15218 15221 15222 15223
-------------------------------------------------------------------------

-------------------- Saved: 3850 of 5144 in MLC_Text --------------------
15231 15232 15233 15234 15235 15236 15237 15238 15260 15261 15262 15264 15267 15271 15272 15279 15281 15284 15292 15296 15311 15325 15326 15331 15332 15339 15342 15343 15347 15349 15350 15352 15356 15357 15363 15365 15370 15374 15376 15377 15378 15379 15380 15381 15382 15383 15387 15388 15389 15392
-------------------------------------------------------------------------

-------------------- Saved: 3900 of 5144 in MLC_Text --------------------
15393 15394 15404 15421 15422 15423 15424 15425 15426 15427 15428 15433 15434 15435 15436 15437 15438 15439 15444 15445 15446 15447 15448 15449 15450 15451 15455 15456 15457 15458 15459 15460 15461 15463 15464 15465 15486 15488 15489 15490 15491 15492 15499 15513 15514 15517 15518 15520 15530 15531
-------------------------------------------------------------------------

-------------------- Saved: 3950 of 5144 in MLC_Text --------------------
15607 15613 15659 15660 15667 15670 15671 15672 15676 15677 15685 15686 15687 15688 15689 15724 15727 15728 15729 15730 15731 15732 15733 15735 15736 15737 15738 15739 15740 15741 15742 15743 15744 15747 15750 15751 15754 15755 15756 15757 15759 15762 15794 15801 15809 17608 17611 17612 17615 17616
-------------------------------------------------------------------------

-------------------- Saved: 4000 of 5144 in MLC_Text --------------------
17620 17621 17624 17625 17626 17627 17628 17629 17634 17635 17636 17638 17640 17642 17643 17644 17645 17649 17650 17651 17652 17653 17654 17655 17656 17657 17661 17662 17663 17677 17679 17680 17691 17704 17706 17709 17710 17711 17713 17714 17734 17735 17736 17737 17745 17749 17751 17752 17753 17754
-------------------------------------------------------------------------

-------------------- Saved: 4050 of 5144 in MLC_Text --------------------
17755 17757 17758 17759 17760 17761 17762 17763 17764 17766 17767 17768 17769 17770 17771 17772 17773 17783 17784 17793 17797 17799 17802 17806 17807 17808 17809 17811 17813 17814 17816 17817 17828 18346 18347 18352 18353 18415 18416 18417 18424 18425 18426 18427 18428 18437 18448 18455 18476 18492
-------------------------------------------------------------------------

-------------------- Saved: 4100 of 5144 in MLC_Text --------------------
18493 18494 18498 18501 18510 18513 18583 18600 18612 18616 18617 18623 18624 18625 18627 18637 18642 18647 18648 18650 18651 18653 18656 18657 18658 18669 18670 18673 18703 18706 18707 18709 18714 18718 18719 18725 18735 18737 18748 18749 18766 18767 18768 18769 18770 18804 22742 22743 22744 22745
-------------------------------------------------------------------------

-------------------- Saved: 4150 of 5144 in MLC_Text --------------------
22748 22783 22785 22791 22792 22823 22829 22838 22839 22844 22856 22859 22860 22867 22868 22906 22907 22908 22909 22910 22911 22912 22916 22918 22924 22927 22945 22946 23012 23013 23014 23015 23016 23017 23023 23072 23097 23098 23099 23100 23102 23103 23106 23107 23108 23109 23122 23123 23125 23126
-------------------------------------------------------------------------

-------------------- Saved: 4200 of 5144 in MLC_Text --------------------
23132 23135 23136 23137 23142 23144 23145 23153 23156 23157 23164 23166 23176 23177 23178 23179 23180 23183 23200 23201 23212 23213 23214 23220 23236 23240 23265 23266 23270 23271 23274 23279 23280 23282 23283 23285 23293 23545 23546 23547 23555 23561 23567 23570 24277 24281 24288 24294 24295 24296
-------------------------------------------------------------------------

-------------------- Saved: 4250 of 5144 in MLC_Text --------------------
24297 24298 24299 24300 24306 24307 24332 24643 24664 24665 24666 24667 24668 24669 24670 24679 24687 24690 24701 24702 24718 24719 24722 24730 24731 24732 24740 24749 24750 24759 24760 24785 24786 24787 24801 24809 24810 24811 24812 24814 24827 24828 24837 24838 24849 24851 24862 24864 24870 24872
-------------------------------------------------------------------------

-------------------- Saved: 4300 of 5144 in MLC_Text --------------------
24873 24902 24904 24905 24906 24907 24908 24909 24910 24916 24923 24924 24925 24931 24932 24944 24949 24950 24951 24952 24953 24955 24961 24963 24968 24969 24975 24976 25000 25001 25002 25003 25004 25005 25006 25007 25008 25009 25010 25011 25012 25013 25014 25015 25016 25018 25019 25020 25021 25022
-------------------------------------------------------------------------

-------------------- Saved: 4350 of 5144 in MLC_Text --------------------
25023 25024 25025 25026 25027 25028 25029 25031 25033 25034 25035 25039 25040 25042 25043 25044 25045 25046 25047 25048 25049 25050 25051 25052 25053 25054 25055 25056 25059 25060 25061 25062 25064 25065 25067 25068 25070 25071 25072 25073 25074 25075 25077 25078 25079 25080 25081 25082 25083 25084
-------------------------------------------------------------------------

-------------------- Saved: 4400 of 5144 in MLC_Text --------------------
25085 25107 25108 25113 25114 25115 25116 25117 25135 25136 25137 25138 25140 25141 25147 25150 25151 25152 25155 25156 25157 25158 25159 25161 25162 25163 25198 25200 25201 25202 25203 25204 25205 25206 25207 25208 25216 25234 25245 25296 25297 25298 25299 25300 25303 25304 25305 25311 25314 25320
-------------------------------------------------------------------------

-------------------- Saved: 4450 of 5144 in MLC_Text --------------------
25321 25322 25328 25329 25398 25399 25402 25405 25407 25410 25412 25413 25414 25417 25419 25430 25431 25434 25502 25504 25507 25517 25519 25526 25567 25782 25783 25784 25786 25788 25864 25866 25867 25870 25871 25878 25879 25880 25881 25882 25883 25885 25886 25887 25888 25889 25890 25891 26499 26503
-------------------------------------------------------------------------

-------------------- Saved: 4500 of 5144 in MLC_Text --------------------
26506 26507 26520 26541 26547 26574 26578 26579 26580 26581 26582 26583 26611 26612 26649 26659 26674 26676 26682 26689 26696 26811 26821 26914 26949 26950 26951 26953 26957 26958 26965 26969 27449 27452 27462 27463 27477 27482 27502 27504 27511 27514 27552 27572 27576 27577 27579 27580 27583 27584
-------------------------------------------------------------------------

-------------------- Saved: 4550 of 5144 in MLC_Text --------------------
27585 27830 27864 27869 27872 27877 28132 28133 28135 28136 28137 28144 28145 28147 28156 28157 28158 28159 28160 28166 28174 28175 28345 28364 28383 28391 28440 28441 28455 28456 28460 28465 28475 28488 28500 28550 28551 28552 28553 28560 28563 28569 28590 28591 28592 28594 28600 28608 28609 28613
-------------------------------------------------------------------------

-------------------- Saved: 4600 of 5144 in MLC_Text --------------------
28643 28644 28659 28660 28662 28666 28667 28668 28674 28684 28708 28719 28777 28811 28814 28819 28830 28833 28843 28844 28846 28849 28856 28861 28869 28925 28950 28951 28952 28953 28954 28955 28956 28957 28958 28959 28960 28961 28962 28963 28964 28965 28967 28968 28969 28970 28971 28974 28985 28993
-------------------------------------------------------------------------

-------------------- Saved: 4650 of 5144 in MLC_Text --------------------
28994 28995 28996 28998 28999 29000 29001 29006 29014 29024 29036 29066 29067 29069 29071 29072 29076 29077 29078 29079 29082 29083 29084 29086 29087 29088 29089 29090 29091 29092 29093 29096 29097 29099 29103 29109 29110 29111 29115 29154 29155 29157 29173 29186 29187 29195 29198 29216 29217 29233
-------------------------------------------------------------------------

-------------------- Saved: 4700 of 5144 in MLC_Text --------------------
29247 29291 29311 29331 29408 29410 29431 29432 29445 29450 29452 29453 29454 29455 29525 29530 29531 29532 29533 29534 29535 29536 29537 29538 29562 29563 29584 29588 29689 29703 29718 29794 29876 29973 29974 29975 29976 29979 29985 29986 30001 30017 30021 30036 30040 30084 30095 30104 30107 30148
-------------------------------------------------------------------------

-------------------- Saved: 4750 of 5144 in MLC_Text --------------------
30886 30888 30889 30900 30910 30911 30915 30930 30933 30934 30936 30937 30939 30941 30945 30946 30949 30952 30954 30961 30970 31151 31152 31157 31158 31161 31165 31166 31167 31168 31169 31172 31209 31210 31211 31212 31276 31346 31348 31355 31362 31365 31388 31390 31391 31392 31393 31395 31425 31426
-------------------------------------------------------------------------

-------------------- Saved: 4800 of 5144 in MLC_Text --------------------
31435 31466 31500 31501 31502 31503 31516 31581 31631 31662 31823 31824 31825 31826 31828 31838 31840 31852 31855 31860 31889 31896 31925 31932 31945 31960 32399 32436 32440 32443 32446 32498 32499 32507 32568 32571 32573 32574 32575 32591 32595 32803 32830 32839 32910 32911 32912 32913 32914 32933
-------------------------------------------------------------------------

-------------------- Saved: 4850 of 5144 in MLC_Text --------------------
32947 32956 33032 33070 33073 33076 33078 33079 33080 33081 33082 33084 33086 33087 33098 33105 33109 33110 33115 33232 33233 33234 33235 33240 33339 33340 33341 33342 33343 33344 33345 33346 33347 33348 33349 33350 33351 33352 33353 33354 33355 33356 33357 33358 33359 33361 33371 33374 33375 33381
-------------------------------------------------------------------------

-------------------- Saved: 4900 of 5144 in MLC_Text --------------------
33382 33383 33445 33522 33526 33528 33529 33534 33536 33538 33546 33548 33549 33550 33551 33552 33553 33563 33564 33683 33684 33710 33737 33854 33902 33905 33907 33908 34281 34282 34333 34337 34456 34551 34563 34578 34583 34584 34586 34602 34612 34614 34662 34690 34706 34707 34872 34904 34941 34946
-------------------------------------------------------------------------

-------------------- Saved: 4950 of 5144 in MLC_Text --------------------
34948 34949 34996 35016 35266 35350 35402 35403 35404 35408 35410 35411 35416 35430 35576 35610 35649 35653 35718 35750 35753 35859 35861 35888 35891 35894 36052 36053 36170 36215 36217 36272 36537 36542 36570 36617 36713 36716 37018 37288 37305 37347 37350 37351 37354 37685 37699 37708 37709 37757
-------------------------------------------------------------------------

-------------------- Saved: 5000 of 5144 in MLC_Text --------------------
37758 37759 37788 37791 37793 37864 37865 37866 37892 37985 37986 37989 37990 37992 37993 37994 37995 37997 38084 38103 38106 38108 38109 38208 38210 38309 38370 38374 38376 38378 38379 38425 38426 38606 38712 38713 38714 38716 38717 38718 38719 38720 38721 38722 38848 39005 39008 39010 39017 39024
-------------------------------------------------------------------------

-------------------- Saved: 5050 of 5144 in MLC_Text --------------------
39027 39085 39102 39103 39105 39106 39108 39111 39121 39122 39147 39209 39224 39225 39268 39285 39326 39336 39344 39347 39349 39357 39487 39505 39507 39508 39543 39544 39561 39621 39623 39789 39824 39851 39862 39872 39889 39926 39929 39930 40115 40211 40227 40295 40297 40327 40336 40402 40405 40412
-------------------------------------------------------------------------

-------------------- Saved: 5100 of 5144 in MLC_Text --------------------
40418 40419 40424 40433 40435 40456 40475 40510 40512 40581 40675 40676 40682 40752 40760 40764 40819 40820 40822 40823 40825 40826 40827 40828 40830 40838 40967 41001 41006 41013 41014 41061 41062 41063 41064 41067 41068 41069 41070 41071 41072 41073 41074 41075 41076 41092 41306 41330 41609 41611
-------------------------------------------------------------------------

-------------------- Saved: 5144 of 5144 in MLC_Text --------------------
41748 41752 41803 41809 41824 41863 41883 41884 41885 41906 42055 42098 42102 42116 42136 42244 42418 42419 42421 42425 42426 42427 42452 43179 43180 43337 43339 43340 43346 43348 43349 43350 43354 43360 43374 43375 43452 43495 43496 43498 43501 43502 43503 43504
-------------------------------------------------------------------------

-------------------- Saved: 50 of 5144 in MLC_Text_edit --------------------
3 7 10 11 14 15 16 17 18 20 21 22 23 24 25 26 27 29 30 31 32 33 35 36 41 43 47 48 51 52 53 54 55 60 61 62 63 64 67 68 69 70 71 73 78 79 81 82 83 85
----------------------------------------------------------------------------

-------------------- Saved: 100 of 5144 in MLC_Text_edit --------------------
86 88 90 91 92 93 96 97 99 102 103 104 105 107 111 121 122 123 124 125 126 127 128 129 130 131 141 142 143 147 148 149 152 153 154 160 161 162 163 165 166 171 173 174 177 178 179 181 182 188
-----------------------------------------------------------------------------

-------------------- Saved: 150 of 5144 in MLC_Text_edit --------------------
189 190 191 192 193 196 197 198 202 203 204 205 236 237 239 240 245 246 253 254 255 256 257 258 267 271 272 274 276 279 280 283 288 291 292 293 295 296 298 299 300 301 302 303 304 305 306 312 316 317
-----------------------------------------------------------------------------

-------------------- Saved: 200 of 5144 in MLC_Text_edit --------------------
318 321 324 328 329 330 332 334 335 336 337 339 340 343 344 345 346 348 352 353 356 357 358 361 362 364 368 369 370 371 373 374 375 376 377 378 379 381 382 383 386 387 388 395 396 397 405 406 407 408
-----------------------------------------------------------------------------

-------------------- Saved: 250 of 5144 in MLC_Text_edit --------------------
409 410 413 414 419 420 421 422 427 428 429 433 434 435 440 441 442 443 445 447 448 452 453 454 459 460 461 462 463 465 466 467 468 469 470 478 481 482 485 486 487 488 489 490 491 492 494 495 514 518
-----------------------------------------------------------------------------

-------------------- Saved: 300 of 5144 in MLC_Text_edit --------------------
523 524 529 530 531 533 534 535 536 537 539 542 544 545 549 550 551 552 554 555 556 557 561 562 576 579 580 584 589 590 592 594 595 596 597 604 605 606 607 609 610 619 620 621 623 636 651 652 653 654
-----------------------------------------------------------------------------

-------------------- Saved: 350 of 5144 in MLC_Text_edit --------------------
655 656 657 658 659 660 661 662 674 676 677 678 679 680 681 683 685 686 687 688 690 696 699 700 701 702 703 704 705 711 712 713 714 715 716 717 718 719 721 723 725 727 730 734 735 737 742 743 744 745
-----------------------------------------------------------------------------

-------------------- Saved: 400 of 5144 in MLC_Text_edit --------------------
746 747 748 750 752 765 766 767 769 773 774 776 777 778 779 782 786 789 790 791 792 794 795 796 797 798 807 813 814 815 816 817 818 819 820 821 822 823 824 825 826 828 829 830 831 832 834 836 840 841
-----------------------------------------------------------------------------

-------------------- Saved: 450 of 5144 in MLC_Text_edit --------------------
842 843 848 853 855 856 857 860 861 866 868 869 870 871 872 873 874 875 876 877 880 881 882 883 884 885 886 887 888 889 896 897 899 902 903 918 920 921 943 947 960 961 963 964 966 967 970 971 972 973
-----------------------------------------------------------------------------

-------------------- Saved: 500 of 5144 in MLC_Text_edit --------------------
981 984 985 986 987 988 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1012 1013 1022 1023 1024 1025 1026 1027 1029 1031 1032 1034 1035 1041 1044 1046 1047 1048 1049 1050 1055 1056 1057 1058 1059 1060 1061 1066 1068 1071 1072
-----------------------------------------------------------------------------

-------------------- Saved: 550 of 5144 in MLC_Text_edit --------------------
1073 1074 1075 1079 1080 1081 1082 1084 1085 1088 1089 1092 1093 1100 1101 1102 1103 1105 1106 1107 1108 1114 1117 1118 1122 1124 1128 1131 1132 1139 1141 1143 1144 1145 1146 1147 1154 1156 1157 1158 1161 1162 1165 1166 1167 1170 1171 1180 1181 1182
-----------------------------------------------------------------------------

-------------------- Saved: 600 of 5144 in MLC_Text_edit --------------------
1183 1184 1185 1186 1187 1188 1198 1202 1203 1204 1205 1206 1207 1208 1210 1211 1215 1220 1235 1236 1244 1246 1247 1248 1249 1250 1251 1252 1253 1254 1256 1257 1260 1261 1264 1265 1266 1267 1293 1295 1299 1300 1304 1305 1306 1307 1308 1311 1312 1314
-----------------------------------------------------------------------------

-------------------- Saved: 650 of 5144 in MLC_Text_edit --------------------
1315 1317 1318 1320 1321 1322 1325 1326 1327 1328 1329 1331 1333 1335 1336 1338 1339 1341 7798 7799 7803 7808 7809 7810 7811 7814 7815 7816 7820 7823 7824 7826 7828 7829 7830 7833 7837 7838 7842 7848 7849 7850 7851 7854 7858 7861 7864 7865 7870 7871
-----------------------------------------------------------------------------

-------------------- Saved: 700 of 5144 in MLC_Text_edit --------------------
7872 7873 7874 7875 7876 7877 7878 7882 7886 7887 7889 7891 7896 7898 7899 7900 7906 7907 7908 7909 7910 7912 7914 7915 7917 7918 7921 7922 7923 7924 7925 7926 7927 7930 8272 8287 8288 8289 8290 8291 8292 8293 8294 8295 8296 8297 8298 8301 8303 8304
-----------------------------------------------------------------------------

-------------------- Saved: 750 of 5144 in MLC_Text_edit --------------------
8305 8306 8307 8308 8309 8316 8317 8326 8330 8331 8332 8333 8337 8338 8339 8341 8344 8345 8348 8350 8359 8360 8364 8365 8368 8372 8373 8374 8376 8379 8442 8443 8444 8445 8446 8447 8448 8449 8450 8451 8452 8453 8454 8455 8456 8457 8458 8459 8460 8461
-----------------------------------------------------------------------------

-------------------- Saved: 800 of 5144 in MLC_Text_edit --------------------
8462 8463 8464 8465 8466 8473 8484 8495 8499 8500 8501 8506 8507 8510 8511 8512 8517 8562 8563 8565 8566 8568 8569 8570 8572 8573 8576 8577 8578 8579 8584 8585 8589 8590 8591 8592 8598 8632 8633 8634 8635 8636 8637 8638 8639 8640 8641 8642 8643 8645
-----------------------------------------------------------------------------

-------------------- Saved: 850 of 5144 in MLC_Text_edit --------------------
8646 8649 8650 8651 8652 8653 8654 8655 8656 8657 8658 8659 8660 8661 8663 8664 8671 8673 8676 8677 8681 8682 8683 8684 8687 8688 8689 8691 8693 8694 8697 8698 8701 8702 8703 8704 8706 8707 8712 8715 8716 8717 8719 8720 8721 8722 8725 8726 8727 8728
-----------------------------------------------------------------------------

-------------------- Saved: 900 of 5144 in MLC_Text_edit --------------------
8729 8732 8733 8734 8739 8740 8741 8742 8743 8746 8753 8756 8757 8758 8759 8760 8761 8762 8763 8764 8765 8766 8770 8778 8779 8780 8781 8782 8783 8784 8793 8794 8795 8796 8798 8799 8802 8803 8806 8807 8808 8812 8813 8815 8816 8818 8819 8823 8824 8826
-----------------------------------------------------------------------------

-------------------- Saved: 950 of 5144 in MLC_Text_edit --------------------
8827 8828 8830 8832 8833 8834 8835 8837 8848 8849 8851 8852 8853 8856 8858 8860 8865 8868 8869 8874 8875 8876 8877 8878 8879 8883 8884 8885 8886 8887 8888 8889 8890 8891 8893 8894 8895 8896 8902 8903 8906 8915 8916 8917 8918 8919 8920 8921 8923 8924
-----------------------------------------------------------------------------

-------------------- Saved: 1000 of 5144 in MLC_Text_edit --------------------
8925 8927 8928 8931 8932 8941 8942 8943 8944 8945 8946 8950 8951 8952 8953 8956 8957 8958 8959 8961 8962 8963 8964 8971 8972 8973 8974 8976 8978 8980 8981 8982 8983 8984 8985 8986 8987 8988 8989 8990 8991 8992 8993 8995 8998 9006 9007 9008 9009 9010
------------------------------------------------------------------------------

-------------------- Saved: 1050 of 5144 in MLC_Text_edit --------------------
9011 9016 9017 9018 9019 9021 9023 9028 9032 9033 9034 9035 9037 9038 9041 9042 9045 9046 9050 9053 9055 9056 9059 9061 9064 9065 9067 9069 9072 9073 9076 9080 9081 9082 9083 9084 9087 9088 9091 9092 9099 9100 9101 9102 9103 9104 9110 9111 9112 9113
------------------------------------------------------------------------------

-------------------- Saved: 1100 of 5144 in MLC_Text_edit --------------------
9114 9115 9116 9119 9120 9121 9122 9123 9124 9125 9126 9127 9128 9129 9131 9132 9133 9138 9144 9145 9146 9147 9148 9149 9150 9152 9179 9181 9182 9184 9185 9187 9188 9189 9190 9191 9192 9193 9197 9198 9199 9200 9201 9202 9203 9206 9207 9208 9214 9215
------------------------------------------------------------------------------

-------------------- Saved: 1150 of 5144 in MLC_Text_edit --------------------
9216 9217 9218 9219 9220 9221 9222 9223 9229 9230 9231 9240 9245 9246 9247 9248 9251 9253 9255 9256 9260 9261 9262 9263 9264 9265 9266 9267 9268 9269 9270 9271 9272 9273 9274 9275 9277 9278 9279 9280 9281 9282 9283 9286 9287 9288 9289 9290 9292 9293
------------------------------------------------------------------------------

-------------------- Saved: 1200 of 5144 in MLC_Text_edit --------------------
9294 9295 9297 9303 9304 9305 9307 9311 9312 9313 9316 9326 9327 9337 9339 9342 9344 9347 9348 9349 9350 9351 9354 9355 9491 9492 9493 9494 9495 9496 9497 9498 9499 9500 9501 9503 9504 9510 9511 9512 9521 9525 9538 9539 9540 9542 9543 9544 9545 9546
------------------------------------------------------------------------------

-------------------- Saved: 1250 of 5144 in MLC_Text_edit --------------------
9547 9548 9560 9577 9578 9579 9580 9581 9582 9583 9584 9585 9586 9587 9588 9589 9590 9591 9592 9593 9594 9595 9596 9597 9598 9599 9600 9601 9602 9603 9604 9607 9608 9609 9610 9611 9612 9614 9615 9616 9617 9618 9619 9625 9632 9633 9636 9637 9640 9641
------------------------------------------------------------------------------

-------------------- Saved: 1300 of 5144 in MLC_Text_edit --------------------
9643 9644 9645 9646 9647 9648 9649 9650 9651 9652 9653 9654 9658 9659 9660 9661 9662 9663 9664 9665 9666 9667 9668 9669 9670 9671 9672 9673 9674 9675 9676 9677 9678 9679 9680 9685 9686 9688 9689 9690 9691 9692 9696 9697 9698 9699 9700 9701 9704 9705
------------------------------------------------------------------------------

-------------------- Saved: 1350 of 5144 in MLC_Text_edit --------------------
9706 9708 9709 9711 9712 9714 9715 9716 9718 9722 9723 9724 9727 9728 9729 9730 9731 9732 9733 9739 9743 9745 9748 9750 9751 9753 9754 9755 9756 9757 9758 9759 9761 9762 9764 9765 9766 9767 9768 9769 9770 9771 9772 9773 9774 9775 9776 9777 9778 9779
------------------------------------------------------------------------------

-------------------- Saved: 1400 of 5144 in MLC_Text_edit --------------------
9780 9781 9782 9783 9784 9785 9786 9787 9788 9789 9790 9791 9792 9793 9794 9795 9796 9797 9798 9799 9800 9801 9802 9803 9804 9805 9806 9807 9809 9810 9811 9812 9814 9822 9826 9827 9885 9886 9887 9888 9889 9890 9891 9892 9893 9894 9895 9897 9898 9899
------------------------------------------------------------------------------

-------------------- Saved: 1450 of 5144 in MLC_Text_edit --------------------
9900 9901 9902 9903 9904 9905 9907 9908 9909 9910 9911 9912 9913 9914 9915 9916 9917 9918 9919 9920 9922 9923 9924 9925 9926 9927 9928 9932 9933 9934 9936 9937 9938 9939 9940 9942 9943 9945 9946 9947 9950 9951 9953 9955 9956 9960 9961 9962 9963 9965
------------------------------------------------------------------------------

-------------------- Saved: 1500 of 5144 in MLC_Text_edit --------------------
9966 9967 9968 9969 9971 9973 9974 9977 9978 9979 9980 9983 9984 9985 9986 9987 9989 9990 9995 9997 9998 9999 10000 10003 10009 10010 10011 10013 10014 10017 10018 10019 10020 10022 10023 10025 10026 10028 10029 10032 10033 10034 10035 10037 10041 10042 10043 10044 10047 10050
------------------------------------------------------------------------------

-------------------- Saved: 1550 of 5144 in MLC_Text_edit --------------------
10051 10068 10074 10075 10079 10080 10081 10082 10083 10086 10092 10094 10095 10099 10100 10101 10102 10103 10104 10105 10106 10107 10108 10109 10110 10112 10115 10116 10117 10118 10119 10120 10121 10122 10123 10124 10125 10126 10127 10128 10129 10130 10131 10132 10133 10134 10135 10139 10141 10144
------------------------------------------------------------------------------

-------------------- Saved: 1600 of 5144 in MLC_Text_edit --------------------
10145 10146 10147 10148 10149 10158 10159 10162 10163 10164 10165 10167 10168 10169 10170 10181 10182 10185 10186 10187 10188 10189 10190 10191 10192 10193 10197 10198 10199 10200 10201 10202 10203 10209 10210 10211 10212 10231 10232 10233 10234 10235 10236 10238 10239 10242 10243 10244 10245 10247
------------------------------------------------------------------------------

-------------------- Saved: 1650 of 5144 in MLC_Text_edit --------------------
10248 10249 10250 10251 10252 10253 10254 10255 10256 10257 10258 10259 10260 10261 10267 10289 10305 10306 10307 10309 10311 10314 10321 10324 10328 10346 10349 10351 10353 10356 10357 10358 10375 10377 10378 10379 10380 10381 10385 10386 10387 10388 10390 10391 10392 10393 10395 10399 10401 10403
------------------------------------------------------------------------------

-------------------- Saved: 1700 of 5144 in MLC_Text_edit --------------------
10405 10407 10408 10409 10411 10412 10414 10417 10420 10421 10422 10427 10428 10430 10431 10442 10443 10445 10460 10461 10470 10471 10472 10473 10474 10475 10480 10481 10491 10492 10493 10494 10495 10496 10497 10498 10499 10500 10501 10502 10503 10504 10505 10506 10507 10508 10509 10510 10511 10515
------------------------------------------------------------------------------

-------------------- Saved: 1750 of 5144 in MLC_Text_edit --------------------
10516 10517 10519 10520 10523 10524 10527 10528 10529 10531 10532 10533 10534 10535 10537 10539 10540 10541 10544 10547 10548 10549 10550 10552 10553 10554 10557 10558 10559 10560 10567 10573 10574 10575 10576 10577 10578 10579 10580 10581 10582 10583 10584 10585 10586 10587 10588 10589 10590 10591
------------------------------------------------------------------------------

-------------------- Saved: 1800 of 5144 in MLC_Text_edit --------------------
10592 10598 10600 10602 10603 10609 10615 10616 10618 10619 10621 10655 10657 10659 10660 10661 10662 10663 10664 10669 10672 10673 10674 10676 10679 10680 10682 10683 10711 10712 10715 10716 10722 10737 10745 10746 10747 10748 10753 10754 10759 10762 10767 10768 10769 10770 10775 10776 10777 10785
------------------------------------------------------------------------------

-------------------- Saved: 1850 of 5144 in MLC_Text_edit --------------------
10786 10787 10788 10789 10790 10791 10794 10795 10796 10797 10800 10803 10804 10808 10809 10810 10813 10814 10815 10816 10817 10819 10820 10821 10822 10823 10824 10825 10827 10831 10834 10835 10836 10837 10849 10850 10851 10856 10868 10871 10873 10874 10875 10876 10877 10878 10879 10880 10883 10884
------------------------------------------------------------------------------

-------------------- Saved: 1900 of 5144 in MLC_Text_edit --------------------
10887 10888 10892 10893 10894 10901 10903 10904 10906 10907 10910 10912 10914 10915 10919 10920 10921 10924 10930 10931 10932 10933 10934 10941 10942 10944 10946 10947 10948 10952 10963 11034 11035 11036 11037 11038 11039 11040 11041 11042 11044 11045 11046 11047 11048 11049 11050 11051 11058 11059
------------------------------------------------------------------------------

-------------------- Saved: 1950 of 5144 in MLC_Text_edit --------------------
11062 11066 11067 11068 11078 11079 11080 11081 11082 11085 11088 11089 11097 11098 11099 11101 11102 11103 11104 11105 11106 11108 11109 11110 11112 11117 11118 11119 11120 11122 11123 11125 11128 11129 11132 11135 11136 11137 11138 11139 11143 11146 11147 11148 11149 11152 11153 11154 11157 11158
------------------------------------------------------------------------------

-------------------- Saved: 2000 of 5144 in MLC_Text_edit --------------------
11168 11169 11170 11171 11172 11173 11174 11175 11176 11177 11178 11179 11183 11184 11188 11189 11190 11192 11196 11199 11202 11205 11207 11208 11209 11214 11215 11217 11218 11219 11220 11224 11225 11235 11236 11237 11238 11239 11242 11247 11248 11249 11251 11252 11253 11254 11255 11256 11257 11258
------------------------------------------------------------------------------

-------------------- Saved: 2050 of 5144 in MLC_Text_edit --------------------
11264 11270 11272 11279 11280 11281 11282 11284 11289 11290 11292 11293 11294 11295 11296 11297 11298 11299 11326 11327 11328 11329 11330 11331 11332 11333 11334 11335 11336 11337 11338 11339 11340 11344 11345 11346 11347 11348 11349 11350 11351 11352 11353 11355 11363 11364 11366 11367 11370 11373
------------------------------------------------------------------------------

-------------------- Saved: 2100 of 5144 in MLC_Text_edit --------------------
11375 11394 11395 11396 11397 11399 11400 11401 11402 11403 11404 11405 11406 11407 11408 11409 11410 11411 11417 11422 11424 11426 11488 11489 11490 11491 11492 11493 11494 11495 11496 11497 11498 11499 11500 11501 11502 11503 11504 11505 11506 11507 11508 11509 11510 11511 11512 11513 11514 11515
------------------------------------------------------------------------------

-------------------- Saved: 2150 of 5144 in MLC_Text_edit --------------------
11516 11517 11518 11521 11522 11523 11524 11525 11526 11532 11543 11545 11546 11547 11548 11550 11552 11553 11554 11555 11562 11563 11564 11565 11566 11567 11568 11569 11570 11571 11572 11573 11574 11576 11582 11584 11585 11589 11590 11591 11595 11596 11597 11603 11604 11605 11607 11608 11609 11673
------------------------------------------------------------------------------

-------------------- Saved: 2200 of 5144 in MLC_Text_edit --------------------
11674 11675 11676 11677 11678 11679 11680 11681 11682 11683 11684 11685 11686 11687 11688 11689 11690 11691 11692 11693 11694 11695 11696 11697 11698 11699 11700 11701 11702 11703 11704 11705 11706 11707 11708 11709 11712 11715 11716 11717 11718 11720 11721 11723 11731 11736 11738 11741 11742 11743
------------------------------------------------------------------------------

-------------------- Saved: 2250 of 5144 in MLC_Text_edit --------------------
11747 11748 11749 11750 11752 11753 11754 11755 11756 11757 11758 11762 11763 11769 11770 11771 11783 11784 11785 11786 11787 11788 11789 11790 11791 11793 11794 11795 11796 11799 11805 11811 11812 11813 11814 11815 11816 11817 11818 11819 11820 11825 11826 11829 11830 11832 11833 11834 11835 11837
------------------------------------------------------------------------------

-------------------- Saved: 2300 of 5144 in MLC_Text_edit --------------------
11839 11841 11842 11844 11845 11846 11847 11848 11850 11851 11853 11854 11855 11856 11858 11859 11860 11861 11863 11880 11881 11882 11883 11884 11885 11886 11887 11888 11889 11890 11891 11892 11893 11894 11895 11900 11901 11905 11906 11911 11912 11913 11914 11915 11923 11924 11927 11928 11929 11934
------------------------------------------------------------------------------

-------------------- Saved: 2350 of 5144 in MLC_Text_edit --------------------
11935 11937 11938 11942 11943 11944 11945 11947 11949 11950 11952 11954 11955 11956 11962 11963 11964 11965 11966 11967 11971 11972 11974 11979 11985 11986 11989 11990 11991 11993 11995 11996 11997 11998 12004 12020 12021 12022 12023 12024 12025 12026 12027 12031 12034 12035 12036 12037 12038 12039
------------------------------------------------------------------------------

-------------------- Saved: 2400 of 5144 in MLC_Text_edit --------------------
12040 12042 12043 12044 12045 12053 12054 12055 12056 12057 12058 12060 12063 12064 12065 12066 12076 12077 12078 12079 12080 12084 12110 12111 12112 12114 12121 12123 12127 12128 12129 12130 12131 12132 12133 12134 12140 12141 12143 12144 12145 12147 12149 12150 12152 12158 12159 12160 12162 12166
------------------------------------------------------------------------------

-------------------- Saved: 2450 of 5144 in MLC_Text_edit --------------------
12167 12168 12169 12179 12180 12181 12182 12183 12184 12185 12186 12187 12188 12190 12193 12197 12199 12201 12202 12204 12205 12206 12207 12211 12212 12213 12216 12217 12218 12219 12220 12221 12222 12223 12224 12225 12227 12228 12229 12233 12234 12235 12236 12237 12238 12239 12242 12243 12245 12246
------------------------------------------------------------------------------

-------------------- Saved: 2500 of 5144 in MLC_Text_edit --------------------
12253 12255 12263 12264 12265 12266 12267 12269 12272 12273 12276 12277 12278 12281 12282 12283 12293 12294 12295 12296 12297 12298 12299 12300 12301 12305 12306 12307 12309 12313 12314 12315 12316 12317 12322 12323 12324 12325 12328 12329 12337 12338 12339 12340 12342 12343 12344 12349 12354 12355
------------------------------------------------------------------------------

-------------------- Saved: 2550 of 5144 in MLC_Text_edit --------------------
12356 12357 12358 12359 12360 12361 12362 12364 12365 12368 12369 12371 12373 12374 12375 12378 12379 12382 12383 12384 12385 12386 12387 12388 12389 12390 12391 12392 12393 12394 12395 12396 12397 12398 12479 12480 12481 12482 12483 12484 12485 12486 12487 12488 12489 12490 12491 12492 12493 12494
------------------------------------------------------------------------------

-------------------- Saved: 2600 of 5144 in MLC_Text_edit --------------------
12495 12496 12497 12498 12499 12500 12501 12502 12503 12504 12505 12506 12507 12508 12509 12510 12511 12512 12513 12514 12515 12516 12517 12518 12519 12520 12521 12522 12523 12524 12525 12526 12527 12528 12529 12530 12531 12532 12534 12536 12537 12538 12539 12540 12543 12545 12556 12558 12559 12561
------------------------------------------------------------------------------

-------------------- Saved: 2650 of 5144 in MLC_Text_edit --------------------
12562 12571 12572 12573 12574 12590 12591 12592 12593 12594 12595 12596 12597 12598 12599 12600 12601 12602 12603 12605 12606 12609 12611 12612 12613 12616 12617 12618 12619 12620 12624 12631 12633 12635 12636 12637 12638 12639 12640 12641 12642 12645 12646 12648 12652 12655 12656 12659 12660 12667
------------------------------------------------------------------------------

-------------------- Saved: 2700 of 5144 in MLC_Text_edit --------------------
12668 12669 12670 12672 12673 12676 12677 12678 12679 12682 12683 12685 12686 12687 12688 12689 12690 12691 12692 12693 12695 12696 12699 12700 12702 12703 12704 12705 12706 12707 12708 12709 12710 12711 12712 12713 12715 12717 12719 12720 12722 12723 12725 12727 12728 12729 12730 12731 12732 12734
------------------------------------------------------------------------------

-------------------- Saved: 2750 of 5144 in MLC_Text_edit --------------------
12761 12762 12763 12766 12767 12768 12769 12771 12773 12774 12775 12776 12777 12780 12783 12784 12786 12789 12794 12795 12796 12797 12798 12799 12800 12801 12802 12803 12804 12805 12806 12807 12808 12809 12810 12811 12813 12820 12821 12822 12823 12830 12833 12841 12843 12847 12848 12851 12858 12859
------------------------------------------------------------------------------

-------------------- Saved: 2800 of 5144 in MLC_Text_edit --------------------
12860 12866 12867 12871 12872 12874 12878 12883 12884 12885 12886 12889 12890 12891 12893 12894 12897 12898 12902 12903 12905 12910 12915 12918 12919 12920 12921 12922 12924 12927 12928 12932 12933 12934 12935 12940 12941 12942 12943 12944 12947 12948 12949 12950 12951 12952 12966 12967 12968 12969
------------------------------------------------------------------------------

-------------------- Saved: 2850 of 5144 in MLC_Text_edit --------------------
12970 12973 12974 12975 12976 12977 12978 12980 12981 12982 12983 12984 12985 12987 12989 12990 12991 12992 12995 12996 12999 13000 13001 13004 13005 13010 13011 13012 13013 13014 13015 13022 13023 13024 13025 13026 13029 13034 13035 13037 13040 13041 13053 13054 13055 13056 13057 13058 13059 13061
------------------------------------------------------------------------------

-------------------- Saved: 2900 of 5144 in MLC_Text_edit --------------------
13062 13063 13064 13065 13066 13067 13068 13069 13070 13071 13072 13073 13074 13075 13076 13077 13078 13079 13080 13081 13082 13083 13084 13085 13086 13087 13088 13089 13090 13091 13092 13093 13094 13095 13096 13097 13098 13099 13100 13103 13104 13105 13106 13107 13108 13109 13110 13111 13112 13113
------------------------------------------------------------------------------

-------------------- Saved: 2950 of 5144 in MLC_Text_edit --------------------
13114 13115 13116 13117 13118 13119 13120 13121 13122 13123 13124 13125 13126 13127 13128 13129 13130 13131 13132 13133 13134 13135 13138 13139 13140 13141 13142 13143 13145 13147 13148 13149 13150 13151 13152 13153 13154 13155 13156 13157 13158 13159 13160 13161 13162 13163 13164 13166 13167 13168
------------------------------------------------------------------------------

-------------------- Saved: 3000 of 5144 in MLC_Text_edit --------------------
13169 13170 13171 13172 13173 13174 13175 13176 13177 13178 13179 13180 13181 13182 13183 13184 13185 13186 13187 13188 13189 13190 13191 13192 13193 13194 13195 13196 13197 13198 13200 13201 13202 13204 13205 13206 13207 13208 13209 13210 13211 13212 13213 13214 13215 13216 13218 13219 13220 13221
------------------------------------------------------------------------------

-------------------- Saved: 3050 of 5144 in MLC_Text_edit --------------------
13222 13223 13224 13225 13226 13227 13228 13229 13230 13231 13232 13233 13237 13239 13240 13241 13242 13243 13244 13245 13247 13248 13251 13274 13275 13278 13279 13281 13282 13283 13284 13288 13289 13290 13292 13293 13294 13295 13296 13299 13300 13301 13308 13309 13310 13311 13313 13314 13315 13316
------------------------------------------------------------------------------

-------------------- Saved: 3100 of 5144 in MLC_Text_edit --------------------
13318 13324 13325 13326 13329 13331 13332 13334 13337 13338 13340 13341 13346 13347 13349 13350 13351 13352 13353 13354 13355 13356 13357 13358 13359 13361 13362 13363 13364 13365 13366 13367 13369 13371 13375 13376 13377 13378 13381 13382 13383 13384 13385 13387 13388 13390 13398 13400 13401 13402
------------------------------------------------------------------------------

-------------------- Saved: 3150 of 5144 in MLC_Text_edit --------------------
13403 13416 13419 13420 13425 13430 13431 13432 13433 13435 13437 13438 13439 13440 13442 13452 13455 13458 13461 13462 13463 13467 13468 13471 13472 13473 13477 13478 13481 13482 13483 13487 13488 13489 13490 13491 13492 13494 13495 13496 13497 13498 13499 13500 13501 13502 13503 13505 13506 13507
------------------------------------------------------------------------------

-------------------- Saved: 3200 of 5144 in MLC_Text_edit --------------------
13508 13509 13512 13513 13516 13517 13520 13521 13527 13528 13529 13530 13531 13532 13533 13534 13535 13536 13537 13538 13539 13540 13541 13545 13546 13550 13556 13557 13558 13559 13561 13565 13568 13569 13572 13573 13576 13577 13578 13581 13582 13583 13584 13586 13587 13590 13592 13611 13612 13613
------------------------------------------------------------------------------

-------------------- Saved: 3250 of 5144 in MLC_Text_edit --------------------
13614 13615 13616 13617 13618 13619 13620 13621 13622 13623 13624 13625 13626 13627 13628 13629 13631 13632 13634 13638 13642 13645 13647 13648 13649 13650 13658 13663 13667 13669 13670 13671 13672 13683 13684 13685 13686 13687 13695 13696 13697 13698 13700 13702 13703 13706 13713 13715 13716 13717
------------------------------------------------------------------------------

-------------------- Saved: 3300 of 5144 in MLC_Text_edit --------------------
13718 13720 13721 13722 13723 13727 13733 13735 13737 13739 13740 13741 13743 13746 13747 13750 13751 13753 13755 13758 13765 13766 13767 13785 13786 13790 13791 13793 13794 13795 13797 13798 13818 13838 13840 13858 13860 13861 13867 13877 13878 13879 13880 13902 13903 13904 13905 13906 13935 13936
------------------------------------------------------------------------------

-------------------- Saved: 3350 of 5144 in MLC_Text_edit --------------------
13937 13938 13947 13948 13953 13954 13978 13979 13980 13995 13996 13997 13998 14000 14001 14002 14003 14007 14008 14013 14016 14017 14018 14021 14022 14023 14024 14025 14026 14027 14028 14029 14030 14031 14032 14033 14034 14035 14036 14037 14038 14039 14040 14041 14042 14043 14044 14045 14046 14047
------------------------------------------------------------------------------

-------------------- Saved: 3400 of 5144 in MLC_Text_edit --------------------
14048 14049 14050 14051 14052 14053 14054 14055 14056 14057 14058 14059 14060 14061 14062 14067 14068 14070 14073 14075 14091 14094 14099 14100 14101 14102 14103 14104 14105 14106 14107 14110 14118 14119 14120 14121 14122 14123 14126 14130 14131 14134 14136 14138 14141 14142 14145 14146 14147 14148
------------------------------------------------------------------------------

-------------------- Saved: 3450 of 5144 in MLC_Text_edit --------------------
14149 14150 14152 14154 14155 14156 14161 14162 14168 14169 14170 14171 14172 14175 14176 14178 14179 14180 14181 14182 14190 14191 14192 14196 14199 14200 14201 14202 14203 14204 14209 14211 14222 14223 14224 14225 14226 14227 14228 14229 14230 14231 14233 14238 14241 14242 14245 14251 14252 14256
------------------------------------------------------------------------------

-------------------- Saved: 3500 of 5144 in MLC_Text_edit --------------------
14257 14258 14259 14267 14272 14279 14280 14283 14286 14287 14292 14293 14294 14295 14302 14303 14304 14306 14307 14310 14311 14313 14314 14315 14316 14317 14318 14319 14320 14321 14323 14325 14326 14328 14330 14331 14335 14337 14338 14343 14344 14345 14346 14347 14348 14351 14352 14353 14354 14355
------------------------------------------------------------------------------

-------------------- Saved: 3550 of 5144 in MLC_Text_edit --------------------
14357 14358 14359 14363 14367 14368 14369 14371 14377 14379 14384 14385 14389 14390 14391 14395 14396 14398 14399 14400 14401 14403 14404 14406 14407 14408 14409 14410 14411 14413 14415 14417 14418 14419 14424 14425 14426 14427 14430 14432 14433 14444 14445 14446 14447 14450 14451 14458 14459 14460
------------------------------------------------------------------------------

-------------------- Saved: 3600 of 5144 in MLC_Text_edit --------------------
14461 14462 14463 14464 14465 14466 14467 14468 14480 14481 14482 14483 14484 14485 14486 14487 14488 14489 14490 14491 14492 14494 14497 14498 14500 14501 14502 14506 14508 14509 14512 14513 14515 14516 14517 14518 14519 14599 14600 14601 14602 14603 14604 14605 14606 14607 14608 14609 14610 14611
------------------------------------------------------------------------------

-------------------- Saved: 3650 of 5144 in MLC_Text_edit --------------------
14612 14613 14614 14615 14616 14617 14618 14619 14620 14621 14622 14623 14624 14625 14626 14627 14628 14629 14630 14632 14633 14634 14635 14636 14637 14638 14639 14640 14641 14642 14643 14644 14645 14646 14647 14648 14649 14650 14651 14652 14653 14654 14655 14656 14657 14658 14659 14660 14661 14663
------------------------------------------------------------------------------

-------------------- Saved: 3700 of 5144 in MLC_Text_edit --------------------
14666 14667 14668 14749 14750 14751 14752 14753 14754 14755 14756 14757 14758 14759 14760 14761 14762 14763 14764 14765 14766 14767 14768 14769 14770 14771 14772 14773 14774 14775 14776 14777 14778 14779 14780 14781 14782 14783 14784 14785 14787 14788 14790 14791 14792 14793 14794 14795 14797 14798
------------------------------------------------------------------------------

-------------------- Saved: 3750 of 5144 in MLC_Text_edit --------------------
14799 14800 14801 14804 14805 14806 14807 14808 14809 14815 14826 14828 14829 14861 14863 14865 14866 14869 14871 14872 14873 14874 14875 14876 14878 14883 14938 14939 14940 14941 14942 14943 14944 14945 14946 14947 14948 14949 14950 14951 14952 14953 14954 14955 14956 14957 14958 14959 14960 14961
------------------------------------------------------------------------------

-------------------- Saved: 3800 of 5144 in MLC_Text_edit --------------------
14962 14963 14964 14965 14966 14967 14968 14969 14970 14971 14976 14980 14981 14982 14983 14984 14985 14986 14987 14988 14989 14990 14991 14992 14993 14994 14995 14998 14999 15002 15003 15005 15006 15007 15044 15047 15049 15051 15054 15197 15198 15199 15200 15216 15217 15218 15221 15222 15223 15231
------------------------------------------------------------------------------

-------------------- Saved: 3850 of 5144 in MLC_Text_edit --------------------
15232 15233 15234 15235 15236 15237 15238 15260 15261 15262 15264 15267 15271 15272 15279 15281 15284 15292 15296 15311 15325 15326 15331 15332 15339 15342 15343 15347 15349 15350 15352 15356 15357 15363 15365 15370 15374 15376 15377 15378 15379 15380 15381 15382 15383 15387 15388 15389 15392 15393
------------------------------------------------------------------------------

-------------------- Saved: 3900 of 5144 in MLC_Text_edit --------------------
15394 15404 15421 15422 15423 15424 15425 15426 15427 15428 15433 15434 15435 15436 15437 15438 15439 15444 15445 15446 15447 15448 15449 15450 15451 15455 15456 15457 15458 15459 15460 15461 15463 15464 15465 15486 15488 15489 15490 15491 15492 15499 15513 15514 15517 15518 15520 15530 15531 15607
------------------------------------------------------------------------------

-------------------- Saved: 3950 of 5144 in MLC_Text_edit --------------------
15613 15659 15660 15667 15670 15671 15672 15676 15677 15685 15686 15687 15688 15689 15724 15727 15728 15729 15730 15731 15732 15733 15735 15736 15737 15738 15739 15740 15741 15742 15743 15744 15747 15750 15751 15754 15755 15756 15757 15759 15762 15794 15801 15809 17608 17611 17612 17615 17616 17620
------------------------------------------------------------------------------

-------------------- Saved: 4000 of 5144 in MLC_Text_edit --------------------
17621 17624 17625 17626 17627 17628 17629 17634 17635 17636 17638 17640 17642 17643 17644 17645 17649 17650 17651 17652 17653 17654 17655 17656 17657 17661 17662 17663 17677 17679 17680 17691 17704 17706 17709 17710 17711 17713 17714 17734 17735 17736 17737 17745 17749 17751 17752 17753 17754 17755
------------------------------------------------------------------------------

-------------------- Saved: 4050 of 5144 in MLC_Text_edit --------------------
17757 17758 17759 17760 17761 17762 17763 17764 17766 17767 17768 17769 17770 17771 17772 17773 17783 17784 17793 17797 17799 17802 17806 17807 17808 17809 17811 17813 17814 17816 17817 17828 18346 18347 18352 18353 18415 18416 18417 18424 18425 18426 18427 18428 18437 18448 18455 18476 18492 18493
------------------------------------------------------------------------------

-------------------- Saved: 4100 of 5144 in MLC_Text_edit --------------------
18494 18498 18501 18510 18513 18583 18600 18612 18616 18617 18623 18624 18625 18627 18637 18642 18647 18648 18650 18651 18653 18656 18657 18658 18669 18670 18673 18703 18706 18707 18709 18714 18718 18719 18725 18735 18737 18748 18749 18766 18767 18768 18769 18770 18804 22742 22743 22744 22745 22748
------------------------------------------------------------------------------

-------------------- Saved: 4150 of 5144 in MLC_Text_edit --------------------
22783 22785 22791 22792 22823 22829 22838 22839 22844 22856 22859 22860 22867 22868 22906 22907 22908 22909 22910 22911 22912 22916 22918 22924 22927 22945 22946 23012 23013 23014 23015 23016 23017 23023 23072 23097 23098 23099 23100 23102 23103 23106 23107 23108 23109 23122 23123 23125 23126 23132
------------------------------------------------------------------------------

-------------------- Saved: 4200 of 5144 in MLC_Text_edit --------------------
23135 23136 23137 23142 23144 23145 23153 23156 23157 23164 23166 23176 23177 23178 23179 23180 23183 23200 23201 23212 23213 23214 23220 23236 23240 23265 23266 23270 23271 23274 23279 23280 23282 23283 23285 23293 23545 23546 23547 23555 23561 23567 23570 24277 24281 24288 24294 24295 24296 24297
------------------------------------------------------------------------------

-------------------- Saved: 4250 of 5144 in MLC_Text_edit --------------------
24298 24299 24300 24306 24307 24332 24643 24664 24665 24666 24667 24668 24669 24670 24679 24687 24690 24701 24702 24718 24719 24722 24730 24731 24732 24740 24749 24750 24759 24760 24785 24786 24787 24801 24809 24810 24811 24812 24814 24827 24828 24837 24838 24849 24851 24862 24864 24870 24872 24873
------------------------------------------------------------------------------

-------------------- Saved: 4300 of 5144 in MLC_Text_edit --------------------
24902 24904 24905 24906 24907 24908 24909 24910 24916 24923 24924 24925 24931 24932 24944 24949 24950 24951 24952 24953 24955 24961 24963 24968 24969 24975 24976 25000 25001 25002 25003 25004 25005 25006 25007 25008 25009 25010 25011 25012 25013 25014 25015 25016 25018 25019 25020 25021 25022 25023
------------------------------------------------------------------------------

-------------------- Saved: 4350 of 5144 in MLC_Text_edit --------------------
25024 25025 25026 25027 25028 25029 25031 25033 25034 25035 25039 25040 25042 25043 25044 25045 25046 25047 25048 25049 25050 25051 25052 25053 25054 25055 25056 25059 25060 25061 25062 25064 25065 25067 25068 25070 25071 25072 25073 25074 25075 25077 25078 25079 25080 25081 25082 25083 25084 25085
------------------------------------------------------------------------------

-------------------- Saved: 4400 of 5144 in MLC_Text_edit --------------------
25107 25108 25113 25114 25115 25116 25117 25135 25136 25137 25138 25140 25141 25147 25150 25151 25152 25155 25156 25157 25158 25159 25161 25162 25163 25198 25200 25201 25202 25203 25204 25205 25206 25207 25208 25216 25234 25245 25296 25297 25298 25299 25300 25303 25304 25305 25311 25314 25320 25321
------------------------------------------------------------------------------

-------------------- Saved: 4450 of 5144 in MLC_Text_edit --------------------
25322 25328 25329 25398 25399 25402 25405 25407 25410 25412 25413 25414 25417 25419 25430 25431 25434 25502 25504 25507 25517 25519 25526 25567 25782 25783 25784 25786 25788 25864 25866 25867 25870 25871 25878 25879 25880 25881 25882 25883 25885 25886 25887 25888 25889 25890 25891 26499 26503 26506
------------------------------------------------------------------------------

-------------------- Saved: 4500 of 5144 in MLC_Text_edit --------------------
26507 26520 26541 26547 26574 26578 26579 26580 26581 26582 26583 26611 26612 26649 26659 26674 26676 26682 26689 26696 26811 26821 26914 26949 26950 26951 26953 26957 26958 26965 26969 27449 27452 27462 27463 27477 27482 27502 27504 27511 27514 27552 27572 27576 27577 27579 27580 27583 27584 27585
------------------------------------------------------------------------------

-------------------- Saved: 4550 of 5144 in MLC_Text_edit --------------------
27830 27864 27869 27872 27877 28132 28133 28135 28136 28137 28144 28145 28147 28156 28157 28158 28159 28160 28166 28174 28175 28345 28364 28383 28391 28440 28441 28455 28456 28460 28465 28475 28488 28500 28550 28551 28552 28553 28560 28563 28569 28590 28591 28592 28594 28600 28608 28609 28613 28643
------------------------------------------------------------------------------

-------------------- Saved: 4600 of 5144 in MLC_Text_edit --------------------
28644 28659 28660 28662 28666 28667 28668 28674 28684 28708 28719 28777 28811 28814 28819 28830 28833 28843 28844 28846 28849 28856 28861 28869 28925 28950 28951 28952 28953 28954 28955 28956 28957 28958 28959 28960 28961 28962 28963 28964 28965 28967 28968 28969 28970 28971 28974 28985 28993 28994
------------------------------------------------------------------------------

-------------------- Saved: 4650 of 5144 in MLC_Text_edit --------------------
28995 28996 28998 28999 29000 29001 29006 29014 29024 29036 29066 29067 29069 29071 29072 29076 29077 29078 29079 29082 29083 29084 29086 29087 29088 29089 29090 29091 29092 29093 29096 29097 29099 29103 29109 29110 29111 29115 29154 29155 29157 29173 29186 29187 29195 29198 29216 29217 29233 29247
------------------------------------------------------------------------------

-------------------- Saved: 4700 of 5144 in MLC_Text_edit --------------------
29291 29311 29331 29408 29410 29431 29432 29445 29450 29452 29453 29454 29455 29525 29530 29531 29532 29533 29534 29535 29536 29537 29538 29562 29563 29584 29588 29689 29703 29718 29794 29876 29973 29974 29975 29976 29979 29985 29986 30001 30017 30021 30036 30040 30084 30095 30104 30107 30148 30886
------------------------------------------------------------------------------

-------------------- Saved: 4750 of 5144 in MLC_Text_edit --------------------
30888 30889 30900 30910 30911 30915 30930 30933 30934 30936 30937 30939 30941 30945 30946 30949 30952 30954 30961 30970 31151 31152 31157 31158 31161 31165 31166 31167 31168 31169 31172 31209 31210 31211 31212 31276 31346 31348 31355 31362 31365 31388 31390 31391 31392 31393 31395 31425 31426 31435
------------------------------------------------------------------------------

-------------------- Saved: 4800 of 5144 in MLC_Text_edit --------------------
31466 31500 31501 31502 31503 31516 31581 31631 31662 31823 31824 31825 31826 31828 31838 31840 31852 31855 31860 31889 31896 31925 31932 31945 31960 32399 32436 32440 32443 32446 32498 32499 32507 32568 32571 32573 32574 32575 32591 32595 32803 32830 32839 32910 32911 32912 32913 32914 32933 32947
------------------------------------------------------------------------------

-------------------- Saved: 4850 of 5144 in MLC_Text_edit --------------------
32956 33032 33070 33073 33076 33078 33079 33080 33081 33082 33084 33086 33087 33098 33105 33109 33110 33115 33232 33233 33234 33235 33240 33339 33340 33341 33342 33343 33344 33345 33346 33347 33348 33349 33350 33351 33352 33353 33354 33355 33356 33357 33358 33359 33361 33371 33374 33375 33381 33382
------------------------------------------------------------------------------

-------------------- Saved: 4900 of 5144 in MLC_Text_edit --------------------
33383 33445 33522 33526 33528 33529 33534 33536 33538 33546 33548 33549 33550 33551 33552 33553 33563 33564 33683 33684 33710 33737 33854 33902 33905 33907 33908 34281 34282 34333 34337 34456 34551 34563 34578 34583 34584 34586 34602 34612 34614 34662 34690 34706 34707 34872 34904 34941 34946 34948
------------------------------------------------------------------------------

-------------------- Saved: 4950 of 5144 in MLC_Text_edit --------------------
34949 34996 35016 35266 35350 35402 35403 35404 35408 35410 35411 35416 35430 35576 35610 35649 35653 35718 35750 35753 35859 35861 35888 35891 35894 36052 36053 36170 36215 36217 36272 36537 36542 36570 36617 36713 36716 37018 37288 37305 37347 37350 37351 37354 37685 37699 37708 37709 37757 37758
------------------------------------------------------------------------------

-------------------- Saved: 5000 of 5144 in MLC_Text_edit --------------------
37759 37788 37791 37793 37864 37865 37866 37892 37985 37986 37989 37990 37992 37993 37994 37995 37997 38084 38103 38106 38108 38109 38208 38210 38217 38309 38370 38374 38376 38378 38379 38425 38426 38606 38712 38713 38714 38716 38717 38718 38719 38720 38721 38722 38848 39005 39008 39010 39017 39024
------------------------------------------------------------------------------

-------------------- Saved: 5050 of 5144 in MLC_Text_edit --------------------
39027 39085 39102 39103 39105 39106 39108 39111 39121 39122 39147 39209 39224 39225 39268 39285 39326 39336 39344 39347 39349 39357 39487 39505 39507 39508 39543 39544 39561 39621 39623 39789 39824 39851 39862 39872 39889 39926 39929 39930 40115 40211 40227 40295 40297 40327 40336 40402 40405 40412
------------------------------------------------------------------------------

-------------------- Saved: 5100 of 5144 in MLC_Text_edit --------------------
40418 40419 40424 40433 40435 40456 40475 40510 40512 40581 40675 40676 40682 40752 40760 40764 40819 40820 40822 40823 40825 40826 40827 40828 40830 40838 40967 41001 41006 41013 41014 41061 41062 41063 41064 41067 41068 41069 41070 41071 41072 41073 41074 41075 41076 41092 41306 41330 41609 41611
------------------------------------------------------------------------------

-------------------- Saved: 5144 of 5144 in MLC_Text_edit --------------------
41748 41752 41803 41809 41824 41863 41883 41884 41885 41906 42055 42098 42102 42116 42136 42244 42418 42419 42421 42425 42426 42427 42452 43179 43180 43337 43339 43340 43346 43348 43349 43350 43354 43360 43374 43375 43452 43495 43496 43498 43501 43502 43503 43504
------------------------------------------------------------------------------


TR 487/554/611 EST migration...
See migrateEST.MGD.mgd.log for details of EST migration

TR 487: Get UniGene cluster data...
['fileByUrl.py', 'ftp://ftp.ncbi.nlm.nih.gov/repository/UniGene/Mm.data.Z']

Load UniGene cluster associations...

Date:   Sat Nov 20 21:31:46 1999
Server: MGD  Database: mgd

Using existing UniGene input file: ./Mm.data.
Loading UniGene input file...

bcp file = /usr/tmp/@18898.1 #records = 4644

Incremental loading of Accession and Accession References:
DEBUG echo glider | bcp tempdb..unigeneAcc in /usr/tmp/@18898.1 -S MGD -U mgd_dbo -c -t '|' -m 1
Password: 

Starting copy...
1000 rows sent to SQL Server.
2000 rows sent to SQL Server.
3000 rows sent to SQL Server.
4000 rows sent to SQL Server.

4644 rows copied.
Clock Time (ms.): total = 1  Avg = 0 (4644000.00 rows per sec.)
4644 UG links.
0 obsolete UG accession records removed.
4644 new UG accession records added.
0 existing UG accession records.

TR 487: Regenerate putatives based on UniGene cluster data...
Previous Download's thruDate: "Jan 7 1998 12:00AM "
Current Download's thruDate: "Oct 6 1999 12:00AM "
Getting putative relationships from dbEST...
Sat Nov 20 21:35:32 EST 1999
Sat Nov 20 21:38:21 EST 1999
Sat Nov 20 21:38:21 EST 1999
 
get mgd's IMAGE / _Probe_key mapping for clones...
Sat Nov 20 21:39:47 EST 1999
joining imageProbes.MGD.out with dbESTputatives.out...
chmod: WARNING: can't change dbESTputatives.out.join
Generate and load putative associations...
Sat Nov 20 21:40:12 EST 1999
Loading UniGene Cluster-SID and MGI SID-Gene associations... 

Processing input...
10000 dbEST input lines read
20000 dbEST input lines read
30000 dbEST input lines read
40000 dbEST input lines read
50000 dbEST input lines read
60000 dbEST input lines read
70000 dbEST input lines read
80000 dbEST input lines read
90000 dbEST input lines read
100000 dbEST input lines read
110000 dbEST input lines read
120000 dbEST input lines read
130000 dbEST input lines read
140000 dbEST input lines read
150000 dbEST input lines read
160000 dbEST input lines read
170000 dbEST input lines read
180000 dbEST input lines read
190000 dbEST input lines read
200000 dbEST input lines read

***************************************************************************

203926 lines processed: 
	147437 putative relationships 147437 PRB_Marker records output.
(Rows with no mapping onto corresponding MGD Clone: 0)

Loading putative associations...
Password: 

Starting copy...
1000 rows sent to SQL Server.
2000 rows sent to SQL Server.
3000 rows sent to SQL Server.
4000 rows sent to SQL Server.
5000 rows sent to SQL Server.
6000 rows sent to SQL Server.
7000 rows sent to SQL Server.
8000 rows sent to SQL Server.
9000 rows sent to SQL Server.
10000 rows sent to SQL Server.
11000 rows sent to SQL Server.
12000 rows sent to SQL Server.
13000 rows sent to SQL Server.
14000 rows sent to SQL Server.
15000 rows sent to SQL Server.
16000 rows sent to SQL Server.
17000 rows sent to SQL Server.
18000 rows sent to SQL Server.
19000 rows sent to SQL Server.
20000 rows sent to SQL Server.
21000 rows sent to SQL Server.
22000 rows sent to SQL Server.
23000 rows sent to SQL Server.
24000 rows sent to SQL Server.
25000 rows sent to SQL Server.
26000 rows sent to SQL Server.
27000 rows sent to SQL Server.
28000 rows sent to SQL Server.
29000 rows sent to SQL Server.
30000 rows sent to SQL Server.
31000 rows sent to SQL Server.
32000 rows sent to SQL Server.
33000 rows sent to SQL Server.
34000 rows sent to SQL Server.
35000 rows sent to SQL Server.
36000 rows sent to SQL Server.
37000 rows sent to SQL Server.
38000 rows sent to SQL Server.
39000 rows sent to SQL Server.
40000 rows sent to SQL Server.
41000 rows sent to SQL Server.
42000 rows sent to SQL Server.
43000 rows sent to SQL Server.
44000 rows sent to SQL Server.
45000 rows sent to SQL Server.
46000 rows sent to SQL Server.
47000 rows sent to SQL Server.
48000 rows sent to SQL Server.
49000 rows sent to SQL Server.
50000 rows sent to SQL Server.
51000 rows sent to SQL Server.
52000 rows sent to SQL Server.
53000 rows sent to SQL Server.
54000 rows sent to SQL Server.
55000 rows sent to SQL Server.
56000 rows sent to SQL Server.
57000 rows sent to SQL Server.
58000 rows sent to SQL Server.
59000 rows sent to SQL Server.
60000 rows sent to SQL Server.
61000 rows sent to SQL Server.
62000 rows sent to SQL Server.
63000 rows sent to SQL Server.
64000 rows sent to SQL Server.
65000 rows sent to SQL Server.
66000 rows sent to SQL Server.
67000 rows sent to SQL Server.
68000 rows sent to SQL Server.
69000 rows sent to SQL Server.
70000 rows sent to SQL Server.
71000 rows sent to SQL Server.
72000 rows sent to SQL Server.
73000 rows sent to SQL Server.
74000 rows sent to SQL Server.
75000 rows sent to SQL Server.
76000 rows sent to SQL Server.
77000 rows sent to SQL Server.
78000 rows sent to SQL Server.
79000 rows sent to SQL Server.
80000 rows sent to SQL Server.
81000 rows sent to SQL Server.
82000 rows sent to SQL Server.
83000 rows sent to SQL Server.
84000 rows sent to SQL Server.
85000 rows sent to SQL Server.
86000 rows sent to SQL Server.
87000 rows sent to SQL Server.
88000 rows sent to SQL Server.
89000 rows sent to SQL Server.
90000 rows sent to SQL Server.
91000 rows sent to SQL Server.
92000 rows sent to SQL Server.
93000 rows sent to SQL Server.
94000 rows sent to SQL Server.
95000 rows sent to SQL Server.
96000 rows sent to SQL Server.
97000 rows sent to SQL Server.
98000 rows sent to SQL Server.
99000 rows sent to SQL Server.
100000 rows sent to SQL Server.
101000 rows sent to SQL Server.
102000 rows sent to SQL Server.
103000 rows sent to SQL Server.
104000 rows sent to SQL Server.
105000 rows sent to SQL Server.
106000 rows sent to SQL Server.
107000 rows sent to SQL Server.
108000 rows sent to SQL Server.
109000 rows sent to SQL Server.
110000 rows sent to SQL Server.
111000 rows sent to SQL Server.
112000 rows sent to SQL Server.
113000 rows sent to SQL Server.
114000 rows sent to SQL Server.
115000 rows sent to SQL Server.
116000 rows sent to SQL Server.
117000 rows sent to SQL Server.
118000 rows sent to SQL Server.
119000 rows sent to SQL Server.
120000 rows sent to SQL Server.
121000 rows sent to SQL Server.
122000 rows sent to SQL Server.
123000 rows sent to SQL Server.
124000 rows sent to SQL Server.
125000 rows sent to SQL Server.
126000 rows sent to SQL Server.
127000 rows sent to SQL Server.
128000 rows sent to SQL Server.
129000 rows sent to SQL Server.
130000 rows sent to SQL Server.
131000 rows sent to SQL Server.
132000 rows sent to SQL Server.
133000 rows sent to SQL Server.
134000 rows sent to SQL Server.
135000 rows sent to SQL Server.
136000 rows sent to SQL Server.
137000 rows sent to SQL Server.
138000 rows sent to SQL Server.
139000 rows sent to SQL Server.
140000 rows sent to SQL Server.
141000 rows sent to SQL Server.
142000 rows sent to SQL Server.
143000 rows sent to SQL Server.
144000 rows sent to SQL Server.
145000 rows sent to SQL Server.
146000 rows sent to SQL Server.
147000 rows sent to SQL Server.

147437 rows copied.
Clock Time (ms.): total = 3000  Avg = 0 (49145.67 rows per sec.)
Processing putative assignments...
indexing...
Checking for Putatives superseded by an Encodes...
505 Putative records will not be loaded due to encodes relationship.

Remove putative records in PRB_Marker no longer supported in dbEST...
Eliminate input rows for existing relationships and
	where an Encodes relationship exists for the probe...
New rows loaded into PRB_Marker: 146939
Sat Nov 20 23:02:54 EST 1999
Rebuild MRK tables...
Sat Nov 20 23:02:54 1999
"./createMRK.py All" processing...
Creating MRK_Reference.bcp...
Creating MRK_Name.bcp...Sat Nov 20 23:05:41 1999
Creating MRK_Symbol.bcp...Sat Nov 20 23:05:58 1999
"./createMRK.py All" finished.
Sat Nov 20 23:06:10 1999
Password: 
1> 
2> use master
1> 
2> sp_dboption mgd,"select into",true
Database option 'select into/bulkcopy/pllsort' turned ON for database 'mgd'.
Run the CHECKPOINT command in the database that was changed.
(return status = 0) 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> truncate table MRK_Name
1> 
2> truncate table MRK_Reference
1> 
2> truncate table MRK_Symbol
Password: 
1> 
2> use mgd 
3> 
1> 
2> dump transaction mgd with truncate_only
1> 
2> drop index MRK_Name.index_name
1> 
2> drop index MRK_Name.index_Marker_key
1> 
2> drop index MRK_Name.index_Marker_Type_fkey
1> 
2> drop index MRK_Name.index_Marker_Type_name
1> 
2> drop index MRK_Name.index_modification_date
1> 
2> drop index MRK_Reference.index_auto
1> 
2> drop index MRK_Reference.index_Refs_key
1> 
2> drop index MRK_Reference.index_Marker_key
1> 
2> drop index MRK_Reference.index_Marker_Refs_key
1> 
2> drop index MRK_Reference.index_modification_date
1> 
2> drop index MRK_Symbol.index_symbol
1> 
2> drop index MRK_Symbol.index_Marker_key
1> 
2> drop index MRK_Symbol.index_Marker_Type_key
1> 
2> drop index MRK_Symbol.index_modification_date
1> 
2> drop index MRK_Symbol.index_Marker_Type_symbol_key
1> 
2> dump transaction mgd with truncate_only
1> 
2> checkpoint
Password: 

Starting copy...
1000 rows sent to SQL Server.
2000 rows sent to SQL Server.
3000 rows sent to SQL Server.
4000 rows sent to SQL Server.
5000 rows sent to SQL Server.
6000 rows sent to SQL Server.
7000 rows sent to SQL Server.
8000 rows sent to SQL Server.
9000 rows sent to SQL Server.
10000 rows sent to SQL Server.
11000 rows sent to SQL Server.
12000 rows sent to SQL Server.
13000 rows sent to SQL Server.
14000 rows sent to SQL Server.
15000 rows sent to SQL Server.
16000 rows sent to SQL Server.
17000 rows sent to SQL Server.
18000 rows sent to SQL Server.
19000 rows sent to SQL Server.
20000 rows sent to SQL Server.
21000 rows sent to SQL Server.
22000 rows sent to SQL Server.
23000 rows sent to SQL Server.
24000 rows sent to SQL Server.
25000 rows sent to SQL Server.
26000 rows sent to SQL Server.
27000 rows sent to SQL Server.
28000 rows sent to SQL Server.
29000 rows sent to SQL Server.
30000 rows sent to SQL Server.
31000 rows sent to SQL Server.
32000 rows sent to SQL Server.
33000 rows sent to SQL Server.
34000 rows sent to SQL Server.
35000 rows sent to SQL Server.
36000 rows sent to SQL Server.
37000 rows sent to SQL Server.
38000 rows sent to SQL Server.

38361 rows copied.
Clock Time (ms.): total = 6000  Avg = 0 (6393.50 rows per sec.)
Password: 

Starting copy...
1000 rows sent to SQL Server.
2000 rows sent to SQL Server.
3000 rows sent to SQL Server.
4000 rows sent to SQL Server.
5000 rows sent to SQL Server.
6000 rows sent to SQL Server.
7000 rows sent to SQL Server.
8000 rows sent to SQL Server.
9000 rows sent to SQL Server.
10000 rows sent to SQL Server.
11000 rows sent to SQL Server.
12000 rows sent to SQL Server.
13000 rows sent to SQL Server.
14000 rows sent to SQL Server.
15000 rows sent to SQL Server.
16000 rows sent to SQL Server.
17000 rows sent to SQL Server.
18000 rows sent to SQL Server.
19000 rows sent to SQL Server.
20000 rows sent to SQL Server.
21000 rows sent to SQL Server.
22000 rows sent to SQL Server.
23000 rows sent to SQL Server.
24000 rows sent to SQL Server.
25000 rows sent to SQL Server.
26000 rows sent to SQL Server.
27000 rows sent to SQL Server.
28000 rows sent to SQL Server.
29000 rows sent to SQL Server.
30000 rows sent to SQL Server.
31000 rows sent to SQL Server.
32000 rows sent to SQL Server.
33000 rows sent to SQL Server.
34000 rows sent to SQL Server.
35000 rows sent to SQL Server.
36000 rows sent to SQL Server.
37000 rows sent to SQL Server.
38000 rows sent to SQL Server.
39000 rows sent to SQL Server.
40000 rows sent to SQL Server.
41000 rows sent to SQL Server.
42000 rows sent to SQL Server.
43000 rows sent to SQL Server.
44000 rows sent to SQL Server.
45000 rows sent to SQL Server.
46000 rows sent to SQL Server.
47000 rows sent to SQL Server.
48000 rows sent to SQL Server.
49000 rows sent to SQL Server.
50000 rows sent to SQL Server.
51000 rows sent to SQL Server.
52000 rows sent to SQL Server.
53000 rows sent to SQL Server.
54000 rows sent to SQL Server.
55000 rows sent to SQL Server.
56000 rows sent to SQL Server.
57000 rows sent to SQL Server.
58000 rows sent to SQL Server.
59000 rows sent to SQL Server.
60000 rows sent to SQL Server.
61000 rows sent to SQL Server.
62000 rows sent to SQL Server.
63000 rows sent to SQL Server.
64000 rows sent to SQL Server.
65000 rows sent to SQL Server.
66000 rows sent to SQL Server.
67000 rows sent to SQL Server.
68000 rows sent to SQL Server.
69000 rows sent to SQL Server.
70000 rows sent to SQL Server.
71000 rows sent to SQL Server.
72000 rows sent to SQL Server.
73000 rows sent to SQL Server.
74000 rows sent to SQL Server.
75000 rows sent to SQL Server.
76000 rows sent to SQL Server.
77000 rows sent to SQL Server.
78000 rows sent to SQL Server.
79000 rows sent to SQL Server.
80000 rows sent to SQL Server.
81000 rows sent to SQL Server.
82000 rows sent to SQL Server.
83000 rows sent to SQL Server.
84000 rows sent to SQL Server.
85000 rows sent to SQL Server.
86000 rows sent to SQL Server.
87000 rows sent to SQL Server.
88000 rows sent to SQL Server.
89000 rows sent to SQL Server.
90000 rows sent to SQL Server.
91000 rows sent to SQL Server.
92000 rows sent to SQL Server.
93000 rows sent to SQL Server.
94000 rows sent to SQL Server.
95000 rows sent to SQL Server.
96000 rows sent to SQL Server.
97000 rows sent to SQL Server.
98000 rows sent to SQL Server.
99000 rows sent to SQL Server.
100000 rows sent to SQL Server.
101000 rows sent to SQL Server.
102000 rows sent to SQL Server.
103000 rows sent to SQL Server.
104000 rows sent to SQL Server.
105000 rows sent to SQL Server.
106000 rows sent to SQL Server.
107000 rows sent to SQL Server.
108000 rows sent to SQL Server.
109000 rows sent to SQL Server.
110000 rows sent to SQL Server.
111000 rows sent to SQL Server.
112000 rows sent to SQL Server.
113000 rows sent to SQL Server.
114000 rows sent to SQL Server.
115000 rows sent to SQL Server.
116000 rows sent to SQL Server.
117000 rows sent to SQL Server.
118000 rows sent to SQL Server.
119000 rows sent to SQL Server.
120000 rows sent to SQL Server.
121000 rows sent to SQL Server.
122000 rows sent to SQL Server.
123000 rows sent to SQL Server.
124000 rows sent to SQL Server.
125000 rows sent to SQL Server.
126000 rows sent to SQL Server.
127000 rows sent to SQL Server.
128000 rows sent to SQL Server.
129000 rows sent to SQL Server.

129218 rows copied.
Clock Time (ms.): total = 17000  Avg = 0 (7601.06 rows per sec.)
Password: 

Starting copy...
1000 rows sent to SQL Server.
2000 rows sent to SQL Server.
3000 rows sent to SQL Server.
4000 rows sent to SQL Server.
5000 rows sent to SQL Server.
6000 rows sent to SQL Server.
7000 rows sent to SQL Server.
8000 rows sent to SQL Server.
9000 rows sent to SQL Server.
10000 rows sent to SQL Server.
11000 rows sent to SQL Server.
12000 rows sent to SQL Server.
13000 rows sent to SQL Server.
14000 rows sent to SQL Server.
15000 rows sent to SQL Server.
16000 rows sent to SQL Server.
17000 rows sent to SQL Server.
18000 rows sent to SQL Server.
19000 rows sent to SQL Server.
20000 rows sent to SQL Server.
21000 rows sent to SQL Server.
22000 rows sent to SQL Server.
23000 rows sent to SQL Server.
24000 rows sent to SQL Server.
25000 rows sent to SQL Server.
26000 rows sent to SQL Server.
27000 rows sent to SQL Server.
28000 rows sent to SQL Server.
29000 rows sent to SQL Server.
30000 rows sent to SQL Server.
31000 rows sent to SQL Server.
32000 rows sent to SQL Server.
33000 rows sent to SQL Server.

33864 rows copied.
Clock Time (ms.): total = 5000  Avg = 0 (6772.80 rows per sec.)
Password: 
1> 
2> use mgd 
3> 
1> 
2> dump transaction mgd with truncate_only
1> 
2> create nonclustered  index index_Marker_Type_fkey on MRK_Name ( _Marker_Type_key ) on mgd_seg_1
1> 
2> create nonclustered  index index_modification_date on MRK_Name ( modification_date ) on mgd_seg_1
1> 
2> create nonclustered  index index_name on MRK_Name ( name ) on mgd_seg_1
1> 
2> create nonclustered  index index_Marker_key on MRK_Name ( _Marker_key ) on mgd_seg_1
1> 
2> create unique clustered  index index_Marker_Type_name on MRK_Name ( _Marker_key, _Marker_Type_key, name ) on mgd_seg_0
Non-clustered index (index id = 2) is being rebuilt.
Non-clustered index (index id = 3) is being rebuilt.
Non-clustered index (index id = 4) is being rebuilt.
Non-clustered index (index id = 5) is being rebuilt.
1> 
2> /* see tr 375 */
3> 
4> /*create unique clustered  index index_Marker_Refs_key on MRK_Reference ( _Marker_key, _Refs_key ) on mgd_seg_0*/
5> /*go*/
6> 
7> CREATE UNIQUE CLUSTERED INDEX index_Marker_Refs_key ON MRK_Reference
8> (
9>    _Marker_key,
10>    _Refs_key,
11>    auto
12> )
13> ON mgd_seg_0
1> 
2> create nonclustered  index index_Marker_key on MRK_Reference ( _Marker_key ) on mgd_seg_1
1> 
2> create nonclustered  index index_Refs_key on MRK_Reference ( _Refs_key ) on mgd_seg_1
1> 
2> create nonclustered  index index_auto on MRK_Reference ( auto ) on mgd_seg_1
1> 
2> create nonclustered  index index_modification_date on MRK_Reference ( modification_date ) on mgd_seg_1
1> 
2> create nonclustered  index index_modification_date on MRK_Symbol ( modification_date ) on mgd_seg_1
1> 
2> create nonclustered  index index_Marker_Type_key on MRK_Symbol ( _Marker_Type_key ) on mgd_seg_1
1> 
2> create nonclustered  index index_symbol on MRK_Symbol ( symbol ) on mgd_seg_1
1> 
2> create nonclustered  index index_Marker_key on MRK_Symbol ( _Marker_key ) on mgd_seg_1
1> 
2> create unique clustered  index index_Marker_Type_symbol_key on MRK_Symbol ( _Marker_key, _Marker_Type_key, symbol ) on mgd_seg_0
Non-clustered index (index id = 2) is being rebuilt.
Non-clustered index (index id = 3) is being rebuilt.
Non-clustered index (index id = 4) is being rebuilt.
Non-clustered index (index id = 5) is being rebuilt.
1> 
2> dump transaction mgd with truncate_only
1> 
2> checkpoint
Sat Nov 20 23:07:13 EST 1999
