Script started on Tue Apr 06 08:26:32 1999
sybase@kelso:1> ls
MGI.log               SCCS                  tr130.py
MGI.sh                last_load.log
MappingText.sql       release_script.merge
sybase@kelso:2> release_script.merge MGD mgd
Password: 
1> 
2> use mgd 
1> 
2> select 'TR#244 change ACC_ActualDB.url column from null to not null.'
                                                              
 ------------------------------------------------------------ 
 TR#244 change ACC_ActualDB.url column from null to not null. 

(1 row affected)
1> 
2> execute sp_unbindefault "ACC_ActualDB.active"
Default unbound from table column.
(return status = 0)
1> 
2> execute sp_unbindefault "ACC_ActualDB.allowsMultiple"
Default unbound from table column.
(return status = 0)
1> 
2> execute sp_unbindefault "ACC_ActualDB.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> execute sp_unbindefault "ACC_ActualDB.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> execute sp_unbindefault "ACC_ActualDB.release_date"
Default unbound from table column.
(return status = 0)
1>       
2> execute sp_rename ACC_ActualDB,ACC_ActualDB_Temp
Object name has been changed.
(return status = 0)
1> 
2> CREATE TABLE ACC_ActualDB (
3>        _ActualDB_key        int NOT NULL,
4>        _LogicalDB_key       int NOT NULL,
5>        name                 varchar(80) NOT NULL,
6>        active               bit NOT NULL,
7>        url                  varchar(255) NOT NULL,
8>        allowsMultiple       bit NOT NULL,
9>        delimiter            char(8) NULL,
10>        creation_date        datetime NOT NULL,
11>        modification_date    datetime NOT NULL,
12>        release_date         datetime NULL
13> ) on mgd_seg_0
1> 
2> CREATE UNIQUE INDEX index_name ON ACC_ActualDB
3> (
4>        name
5> ) on mgd_seg_0
1> 
2> CREATE INDEX index_LogicalDB_key ON ACC_ActualDB
3> (
4>        _LogicalDB_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX index_modification_date ON ACC_ActualDB
3> (
4>        modification_date
5> ) on mgd_seg_1
1> 
2> exec sp_primarykey ACC_ActualDB, _ActualDB_key
New primary key added.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'ACC_ActualDB.active'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'ACC_ActualDB.allowsMultiple'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_ActualDB.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_ActualDB.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_ActualDB.release_date'
Default bound to column.
(return status = 0)
1> 
2> INSERT INTO ACC_ActualDB 
3> (_ActualDB_key, _LogicalDB_key, name, active, url, 
4> allowsMultiple, delimiter, creation_date, modification_date, release_date) 
5> SELECT _ActualDB_key, _LogicalDB_key, name, active, url, allowsMultiple, 
6> delimiter, creation_date, modification_date, release_date
7> FROM 
8> ACC_ActualDB_Temp
(30 rows affected)
1> 
2> DROP TABLE ACC_ActualDB_Temp
1> 
2> exec sp_foreignkey ACC_ActualDB, ACC_LogicalDB, _LogicalDB_key
New foreign key added.
(return status = 0)
1> 
2> select 'TR#135 CREATE new Table GXD_GelControl WTS'
                                            
 ------------------------------------------ 
 TR#135 CREATE new Table GXD_GelControl WTS 

(1 row affected)
1> 
2> CREATE TABLE GXD_GelControl (
3>        _GelControl_key      int NOT NULL,
4>        gelLaneContent       varchar(255) NOT NULL,
5>        creation_date        datetime NOT NULL,
6>        modification_date    datetime NOT NULL
7> ) on mgd_seg_0
1> 
2> /*
3> Data migration: GelLane.isControl=0 to 'No' in GXD_GelControl.gelLaneContent
4>                 GelLane.isControl=1 to 'Control: no data stored' in GXD_GelControl.gelLaneContent 
5> Other values:  'Transgenic: no data stored'
6>                'In Vitro data: no data stored'
7>                'Non-mouse species: no data stored'
8> */
9> 
10> insert into GXD_GelControl values (1, 'No', getDate(), getDate()) /*Control keys don't start at zero: lec */
(1 row affected)
1> 
2> insert into GXD_GelControl values (2, 'Control: no data stored', getDate(), getDate())
(1 row affected)
1> 
2> insert into GXD_GelControl values (3, 'Transgenic: no data stored', getDate(), getDate())
(1 row affected)
1> 
2> insert into GXD_GelControl values (4, 'In Vitro data: no data stored', getDate(), getDate())
(1 row affected)
1> 
2> insert into GXD_GelControl values (5, 'Non-mouse species: no data stored', getDate(), getDate())
(1 row affected)
1> 
2> /* Indexes */
3> 
4> create unique clustered index index_GelControl_key on GXD_GelControl
5> (_GelControl_key)
6> on mgd_seg_0
1> 
2> create nonclustered index index_modification_date on GXD_GelControl (modification_date)
3> on mgd_seg_1
1> 
2> /*Keys*/
3> 
4> execute sp_primarykey GXD_GelControl, _GelControl_key
New primary key added.
(return status = 0)
1> 
2> select 'WTS TR#188 Modify GXD_GelLane.laneLabel from varchar(20) to varchar(255)'
                                                                          
 ------------------------------------------------------------------------ 
 WTS TR#188 Modify GXD_GelLane.laneLabel from varchar(20) to varchar(255) 

(1 row affected)
1> 
2> select * into tempdb.dbo.GXD_GelLane
3> from mgd.dbo.GXD_GelLane
(38043 rows affected)
1> 
2> DROP TABLE GXD_GelLane
1> 
2> CREATE TABLE GXD_GelLane (
3>        _GelLane_key         int NOT NULL,
4>        _Assay_key           int NOT NULL,
5>        _Genotype_key        int NOT NULL,
6>        _GelRNAType_key      int NOT NULL,
7>        _GelControl_key      int NOT NULL,   /* tr#135 */
8>        sequenceNum          int NOT NULL,
9>        laneLabel            varchar(255) NULL,
10>        sampleAmount         float NULL,
11>        sex                  varchar(15) NOT NULL,
12>        age                  varchar(50) NOT NULL,
13>        ageMin               float NULL,
14>        ageMax               float NULL,
15>        ageNote              varchar(255) NULL,
16>        laneNote             varchar(255) NULL,
17>        creation_date        datetime NOT NULL,
18>        modification_date    datetime NOT NULL
19> ) on mgd_seg_0
1> 
2> /* Data migration*/
3>  
4> insert into GXD_GelLane select _GelLane_key, _Assay_key, 
5> _Genotype_key, _GelRNAType_key, isControl, sequenceNum, 
6> laneLabel, sampleAmount, sex, age, ageMin, ageMax, ageNote, 
7> laneNote, creation_date, modification_date
8> from tempdb.dbo.GXD_GelLane
(38043 rows affected)
1> 
2> /* The _GelControl_key can't start at 0 so need to shift 0 to 1 and 1 to 2 */
3> update GXD_Gellane
4> set _GelControl_key = 2
5> where _GelControl_key = 1
(2080 rows affected)
1> 
2> update GXD_Gellane
3> set _GelControl_key = 1
4> where _GelControl_key =0
(35963 rows affected)
1> 
2> drop table tempdb.dbo.GXD_GelLane
1> 
2> /* Indexes*/
3> 
4> CREATE UNIQUE CLUSTERED INDEX index_GelLane_key ON GXD_GelLane (_GelLane_key)
5> with sorted_data
6> on mgd_seg_0
1> 
2> create nonclustered index index_modification_date on GXD_GelLane (modification_date)
3> on mgd_seg_1
1> 
2> create nonclustered index index_Assay_key on GXD_GelLane(_Assay_key)
3> on mgd_seg_1
1> 
2> create nonclustered index index_Genotype_key on GXD_GelLane(_Genotype_key)
3> on mgd_seg_1
1> 
2> create nonclustered index index_GelRNAType_key on GXD_GelLane(_GelRNAType_key)
3> on mgd_seg_1
1> 
2> create nonclustered index index_GelControl_key on GXD_GelLane (_GelControl_key)
3> on mgd_seg_1
1> 
2> 
3> /*Keys*/
4> 
5> exec sp_primarykey GXD_GelLane, _GelLane_key
New primary key added.
(return status = 0)
1> 
2> /*Triggers*/
3> 
4> DROP TRIGGER GXD_GelLane_Delete
Msg 3701, Level 11, State 1:
Line 4:
Cannot drop the trigger 'GXD_GelLane_Delete', because it doesn't exist in the
system catalogs.
1> 
2> CREATE TRIGGER
3> GXD_GelLane_Delete
4> on GXD_GelLane
5> for DELETE
6> as
7> delete GXD_GelLaneStructure from GXD_GelLaneStructure, deleted
8> where GXD_GelLaneStructure._GelLane_key = deleted._GelLane_key
9> 
10> /* If Genotypes are specific to each specimen... */
11> 
12> if (select count(*) from GXD_GelLane, deleted
13>         where GXD_GelLane._Genotype_key = deleted._Genotype_key) = 1
14> begin
15>         delete GXD_Genotype from GXD_Genotype, deleted
16>         where GXD_Genotype._Genotype_key = deleted._Genotype_key
17> end
1> 
2> /*
3> ------------------------------------------------------------------------
4> */
5> select 'WTS TR#28 IMG_ImageNote table and IMG_Image table'
                                                   
 ------------------------------------------------- 
 WTS TR#28 IMG_ImageNote table and IMG_Image table 

(1 row affected)
1> 
2> CREATE TABLE IMG_ImageNote (
3>        _Image_key           int NOT NULL,
4>        sequenceNum          int NOT NULL,
5>        imageNote            varchar(255) NULL,
6>        creation_date        datetime NOT NULL,
7>        modification_date    datetime NOT NULL
8> ) on mgd_seg_0
1> 
2> /*
3> Data migration:
4> Migrate data from IMG_Image.imageNote to IMG_ImageNote.imageNote
5> */
6> 
7> insert into IMG_ImageNote select _Image_key, 1, imageNote,
8> creation_date, modification_date
9> from
10> mgd.dbo.IMG_Image
(1284 rows affected)
1> 
2> /*Indexes*/
3> 
4> CREATE UNIQUE CLUSTERED INDEX index_Image_key_sequenceNum ON IMG_ImageNote
5> (_Image_key, sequenceNum)
6> with sorted_data
7> on mgd_seg_0
1> 
2> create nonclustered index index_Image_key on IMG_ImageNote (_Image_key) on mgd_seg_1
1> 
2> create nonclustered index index_image_note on IMG_ImageNote (imageNote) on mgd_seg_1
1> 
2> create nonclustered index index_modification_date on IMG_ImageNote (modification_date)
3> on mgd_seg_1
1> 
2> /*Keys*/
3> 
4> exec sp_primarykey IMG_ImageNote, _Image_key, sequenceNum
New primary key added.
(return status = 0)
1> 
2> select * into tempdb.dbo.IMG_Image
3> from IMG_Image
(1284 rows affected)
1> 
2> drop table IMG_Image
1> 
2> CREATE TABLE IMG_Image (
3>        _Image_key           int NOT NULL,
4>        _Refs_key            int NOT NULL,
5>        xDim                 int NULL,
6>        yDim                 int NULL,
7>        figureLabel          varchar(255) NOT NULL, /* Removed imageNote */
8>        copyrightNote        varchar(255) NULL,
9>        creation_date        datetime NOT NULL,
10>        modification_date    datetime NOT NULL
11> )
12> on mgd_seg_0
1> 
2> /*Data migration*/
3> 
4> insert into IMG_Image select _Image_key, _Refs_key, 
5> xDim, yDim, figureLabel, copyrightNote, creation_date, modification_date
6> from
7> tempdb.dbo.IMG_Image
(1284 rows affected)
1> 
2> drop table tempdb.dbo.IMG_Image
1> 
2> /* Indexes*/
3> 
4> CREATE UNIQUE CLUSTERED INDEX _IMG_Image_idx ON IMG_Image (_Image_key) WITH SORTED_DATA
5> ON mgd_seg_0
1> 
2> CREATE INDEX index_modification_date ON IMG_Image (modification_date)
3> ON mgd_seg_1
1> 
2> CREATE INDEX index_Refs_key ON IMG_Image (_Refs_key)
3> ON mgd_seg_1
1> 
2> /*Keys*/
3> 
4> exec sp_primarykey IMG_Image, _Image_key
New primary key added.
(return status = 0)
1> 
2> /*Views*/
3> 
4> drop view IMG_Image_View
1> 
2> create view IMG_Image_View
3> as
4> select i.*, mgiID = a.accID, a.prefixPart, a.numericPart,
5> c.jnumID, c.jnum, c.short_citation
6> from IMG_Image i, IMG_Image_Acc_View a, BIB_All_View c
7> where i._Image_key = a._Object_key
8> and a.prefixPart = "MGI:"
9> and a.preferred = 1
10> and i._Refs_key = c._Refs_key
1> 
2> /* 
3> --------------------------------------------------------------------
4> */
5> select 'GXD_Specimen WTS TR#135 '
                          
 ------------------------ 
 GXD_Specimen WTS TR#135  

(1 row affected)
1> 
2> select * into tempdb.dbo.GXD_Specimen
3> from GXD_Specimen
(2085 rows affected)
1> 
2> drop table GXD_Specimen
1> 
2> CREATE TABLE GXD_Specimen (
3>        _Specimen_key        int NOT NULL,
4>        _Assay_key           int NOT NULL,
5>        _Embedding_key       int NOT NULL,
6>        _Fixation_key        int NOT NULL,
7>        _Genotype_key        int NOT NULL,
8>        sequenceNum          int NOT NULL,
9>        specimenLabel        varchar(255) NULL,
10>        sex                  varchar(15) NOT NULL,
11>        age                  varchar(50) NOT NULL,
12>        ageMin               float NULL,
13>        ageMax               float NULL,
14>        ageNote              varchar(255) NULL,
15>        hybridization        varchar(255) NOT NULL,  /* Changed from 15 to 255 */
16>        specimenNote         varchar(255) NULL,
17>        creation_date        datetime NOT NULL,
18>        modification_date    datetime NOT NULL
19> )
20> on mgd_seg_0
1> 
2> /*Data migration*/
3> 
4> INSERT INTO GXD_Specimen (_Specimen_key, _Assay_key, _Embedding_key, 
5>     _Fixation_key, _Genotype_key, sequenceNum, specimenLabel, sex, age, ageMin, 
6>     ageMax, ageNote, hybridization, specimenNote, creation_date, 
7>     modification_date) SELECT _Specimen_key, _Assay_key, _Embedding_key, 
8>     _Fixation_key, _Genotype_key, sequenceNum, specimenLabel, sex, age, ageMin, 
9>     ageMax, ageNote, hybridization, specimenNote, creation_date, 
10>     modification_date 
11> FROM 
12> tempdb.dbo.GXD_Specimen
(2085 rows affected)
1> 
2> DROP TABLE tempdb.dbo.GXD_Specimen
1> 
2> /*Indexes*/
3> 
4> create unique clustered index index_Specimen_key on GXD_Specimen
5> (
6>      _Specimen_key
7> ) 
8> with sorted_data
9> on mgd_seg_0
1> 
2> CREATE INDEX index_modification_date ON GXD_Specimen
3> (
4>        modification_date
5> ) on mgd_seg_1
1> 
2> CREATE INDEX index_Assay_key ON GXD_Specimen
3> (
4>        _Assay_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX index_Embedding_key ON GXD_Specimen
3> (
4>        _Embedding_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX index_Fixation_key ON GXD_Specimen
3> (
4>        _Fixation_key
5> ) on mgd_seg_1
1> 
2> CREATE INDEX index_Genotype_key ON GXD_Specimen
3> (
4>        _Genotype_key
5> ) on mgd_seg_1
1> 
2> /* Keys */
3> 
4> exec sp_primarykey GXD_Specimen, _Specimen_key
New primary key added.
(return status = 0)
1> 
2> 
3> /* Can't create triggers on system objects */
4> 
5> select 'WTS TR#322 MLC modifications'
                              
 ---------------------------- 
 WTS TR#322 MLC modifications 

(1 row affected)
1> 
2> /* Drop the MLC_History and MLC_History_edit tables.*/
3> 
4> drop table MLC_History
1> 
2> drop table MLC_History_edit
1> 
2> /* Add the following column to MLC_Text and MLC_Text_edit for storing the user id of the Editor who modifies the record: 
3> 
4> userID  varchar(30)     not null
5> */
6> 
7> execute sp_unbindefault "MLC_Text_edit.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> execute sp_unbindefault "MLC_Text_edit.modification_date"
Default unbound from table column.
(return status = 0)
1>       
2> /* make dpd the default for userID*/
3> sp_adduser dpd
New user added.
(return status = 0)
1> 
2> /* Need to allow select into */
3> use master
1> 
2> sp_dboption mgd, "select into", true
Database option 'select into/bulkcopy' turned ON for database 'mgd'.
Run the CHECKPOINT command in the database that was changed.
(return status = 0)
1> 
2> use mgd 
1> 
2> checkpoint
1> 
2> select _Marker_key ,mode,description, userID = name,creation_date, modification_date
3> into MLC_Text_edit_Temp
4> from
5> MLC_text_edit, sysusers
6> where
7> name =  'dpd'
(5072 rows affected)
1> 
2> drop table MLC_Text_edit
1> 
2> CREATE TABLE MLC_Text_edit (
3>        _Marker_key          int NOT NULL,
4>        mode                 varchar(60) NULL,
5>        description          text NULL,
6>        userID               varchar(30) NOT NULL, 
7>        creation_date        datetime NOT NULL,
8>        modification_date    datetime NOT NULL
9> ) on mgd_seg_0
1> 
2> insert into MLC_Text_edit
3> select * from MLC_Text_edit_Temp
(5072 rows affected)
1> 
2> CREATE INDEX index_modification_date ON MLC_Text_edit
3> (
4>        modification_date
5> )
1> 
2> exec sp_primarykey MLC_Text_edit,
3>        _Marker_key
New primary key added.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Text_edit.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Text_edit.modification_date'
Default bound to column.
(return status = 0)
1> 
2> DROP TABLE MLC_Text_edit_Temp
1> 
2> exec sp_foreignkey MLC_Text_edit, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1> 
2> /* Changes to MLC_Text */
3> 
4> execute sp_unbindefault "MLC_Text.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> execute sp_unbindefault "MLC_Text.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> select _Marker_key ,mode,description, userID = name,creation_date, modification_date
3> into MLC_Text_Temp
4> from
5> MLC_text, sysusers
6> where
7> name =  'dpd'
(5070 rows affected)
1> 
2> drop table MLC_Text
1> 
2> CREATE TABLE MLC_Text (
3>        _Marker_key          int NOT NULL,
4>        mode                 varchar(60) NULL,
5>        description          text NULL,
6>        userID               varchar(30) NOT NULL, 
7>        creation_date        datetime NOT NULL,
8>        modification_date    datetime NOT NULL
9> ) on mgd_seg_0
1> 
2> CREATE INDEX index_modification_date ON MLC_Text
3> (
4>        modification_date
5> )
1> 
2> INSERT INTO MLC_Text 
3> SELECT * FROM MLC_Text_Temp
(5070 rows affected)
1> 
2> exec sp_primarykey MLC_Text,
3>        _Marker_key
New primary key added.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Text.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Text.modification_date'
Default bound to column.
(return status = 0)
1> 
2> DROP TABLE MLC_Text_Temp
1> 
2> exec sp_foreignkey MLC_Text, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1> 
2> select 'WTS TR#327 Increase MLD_Expts.exptType from varchar(8) to a more appropriate length, say varchar(255).'  
 
                                                                                                                
  
        ------------------------------------------------------------------------------------------------------ 
 
         WTS TR#327 Increase MLD_Expts.exptType from varchar(8) to a more appropriate length, say varchar(255). 

(1 row affected)
1> 
2> execute sp_rename MLD_Expts, MLD_Expts_Temp
Object name has been changed.
(return status = 0)
1> 
2> CREATE TABLE MLD_Expts
3> (
4> _Expt_key    int     not null,
5> _Refs_key    int     not null,
6> exptType     varchar(255)    not null,
7> tag          int     not null,
8> chromosome   varchar(8)      not null,
9> creation_date        datetime        not null,
10> modification_date   datetime        not null
11> )
12> on mgd_seg_0
1> 
2> insert into MLD_Expts
3> select * 
4> FROM
5> MLD_Expts_Temp 
(13998 rows affected)
1> 
2> drop table MLD_Expts_temp
1> 
2> exec sp_primarykey MLD_Expts, _Expt_key
New primary key added.
(return status = 0)
1> 
2> create unique clustered index index_Expt_key on MLD_Expts (_Expt_key)
3> on mgd_seg_0
1> 
2> create nonclustered index index_Refs_key on MLD_Expts (_Refs_key)
3> on mgd_seg_1
1> 
2> create nonclustered index index_chromosome on MLD_Expts (chromosome)
3> on mgd_seg_1
1> 
2> create nonclustered index index_exptType on MLD_Expts (exptType)
3> on mgd_seg_1
1> 
2> create nonclustered index index_modification_date on MLD_Expts (modification_date)
3> on mgd_seg_1
1> 
2> sp_bindefault current_date_default, 'MLD_Expts.creation_date'
Default bound to column.
(return status = 0)
1> 
2> sp_bindefault current_date_default, 'MLD_Expts.modification_date'
Default bound to column.
(return status = 0)
1> 
2> /*
3> WTS TR#249 MGI_Tables and MGI_Columns
4> -------------------------------------
5> This script is to update MGD_Tables and MGD_Comments for the Feb 1999 Release 
6> JCG: Jan. 5, 1999 
7> */
8> 
9> select 'MGI Tables'
            
 ---------- 
 MGI Tables 

(1 row affected)
1> 
2> /* TABLES */
3> 
4> drop table MGI_Tables
Msg 3701, Level 11, State 1:
Line 4:
Cannot drop the table 'MGI_Tables', because it doesn't exist in the system
catalogs.
1> 
2> /* MGI_Tables: species is not needed */
3> 
4> CREATE TABLE MGI_Tables (
5>        _Table_id            int NOT NULL,      /* names can be obtained by joining ids to sysobjects */
6>        description          text NULL,
7>        creation_date        datetime NOT NULL,
8>        modification_date    datetime NOT NULL
9> ) on mgd_seg_0
1> 
2> /* migration from data in MGD_Tables */
3> 
4> insert into MGI_Tables 
5> select s.id, t.description, t.creation_date, t.modification_date
6> from sysobjects s, MGD_Tables t
7> where
8> s.name = t.name
9> and
10> s.type = 'U'
(132 rows affected)
1> 
2> drop table MGI_Columns
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the table 'MGI_Columns', because it doesn't exist in the system
catalogs.
1> 
2> /* For a unique primary key, need table and column number */
3> 
4> CREATE TABLE MGI_Columns (
5>        _Table_id            int NOT NULL,
6>        _Column_id           int NOT NULL,
7>        description          varchar(255) NULL,
8>        example              varchar(255) NULL,
9>        creation_date        datetime NOT NULL,
10>        modification_date    datetime NOT NULL
11> ) on mgd_seg_0
1> 
2> /* data migration from MGD_Comments */
3> 
4> insert into MGI_Columns
5> SELECT 
6> sysobjects.id, syscolumns.colid, 
7> MGD_Comments.description, MGD_Comments.example, 
8> MGD_Comments.creation_date, MGD_Comments.modification_date
9> FROM 
10> mgd.dbo.MGD_Comments MGD_Comments, syscolumns syscolumns, 
11> sysobjects sysobjects
12> WHERE 
13> sysobjects.id = syscolumns.id AND 
14> sysobjects.name = MGD_Comments.table_name AND 
15> syscolumns.name = MGD_Comments.col_name AND ((sysobjects.type='U'))
(578 rows affected)
1> 
2> drop table MGD_Comments
1> 
2> drop table MGD_Tables
1> 
2> select 'Defaults'
          
 -------- 
 Defaults 

(1 row affected)
1> 
2> /* DEFAULTS */
3> 
4> exec sp_bindefault current_date_default, 'MGI_Tables.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MGI_Tables.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MGI_Columns.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MGI_Columns.modification_date'
Default bound to column.
(return status = 0)
1> 
2> select 'Keys'
      
 ---- 
 Keys 

(1 row affected)
1> 
2> /* KEYS */
3> 
4> sp_primarykey MGI_Tables,
5>        _Table_id
New primary key added.
(return status = 0)
1> 
2> sp_primarykey MGI_Columns,
3>        _Table_id, _Column_id
New primary key added.
(return status = 0)
1> 
2> sp_foreignkey MGI_Tables, sysobjects, 
3>        _Table_id
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey MGI_Columns, MGI_Tables,
3>        _Table_id
New foreign key added.
(return status = 0)
1> 
2> /* 
3> Can't do this foreign key because MGI_Columns doesn't have number sp_foreignkey MGI_Columns, syscolumns, id, number, colid
4> */
5> 
6> select 'Indices'
         
 ------- 
 Indices 

(1 row affected)
1> 
2> /* INDICES */
3> 
4> CREATE UNIQUE CLUSTERED INDEX index_Table_key ON MGI_Tables
5> (
6>        _Table_id
7> )
8>        ON mgd_seg_0
1> 
2> 
3> CREATE INDEX index_modification_date ON MGI_Tables
4> (
5>        modification_date
6> )
7>        ON mgd_seg_1
1> 
2> CREATE INDEX index_creation_date ON MGI_Tables
3> (
4>        creation_date
5> )
6>        ON mgd_seg_1
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Table_key ON MGI_Columns
3> (
4>        _Table_id, _Column_id
5> )
6>        ON mgd_seg_0
1> 
2> 
3> CREATE INDEX index_modification_date ON MGI_Columns
4> (
5>        modification_date
6> )
7>        ON mgd_seg_1
1> 
2> CREATE INDEX index_creation_date ON MGI_Columns
3> (
4>        creation_date
5> )
6>        ON mgd_seg_1
1> use master
1> 
2> sp_dboption mgd, "select into", false 
Database option 'select into/bulkcopy' turned OFF for database 'mgd'.
Run the CHECKPOINT command in the database that was changed.
(return status = 0)
1> 
2> use mgd 
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> exec sp_addgroup 'progs'
A group with the specified name already exists.
(return status = 1)
1> 
2> exec sp_addgroup 'editors'
A group with the specified name already exists.
(return status = 1)
1> 
2> sp_dropuser mgd_public
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser mgd_dbo
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser jeo
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser sbs
No user with the specified name exists in the current database.
(return status = 1)
1> 
2> sp_dropuser plg
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser let
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser djr
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser lec
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser dradt
No user with the specified name exists in the current database.
(return status = 1)
1> 
2> sp_dropuser dab
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser gld
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser jcg
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser jjm
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser jblake
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser sfr
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser ksf
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser gtc
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser mlp
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser ljm
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser neb
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser rpp
No user with the specified name exists in the current database.
(return status = 1)
1> 
2> sp_dropuser jer
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser cjd
No user with the specified name exists in the current database.
(return status = 1)
1> 
2> sp_dropuser jak
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser lglass
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser jsb
No user with the specified name exists in the current database.
(return status = 1)
1> 
2> sp_dropuser rmb
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser sr
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser corrigan
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser jms
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser dph
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser apd
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser cml
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser pm
User has been dropped from current database.
(return status = 0)
1> 
2> sp_dropuser wjb
User has been dropped from current database.
(return status = 0)
1> 
2> sp_adduser mgd_public
New user added.
(return status = 0)
1> 
2> sp_adduser mgd_dbo
New user added.
(return status = 0)
1> 
2> sp_adduser jeo, jeo, editors
New user added.
(return status = 0)
1> 
2> sp_adduser sbs, sbs, editors
No login with the specified name exists.
(return status = 1)
1> 
2> sp_adduser plg, plg, editors
New user added.
(return status = 0)
1> 
2> sp_adduser let, let, editors
New user added.
(return status = 0)
1> 
2> sp_adduser djr, djr, editors
New user added.
(return status = 0)
1> 
2> sp_adduser lec, lec, progs
New user added.
(return status = 0)
1> 
2> sp_adduser dbradt, dbradt, editors
A user with the same name already exists in the database.
(return status = 1)
1> 
2> sp_adduser dab, dab, editors
New user added.
(return status = 0)
1> 
2> sp_adduser gld, gld, progs
New user added.
(return status = 0)
1> 
2> sp_adduser jcg, jcg, progs
New user added.
(return status = 0)
1> 
2> sp_adduser jjm, jjm, editors
New user added.
(return status = 0)
1> 
2> sp_adduser jblake, jblake, editors
New user added.
(return status = 0)
1> 
2> sp_adduser sfr, sfr, editors
New user added.
(return status = 0)
1> 
2> sp_adduser ksf, ksf, editors
New user added.
(return status = 0)
1> 
2> sp_adduser gtc, gtc, progs
New user added.
(return status = 0)
1> 
2> sp_adduser mlp, mlp, editors
New user added.
(return status = 0)
1> 
2> sp_adduser ljm, ljm, editors
New user added.
(return status = 0)
1> 
2> sp_adduser neb, neb, editors
New user added.
(return status = 0)
1> 
2> sp_adduser rpp, rpp, progs
No login with the specified name exists.
(return status = 1)
1> 
2> sp_adduser jer, jer, progs
New user added.
(return status = 0)
1> 
2> sp_adduser cjd, cjd, progs
No login with the specified name exists.
(return status = 1)
1> 
2> sp_adduser jak, jak, progs
New user added.
(return status = 0)
1> 
2> sp_adduser lglass, lglass, editors
New user added.
(return status = 0)
1> 
2> sp_adduser jsb, jsb, progs
No login with the specified name exists.
(return status = 1)
1> 
2> sp_adduser rmb, rmb, editors
New user added.
(return status = 0)
1> 
2> sp_adduser sr, sr, editors
New user added.
(return status = 0)
1> 
2> sp_adduser corrigan, corrigan, editors
New user added.
(return status = 0)
1> 
2> sp_adduser jms, jms, editors
New user added.
(return status = 0)
1> 
2> sp_adduser dph, dph, editors
New user added.
(return status = 0)
1> 
2> sp_adduser apd, apd, editors
New user added.
(return status = 0)
1> 
2> sp_adduser cml, cml, editors
New user added.
(return status = 0)
1> 
2> sp_adduser pm, pm, progs
New user added.
(return status = 0)
1> 
2> sp_adduser wjb, wjb,editors
New user added.
(return status = 0)
1> checkpoint
Password: 
1> 
2> use mgd 
1> 
2> dump transaction mgd with truncate_only
1> 
2> create unique clustered  index index_Accession_key on ACC_Accession ( _Accession_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'ACC_Accession'.  Drop the
existing clustered index 'index_Accession_key' before creating another
1> 
2> create nonclustered  index index_Object_key on ACC_Accession ( _Object_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_Accession' named 'index_Object_key'
1> 
2> create nonclustered  index index_numericPart on ACC_Accession ( numericPart ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_Accession' named 'index_numericPart'
1> 
2> create nonclustered  index index_LogicalDB_key on ACC_Accession ( _LogicalDB_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_Accession' named 'index_LogicalDB_key'
1> 
2> create nonclustered  index index_MGIType_key on ACC_Accession ( _MGIType_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_Accession' named 'index_MGIType_key'
1> 
2> create nonclustered  index index_prefixPart on ACC_Accession ( prefixPart ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_Accession' named 'index_prefixPart'
1> 
2> create nonclustered  index index_modification_date on ACC_Accession ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_Accession' named
'index_modification_date'
1> 
2> create nonclustered  index index_accID on ACC_Accession ( accID ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_Accession' named 'index_accID'
1> 
2> create nonclustered  index index_LogicalDB_MGI_Type_key on ACC_Accession ( _LogicalDB_key, _MGIType_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_Accession' named
'index_LogicalDB_MGI_Type_key'
1> 
2> create unique clustered  index index_prefixPart on ACC_AccessionMax ( prefixPart ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'ACC_AccessionMax'.  Drop
the existing clustered index 'index_prefixPart' before creating another
1> 
2> create nonclustered  index index_modification_date on ACC_AccessionMax ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_AccessionMax' named
'index_modification_date'
1> 
2> create unique clustered  index index_Acc_Refs_key on ACC_AccessionReference ( _Accession_key, _Refs_key ) 
3> on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'ACC_AccessionReference'. 
Drop the existing clustered index 'index_Acc_Refs_key' before creating another
1> 
2> create nonclustered  index index_Accession_key on ACC_AccessionReference ( _Accession_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_AccessionReference' named
'index_Accession_key'
1> 
2> create nonclustered  index index_modification_date on ACC_AccessionReference ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_AccessionReference' named
'index_modification_date'
1> 
2> create nonclustered  index index_Refs_key on ACC_AccessionReference ( _Refs_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_AccessionReference' named
'index_Refs_key'
1> 
2> create unique clustered  index index_ActualDB_key on ACC_ActualDB ( _ActualDB_key ) 
3> with sorted_data on mgd_seg_0
Non-clustered index (index id = 2) is being rebuilt.
Non-clustered index (index id = 3) is being rebuilt.
Non-clustered index (index id = 4) is being rebuilt.
1> 
2> create nonclustered  index index_LogicalDB_key on ACC_ActualDB ( _LogicalDB_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_ActualDB' named 'index_LogicalDB_key'
1> 
2> create unique nonclustered  index index_name on ACC_ActualDB ( name ) 
3> on mgd_seg_0
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_ActualDB' named 'index_name'
1> 
2> create nonclustered  index index_modification_date on ACC_ActualDB ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_ActualDB' named
'index_modification_date'
1> 
2> create unique clustered  index index_LogicalDB_key on ACC_LogicalDB ( _LogicalDB_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'ACC_LogicalDB'.  Drop the
existing clustered index 'index_LogicalDB_key' before creating another
1> 
2> create nonclustered  index index_Species_key on ACC_LogicalDB ( _Species_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_LogicalDB' named 'index_Species_key'
1> 
2> create nonclustered  index index_modification_date on ACC_LogicalDB ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_LogicalDB' named
'index_modification_date'
1> 
2> create unique nonclustered  index index_name on ACC_LogicalDB ( name ) 
3> on mgd_seg_0
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_LogicalDB' named 'index_name'
1> 
2> create unique clustered  index index_MGIType_key on ACC_MGIType ( _MGIType_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'ACC_MGIType'.  Drop the
existing clustered index 'index_MGIType_key' before creating another
1> 
2> create unique nonclustered  index index_name on ACC_MGIType ( name ) 
3> on mgd_seg_0
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_MGIType' named 'index_name'
1> 
2> create nonclustered  index index_modification_date on ACC_MGIType ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'ACC_MGIType' named 'index_modification_date'
1> 
2> create unique clustered  index index_Refs_key on BIB_Books ( _Refs_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'BIB_Books'.  Drop the
existing clustered index 'index_Refs_key' before creating another
1> 
2> create nonclustered  index index_modification_date on BIB_Books ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'BIB_Books' named 'index_modification_date'
1> 
2> create unique clustered  index index_Refs_key on BIB_Notes ( _Refs_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'BIB_Notes'.  Drop the
existing clustered index 'index_Refs_key' before creating another
1> 
2> create nonclustered  index index_note on BIB_Notes ( note ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'BIB_Notes' named 'index_note'
1> 
2> create nonclustered  index index_modification_date on BIB_Notes ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'BIB_Notes' named 'index_modification_date'
1> 
2> create nonclustered  index index_Refs_key_fk on BIB_Notes ( _Refs_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'BIB_Notes' named 'index_Refs_key_fk'
1> 
2> create unique clustered  index index_Refs_key on BIB_Refs ( _Refs_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'BIB_Refs'.  Drop the
existing clustered index 'index_Refs_key' before creating another
1> 
2> create nonclustered  index index_primary on BIB_Refs ( _primary ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'BIB_Refs' named 'index_primary'
1> 
2> create nonclustered  index index_authors on BIB_Refs ( authors ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'BIB_Refs' named 'index_authors'
1> 
2> create nonclustered  index index_year on BIB_Refs ( year ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'BIB_Refs' named 'index_year'
1> 
2> create nonclustered  index index_journal on BIB_Refs ( journal ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'BIB_Refs' named 'index_journal'
1> 
2> create nonclustered  index index_title on BIB_Refs ( title ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'BIB_Refs' named 'index_title'
1> 
2> create nonclustered  index index_dbs on BIB_Refs ( dbs ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'BIB_Refs' named 'index_dbs'
1> 
2> create nonclustered  index index_modification_date on BIB_Refs ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'BIB_Refs' named 'index_modification_date'
1> 
2> create nonclustered  index index_ReviewStatus_key on BIB_Refs ( _ReviewStatus_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'BIB_Refs' named 'index_ReviewStatus_key'
1> 
2> create unique clustered  index index_BIB_ReviewStatus_key on BIB_ReviewStatus ( _ReviewStatus_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'BIB_ReviewStatus'.  Drop
the existing clustered index 'index_BIB_ReviewStatus_key' before creating
another
1> 
2> create nonclustered  index index_modification_date on BIB_ReviewStatus ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'BIB_ReviewStatus' named
'index_modification_date'
1> 
2> create nonclustered  index index_creation_date on BIB_ReviewStatus ( creation_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'BIB_ReviewStatus' named
'index_creation_date'
1> 
2> create unique clustered  index index_Cross_key on CRS_Cross ( _Cross_key )with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'CRS_Cross'.  Drop the
existing clustered index 'index_Cross_key' before creating another
1> 
2> create nonclustered  index index_maleStrain_fkey on CRS_Cross ( _maleStrain_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Cross' named 'index_maleStrain_fkey'
1> 
2> create nonclustered  index index_femaleStrain_fkey on CRS_Cross ( _femaleStrain_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Cross' named 'index_femaleStrain_fkey'
1> 
2> create nonclustered  index index_strainHO_fkey on CRS_Cross ( _StrainHO_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Cross' named 'index_strainHO_fkey'
1> 
2> create nonclustered  index index_strainHT_fkey on CRS_Cross ( _StrainHT_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Cross' named 'index_strainHT_fkey'
1> 
2> create nonclustered  index index_whoseCross on CRS_Cross ( whoseCross )
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Cross' named 'index_whoseCross'
1> 
2> create nonclustered  index index_type on CRS_Cross ( type ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Cross' named 'index_type'
1> 
2> create nonclustered  index index_modification_date on CRS_Cross ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Cross' named 'index_modification_date'
1> 
2> create nonclustered  index index_modification_date on CRS_Matrix ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Matrix' named 'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key on CRS_Matrix ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Matrix' named 'index_Marker_key'
1> 
2> create nonclustered  index index_Cross_key on CRS_Matrix ( _Cross_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Matrix' named 'index_Cross_key'
1> 
2> create unique clustered  index index_Cross_Marker_key on CRS_Matrix ( _Cross_key, _Marker_key, otherSymbol, chromosome, rowNumber ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'CRS_Matrix'.  Drop the
existing clustered index 'index_Cross_Marker_key' before creating another
1> 
2> create unique clustered  index index_Cross_sequenceNum_key on CRS_Progeny ( _Cross_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'CRS_Progeny'.  Drop the
existing clustered index 'index_Cross_sequenceNum_key' before creating another
1> 
2> create nonclustered  index index_modification_date on CRS_Progeny ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Progeny' named 'index_modification_date'
1> 
2> create nonclustered  index index_Cross_key on CRS_Progeny ( _Cross_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Progeny' named 'index_Cross_key'
1> 
2> create nonclustered  index index_modification_date on CRS_References ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_References' named
'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key on CRS_References ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_References' named 'index_Marker_key'
1> 
2> create nonclustered  index index_Cross_key on CRS_References ( _Cross_key )
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_References' named 'index_Cross_key'
1> 
2> create unique clustered  index index_Cross_Marker_Refs_key on CRS_References ( _Cross_key, _Marker_key, _Refs_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'CRS_References'.  Drop the
existing clustered index 'index_Cross_Marker_Refs_key' before creating another
1> 
2> create nonclustered  index index_modification_date on CRS_Typings ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Typings' named 'index_modification_date'
1> 
2> create nonclustered  index index_cross_key on CRS_Typings ( _Cross_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Typings' named 'index_cross_key'
1> 
2> create unique clustered  index index_Cross_row_col_key on CRS_Typings ( _Cross_key, rowNumber, colNumber ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'CRS_Typings'.  Drop the
existing clustered index 'index_Cross_row_col_key' before creating another
1> 
2> create nonclustered  index index_Cross_key_rowNumber on CRS_Typings ( _Cross_key, rowNumber ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'CRS_Typings' named
'index_Cross_key_rowNumber'
1> 
2> create unique clustered  index index_index_id on GXD_Index ( index_id ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_Index'.  Drop the
existing clustered index 'index_index_id' before creating another
1> 
2> create nonclustered  index index_modification_date on GXD_Index ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Index' named 'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key on GXD_Index ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Index' named 'index_Marker_key'
1> 
2> create nonclustered  index index_Refs_key on GXD_Index ( _Refs_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Index' named 'index_Refs_key'
1> 
2> create unique clustered  index index_id_stage_id on GXD_Index_Stages ( index_id, stage_id ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_Index_Stages'.  Drop
the existing clustered index 'index_id_stage_id' before creating another
1> 
2> create nonclustered  index index_index_id on GXD_Index_Stages ( index_id ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Index_Stages' named 'index_index_id'
1> 
2> create nonclustered  index index_modification_date on GXD_Index_Stages ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Index_Stages' named
'index_modification_date'
1> 
2> create unique clustered  index index_Assay_key on HMD_Assay ( _Assay_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'HMD_Assay'.  Drop the
existing clustered index 'index_Assay_key' before creating another
1> 
2> create unique nonclustered  index index_assay on HMD_Assay ( assay ) 
3> on mgd_seg_0
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Assay' named 'index_assay'
1> 
2> create nonclustered  index index_modification_date on HMD_Assay ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Assay' named 'index_modification_date'
1> 
2> create unique clustered  index index_Class_key on HMD_Class ( _Class_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'HMD_Class'.  Drop the
existing clustered index 'index_Class_key' before creating another
1> 
2> create nonclustered  index index_modification_date on HMD_Class ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Class' named 'index_modification_date'
1> 
2> create unique clustered  index index_Homology_key on HMD_Homology ( _Homology_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'HMD_Homology'.  Drop the
existing clustered index 'index_Homology_key' before creating another
1> 
2> create nonclustered  index index_Class_fkey on HMD_Homology ( _Class_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Homology' named 'index_Class_fkey'
1> 
2> create nonclustered  index index_Refs_fkey on HMD_Homology ( _Refs_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Homology' named 'index_Refs_fkey'
1> 
2> create nonclustered  index index_modification_date on HMD_Homology ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Homology' named
'index_modification_date'
1> 
2> create unique clustered  index index_Homology_Assay_key on HMD_Homology_Assay ( _Assay_key, _Homology_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'HMD_Homology_Assay'.  Drop
the existing clustered index 'index_Homology_Assay_key' before creating another
1> 
2> create nonclustered  index index_Assay_key on HMD_Homology_Assay ( _Assay_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Homology_Assay' named 'index_Assay_key'
1> 
2> create nonclustered  index index_modification_date on HMD_Homology_Assay ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Homology_Assay' named
'index_modification_date'
1> 
2> create nonclustered  index index_Homology_fkey on HMD_Homology_Assay ( _Homology_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Homology_Assay' named
'index_Homology_fkey'
1> 
2> create unique clustered  index index_Homology_Marker_key on HMD_Homology_Marker ( _Homology_key, _Marker_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'HMD_Homology_Marker'. 
Drop the existing clustered index 'index_Homology_Marker_key' before creating
another
1> 
2> create nonclustered  index index_Marker_fkey on HMD_Homology_Marker ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Homology_Marker' named
'index_Marker_fkey'
1> 
2> create nonclustered  index index_Homology_fkey on HMD_Homology_Marker ( _Homology_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Homology_Marker' named
'index_Homology_fkey'
1> 
2> create nonclustered  index index_modification_date on HMD_Homology_Marker ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Homology_Marker' named
'index_modification_date'
1> 
2> create unique clustered  index index_Homology_sequenceNum_key on HMD_Notes ( _Homology_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'HMD_Notes'.  Drop the
existing clustered index 'index_Homology_sequenceNum_key' before creating
another
1> 
2> create nonclustered  index index_modification_date on HMD_Notes ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Notes' named 'index_modification_date'
1> 
2> create nonclustered  index index_Homology_fkey on HMD_Notes ( _Homology_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Notes' named 'index_Homology_fkey'
1> 
2> create nonclustered  index index_notes on HMD_Notes ( notes ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'HMD_Notes' named 'index_notes'
1> 
2> create unique clustered  index index_table_col_name on MGD_Comments ( table_name, col_name ) 
3> with sorted_data on mgd_seg_0
Msg 1906, Level 16, State 1:
Line 2:
Cannot create an index on table 'MGD_Comments', because this table does not
exist in database 'mgd'.
1> 
2> create nonclustered  index index_modification_date on MGD_Comments ( modification_date ) 
3> on mgd_seg_1
Msg 1906, Level 16, State 1:
Line 2:
Cannot create an index on table 'MGD_Comments', because this table does not
exist in database 'mgd'.
1> 
2> create unique clustered  index index_name on MGD_Tables ( name ) 
3> with sorted_data on mgd_seg_0
Msg 1906, Level 16, State 1:
Line 2:
Cannot create an index on table 'MGD_Tables', because this table does not exist
in database 'mgd'.
1> 
2> create nonclustered  index index_modification_date on MGD_Tables ( modification_date ) 
3> on mgd_seg_1
Msg 1906, Level 16, State 1:
Line 2:
Cannot create an index on table 'MGD_Tables', because this table does not exist
in database 'mgd'.
1> 
2> create unique clustered  index index_Marker_time_key on MLC_History ( _Marker_key, time ) 
3> with sorted_data on mgd_seg_0
Msg 1906, Level 16, State 1:
Line 2:
Cannot create an index on table 'MLC_History', because this table does not exist
in database 'mgd'.
1> 
2> create nonclustered  index index_modification_date on MLC_History ( modification_date ) 
3> on mgd_seg_1
Msg 1906, Level 16, State 1:
Line 2:
Cannot create an index on table 'MLC_History', because this table does not exist
in database 'mgd'.
1> 
2> create nonclustered  index index_Marker_key_fk on MLC_History ( _Marker_key ) 
3> on mgd_seg_1
Msg 1906, Level 16, State 1:
Line 2:
Cannot create an index on table 'MLC_History', because this table does not exist
in database 'mgd'.
1> 
2> create unique clustered  index index_Marker_key_time on MLC_History_edit ( _Marker_key, time ) 
3> with sorted_data on mgd_seg_0
Msg 1906, Level 16, State 1:
Line 2:
Cannot create an index on table 'MLC_History_edit', because this table does not
exist in database 'mgd'.
1> 
2> create nonclustered  index index_modification_date on MLC_History_edit ( modification_date ) 
3> on mgd_seg_1
Msg 1906, Level 16, State 1:
Line 2:
Cannot create an index on table 'MLC_History_edit', because this table does not
exist in database 'mgd'.
1> 
2> create nonclustered  index index_Marker_key_fk on MLC_History_edit ( _Marker_key ) 
3> on mgd_seg_1
Msg 1906, Level 16, State 1:
Line 2:
Cannot create an index on table 'MLC_History_edit', because this table does not
exist in database 'mgd'.
1> 
2> create unique clustered  index index_Marker_time on MLC_Lock_edit ( _Marker_key, time ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLC_Lock_edit'.  Drop the
existing clustered index 'index_Marker_time' before creating another
1> 
2> create unique nonclustered index index_time on dbo.MLC_Lock_edit (time)
3> on mgd_seg_0
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Lock_edit' named 'index_time'
1> 
2> create nonclustered index index_modification_date on dbo.MLC_Lock_edit (modification_date)
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Lock_edit' named
'index_modification_date'
1> 
2> create nonclustered index index_Marker_key on dbo.MLC_Lock_edit (_Marker_key)
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Lock_edit' named 'index_Marker_key'
1> 
2> create nonclustered  index index_modification_date on MLC_Marker ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Marker' named 'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key_2 on MLC_Marker ( _Marker_key_2 ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Marker' named 'index_Marker_key_2'
1> 
2> create nonclustered  index index_Marker_key on MLC_Marker ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Marker' named 'index_Marker_key'
1> 
2> create unique clustered  index index_Marker_tag_key on MLC_Marker ( _Marker_key, _Marker_key_2, tag ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLC_Marker'.  Drop the
existing clustered index 'index_Marker_tag_key' before creating another
1> 
2> create unique clustered  index index_Marker_Marker_2_key on MLC_Marker_edit ( _Marker_key, _Marker_key_2 ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLC_Marker_edit'.  Drop
the existing clustered index 'index_Marker_Marker_2_key' before creating another
1> 
2> create nonclustered  index index_Marker_key on MLC_Marker_edit ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Marker_edit' named 'index_Marker_key'
1> 
2> create nonclustered  index index_modification_date on MLC_Marker_edit ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Marker_edit' named
'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key_2 on MLC_Marker_edit ( _Marker_key_2 ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Marker_edit' named 'index_Marker_key_2'
1> 
2> create nonclustered  index index_modification_date on MLC_Reference ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Reference' named
'index_modification_date'
1> 
2> create nonclustered  index index_modification_date on MLC_Reference_edit ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Reference_edit' named
'index_modification_date'
1> 
2> create nonclustered  index index_Refs_key on MLC_Reference ( _Refs_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Reference' named 'index_Refs_key'
1> 
2> create nonclustered  index index_Marker_key on MLC_Reference ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Reference' named 'index_Marker_key'
1> 
2> create unique clustered  index index_Marker_Refs_tag_key on MLC_Reference ( _Marker_key, _Refs_key, tag ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLC_Reference'.  Drop the
existing clustered index 'index_Marker_Refs_tag_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MLC_Reference_edit ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Reference_edit' named
'index_modification_date'
1> 
2> create nonclustered  index index_Refs_key on MLC_Reference_edit ( _Refs_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Reference_edit' named 'index_Refs_key'
1> 
2> create nonclustered  index index_Marker_key on MLC_Reference_edit ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Reference_edit' named 'index_Marker_key'
1> 
2> create unique clustered  index index_Marker_Refs_key on MLC_Reference_edit ( _Marker_key, _Refs_key, tag ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLC_Reference_edit'.  Drop
the existing clustered index 'index_Marker_Refs_key' before creating another
1> 
2> create unique clustered  index index_Marker_key on MLC_Text ( _Marker_key ) 
3> with sorted_data on mgd_seg_0
Non-clustered index (index id = 2) is being rebuilt.
1> 
2> create nonclustered  index index_modification_date on MLC_Text ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Text' named 'index_modification_date'
1> 
2> create unique clustered  index index_Marker_key on MLC_Text_edit ( _Marker_key ) 
3> with sorted_data on mgd_seg_0
Non-clustered index (index id = 2) is being rebuilt.
1> 
2> create nonclustered  index index_modification_date on MLC_Text_edit ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLC_Text_edit' named
'index_modification_date'
1> 
2> create unique clustered  index index_Assay_Type_key on MLD_Assay_Types ( _Assay_Type_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_Assay_Types'.  Drop
the existing clustered index 'index_Assay_Type_key' before creating another
1> 
2> create unique nonclustered  index index_description on MLD_Assay_Types ( description ) 
3> on mgd_seg_0
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Assay_Types' named 'index_description'
1> 
2> create nonclustered  index index_modification_date on MLD_Assay_Types ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Assay_Types' named
'index_modification_date'
1> 
2> create unique clustered  index index_Expt_sequenceNum_key on MLD_Concordance ( _Expt_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_Concordance'.  Drop
the existing clustered index 'index_Expt_sequenceNum_key' before creating
another
1> 
2> create nonclustered  index index_Marker_key on MLD_Concordance ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Concordance' named 'index_Marker_key'
1> 
2> create nonclustered  index index_modification_date on MLD_Concordance ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Concordance' named
'index_modification_date'
1> 
2> create nonclustered  index index_Expt_key on MLD_Concordance ( _Expt_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Concordance' named 'index_Expt_key'
1> 
2> create unique clustered  index index_Contig_key on MLD_Contig ( _Contig_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_Contig'.  Drop the
existing clustered index 'index_Contig_key' before creating another
1> 
2> create unique nonclustered  index index_name on MLD_Contig ( name ) 
3> on mgd_seg_0
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Contig' named 'index_name'
1> 
2> create nonclustered  index index_modification_date on MLD_Contig ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Contig' named 'index_modification_date'
1> 
2> create nonclustered  index index_Expt_key on MLD_Contig ( _Expt_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Contig' named 'index_Expt_key'
1> 
2> create unique clustered  index index_Contig_key on MLD_ContigProbe ( _Contig_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_ContigProbe'.  Drop
the existing clustered index 'index_Contig_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MLD_ContigProbe ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_ContigProbe' named
'index_modification_date'
1> 
2> create nonclustered  index index_Probe_key on MLD_ContigProbe ( _Probe_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_ContigProbe' named 'index_Probe_key'
1> 
2> create nonclustered  index index_Contig_key_fk on MLD_ContigProbe ( _Contig_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_ContigProbe' named 'index_Contig_key_fk'
1> 
2> create unique clustered  index index_Expt_sequenceNum_key on MLD_Distance ( _Expt_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_Distance'.  Drop the
existing clustered index 'index_Expt_sequenceNum_key' before creating another
1> 
2> create nonclustered  index index_Marker_key_2 on MLD_Distance ( _Marker_key_2 ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Distance' named 'index_Marker_key_2'
1> 
2> create nonclustered  index index_modification_date on MLD_Distance ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Distance' named
'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key_1 on MLD_Distance ( _Marker_key_1 ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Distance' named 'index_Marker_key_1'
1> 
2> create nonclustered  index index_Expt_key on MLD_Distance ( _Expt_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Distance' named 'index_Expt_key'
1> 
2> create nonclustered  index index_Allele_fkey on MLD_Expt_Marker ( _Allele_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Expt_Marker' named 'index_Allele_fkey'
1> 
2> create nonclustered  index index_Assay_Type_key on MLD_Expt_Marker ( _Assay_Type_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Expt_Marker' named
'index_Assay_Type_key'
1> 
2> create nonclustered  index index_modification_date on MLD_Expt_Marker ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Expt_Marker' named
'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key on MLD_Expt_Marker ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Expt_Marker' named 'index_Marker_key'
1> 
2> create nonclustered  index index_Expt_key on MLD_Expt_Marker ( _Expt_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Expt_Marker' named 'index_Expt_key'
1> 
2> create unique clustered  index index_Expt_Marker_key on MLD_Expt_Marker ( _Expt_key, _Marker_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_Expt_Marker'.  Drop
the existing clustered index 'index_Expt_Marker_key' before creating another
1> 
2> create unique clustered  index index_Expt_sequenceNum_key on MLD_Expt_Notes ( _Expt_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_Expt_Notes'.  Drop the
existing clustered index 'index_Expt_sequenceNum_key' before creating another
1> 
2> create nonclustered  index index_Expt_key on MLD_Expt_Notes ( _Expt_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Expt_Notes' named 'index_Expt_key'
1> 
2> create nonclustered  index index_note on MLD_Expt_Notes ( note ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Expt_Notes' named 'index_note'
1> 
2> create nonclustered  index index_modification_date on MLD_Expt_Notes ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Expt_Notes' named
'index_modification_date'
1> 
2> create unique clustered  index index_Expt_key on MLD_Expts ( _Expt_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_Expts'.  Drop the
existing clustered index 'index_Expt_key' before creating another
1> 
2> create nonclustered  index index_Refs_key on MLD_Expts ( _Refs_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Expts' named 'index_Refs_key'
1> 
2> create nonclustered  index index_chromosome on MLD_Expts ( chromosome ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Expts' named 'index_chromosome'
1> 
2> create nonclustered  index index_exptType on MLD_Expts ( exptType ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Expts' named 'index_exptType'
1> 
2> create nonclustered  index index_modification_date on MLD_Expts ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Expts' named 'index_modification_date'
1> 
2> create unique clustered  index index_Expt_key on MLD_FISH ( _Expt_key ) 
3> on mgd_seg_1
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_FISH'.  Drop the
existing clustered index 'index_Expt_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MLD_FISH ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_FISH' named 'index_modification_date'
1> 
2> create nonclustered  index index_strain_fkey on MLD_FISH ( _Strain_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_FISH' named 'index_strain_fkey'
1> 
2> create unique clustered index index_Expt_sequenceNum_key on dbo.MLD_FISH_Region (_Expt_key,sequenceNum) 
3> on mgd_seg_1
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_FISH_Region'.  Drop
the existing clustered index 'index_Expt_sequenceNum_key' before creating
another
1> 
2> create nonclustered  index index_modification_date on MLD_FISH_Region ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_FISH_Region' named
'index_modification_date'
1> 
2> create nonclustered  index index_Expt_fkey on MLD_FISH_Region ( _Expt_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_FISH_Region' named 'index_Expt_fkey'
1> 
2> create nonclustered  index index_Target_key on MLD_Hit ( _Probe_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Hit' named 'index_Target_key'
1> 
2> create nonclustered  index index_modification_date on MLD_Hit ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Hit' named 'index_modification_date'
1> 
2> create nonclustered  index index_Probe_key on MLD_Hit ( _Target_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Hit' named 'index_Probe_key'
1> 
2> create nonclustered  index index_Expt_key_fk on MLD_Hit ( _Expt_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Hit' named 'index_Expt_key_fk'
1> 
2> create unique clustered  index index_Expt_key on MLD_Hit ( _Expt_key, _Target_key, _Probe_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_Hit'.  Drop the
existing clustered index 'index_Expt_key' before creating another
1> 
2> create unique clustered  index index_Expt_key on MLD_Hybrid ( _Expt_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_Hybrid'.  Drop the
existing clustered index 'index_Expt_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MLD_Hybrid ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Hybrid' named 'index_modification_date'
1> 
2> create unique clustered  index index_Expt_sequenceNum_key on MLD_ISRegion ( _Expt_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_ISRegion'.  Drop the
existing clustered index 'index_Expt_sequenceNum_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MLD_ISRegion ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_ISRegion' named
'index_modification_date'
1> 
2> create nonclustered  index index_Expt_fkey on MLD_ISRegion ( _Expt_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_ISRegion' named 'index_Expt_fkey'
1> 
2> create unique clustered  index index_Expt_key on MLD_InSitu ( _Expt_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_InSitu'.  Drop the
existing clustered index 'index_Expt_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MLD_InSitu ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_InSitu' named 'index_modification_date'
1> 
2> create nonclustered  index index_strain_fkey on MLD_InSitu ( _Strain_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_InSitu' named 'index_strain_fkey'
1> 
2> create unique clustered  index index_Expt_sequenceNum_key on MLD_MC2point ( _Expt_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_MC2point'.  Drop the
existing clustered index 'index_Expt_sequenceNum_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MLD_MC2point ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_MC2point' named
'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key on MLD_MC2point ( _Marker_key_1 ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_MC2point' named 'index_Marker_key'
1> 
2> create nonclustered  index index_Marker_key_2 on MLD_MC2point ( _Marker_key_2 ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_MC2point' named 'index_Marker_key_2'
1> 
2> create nonclustered  index index_Expt_fkey on MLD_MC2point ( _Expt_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_MC2point' named 'index_Expt_fkey'
1> 
2> create unique clustered  index index_Expt_sequenceNum_key on MLD_MCDataList ( _Expt_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_MCDataList'.  Drop the
existing clustered index 'index_Expt_sequenceNum_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MLD_MCDataList ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_MCDataList' named
'index_modification_date'
1> 
2> create nonclustered  index index_Expt_fkey on MLD_MCDataList ( _Expt_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_MCDataList' named 'index_Expt_fkey'
1> 
2> create nonclustered  index index_modification_date on MLD_Marker ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Marker' named 'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key on MLD_Marker ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Marker' named 'index_Marker_key'
1> 
2> create nonclustered  index index_Refs_key on MLD_Marker ( _Refs_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Marker' named 'index_Refs_key'
1> 
2> create unique clustered  index index_Refs_Marker_sequenceNum on MLD_Marker ( _Refs_key, _Marker_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_Marker'.  Drop the
existing clustered index 'index_Refs_Marker_sequenceNum' before creating another
1> 
2> create unique clustered  index index_Expt_key on MLD_Matrix ( _Expt_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_Matrix'.  Drop the
existing clustered index 'index_Expt_key' before creating another
1> 
2> create nonclustered  index index_Cross_key on MLD_Matrix ( _Cross_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Matrix' named 'index_Cross_key'
1> 
2> create nonclustered  index index_modification_date on MLD_Matrix ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Matrix' named 'index_modification_date'
1> 
2> create unique clustered  index index_Refs_sequenceNum_key on MLD_Notes ( _Refs_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_Notes'.  Drop the
existing clustered index 'index_Refs_sequenceNum_key' before creating another
1> 
2> create nonclustered  index index_note on MLD_Notes ( note ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Notes' named 'index_note'
1> 
2> create nonclustered  index index_modification_date on MLD_Notes ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Notes' named 'index_modification_date'
1> 
2> create nonclustered  index index_Refs_key on MLD_Notes ( _Refs_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Notes' named 'index_Refs_key'
1> 
2> create unique clustered  index index_Expt_key on MLD_PhysMap ( _Expt_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_PhysMap'.  Drop the
existing clustered index 'index_Expt_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MLD_PhysMap ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_PhysMap' named 'index_modification_date'
1> 
2> create unique clustered  index index_Expt_key on MLD_RI ( _Expt_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_RI'.  Drop the
existing clustered index 'index_Expt_key' before creating another
1> 
2> create nonclustered  index index_designation on MLD_RI ( designation ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_RI' named 'index_designation'
1> 
2> create nonclustered  index index_modification_date on MLD_RI ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_RI' named 'index_modification_date'
1> 
2> create nonclustered  index index_RIset_key on MLD_RI ( _RISet_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_RI' named 'index_RIset_key'
1> 
2> create unique clustered  index index_Expt_sequenceNum_key on MLD_RI2Point ( _Expt_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_RI2Point'.  Drop the
existing clustered index 'index_Expt_sequenceNum_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MLD_RI2Point ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_RI2Point' named
'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key_1 on MLD_RI2Point ( _Marker_key_1 ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_RI2Point' named 'index_Marker_key_1'
1> 
2> create nonclustered  index index_Marker_key_2 on MLD_RI2Point ( _Marker_key_2 ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_RI2Point' named 'index_Marker_key_2'
1> 
2> create nonclustered  index index_Expt_fkey on MLD_RI2Point ( _Expt_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_RI2Point' named 'index_Expt_fkey'
1> 
2> create unique clustered  index index_Expt_sequenceNum_key on MLD_RIData ( sequenceNum, _Expt_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_RIData'.  Drop the
existing clustered index 'index_Expt_sequenceNum_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MLD_RIData ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_RIData' named 'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key on MLD_RIData ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_RIData' named 'index_Marker_key'
1> 
2> create nonclustered  index index_Expt_key on MLD_RIData ( _Expt_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_RIData' named 'index_Expt_key'
1> 
2> create unique clustered  index index_Expt_sequenceNum_key on MLD_Statistics ( _Expt_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MLD_Statistics'.  Drop the
existing clustered index 'index_Expt_sequenceNum_key' before creating another
1> 
2> create nonclustered  index index_Marker_key_2 on MLD_Statistics ( _Marker_key_2 ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Statistics' named 'index_Marker_key_2'
1> 
2> create nonclustered  index index_modification_date on MLD_Statistics ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Statistics' named
'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key_1 on MLD_Statistics ( _Marker_key_1 ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Statistics' named 'index_Marker_key_1'
1> 
2> create nonclustered  index index_Expt_key on MLD_Statistics ( _Expt_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MLD_Statistics' named 'index_Expt_key'
1> 
2> create unique clustered  index index_Alias_Marker_key on MRK_Alias ( _Alias_key, _Marker_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MRK_Alias'.  Drop the
existing clustered index 'index_Alias_Marker_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MRK_Alias ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Alias' named 'index_modification_date'
1> 
2> create nonclustered  index index_alias_key on MRK_Alias ( _Alias_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Alias' named 'index_alias_key'
1> 
2> create nonclustered  index index_Marker_key_fk on MRK_Alias ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Alias' named 'index_Marker_key_fk'
1> 
2> create unique clustered  index index_Allele_key on MRK_Allele ( _Allele_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MRK_Allele'.  Drop the
existing clustered index 'index_Allele_key' before creating another
1> 
2> create nonclustered  index index_name on MRK_Allele ( name ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Allele' named 'index_name'
1> 
2> create nonclustered  index index_modification_date on MRK_Allele ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Allele' named 'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key on MRK_Allele ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Allele' named 'index_Marker_key'
1> 
2> create nonclustered  index index_symbol on MRK_Allele ( symbol ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Allele' named 'index_symbol'
1> 
2> create unique clustered  index index_Marker_key on MRK_Anchors ( _Marker_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MRK_Anchors'.  Drop the
existing clustered index 'index_Marker_key' before creating another
1> 
2> create nonclustered  index index_chromosome on MRK_Anchors ( chromosome ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Anchors' named 'index_chromosome'
1> 
2> create nonclustered  index index_modification_date on MRK_Anchors ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Anchors' named 'index_modification_date'
1> 
2> create unique nonclustered  index index_chromosome_Marker_key on MRK_Anchors ( chromosome, _Marker_key ) 
3> on mgd_seg_0
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Anchors' named
'index_chromosome_Marker_key'
1> 
2> create unique clustered  index index_Species_SeqNum_key on MRK_Chromosome ( _Species_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MRK_Chromosome'.  Drop the
existing clustered index 'index_Species_SeqNum_key' before creating another
1> 
2> create nonclustered  index index_chromosome on MRK_Chromosome ( chromosome ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Chromosome' named 'index_chromosome'
1> 
2> create nonclustered  index index_modification_date on MRK_Chromosome ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Chromosome' named
'index_modification_date'
1> 
2> create nonclustered  index index_Species_key on MRK_Chromosome ( _Species_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Chromosome' named 'index_Species_key'
1> 
2> create unique clustered  index index_Class_key on MRK_Class ( _Class_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MRK_Class'.  Drop the
existing clustered index 'index_Class_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MRK_Class ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Class' named 'index_modification_date'
1> 
2> create nonclustered  index index_name on MRK_Class ( name ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Class' named 'index_name'
1> 
2> create unique clustered  index index_Marker_Class_key on MRK_Classes ( _Marker_key, _Class_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MRK_Classes'.  Drop the
existing clustered index 'index_Marker_Class_key' before creating another
1> 
2> create nonclustered  index index_Class_fkey on MRK_Classes ( _Class_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Classes' named 'index_Class_fkey'
1> 
2> create nonclustered  index index_modification_date on MRK_Classes ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Classes' named 'index_modification_date'
1> 
2> create nonclustered  index index_Marker_fkey on MRK_Classes ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Classes' named 'index_Marker_fkey'
1> 
2> create unique clustered  index index_Current_Marker_key on MRK_Current ( _Current_key, _Marker_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MRK_Current'.  Drop the
existing clustered index 'index_Current_Marker_key' before creating another
1> 
2> create nonclustered  index index_Current_fkey on MRK_Current ( _Current_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Current' named 'index_Current_fkey'
1> 
2> create nonclustered  index index_modification_date on MRK_Current ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Current' named 'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key on MRK_Current ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Current' named 'index_Marker_key'
1> 
2> create nonclustered  index index_Refs_key on MRK_History ( _Refs_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_History' named 'index_Refs_key'
1> 
2> create nonclustered  index index_modification_date on MRK_History ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_History' named 'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key on MRK_History ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_History' named 'index_Marker_key'
1> 
2> create nonclustered  index index_History_key on MRK_History ( _History_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_History' named 'index_History_key'
1> 
2> create nonclustered  index index_History_fkey on MRK_History ( _History_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_History' named 'index_History_fkey'
1> 
2> create unique clustered  index index_sequenceNum_Marker_key on MRK_History ( sequenceNum, _Marker_key, _History_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MRK_History'.  Drop the
existing clustered index 'index_sequenceNum_Marker_key' before creating another
1> 
2> create unique clustered  index index_Marker_key on MRK_Marker ( _Marker_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MRK_Marker'.  Drop the
existing clustered index 'index_Marker_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MRK_Marker ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Marker' named 'index_modification_date'
1> 
2> create nonclustered  index index_chromosome on MRK_Marker ( chromosome ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Marker' named 'index_chromosome'
1> 
2> create nonclustered  index index_Marker_Type_key on MRK_Marker ( _Marker_Type_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Marker' named 'index_Marker_Type_key'
1> 
2> create nonclustered  index index_symbol on MRK_Marker ( symbol ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Marker' named 'index_symbol'
1> 
2> create nonclustered  index index_Species_key on MRK_Marker ( _Species_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Marker' named 'index_Species_key'
1> 
2> create nonclustered  index index_Species_symbol on MRK_Marker ( _Species_key, symbol ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Marker' named 'index_Species_symbol'
1> 
2> /* will fail if used with sorted data */
3> create unique clustered  index index_Marker_Type_name on MRK_Name ( _Marker_key, _Marker_Type_key, name ) 
4> on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 3:
Cannot create more than one clustered index on table 'MRK_Name'.  Drop the
existing clustered index 'index_Marker_Type_name' before creating another
1> 
2> create nonclustered  index index_Marker_Type_fkey on MRK_Name ( _Marker_Type_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Name' named 'index_Marker_Type_fkey'
1> 
2> create nonclustered  index index_modification_date on MRK_Name ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Name' named 'index_modification_date'
1> 
2> create nonclustered  index index_name on MRK_Name ( name ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Name' named 'index_name'
1> 
2> create nonclustered  index index_Marker_key on MRK_Name ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Name' named 'index_Marker_key'
1> 
2> create unique clustered  index index_Marker_sequenceNum_key on MRK_Notes ( _Marker_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MRK_Notes'.  Drop the
existing clustered index 'index_Marker_sequenceNum_key' before creating another
1> 
2> create nonclustered  index index_Marker_key on MRK_Notes ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Notes' named 'index_Marker_key'
1> 
2> create nonclustered  index index_note on MRK_Notes ( note ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Notes' named 'index_note'
1> 
2> create nonclustered  index index_modification_date on MRK_Notes ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Notes' named 'index_modification_date'
1> 
2> create unique clustered  index index_Marker_source_key on MRK_Offset ( _Marker_key, source ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MRK_Offset'.  Drop the
existing clustered index 'index_Marker_source_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MRK_Offset ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Offset' named 'index_modification_date'
1> 
2> create nonclustered  index index_offset on MRK_Offset ( offset ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Offset' named 'index_offset'
1> 
2> create nonclustered  index index_source on MRK_Offset ( source ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Offset' named 'index_source'
1> 
2> create nonclustered  index index_Marker_key on MRK_Offset ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Offset' named 'index_Marker_key'
1> 
2> create unique clustered  index index_Marker_key on MRK_Other ( _Other_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MRK_Other'.  Drop the
existing clustered index 'index_Marker_key' before creating another
1> 
2> create nonclustered  index index_name on MRK_Other ( name ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Other' named 'index_name'
1> 
2> create nonclustered  index index_modification_date on MRK_Other ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Other' named 'index_modification_date'
1> 
2> create nonclustered  index index_Marker_fkey on MRK_Other ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Other' named 'index_Marker_fkey'
1> 
2> /* will fail if used with sorted data */
3> create unique clustered  index index_Marker_Refs_key on MRK_Reference ( _Marker_key, _Refs_key ) 
4> on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 3:
Cannot create more than one clustered index on table 'MRK_Reference'.  Drop the
existing clustered index 'index_Marker_Refs_key' before creating another
1> 
2> create nonclustered  index index_Marker_key on MRK_Reference ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Reference' named 'index_Marker_key'
1> 
2> create nonclustered  index index_Refs_key on MRK_Reference ( _Refs_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Reference' named 'index_Refs_key'
1> 
2> create nonclustered  index index_auto on MRK_Reference ( auto ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Reference' named 'index_auto'
1> 
2> create nonclustered  index index_modification_date on MRK_Reference ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Reference' named
'index_modification_date'
1> 
2> create unique clustered  index index_Species_key on MRK_Species ( _Species_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MRK_Species'.  Drop the
existing clustered index 'index_Species_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MRK_Species ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Species' named 'index_modification_date'
1> 
2> create nonclustered  index index_species on MRK_Species ( species ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Species' named 'index_species'
1> 
2> /* will failed if used with sorted data */
3> create unique clustered  index index_Marker_Type_symbol_key on MRK_Symbol ( _Marker_key, _Marker_Type_key, symbol ) 
4> on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 3:
Cannot create more than one clustered index on table 'MRK_Symbol'.  Drop the
existing clustered index 'index_Marker_Type_symbol_key' before creating another
1> 
2> create nonclustered  index index_modification_date on MRK_Symbol ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Symbol' named 'index_modification_date'
1> 
2> create nonclustered  index index_Marker_Type_key on MRK_Symbol ( _Marker_Type_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Symbol' named 'index_Marker_Type_key'
1> 
2> create nonclustered  index index_symbol on MRK_Symbol ( symbol ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Symbol' named 'index_symbol'
1> 
2> create nonclustered  index index_Marker_key on MRK_Symbol ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Symbol' named 'index_Marker_key'
1> 
2> create unique clustered  index index_Marker_Type_key on MRK_Types ( _Marker_Type_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'MRK_Types'.  Drop the
existing clustered index 'index_Marker_Type_key' before creating another
1> 
2> create nonclustered  index index_name on MRK_Types ( name ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Types' named 'index_name'
1> 
2> create nonclustered  index index_modification_date on MRK_Types ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'MRK_Types' named 'index_modification_date'
1> 
2> create unique clustered  index index_Alias_key on PRB_Alias ( _Alias_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'PRB_Alias'.  Drop the
existing clustered index 'index_Alias_key' before creating another
1> 
2> create nonclustered  index index_modification_date on PRB_Alias ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Alias' named 'index_modification_date'
1> 
2> create nonclustered  index index_Reference_key on PRB_Alias ( _Reference_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Alias' named 'index_Reference_key'
1> 
2> create nonclustered  index index_alias on PRB_Alias ( alias ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Alias' named 'index_alias'
1> 
2> create unique clustered  index index_Allele_key on PRB_Allele ( _Allele_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'PRB_Allele'.  Drop the
existing clustered index 'index_Allele_key' before creating another
1> 
2> create nonclustered  index index_modification_date on PRB_Allele ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Allele' named 'index_modification_date'
1> 
2> create nonclustered  index index_RFLV_fkey on PRB_Allele ( _RFLV_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Allele' named 'index_RFLV_fkey'
1> 
2> create unique clustered  index index_Allele_Strain_key on PRB_Allele_Strain ( _Allele_key, _Strain_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'PRB_Allele_Strain'.  Drop
the existing clustered index 'index_Allele_Strain_key' before creating another
1> 
2> create nonclustered  index index_Strain_fkey on PRB_Allele_Strain ( _Strain_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Allele_Strain' named 'index_Strain_fkey'
1> 
2> create nonclustered  index index_modification_date on PRB_Allele_Strain ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Allele_Strain' named
'index_modification_date'
1> 
2> create nonclustered  index index_Allele_fkey on PRB_Allele_Strain ( _Allele_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Allele_Strain' named 'index_Allele_fkey'
1> 
2> create unique clustered  index index_Probe_Marker_key on PRB_Marker ( _Probe_key, _Marker_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'PRB_Marker'.  Drop the
existing clustered index 'index_Probe_Marker_key' before creating another
1> 
2> create nonclustered  index index_Probe_key on PRB_Marker ( _Probe_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Marker' named 'index_Probe_key'
1> 
2> create nonclustered  index index_relationship on PRB_Marker ( relationship ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Marker' named 'index_relationship'
1> 
2> create nonclustered  index index_modification_date on PRB_Marker ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Marker' named 'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key on PRB_Marker ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Marker' named 'index_Marker_key'
1> 
2> create unique clustered  index index_Probe_sequenceNum_key on PRB_Notes ( _Probe_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'PRB_Notes'.  Drop the
existing clustered index 'index_Probe_sequenceNum_key' before creating another
1> 
2> create nonclustered  index index_note on PRB_Notes ( note ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Notes' named 'index_note'
1> 
2> create nonclustered  index index_Probe_key on PRB_Notes ( _Probe_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Notes' named 'index_Probe_key'
1> 
2> create nonclustered  index index_modification_date on PRB_Notes ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Notes' named 'index_modification_date'
1> 
2> create unique clustered  index index_Probe_key on PRB_Probe ( _Probe_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'PRB_Probe'.  Drop the
existing clustered index 'index_Probe_key' before creating another
1> 
2> create nonclustered  index index_Source_key on PRB_Probe (_Source_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Probe' named 'index_Source_key'
1> 
2> create nonclustered  index index_derivedFrom on PRB_Probe ( derivedFrom ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Probe' named 'index_derivedFrom'
1> 
2> create nonclustered  index index_Vector_key on PRB_Probe ( _Vector_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Probe' named 'index_Vector_key'
1> 
2> create nonclustered  index index_DNAtype on PRB_Probe ( DNAtype ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Probe' named 'index_DNAtype'
1> 
2> create nonclustered  index index_name on PRB_Probe ( name ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Probe' named 'index_name'
1> 
2> create nonclustered  index index_modification_date on PRB_Probe ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Probe' named 'index_modification_date'
1> 
2> create unique clustered  index index_RFLV_key on PRB_RFLV ( _RFLV_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'PRB_RFLV'.  Drop the
existing clustered index 'index_RFLV_key' before creating another
1> 
2> create nonclustered  index index_Reference_fkey on PRB_RFLV ( _Reference_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_RFLV' named 'index_Reference_fkey'
1> 
2> create nonclustered  index index_modification_date on PRB_RFLV ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_RFLV' named 'index_modification_date'
1> 
2> create nonclustered  index index_Marker_key on PRB_RFLV ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_RFLV' named 'index_Marker_key'
1> 
2> create unique clustered  index index_Ref_sequenceNum_key on PRB_Ref_Notes ( _Reference_key, sequenceNum ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'PRB_Ref_Notes'.  Drop the
existing clustered index 'index_Ref_sequenceNum_key' before creating another
1> 
2> create nonclustered  index index_note on PRB_Ref_Notes ( note ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Ref_Notes' named 'index_note'
1> 
2> create nonclustered  index index_Reference_fkey on PRB_Ref_Notes ( _Reference_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Ref_Notes' named 'index_Reference_fkey'
1> 
2> create nonclustered  index index_modification_date on PRB_Ref_Notes ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Ref_Notes' named
'index_modification_date'
1> 
2> create unique clustered  index index_Reference_key on PRB_Reference ( _Reference_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'PRB_Reference'.  Drop the
existing clustered index 'index_Reference_key' before creating another
1> 
2> create nonclustered  index index_modification_date on PRB_Reference ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Reference' named
'index_modification_date'
1> 
2> create nonclustered  index index_Refs_key on PRB_Reference ( _Refs_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Reference' named 'index_Refs_key'
1> 
2> create nonclustered  index index_Probe_key on PRB_Reference ( _Probe_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Reference' named 'index_Probe_key'
1> 
2> create unique clustered  index index_Source_key on PRB_Source ( _Source_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'PRB_Source'.  Drop the
existing clustered index 'index_Source_key' before creating another
1> 
2> create nonclustered  index index_strain_fkey on PRB_Source ( _Strain_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Source' named 'index_strain_fkey'
1> 
2> create nonclustered  index index_Tissue_fkey on PRB_Source ( _Tissue_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Source' named 'index_Tissue_fkey'
1> 
2> create nonclustered  index index_Refs_fkey on PRB_Source ( _Refs_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Source' named 'index_Refs_fkey'
1> 
2> create nonclustered  index index_name on PRB_Source ( name ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Source' named 'index_name'
1> 
2> create nonclustered  index index_species on PRB_Source ( species ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Source' named 'index_species'
1> 
2> create nonclustered  index index_modification_date on PRB_Source ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Source' named 'index_modification_date'
1> 
2> create unique clustered  index index_Strain_key on PRB_Strain ( _Strain_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'PRB_Strain'.  Drop the
existing clustered index 'index_Strain_key' before creating another
1> 
2> create nonclustered  index index_strain on PRB_Strain ( strain ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Strain' named 'index_strain'
1> 
2> create nonclustered  index index_modification_date on PRB_Strain ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Strain' named 'index_modification_date'
1> 
2> create unique clustered  index index_Tissue_key on PRB_Tissue ( _Tissue_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'PRB_Tissue'.  Drop the
existing clustered index 'index_Tissue_key' before creating another
1> 
2> create nonclustered  index index_modification_date on PRB_Tissue ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Tissue' named 'index_modification_date'
1> 
2> create nonclustered  index index_Tissue on PRB_Tissue ( tissue ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Tissue' named 'index_Tissue'
1> 
2> create unique clustered  index index_Vector_key on PRB_Vector_Types ( _Vector_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'PRB_Vector_Types'.  Drop
the existing clustered index 'index_Vector_key' before creating another
1> 
2> create nonclustered  index index_vectorType on PRB_Vector_Types ( vectorType ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Vector_Types' named 'index_vectorType'
1> 
2> create nonclustered  index index_modification_date on PRB_Vector_Types ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Vector_Types' named
'index_modification_date'
1> 
2> create unique clustered  index index_RISet_key on RI_RISet ( _RISet_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'RI_RISet'.  Drop the
existing clustered index 'index_RISet_key' before creating another
1> 
2> create unique nonclustered  index index_designation on RI_RISet ( designation ) 
3> on mgd_seg_0
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'RI_RISet' named 'index_designation'
1> 
2> create nonclustered  index index_modification_date on RI_RISet ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'RI_RISet' named 'index_modification_date'
1> 
2> create unique clustered  index index_RISummary_key on RI_Summary ( _RISummary_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'RI_Summary'.  Drop the
existing clustered index 'index_RISummary_key' before creating another
1> 
2> create nonclustered  index index_modification_date on RI_Summary ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'RI_Summary' named 'index_modification_date'
1> 
2> create nonclustered  index index_RIset_fkey on RI_Summary ( _RISet_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'RI_Summary' named 'index_RIset_fkey'
1> 
2> create nonclustered  index index_Marker_key on RI_Summary ( _Marker_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'RI_Summary' named 'index_Marker_key'
1> 
2> create unique clustered  index index_Expt_RI_key on RI_Summary_Expt_Ref ( _RISummary_key, _Expt_key ) 
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'RI_Summary_Expt_Ref'. 
Drop the existing clustered index 'index_Expt_RI_key' before creating another
1> 
2> create nonclustered  index index_RISummary_fkey on RI_Summary_Expt_Ref ( _RISummary_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'RI_Summary_Expt_Ref' named
'index_RISummary_fkey'
1> 
2> create nonclustered  index index_Expt_key on RI_Summary_Expt_Ref ( _Expt_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'RI_Summary_Expt_Ref' named 'index_Expt_key'
1> 
2> create nonclustered  index index_modification_date on RI_Summary_Expt_Ref ( modification_date ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'RI_Summary_Expt_Ref' named
'index_modification_date'
1> 
2> create nonclustered  index index_Refs_key on RI_Summary_Expt_Ref ( _Refs_key ) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'RI_Summary_Expt_Ref' named 'index_Refs_key'
1> 
2> create nonclustered  index index_modification_date on Shadow_IDDS_proto1 ( modification_date ) 
3> on mgd_seg_1
Msg 1906, Level 16, State 1:
Line 2:
Cannot create an index on table 'Shadow_IDDS_proto1', because this table does
not exist in database 'mgd'.
1> 
2> create nonclustered  index index_modification_date on Shadow_IDDS_proto2 ( modification_date ) 
3> on mgd_seg_1
Msg 1906, Level 16, State 1:
Line 2:
Cannot create an index on table 'Shadow_IDDS_proto2', because this table does
not exist in database 'mgd'.
1> 
2> /* GXD Indexes: unique, clustered */
3> 
4> CREATE UNIQUE CLUSTERED INDEX index_AllelePair_key ON GXD_AllelePair (_AllelePair_key)
5> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 4:
Cannot create more than one clustered index on table 'GXD_AllelePair'.  Drop the
existing clustered index 'index_AllelePair_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Antibody_key ON GXD_Antibody (_Antibody_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_Antibody'.  Drop the
existing clustered index 'index_Antibody_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_AntibodyClass_key ON GXD_AntibodyClass (_AntibodyClass_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_AntibodyClass'.  Drop
the existing clustered index 'index_AntibodyClass_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Antibody_key ON GXD_AntibodyMarker (_Antibody_key, _Marker_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_AntibodyMarker'.  Drop
the existing clustered index 'index_Antibody_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_AntibodyPrep_key ON GXD_AntibodyPrep (_AntibodyPrep_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_AntibodyPrep'.  Drop
the existing clustered index 'index_AntibodyPrep_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_AntibodyType_key ON GXD_AntibodyType (_AntibodyType_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_AntibodyType'.  Drop
the existing clustered index 'index_AntibodyType_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Antigen_key ON GXD_Antigen (_Antigen_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_Antigen'.  Drop the
existing clustered index 'index_Antigen_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Assay_key ON GXD_Assay (_Assay_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_Assay'.  Drop the
existing clustered index 'index_Assay_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Assay_key ON GXD_AssayNote (_Assay_key, sequenceNum)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_AssayNote'.  Drop the
existing clustered index 'index_Assay_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_AssayType_key ON GXD_AssayType (_AssayType_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_AssayType'.  Drop the
existing clustered index 'index_AssayType_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Embedding_key ON GXD_EmbeddingMethod (_Embedding_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_EmbeddingMethod'. 
Drop the existing clustered index 'index_Embedding_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Expression_key ON GXD_Expression (_Expression_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_Expression'.  Drop the
existing clustered index 'index_Expression_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Fixation_key ON GXD_FixationMethod (_Fixation_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_FixationMethod'.  Drop
the existing clustered index 'index_Fixation_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_GelBand_key ON GXD_GelBand (_GelBand_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_GelBand'.  Drop the
existing clustered index 'index_GelBand_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_GelLane_key ON GXD_GelLane (_GelLane_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_GelLane'.  Drop the
existing clustered index 'index_GelLane_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_GelLane_Structure_key ON GXD_GelLaneStructure (_GelLane_key, _Structure_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_GelLaneStructure'. 
Drop the existing clustered index 'index_GelLane_Structure_key' before creating
another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_GelRNAType_key ON GXD_GelRNAType (_GelRNAType_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_GelRNAType'.  Drop the
existing clustered index 'index_GelRNAType_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_GelRow_key ON GXD_GelRow (_GelRow_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_GelRow'.  Drop the
existing clustered index 'index_GelRow_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_GelUnits_key ON GXD_GelUnits (_GelUnits_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_GelUnits'.  Drop the
existing clustered index 'index_GelUnits_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Genotype_key ON GXD_Genotype (_Genotype_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_Genotype'.  Drop the
existing clustered index 'index_Genotype_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Result_ImagePane_key ON GXD_InSituResultImage (_Result_key, _ImagePane_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_InSituResultImage'. 
Drop the existing clustered index 'index_Result_ImagePane_key' before creating
another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Coverage_key ON GXD_LabelCoverage (_Coverage_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_LabelCoverage'.  Drop
the existing clustered index 'index_Coverage_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Pattern_key ON GXD_Pattern (_Pattern_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_Pattern'.  Drop the
existing clustered index 'index_Pattern_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Label_key ON GXD_Label (_Label_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_Label'.  Drop the
existing clustered index 'index_Label_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_ProbePrep_key ON GXD_ProbePrep (_ProbePrep_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_ProbePrep'.  Drop the
existing clustered index 'index_ProbePrep_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Sense_key ON GXD_ProbeSense (_Sense_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_ProbeSense'.  Drop the
existing clustered index 'index_Sense_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Specimen_key ON GXD_Specimen (_Specimen_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_Specimen'.  Drop the
existing clustered index 'index_Specimen_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Strength_key ON GXD_Strength (_Strength_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_Strength'.  Drop the
existing clustered index 'index_Strength_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Structure_key ON GXD_Structure (_Structure_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_Structure'.  Drop the
existing clustered index 'index_Structure_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Structure_Descendent_key ON GXD_StructureClosure (_Structure_key, _Descendent_key)
3> on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_StructureClosure'. 
Drop the existing clustered index 'index_Structure_Descendent_key' before
creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Stage_key ON GXD_TheilerStage (_Stage_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_TheilerStage'.  Drop
the existing clustered index 'index_Stage_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Visualization_key ON GXD_VisualizationMethod (_Visualization_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_VisualizationMethod'. 
Drop the existing clustered index 'index_Visualization_key' before creating
another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_FieldType_key ON IMG_FieldType (_FieldType_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'IMG_FieldType'.  Drop the
existing clustered index 'index_FieldType_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Image_key ON IMG_Image (_Image_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'IMG_Image'.  Drop the
existing clustered index '_IMG_Image_idx' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_ImagePane_key ON IMG_ImagePane (_ImagePane_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'IMG_ImagePane'.  Drop the
existing clustered index 'index_ImagePane_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Result_Structure_key ON GXD_ISResultStructure (_Result_key, _Structure_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_ISResultStructure'. 
Drop the existing clustered index 'index_Result_Structure_key' before creating
another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_StructureName_key ON GXD_StructureName (_StructureName_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_StructureName'.  Drop
the existing clustered index 'index_StructureName_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Secondary_key ON GXD_Secondary (_Secondary_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_Secondary'.  Drop the
existing clustered index 'index_Secondary_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_Result_key ON GXD_InSituResult (_Result_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_InSituResult'.  Drop
the existing clustered index 'index_Result_key' before creating another
1> 
2> CREATE UNIQUE CLUSTERED INDEX index_AntibodyAlias_key ON GXD_AntibodyAlias (_AntibodyAlias_key)
3> with sorted_data on mgd_seg_0
Msg 1902, Level 16, State 1:
Line 2:
Cannot create more than one clustered index on table 'GXD_AntibodyAlias'.  Drop
the existing clustered index 'index_AntibodyAlias_key' before creating another
1> 
2> /* Indices on modification_date, not creation_date*/
3> 
4> create index index_modification_date on GXD_Genotype (modification_date) 
5> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 4:
There is already an index on table 'GXD_Genotype' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_AllelePair (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AllelePair' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_Antigen (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Antigen' named 'index_modification_date'
1> 
2> create index index_modification_date on PRB_Source (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'PRB_Source' named 'index_modification_date'
1> 
2> create index index_modification_date on GXD_Antibody (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Antibody' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_AntibodyClass (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AntibodyClass' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_AntibodyType (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AntibodyType' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_AntibodyMarker (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AntibodyMarker' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_Structure (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Structure' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_StructureName (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_StructureName' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_TheilerStage (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_TheilerStage' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_StructureClosure (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_StructureClosure' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_ProbePrep (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_ProbePrep' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_ProbeSense (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_ProbeSense' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_Label (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Label' named 'index_modification_date'
1> 
2> create index index_modification_date on GXD_LabelCoverage (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_LabelCoverage' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_VisualizationMethod (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_VisualizationMethod' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_AntibodyPrep (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AntibodyPrep' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_AntibodyAlias (modification_date)
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AntibodyAlias' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_Secondary (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Secondary' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_Assay (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Assay' named 'index_modification_date'
1> 
2> create index index_modification_date on GXD_AssayType (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AssayType' named
'index_modification_date'
1> 
2> create index index_modification_date on IMG_ImagePane (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'IMG_ImagePane' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_AssayNote (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AssayNote' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_GelLane (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelLane' named 'index_modification_date'
1> 
2> create index index_modification_date on GXD_GelRNAType (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelRNAType' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_GelLaneStructure (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelLaneStructure' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_GelRow (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelRow' named 'index_modification_date'
1> 
2> create index index_modification_date on GXD_GelUnits (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelUnits' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_GelBand (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelBand' named 'index_modification_date'
1> 
2> create index index_modification_date on GXD_Strength (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Strength' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_Specimen (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Specimen' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_EmbeddingMethod (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_EmbeddingMethod' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_FixationMethod (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_FixationMethod' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_InSituResult (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_InSituResult' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_Pattern (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Pattern' named 'index_modification_date'
1> 
2> create index index_modification_date on GXD_InSituResultImage (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_InSituResultImage' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_Expression (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Expression' named
'index_modification_date'
1> 
2> create index index_modification_date on GXD_ISResultStructure (modification_date)
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_ISResultStructure' named
'index_modification_date'
1> 
2> create index index_modification_date on IMG_Image (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'IMG_Image' named 'index_modification_date'
1> 
2> create index index_modification_date on IMG_FieldType (modification_date) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'IMG_FieldType' named
'index_modification_date'
1> 
2> 
3> create nonclustered index index_Strain_key on GXD_Genotype(_Strain_key) 
4> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 3:
There is already an index on table 'GXD_Genotype' named 'index_Strain_key'
1> 
2> create nonclustered index index_Genotype_key on GXD_AllelePair(_Genotype_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AllelePair' named 'index_Genotype_key'
1> 
2> create nonclustered index index_Allele_key_1 on GXD_AllelePair(_Allele_key_1) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AllelePair' named 'index_Allele_key_1'
1> 
2> create nonclustered index index_Allele_key_2 on GXD_AllelePair(_Allele_key_2) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AllelePair' named 'index_Allele_key_2'
1> 
2> create nonclustered index index_Marker_key on GXD_AllelePair(_Marker_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AllelePair' named 'index_Marker_key'
1> 
2> create nonclustered index index_Source_key on GXD_Antigen(_Source_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Antigen' named 'index_Source_key'
1> 
2> create nonclustered index index_AntibodyClass_key on GXD_Antibody(_AntibodyClass_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Antibody' named
'index_AntibodyClass_key'
1> 
2> create nonclustered index index_AntibodyType_key on GXD_Antibody(_AntibodyType_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Antibody' named 'index_AntibodyType_key'
1> 
2> create nonclustered index index_Antigen_key on GXD_Antibody(_Antigen_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Antibody' named 'index_Antigen_key'
1> 
2> create nonclustered index index_Refs_key on GXD_Antibody(_Refs_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Antibody' named 'index_Refs_key'
1> 
2> create nonclustered index index_Antibody_key on GXD_AntibodyAlias(_Antibody_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AntibodyAlias' named
'index_Antibody_key'
1> 
2> create nonclustered index index_Refs_key on GXD_AntibodyAlias(_Refs_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AntibodyAlias' named 'index_Refs_key'
1> 
2> create nonclustered index index_Antibody_key on GXD_AntibodyMarker(_Antibody_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AntibodyMarker' named
'index_Antibody_key'
1> 
2> create nonclustered index index_Marker_key on GXD_AntibodyMarker(_Marker_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AntibodyMarker' named 'index_Marker_key'
1> 
2> create nonclustered index index_Parent_key on GXD_Structure(_Parent_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Structure' named 'index_Parent_key'
1> 
2> create nonclustered index index_StructureName_key on GXD_Structure(_StructureName_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Structure' named
'index_StructureName_key'
1> 
2> create nonclustered index index_Stage_key on GXD_Structure(_Stage_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Structure' named 'index_Stage_key'
1> 
2> create nonclustered index index_Structure_key on GXD_Structurename(_Structure_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Structurename' named
'index_Structure_key'
1> 
2> create nonclustered index index_Structure_key on GXD_StructureClosure(_Structure_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_StructureClosure' named
'index_Structure_key'
1> 
2> create nonclustered index index_Descendent_key on GXD_StructureClosure(_Descendent_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_StructureClosure' named
'index_Descendent_key'
1> 
2> create nonclustered index index_Probe_key on GXD_ProbePrep(_Probe_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_ProbePrep' named 'index_Probe_key'
1> 
2> create nonclustered index index_Sense_key on GXD_ProbePrep(_Sense_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_ProbePrep' named 'index_Sense_key'
1> 
2> create nonclustered index index_Label_key on GXD_ProbePrep(_Label_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_ProbePrep' named 'index_Label_key'
1> 
2> create nonclustered index index_Coverage_key on GXD_ProbePrep(_Coverage_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_ProbePrep' named 'index_Coverage_key'
1> 
2> create nonclustered index index_Visualization_key on GXD_ProbePrep(_Visualization_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_ProbePrep' named
'index_Visualization_key'
1> 
2> create nonclustered index index_Antibody_key on GXD_AntibodyPrep(_Antibody_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AntibodyPrep' named 'index_Antibody_key'
1> 
2> create nonclustered index index_Secondary_key on GXD_AntibodyPrep(_Secondary_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AntibodyPrep' named
'index_Secondary_key'
1> 
2> create nonclustered index index_Label_key on GXD_AntibodyPrep(_Label_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AntibodyPrep' named 'index_Label_key'
1> 
2> create nonclustered index index_AssayType_key on GXD_Assay(_AssayType_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Assay' named 'index_AssayType_key'
1> 
2> create nonclustered index index_Refs_key on GXD_Assay(_Refs_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Assay' named 'index_Refs_key'
1> 
2> create nonclustered index index_Marker_key on GXD_Assay(_Marker_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Assay' named 'index_Marker_key'
1> 
2> create nonclustered index index_ProbePrep_key on GXD_Assay(_ProbePrep_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Assay' named 'index_ProbePrep_key'
1> 
2> create nonclustered index index_AntibodyPrep_key on GXD_Assay(_AntibodyPrep_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Assay' named 'index_AntibodyPrep_key'
1> 
2> create nonclustered index index_ImagePane_key on GXD_Assay(_ImagePane_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Assay' named 'index_ImagePane_key'
1> 
2> create nonclustered index index_Assay_key on GXD_AssayNote(_Assay_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_AssayNote' named 'index_Assay_key'
1> 
2> create nonclustered index index_Assay_key on GXD_GelLane(_Assay_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelLane' named 'index_Assay_key'
1> 
2> create nonclustered index index_Genotype_key on GXD_GelLane(_Genotype_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelLane' named 'index_Genotype_key'
1> 
2> create nonclustered index index_GelRNAType_key on GXD_GelLane(_GelRNAType_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelLane' named 'index_GelRNAType_key'
1> 
2> create nonclustered index index_GelLane_key on GXD_GelLaneStructure(_GelLane_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelLaneStructure' named
'index_GelLane_key'
1> 
2> create nonclustered index index_Structure_key on GXD_GelLaneStructure(_Structure_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelLaneStructure' named
'index_Structure_key'
1> 
2> create nonclustered index index_Assay_key on GXD_GelRow(_Assay_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelRow' named 'index_Assay_key'
1> 
2> create nonclustered index index_GelUnits_key on GXD_GelRow(_GelUnits_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelRow' named 'index_GelUnits_key'
1> 
2> create nonclustered index index_GelLane_key on GXD_GelBand(_GelLane_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelBand' named 'index_GelLane_key'
1> 
2> create nonclustered index index_GelRow_key on GXD_GelBand(_GelRow_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelBand' named 'index_GelRow_key'
1> 
2> create nonclustered index index_Strength_key on GXD_GelBand(_Strength_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_GelBand' named 'index_Strength_key'
1> 
2> create nonclustered index index_Assay_key on GXD_Specimen(_Assay_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Specimen' named 'index_Assay_key'
1> 
2> create nonclustered index index_Embedding_key on GXD_Specimen(_Embedding_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Specimen' named 'index_Embedding_key'
1> 
2> create nonclustered index index_Fixation_key on GXD_Specimen(_Fixation_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Specimen' named 'index_Fixation_key'
1> 
2> create nonclustered index index_Genotype_key on GXD_Specimen(_Genotype_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Specimen' named 'index_Genotype_key'
1> 
2> create nonclustered index index_Specimen_key on GXD_InSituResult(_Specimen_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_InSituResult' named 'index_Specimen_key'
1> 
2> create nonclustered index index_Strength_key on GXD_InSituResult(_Strength_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_InSituResult' named 'index_Strength_key'
1> 
2> create nonclustered index index_Pattern_key on GXD_InSituResult(_Pattern_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_InSituResult' named 'index_Pattern_key'
1> 
2> create nonclustered index index_Result_key on GXD_ISResultStructure(_Result_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_ISResultStructure' named
'index_Result_key'
1> 
2> create nonclustered index index_Structure_key on GXD_ISResultStructure(_Structure_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_ISResultStructure' named
'index_Structure_key'
1> 
2> create nonclustered index index_Result_key on GXD_InSituResultImage(_Result_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_InSituResultImage' named
'index_Result_key'
1> 
2> create nonclustered index index_ImagePane_key on GXD_InSituResultImage(_ImagePane_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_InSituResultImage' named
'index_ImagePane_key'
1> 
2> create nonclustered index index_Assay_key on GXD_Expression(_Assay_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Expression' named 'index_Assay_key'
1> 
2> create nonclustered index index_AssayType_key on GXD_Expression(_AssayType_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Expression' named 'index_AssayType_key'
1> 
2> create nonclustered index index_Genotype_key on GXD_Expression(_Genotype_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Expression' named 'index_Genotype_key'
1> 
2> create nonclustered index index_Marker_key on GXD_Expression(_Marker_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Expression' named 'index_Marker_key'
1> 
2> create nonclustered index index_Structure_key on GXD_Expression(_Structure_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'GXD_Expression' named 'index_Structure_key'
1> 
2> create nonclustered index index_Refs_key on IMG_Image(_Refs_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'IMG_Image' named 'index_Refs_key'
1> 
2> create nonclustered index index_Image_key on IMG_ImagePane(_Image_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'IMG_ImagePane' named 'index_Image_key'
1> 
2> create nonclustered index index_FieldType_key on IMG_ImagePane(_FieldType_key) 
3> on mgd_seg_1
Msg 1913, Level 16, State 1:
Line 2:
There is already an index on table 'IMG_ImagePane' named 'index_FieldType_key'
1> 
2> /* End GXD */
3> 
4> dump transaction mgd with truncate_only
1> 
2> checkpoint
Password: 
1> use mgd
2> 
1> 
2> sp_dropkey foreign, ACC_AccessionReference, ACC_Accession
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, ACC_ActualDB, ACC_LogicalDB
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, ACC_Accession, ACC_LogicalDB
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, ACC_Accession, ACC_MGIType
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, ACC_AccessionReference, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, BIB_Books, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Reference, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, BIB_Notes, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Source, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, CRS_References, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, RI_Summary_Expt_Ref, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Index, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLC_Reference, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLC_Reference_edit, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Expts, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Marker, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Notes, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_History, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, CRS_Matrix, CRS_Cross
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, CRS_Progeny, CRS_Cross
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, CRS_References, CRS_Cross
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, CRS_Typings, CRS_Cross
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Matrix, CRS_Cross
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, HMD_Homology_Assay, HMD_Assay
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Expt_Marker, MLD_Assay_Types
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_ContigProbe, MLD_Contig
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, RI_Summary_Expt_Ref, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Concordance, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Contig, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Distance, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Expt_Marker, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Expt_Notes, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_FISH, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_FISH_Region, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Hit, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Hybrid, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_InSitu, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_ISRegion, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Matrix, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_MC2point, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_MCDataList, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_PhysMap, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_RI, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_RI2Point, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_RIData, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Statistics, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, PRB_Marker, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_RFLV, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, CRS_Matrix, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, RI_Summary, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, CRS_References, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Index, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLC_History, MRK_Marker
The table or view named doesn't exist in the current database.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_History_edit, MRK_Marker
The table or view named doesn't exist in the current database.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Lock_edit, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLC_Marker, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLC_Marker_edit, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLC_Reference, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLC_Reference_edit, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLC_Text, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLC_Text_edit, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Concordance, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Distance, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Expt_Marker, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Marker, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_MC2point, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_RI2Point, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_RIData, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Statistics, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Alias, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Allele, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Anchors, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Current, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_History, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Notes, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Offset, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Other, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, ACC_LogicalDB, MRK_Species
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Chromosome, MRK_Species
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Marker, MRK_Species
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Marker, PRB_Probe
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Notes, PRB_Probe
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Probe, PRB_Probe
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Reference, PRB_Probe
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_ContigProbe, PRB_Probe
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Hit, PRB_Probe
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Probe, PRB_Source
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Probe, PRB_Vector_Types
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, ACC_Accession, ACC_LogicalDB
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, ACC_Accession, ACC_MGIType
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, ACC_AccessionReference, ACC_Accession
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, ACC_AccessionReference, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, ACC_ActualDB, ACC_LogicalDB
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, ACC_ActualDB, ACC_LogicalDB
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, ACC_LogicalDB, MRK_Species
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, ACC_LogicalDB, MRK_Species
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, BIB_Books, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, BIB_Notes, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, BIB_Refs, BIB_ReviewStatus
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, CRS_Cross, PRB_Strain
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, CRS_Cross, PRB_Strain
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, CRS_Cross, PRB_Strain
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, CRS_Cross, PRB_Strain
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, CRS_Matrix, CRS_Cross
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, CRS_Matrix, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, CRS_Progeny, CRS_Cross
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, CRS_References, CRS_Cross
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, CRS_References, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, CRS_References, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, CRS_Typings, CRS_Cross
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, CRS_Typings, CRS_Matrix
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Index, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_Index, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_Index_Stages, GXD_Index
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, HMD_Homology, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, HMD_Homology, HMD_Class
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, HMD_Homology_Assay, HMD_Homology
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, HMD_Homology_Assay, HMD_Assay
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, HMD_Homology_Marker, HMD_Homology
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, HMD_Homology_Marker, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, HMD_Notes, HMD_Homology
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLC_History, MRK_Marker
The table or view named doesn't exist in the current database.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_History_edit, MRK_Marker
The table or view named doesn't exist in the current database.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Lock_edit, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Lock_edit, MLC_Text
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Marker, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Marker, MLC_Text
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Marker_edit, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Marker_edit, MLC_Text
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Reference, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Reference, MLC_Text
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Reference, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Reference_edit, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Reference_edit, MLC_Text
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Reference_edit, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Text, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLC_Text_edit, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Concordance, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Concordance, MLD_Hybrid
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Concordance, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Contig, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_ContigProbe, PRB_Probe
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_ContigProbe, MLD_Contig
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Distance, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Distance, MLD_PhysMap
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Distance, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Distance, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Expt_Marker, MRK_Allele
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Expt_Marker, MLD_Assay_Types
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Expt_Marker, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Expt_Marker, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Expt_Notes, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Expts, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_FISH, PRB_Strain
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_FISH, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_FISH_Region, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_FISH_Region, MLD_FISH
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Hit, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Hit, PRB_Probe
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Hit, PRB_Probe
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Hybrid, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_InSitu, PRB_Strain
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_InSitu, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_ISRegion, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_ISRegion, MLD_InSitu
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Marker, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Marker, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Matrix, CRS_Cross
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Matrix, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_MC2point, MLD_Matrix
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_MC2point, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_MC2point, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_MCDataList, MLD_Matrix
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_Notes, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_PhysMap, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_RI, RI_RISet
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_RI, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_RI2Point, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_RI2Point, MLD_RI
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_RI2Point, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_RI2Point, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_RIData, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_RIData, MLD_RI
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MLD_RIData, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Statistics, MLD_Expts
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Statistics, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MLD_Statistics, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_Alias, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_Alias, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_Allele, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_Anchors, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_Chromosome, MRK_Species
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_Classes, MRK_Class
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Classes, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Current, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_Current, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_History, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_History, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_History, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_Marker, MRK_Types
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Marker, MRK_Species
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_Name, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Name, MRK_Types
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Notes, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_Offset, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_Other, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, MRK_Reference, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Reference, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Symbol, MRK_Types
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, MRK_Symbol, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Alias, PRB_Reference
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Allele, PRB_RFLV
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Allele_Strain, PRB_Allele
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Allele_Strain, PRB_Strain
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Marker, PRB_Probe
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, PRB_Marker, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, PRB_Notes, PRB_Probe
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, PRB_Probe, PRB_Vector_Types
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, PRB_Probe, PRB_Source
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, PRB_Probe, PRB_Probe
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, PRB_Ref_Notes, PRB_Reference
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Reference, PRB_Probe
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, PRB_Reference, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, PRB_RFLV, PRB_Reference
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_RFLV, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, PRB_Source, PRB_Tissue
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Source, PRB_Strain
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, PRB_Source, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, RI_Summary, RI_RISet
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, RI_Summary, MRK_Marker
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, RI_Summary_Expt_Ref, MLD_RI
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, RI_Summary_Expt_Ref, RI_Summary
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, RI_Summary_Expt_Ref, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> checkpoint
1> 
2> /* GXD Schema */
3> 
4> sp_dropkey foreign, GXD_Genotype, PRB_Strain
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_AllelePair, GXD_Genotype
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_AllelePair, MRK_Allele
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_AllelePair, MRK_Allele
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_AllelePair, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Antigen, PRB_Source
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Antibody, GXD_AntibodyClass
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Antibody, GXD_AntibodyType
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Antibody, GXD_Antigen
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Antibody, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_AntibodyAlias, GXD_Antibody
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_AntibodyAlias, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_AntibodyMarker, GXD_Antibody
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_AntibodyMarker, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Structure, GXD_Structure
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Structure, GXD_StructureName
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Structure, GXD_TheilerStage
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Structurename, GXD_Structure
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_StructureClosure, GXD_Structure
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_StructureClosure, GXD_Structure
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_ProbePrep, PRB_Probe
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_ProbePrep, GXD_ProbeSense
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_ProbePrep, GXD_Label
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_ProbePrep, GXD_LabelCoverage
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_ProbePrep, GXD_VisualizationMethod
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_AntibodyPrep, GXD_Antibody
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_AntibodyPrep, GXD_Secondary
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_AntibodyPrep, GXD_Label
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Assay, GXD_AssayType
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Assay, BIB_Refs
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Assay, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Assay, GXD_ProbePrep
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Assay, GXD_AntibodyPrep
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Assay, IMG_ImagePane
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_AssayNote, GXD_Assay
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_GelLane, GXD_Assay
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_GelLane, GXD_Genotype
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_GelLane, GXD_GelRNAType
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_GelLane, GXD_GelControl
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_GelLaneStructure, GXD_GelLane
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_GelLaneStructure, GXD_Structure
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_GelRow, GXD_Assay
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_GelRow, GXD_GelUnits
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_GelBand, GXD_GelLane
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_GelBand, GXD_GelRow
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_GelBand, GXD_Strength
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Specimen, GXD_Assay
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_Specimen, GXD_EmbeddingMethod
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_Specimen, GXD_FixationMethod
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_Specimen, GXD_Genotype
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_InSituResult, GXD_Specimen
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, GXD_InSituResult, GXD_Strength
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_InSituResult, GXD_Pattern
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_ISResultStructure, GXD_InSituResult
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_ISResultStructure, GXD_Structure
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_InSituResultImage, GXD_InSituResult
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_InSituResultImage, IMG_ImagePane
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Expression, GXD_Assay
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Expression, GXD_AssayType
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Expression, GXD_Genotype
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Expression, MRK_Marker
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, GXD_Expression, GXD_Structure
Foreign key dropped.
(return status = 0)
1> 
2> sp_dropkey foreign, IMG_Image, BIB_Refs
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_foreignkey IMG_ImageNote, IMG_Image
Msg 201, Level 16, State 2:
Procedure 'sp_foreignkey':
Procedure sp_foreignkey expects parameter @col1, which was not supplied.
(return status = -6)
1> 
2> sp_dropkey foreign, IMG_ImagePane, IMG_Image
No foreign key for the table or view exists.
(return status = 1)
1> 
2> sp_dropkey foreign, IMG_ImagePane, IMG_FieldType
Foreign key dropped.
(return status = 0)
Password: 
1> use mgd
1> 
2> 
3> exec sp_foreignkey ACC_Accession, ACC_LogicalDB,
4>        _LogicalDB_key
New foreign key added.
(return status = 0)
1> 
2> exec sp_foreignkey ACC_Accession, ACC_MGIType,
3>        _MGIType_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey ACC_AccessionReference, ACC_Accession,
3>        _Accession_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey ACC_AccessionReference, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey ACC_ActualDB, ACC_LogicalDB,
3>        _LogicalDB_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey ACC_LogicalDB, MRK_Species,
3>        _Species_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey BIB_Books, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey BIB_Notes, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey BIB_Refs, BIB_ReviewStatus,
3>        _ReviewStatus_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey CRS_Cross, PRB_Strain,
3>        _StrainHT_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey CRS_Cross, PRB_Strain,
3>        _StrainHO_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey CRS_Cross, PRB_Strain,
3>        _femaleStrain_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey CRS_Cross, PRB_Strain,
3>        _maleStrain_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey CRS_Matrix, CRS_Cross,
3>        _Cross_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey CRS_Matrix, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey CRS_Progeny, CRS_Cross,
3>        _Cross_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey CRS_References, CRS_Cross,
3>        _Cross_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey CRS_References, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey CRS_References, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey CRS_Typings, CRS_Cross,
3>        _Cross_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey CRS_Typings, CRS_Matrix,
3>        _Cross_key,
4>        rowNumber
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey GXD_Index, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey GXD_Index, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey GXD_Index_Stages, GXD_Index,
3>        index_id
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey HMD_Homology, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey HMD_Homology, HMD_Class,
3>        _Class_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey HMD_Homology_Assay, HMD_Homology,
3>        _Homology_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey HMD_Homology_Assay, HMD_Assay,
3>        _Assay_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey HMD_Homology_Marker, HMD_Homology,
3>        _Homology_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey HMD_Homology_Marker, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey HMD_Notes, HMD_Homology,
3>        _Homology_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLC_History, MRK_Marker,
3>        _Marker_key
Foreign key table doesn't exist.
(return status = 1)
1>  
2> exec sp_foreignkey MLC_History_edit, MRK_Marker,
3>        _Marker_key
Foreign key table doesn't exist.
(return status = 1)
1>  
2> exec sp_foreignkey MLC_Lock_edit, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLC_Lock_edit, MLC_Text,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLC_Marker, MRK_Marker,
3>        _Marker_key_2
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLC_Marker, MLC_Text,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLC_Marker_edit, MRK_Marker,
3>        _Marker_key_2
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLC_Marker_edit, MLC_Text,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLC_Reference, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLC_Reference, MLC_Text,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLC_Reference, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLC_Reference_edit, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLC_Reference_edit, MLC_Text,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLC_Reference_edit, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLC_Text, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLC_Text_edit, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Concordance, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Concordance, MLD_Hybrid,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Concordance, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Contig, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_ContigProbe, PRB_Probe,
3>        _Probe_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_ContigProbe, MLD_Contig,
3>        _Contig_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Distance, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Distance, MLD_PhysMap,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Distance, MRK_Marker,
3>        _Marker_key_2
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Distance, MRK_Marker,
3>        _Marker_key_1
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Expt_Marker, MRK_Allele,
3>        _Allele_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Expt_Marker, MLD_Assay_Types,
3>        _Assay_Type_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Expt_Marker, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Expt_Marker, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Expt_Notes, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Expts, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_FISH, PRB_Strain,
3>        _Strain_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_FISH, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_FISH_Region, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_FISH_Region, MLD_FISH,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Hit, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Hit, PRB_Probe,
3>        _Probe_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Hit, PRB_Probe,
3>        _Target_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Hybrid, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_InSitu, PRB_Strain,
3>        _Strain_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_InSitu, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_ISRegion, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_ISRegion, MLD_InSitu,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Marker, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Marker, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Matrix, CRS_Cross,
3>        _Cross_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Matrix, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_MC2point, MLD_Matrix,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_MC2point, MRK_Marker,
3>        _Marker_key_2
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_MC2point, MRK_Marker,
3>        _Marker_key_1
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_MCDataList, MLD_Matrix,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Notes, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_PhysMap, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_RI, RI_RISet,
3>        _RISet_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_RI, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_RI2Point, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_RI2Point, MLD_RI,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_RI2Point, MRK_Marker,
3>        _Marker_key_2
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_RI2Point, MRK_Marker,
3>        _Marker_key_1
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_RIData, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_RIData, MLD_RI,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_RIData, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Statistics, MLD_Expts,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Statistics, MRK_Marker,
3>        _Marker_key_2
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MLD_Statistics, MRK_Marker,
3>        _Marker_key_1
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Alias, MRK_Marker,
3>        _Alias_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Alias, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Allele, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Anchors, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Chromosome, MRK_Species,
3>        _Species_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Classes, MRK_Class,
3>        _Class_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Classes, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Current, MRK_Marker,
3>        _Current_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Current, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_History, MRK_Marker,
3>        _History_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_History, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_History, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Marker, MRK_Types,
3>        _Marker_Type_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Marker, MRK_Species,
3>        _Species_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Name, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Name, MRK_Types,
3>        _Marker_Type_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Notes, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Offset, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Other, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Reference, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Reference, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Symbol, MRK_Types,
3>        _Marker_Type_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey MRK_Symbol, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Alias, PRB_Reference,
3>        _Reference_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Allele, PRB_RFLV,
3>        _RFLV_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Allele_Strain, PRB_Allele,
3>        _Allele_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Allele_Strain, PRB_Strain,
3>        _Strain_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Marker, PRB_Probe,
3>        _Probe_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Marker, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Notes, PRB_Probe,
3>        _Probe_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Probe, PRB_Vector_Types,
3>        _Vector_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Probe, PRB_Source,
3>        _Source_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Probe, PRB_Probe,
3>        derivedFrom
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Ref_Notes, PRB_Reference,
3>        _Reference_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Reference, PRB_Probe,
3>        _Probe_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Reference, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_RFLV, PRB_Reference,
3>        _Reference_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_RFLV, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Source, PRB_Tissue,
3>        _Tissue_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Source, PRB_Strain,
3>        _Strain_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey PRB_Source, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey RI_Summary, RI_RISet,
3>        _RISet_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey RI_Summary, MRK_Marker,
3>        _Marker_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey RI_Summary_Expt_Ref, MLD_RI,
3>        _Expt_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey RI_Summary_Expt_Ref, RI_Summary,
3>        _RISummary_key
New foreign key added.
(return status = 0)
1>  
2> exec sp_foreignkey RI_Summary_Expt_Ref, BIB_Refs,
3>        _Refs_key
New foreign key added.
(return status = 0)
1>  
2> /* GXD Schema */
3> 
4> sp_foreignkey GXD_Genotype, PRB_Strain, _Strain_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_AllelePair, GXD_Genotype, _Genotype_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_AllelePair, MRK_Allele, _Allele_key_1
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_AllelePair, MRK_Allele, _Allele_key_2
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_AllelePair, MRK_Marker, _Marker_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Antigen, PRB_Source, _Source_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Antibody, GXD_AntibodyClass, _AntibodyClass_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Antibody, GXD_AntibodyType, _AntibodyType_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Antibody, GXD_Antigen, _Antigen_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Antibody, BIB_Refs, _Refs_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_AntibodyAlias, GXD_Antibody, _Antibody_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_AntibodyAlias, BIB_Refs, _Refs_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_AntibodyMarker, GXD_Antibody, _Antibody_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_AntibodyMarker, MRK_Marker, _Marker_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Structure, GXD_Structure, _Parent_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Structure, GXD_StructureName, _StructureName_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Structure, GXD_TheilerStage, _Stage_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Structurename, GXD_Structure, _Structure_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_StructureClosure, GXD_Structure, _Structure_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_StructureClosure, GXD_Structure, _Descendent_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_ProbePrep, PRB_Probe, _Probe_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_ProbePrep, GXD_ProbeSense, _Sense_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_ProbePrep, GXD_Label, _Label_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_ProbePrep, GXD_LabelCoverage, _Coverage_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_ProbePrep, GXD_VisualizationMethod, _Visualization_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_AntibodyPrep, GXD_Antibody, _Antibody_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_AntibodyPrep, GXD_Secondary, _Secondary_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_AntibodyPrep, GXD_Label, _Label_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Assay, GXD_AssayType, _AssayType_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Assay, BIB_Refs, _Refs_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Assay, MRK_Marker, _Marker_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Assay, GXD_ProbePrep, _ProbePrep_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Assay, GXD_AntibodyPrep, _AntibodyPrep_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Assay, IMG_ImagePane, _ImagePane_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_AssayNote, GXD_Assay, _Assay_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_GelLane, GXD_Assay, _Assay_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_GelLane, GXD_Genotype, _Genotype_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_GelLane, GXD_GelRNAType, _GelRNAType_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_GelLane, GXD_GelControl, _GelControl_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_GelLaneStructure, GXD_GelLane, _GelLane_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_GelLaneStructure, GXD_Structure, _Structure_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_GelRow, GXD_Assay, _Assay_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_GelRow, GXD_GelUnits, _GelUnits_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_GelBand, GXD_GelLane, _GelLane_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_GelBand, GXD_GelRow, _GelRow_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_GelBand, GXD_Strength, _Strength_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Specimen, GXD_Assay, _Assay_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Specimen, GXD_EmbeddingMethod, _Embedding_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Specimen, GXD_FixationMethod, _Fixation_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Specimen, GXD_Genotype, _Genotype_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_InSituResult, GXD_Specimen, _Specimen_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_InSituResult, GXD_Strength, _Strength_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_InSituResult, GXD_Pattern, _Pattern_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_ISResultStructure, GXD_InSituResult, _Result_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_ISResultStructure, GXD_Structure, _Structure_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_InSituResultImage, GXD_InSituResult, _Result_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_InSituResultImage, IMG_ImagePane, _ImagePane_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Expression, GXD_Assay, _Assay_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Expression, GXD_AssayType, _AssayType_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Expression, GXD_Genotype, _Genotype_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Expression, MRK_Marker, _Marker_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey GXD_Expression, GXD_Structure, _Structure_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey IMG_Image, BIB_Refs, _Refs_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey IMG_ImageNote, IMG_Image, _Image_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey IMG_ImagePane, IMG_Image, _Image_key
New foreign key added.
(return status = 0)
1> 
2> sp_foreignkey IMG_ImagePane, IMG_FieldType, _FieldType_key
New foreign key added.
(return status = 0)
1> 
2> /* End GXD Schema */
3> checkpoint
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12406.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12406.sql
Password: 
1> 
2> use mgd
1> 
2> exec sp_unbindrule 'BIB_Refs.NLMstatus'
Rule unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindrule 'PRB_Marker.relationship'
Rule unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindrule 'PRB_Probe.DNAtype'
Rule unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindrule 'PRB_Source.sex'
Rule unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindrule 'GXD_GelLane.sex' 
The specified column has no rule.
(return status = 1)
1> 
2> exec sp_unbindrule 'GXD_Specimen.sex'
The specified column has no rule.
(return status = 1)
1> 
2> drop rule check_DNAtype
1> 
2> drop rule check_NLM_status
1> 
2> drop rule check_Relationship
1> 
2> drop rule check_Sex
1> 
2> CREATE RULE check_DNAtype AS @col IN ('DNA (construct)', 'EST', 'RNA', 'cDNA', 'genomic', 'mitochondrial', 'oligo', 'primer', 'Not Specified')
1> 
2> CREATE RULE check_NLM_status AS @col IN ('Y', 'N', 'X')
1> 
2> CREATE RULE check_Relationship AS @col IN ('A', 'E', 'H', 'M', 'P')
1> 
2> CREATE RULE check_Sex AS @col IN ('Female', 'Male', 'Pooled', 'Not Specified','Not Applicable')
1> 
2> exec sp_bindrule check_NLM_status, 'BIB_Refs.NLMstatus'
Rule bound to table column.
(return status = 0)
1> 
2> exec sp_bindrule check_Relationship, 'PRB_Marker.relationship'
Rule bound to table column.
(return status = 0)
1> 
2> exec sp_bindrule check_DNAtype, 'PRB_Probe.DNAtype'
Rule bound to table column.
(return status = 0)
1> 
2> exec sp_bindrule check_Sex, 'PRB_Source.sex'
Rule bound to table column.
(return status = 0)
1> 
2> /* GXD Schema */
3> 
4> exec sp_unbindrule 'GXD_ProbePrep.type'
Rule unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindrule 'GXD_Specimen.hybridization' 
The specified column has no rule.
(return status = 1)
1> 
2> drop rule check_Hybridization
1> 
2> drop rule check_NucleicAcidType
1> 
2> CREATE RULE check_Hybridization
3>      AS @col IN ('whole mount', 'sections', 'section from whole mount', 'Not Specified', 'Not Applicable')
1> 
2> CREATE RULE check_NucleicAcidType
3>      AS @col IN ('DNA', 'RNA', 'Not Specified')
1> 
2> exec sp_bindrule check_sex, 'GXD_GelLane.sex'
Rule bound to table column.
(return status = 0)
1> 
2> exec sp_bindrule check_NucleicAcidType, 'GXD_ProbePrep.type'
Rule bound to table column.
(return status = 0)
1> 
2> exec sp_bindrule check_sex, 'GXD_Specimen.sex'
Rule bound to table column.
(return status = 0)
1> 
2> exec sp_bindrule check_Hybridization, 'GXD_Specimen.hybridization'
Rule bound to table column.
(return status = 0)
1> 
2> /* End GXD Schema */
3> 
4> checkpoint
rm /tmp/12406.sql
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12416.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12416.sql
Password: 
1> 
2> use mgd
1> 
2> exec sp_unbindefault "ACC_LogicalDB.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Ref_Notes.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_RFLV.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Notes.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Notes.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Offset.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Offset.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Other.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Other.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Species.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Species.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Types.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Types.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Name.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Name.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Symbol.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Symbol.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Strain.standard"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Strain.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Strain.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Alias.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Alias.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_Accession.private"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_Accession.preferred"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_Accession.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_Accession.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_Accession.release_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Allele.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Allele.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_AccessionMax.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_AccessionMax.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_AccessionMax.release_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Marker.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Marker.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_AccessionReference.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_AccessionReference.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_AccessionReference.release_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Notes.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Notes.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_ActualDB.active"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_ActualDB.allowsMultiple"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_ActualDB.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_ActualDB.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_ActualDB.release_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Ref_Notes.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_LogicalDB.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_LogicalDB.release_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_MGIType.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_MGIType.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "ACC_MGIType.release_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Probe.moreProduct"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Probe.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Probe.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Reference.hasRmap"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Reference.hasSequence"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Reference.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Reference.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "BIB_Books.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "BIB_Books.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_RFLV.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "BIB_Notes.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "BIB_Notes.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Tissue.standard"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Tissue.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Tissue.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Vector_Types.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Vector_Types.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "RI_RISet.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "RI_RISet.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "CRS_Matrix.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "CRS_Matrix.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "HMD_Homology_Marker.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "HMD_Homology_Marker.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "RI_Summary.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "RI_Summary.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "CRS_Progeny.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "CRS_Progeny.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "RI_Summary_Expt_Ref.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "RI_Summary_Expt_Ref.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "CRS_References.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "CRS_References.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "HMD_Homology.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "HMD_Homology.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "CRS_Typings.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "CRS_Typings.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index_Stages.insitu_protein_section"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index_Stages.insitu_rna_section"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index_Stages.insitu_protein_mount"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index_Stages.insitu_rna_mount"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index_Stages.northern"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index_Stages.western"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index_Stages.rt_pcr"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index_Stages.clones"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index_Stages.rnase"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index_Stages.nuclease"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index_Stages.primer_extension"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index_Stages.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_Index_Stages.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "CRS_Cross.alleleFromSegParent"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "CRS_Cross.F1DirectionKnown"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "CRS_Cross.displayed"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "CRS_Cross.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "CRS_Cross.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "HMD_Homology_Assay.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "HMD_Homology_Assay.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MGD_Comments.creation_date"
You do not own a table with a column of that name.
(return status = 1)
1> 
2> exec sp_unbindefault "MGD_Comments.modification_date"
You do not own a table with a column of that name.
(return status = 1)
1> 
2> exec sp_unbindefault "MGD_LastLoad.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MGD_LastLoad.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MGD_Tables.creation_date"
You do not own a table with a column of that name.
(return status = 1)
1> 
2> exec sp_unbindefault "MGD_Tables.modification_date"
You do not own a table with a column of that name.
(return status = 1)
1> 
2> exec sp_unbindefault "MLC_History.time"
You do not own a table with a column of that name.
(return status = 1)
1> 
2> exec sp_unbindefault "MLC_History.creation_date"
You do not own a table with a column of that name.
(return status = 1)
1> 
2> exec sp_unbindefault "MLC_History.modification_date"
You do not own a table with a column of that name.
(return status = 1)
1> 
2> exec sp_unbindefault "BIB_Refs.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "BIB_Refs.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_History_edit.time"
You do not own a table with a column of that name.
(return status = 1)
1> 
2> exec sp_unbindefault "MLC_History_edit.creation_date"
You do not own a table with a column of that name.
(return status = 1)
1> 
2> exec sp_unbindefault "MLC_History_edit.modification_date"
You do not own a table with a column of that name.
(return status = 1)
1> 
2> exec sp_unbindefault "MLC_Lock_edit.checkedOut"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_Lock_edit.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_Lock_edit.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "HMD_Notes.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "HMD_Notes.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_Marker.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_Marker.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_Marker_edit.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_Marker_edit.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_Reference.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_Reference.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_Reference_edit.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_Reference_edit.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_Text.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_Text.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_Text_edit.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLC_Text_edit.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Assay_Types.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Assay_Types.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Concordance.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Concordance.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Contig.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Contig.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Allele_Strain.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Allele_Strain.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_ContigProbe.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_ContigProbe.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Distance.units"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Distance.realisticDist"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Distance.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Distance.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Expt_Marker.matrixData"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Expt_Marker.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Expt_Marker.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Expt_Notes.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Expt_Notes.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "HMD_Class.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "HMD_Class.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Expts.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Expts.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "BIB_ReviewStatus.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "BIB_ReviewStatus.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_FISH.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_FISH.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Reference.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Reference.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_FISH_Region.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_FISH_Region.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Hit.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Hit.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Hybrid.chrsOrGenes"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Hybrid.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Hybrid.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_InSitu.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_InSitu.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_ISRegion.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_ISRegion.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Marker.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Marker.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Matrix.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Matrix.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_MC2point.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_MC2point.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_MCDataList.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_MCDataList.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Notes.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Notes.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_PhysMap.definitiveOrder"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_PhysMap.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_PhysMap.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Source.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "PRB_Source.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_RI.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_RI.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_RI2Point.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_RI2Point.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_RIData.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_RIData.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Statistics.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MLD_Statistics.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Alias.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Alias.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "IDDS_TimeStamp.dump_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Allele.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Allele.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Anchors.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Anchors.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Chromosome.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Chromosome.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Class.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Class.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "HMD_Assay.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "HMD_Assay.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Classes.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Classes.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Current.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Current.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_History.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_History.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Marker.creation_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "MRK_Marker.modification_date"
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AllelePair.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AllelePair.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Antibody.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Antibody.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AntibodyClass.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AntibodyClass.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AntibodyMarker.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AntibodyMarker.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AntibodyPrep.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AntibodyPrep.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AntibodyType.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AntibodyType.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Antigen.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Antigen.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Assay.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Assay.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AssayNote.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AssayNote.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AssayType.isRNAAssay'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AssayType.isGelAssay'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AssayType.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AssayType.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_EmbeddingMethod.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_EmbeddingMethod.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Expression.expressed'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Expression.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Expression.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_FixationMethod.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_FixationMethod.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_GelBand.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_GelBand.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_GelLane.creation_date'
The specified column has no default.
(return status = 1)
1> 
2> exec sp_unbindefault 'GXD_GelLane.modification_date'
The specified column has no default.
(return status = 1)
1> 
2> exec sp_unbindefault 'GXD_GelLaneStructure.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_GelLaneStructure.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_GelRNAType.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_GelRNAType.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_GelRow.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_GelRow.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_GelUnits.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_GelUnits.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Genotype.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Genotype.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_InSituResult.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_InSituResult.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_InSituResultImage.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_InSituResultImage.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_ISResultStructure.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_ISResultStructure.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_LabelCoverage.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_LabelCoverage.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Pattern.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Pattern.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Label.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Label.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_ProbePrep.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_ProbePrep.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_ProbeSense.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_ProbeSense.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Secondary.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Secondary.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Specimen.creation_date'
The specified column has no default.
(return status = 1)
1> 
2> exec sp_unbindefault 'GXD_Specimen.modification_date'
The specified column has no default.
(return status = 1)
1> 
2> exec sp_unbindefault 'GXD_Strength.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Strength.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Structure.printStop'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Structure.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_Structure.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_StructureClosure.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_StructureClosure.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_StructureName.mgiAdded'
The specified column has no default.
(return status = 1)
1> 
2> exec sp_unbindefault 'GXD_StructureName.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_StructureName.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_TheilerStage.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_TheilerStage.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_VisualizationMethod.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_VisualizationMethod.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'IMG_FieldType.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'IMG_FieldType.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'IMG_Image.creation_date'
The specified column has no default.
(return status = 1)
1> 
2> exec sp_unbindefault 'IMG_Image.modification_date'
The specified column has no default.
(return status = 1)
1> 
2> exec sp_unbindefault 'IMG_ImagePane.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'IMG_ImagePane.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AntibodyAlias.creation_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault 'GXD_AntibodyAlias.modification_date'
Default unbound from table column.
(return status = 0)
1> 
2> exec sp_unbindefault "GXD_GelControl.creation_date"
The specified column has no default.
(return status = 1)
1> 
2> exec sp_unbindefault "GXD_GelControl.modification_date"
The specified column has no default.
(return status = 1)
1> 
2> exec sp_unbindefault "IMG_ImageNote.creation_date"
The specified column has no default.
(return status = 1)
1> 
2> exec sp_unbindefault "IMG_ImageNote.modification_date"
The specified column has no default.
(return status = 1)
1> 
2> drop default bit_default
1> 
2> drop default current_date_default
Msg 3716, Level 16, State 1:
Line 2:
The default 'current_date_default' cannot be dropped because it is bound to one
or more column.
1> 
2> drop default preferred
1> 
2> CREATE DEFAULT bit_default AS 0
1> 
2> CREATE DEFAULT current_date_default AS getdate()
Msg 2714, Level 16, State 1:
Procedure 'current_date_default', Line 2:
There is already an object named 'current_date_default' in the database.
1> 
2> CREATE DEFAULT preferred AS 1
1> 
2> exec sp_bindefault preferred, 'ACC_Accession.preferred'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'ACC_Accession.private'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_Accession.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_Accession.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_Accession.release_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_AccessionMax.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_AccessionMax.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_AccessionMax.release_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_AccessionReference.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_AccessionReference.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_AccessionReference.release_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'ACC_ActualDB.active'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'ACC_ActualDB.allowsMultiple'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_ActualDB.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_ActualDB.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_ActualDB.release_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_LogicalDB.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_LogicalDB.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_LogicalDB.release_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_MGIType.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_MGIType.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'ACC_MGIType.release_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'BIB_Books.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'BIB_Books.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'BIB_Notes.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'BIB_Notes.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'BIB_Refs.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'BIB_Refs.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'BIB_ReviewStatus.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'BIB_ReviewStatus.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'CRS_Cross.alleleFromSegParent'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'CRS_Cross.F1DirectionKnown'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'CRS_Cross.displayed'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'CRS_Cross.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'CRS_Cross.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'CRS_Matrix.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'CRS_Matrix.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'CRS_Progeny.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'CRS_Progeny.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'CRS_References.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'CRS_References.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'CRS_Typings.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'CRS_Typings.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Index.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Index.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_Index_Stages.insitu_protein_section'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_Index_Stages.insitu_rna_section'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_Index_Stages.insitu_protein_mount'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_Index_Stages.insitu_rna_mount'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_Index_Stages.northern'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_Index_Stages.western'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_Index_Stages.rt_pcr'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_Index_Stages.clones'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_Index_Stages.rnase'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_Index_Stages.nuclease'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_Index_Stages.primer_extension'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Index_Stages.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Index_Stages.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'HMD_Assay.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'HMD_Assay.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'HMD_Class.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'HMD_Class.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'HMD_Homology.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'HMD_Homology.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'HMD_Homology_Assay.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'HMD_Homology_Assay.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'HMD_Homology_Marker.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'HMD_Homology_Marker.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'HMD_Notes.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'HMD_Notes.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'IDDS_TimeStamp.dump_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MGD_Comments.creation_date'
You do not own a column of that name.
(return status = 1)
1> 
2> exec sp_bindefault current_date_default, 'MGD_Comments.modification_date'
You do not own a column of that name.
(return status = 1)
1> 
2> exec sp_bindefault current_date_default, 'MGD_LastLoad.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MGD_LastLoad.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MGD_Tables.creation_date'
You do not own a column of that name.
(return status = 1)
1> 
2> exec sp_bindefault current_date_default, 'MGD_Tables.modification_date'
You do not own a column of that name.
(return status = 1)
1> 
2> exec sp_bindefault current_date_default, 'MLC_History.time'
You do not own a column of that name.
(return status = 1)
1> 
2> exec sp_bindefault current_date_default, 'MLC_History.creation_date'
You do not own a column of that name.
(return status = 1)
1> 
2> exec sp_bindefault current_date_default, 'MLC_History.modification_date'
You do not own a column of that name.
(return status = 1)
1> 
2> exec sp_bindefault current_date_default, 'MLC_History_edit.time'
You do not own a column of that name.
(return status = 1)
1> 
2> exec sp_bindefault current_date_default, 'MLC_History_edit.creation_date'
You do not own a column of that name.
(return status = 1)
1> 
2> exec sp_bindefault current_date_default, 'MLC_History_edit.modification_date'
You do not own a column of that name.
(return status = 1)
1> 
2> exec sp_bindefault bit_default, 'MLC_Lock_edit.checkedOut'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Lock_edit.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Lock_edit.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Marker.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Marker.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Marker_edit.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Marker_edit.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Reference.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Reference.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Reference_edit.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Reference_edit.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Text.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Text.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Text_edit.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLC_Text_edit.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Assay_Types.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Assay_Types.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Concordance.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Concordance.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Contig.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Contig.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_ContigProbe.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_ContigProbe.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'MLD_Distance.units'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'MLD_Distance.realisticDist'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Distance.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Distance.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'MLD_Expt_Marker.matrixData'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Expt_Marker.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Expt_Marker.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Expt_Notes.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Expt_Notes.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Expts.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Expts.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_FISH.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_FISH.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_FISH_Region.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_FISH_Region.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Hit.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Hit.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'MLD_Hybrid.chrsOrGenes'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Hybrid.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Hybrid.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_InSitu.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_InSitu.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_ISRegion.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_ISRegion.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Marker.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Marker.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Matrix.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Matrix.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_MC2point.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_MC2point.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_MCDataList.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_MCDataList.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Notes.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Notes.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'MLD_PhysMap.definitiveOrder'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_PhysMap.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_PhysMap.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_RI.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_RI.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_RI2Point.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_RI2Point.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_RIData.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_RIData.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Statistics.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MLD_Statistics.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Alias.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Alias.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Allele.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Allele.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Anchors.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Anchors.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Chromosome.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Chromosome.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Class.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Class.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Classes.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Classes.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Current.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Current.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_History.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_History.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Marker.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Marker.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Name.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Name.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Notes.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Notes.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Offset.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Offset.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Other.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Other.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Reference.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Reference.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Species.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Species.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Symbol.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Symbol.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Types.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'MRK_Types.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Alias.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Alias.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Allele.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Allele.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Allele_Strain.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Allele_Strain.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Marker.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Marker.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Notes.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Notes.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'PRB_Probe.moreProduct'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Probe.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Probe.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Ref_Notes.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Ref_Notes.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'PRB_Reference.hasRmap'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'PRB_Reference.hasSequence'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Reference.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Reference.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_RFLV.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_RFLV.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Source.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Source.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'PRB_Strain.standard'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Strain.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Strain.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'PRB_Tissue.standard'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Tissue.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Tissue.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Vector_Types.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'PRB_Vector_Types.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'RI_RISet.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'RI_RISet.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'RI_Summary.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'RI_Summary.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'RI_Summary_Expt_Ref.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'RI_Summary_Expt_Ref.modification_date'
Default bound to column.
(return status = 0)
1> 
2> /*New GXD schema part: March 9, 1998*/
3> 
4> exec sp_bindefault current_date_default, 'GXD_AllelePair.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AllelePair.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Antibody.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Antibody.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AntibodyClass.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AntibodyClass.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AntibodyMarker.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AntibodyMarker.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AntibodyPrep.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AntibodyPrep.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AntibodyType.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AntibodyType.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Antigen.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Antigen.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Assay.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Assay.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AssayNote.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AssayNote.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_AssayType.isRNAAssay'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_AssayType.isGelAssay'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AssayType.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AssayType.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_EmbeddingMethod.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_EmbeddingMethod.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_Expression.expressed'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Expression.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Expression.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_FixationMethod.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_FixationMethod.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_GelBand.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_GelBand.modification_date'
Default bound to column.
(return status = 0)
1> 
2> /* Remove for new release  */
3> /* exec sp_bindefault bit_default, 'GXD_GelLane.isControl' */
4> /* go */
5> 
6> exec sp_bindefault current_date_default, 'GXD_GelLane.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_GelLane.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_GelLaneStructure.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_GelLaneStructure.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_GelRNAType.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_GelRNAType.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_GelRow.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_GelRow.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_GelUnits.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_GelUnits.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Genotype.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Genotype.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_InSituResult.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_InSituResult.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_InSituResultImage.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_InSituResultImage.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_ISResultStructure.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_ISResultStructure.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_LabelCoverage.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_LabelCoverage.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Pattern.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Pattern.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Label.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Label.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_ProbePrep.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_ProbePrep.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_ProbeSense.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_ProbeSense.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Secondary.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Secondary.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Specimen.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Specimen.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Strength.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Strength.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_Structure.printStop'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Structure.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_Structure.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_StructureClosure.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_StructureClosure.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault bit_default, 'GXD_StructureName.mgiAdded'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_StructureName.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_StructureName.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_TheilerStage.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_TheilerStage.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_VisualizationMethod.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_VisualizationMethod.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'IMG_FieldType.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'IMG_FieldType.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'IMG_Image.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'IMG_Image.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'IMG_ImagePane.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'IMG_ImagePane.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AntibodyAlias.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_AntibodyAlias.modification_date'
Default bound to column.
(return status = 0)
1> 
2> /* New release items feb 1999 */
3> exec sp_bindefault current_date_default, 'GXD_GelControl.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'GXD_GelControl.modification_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'IMG_ImageNote.creation_date'
Default bound to column.
(return status = 0)
1> 
2> exec sp_bindefault current_date_default, 'IMG_ImageNote.modification_date'
Default bound to column.
(return status = 0)
1> 
2> /* End new GXD schema part */
3> 
4> checkpoint
rm /tmp/12416.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger ACC_Accession_Insert
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'ACC_Accession_Insert', because it doesn't exist in the
system catalogs.
1> 
2> create trigger ACC_Accession_Insert
3> on ACC_Accession
4> for insert
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   declare @accID varchar(30)
10>   select @accID = accID from inserted
11> 
12>   /* If adding Sequence ID for Molecular Segment */
13>   /* and the Sequence ID does not exist for one of the encoding Markers */
14> 
15>   if (select _LogicalDB_key from inserted) = 9 and
16>       (select _MGIType_key from inserted) = 3 and
17>       not exists (select a._Accession_key
18>               from ACC_Accession a, PRB_Marker pm, inserted i
19>               where i.accID = a.accID and
20>                 i._Object_key = pm._Probe_key and
21>                 pm.relationship = "E" and
22>                 pm._Marker_key = a._Object_key and
23>                 a._MGIType_key = 2)
24>   begin
25>     print "The Sequence ID '%1!' should probably be added to the encoding Marker(s).", @accID
26>   end
27> 
28>   /* If inserting the Sequence or SWISS-PROT ID for a Marker */
29>   /* and the same ID exists for another Marker...*/
30> 
31>   if (select _LogicalDB_key from inserted) in (9, 13) and
32>       (select _MGIType_key from inserted) = 2 and
33>       exists (select a._Accession_key
34>               from ACC_Accession a, inserted i
35>               where i.accID = a.accID and
36>                 i._Object_key != a._Object_key and
37>                 a._MGIType_key = 2)
38>   begin
39>     print "The Accession ID '%1!' is associated with another Marker.", @accID
40>   end
41> 
42> end
43> 
1> 
2> drop trigger ACC_Accession_Update
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'ACC_Accession_Update', because it doesn't exist in the
system catalogs.
1> 
2> create trigger ACC_Accession_Update
3> on ACC_Accession
4> for update
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   declare @accID varchar(30)
10>   select @accID = accID from deleted
11> 
12>   /* If updating Sequence ID for Molecular Segment */
13>   /* and the same Sequence ID exists for one of the Segment's Markers... */
14> 
15>   if (select _LogicalDB_key from inserted) = 9 and
16>       (select _MGIType_key from inserted) = 3 and
17>       exists (select a._Accession_key
18>               from ACC_Accession a, PRB_Marker pm, deleted d
19>               where d.accID = a.accID and
20>                 d._Object_key = pm._Probe_key and
21>                 pm._Marker_key = a._Object_key and
22>                 a._MGIType_key = 2)
23>   begin
24>     print "Please review the relationship(s) between the Sequence ID '%1!' and the Molecular Segment's Marker(s).  These relationships may no longer be appropriate.", @accID
25>   end
26> 
27>   /* If updating the Sequence ID for a Marker */
28>   /* and the same Sequence ID exists for one of the Marker's Segments...*/
29> 
30>   if (select _LogicalDB_key from inserted) = 9 and
31>       (select _MGIType_key from inserted) = 2 and
32>       exists (select a._Accession_key
33>               from ACC_Accession a, PRB_Marker pm, deleted d
34>               where d.accID = a.accID and
35>                 d._Object_key = pm._Marker_key and
36>                 pm._Probe_key = a._Object_key and
37>                 a._MGIType_key = 3)
38>   begin
39>     print "Please review the relationship(s) between the Sequence ID '%1!' and its Molecular Segments.  These relationships may no longer be appropriate.", @accID
40>   end
41> 
42>   /* If updating the Sequence or SWISS-PROT ID for a Marker */
43>   /* and the same ID exists for another Marker...*/
44> 
45>   if (select _LogicalDB_key from inserted) in (9, 13) and
46>       (select _MGIType_key from inserted) = 2 and
47>       exists (select a._Accession_key
48>               from ACC_Accession a, inserted i
49>               where i.accID = a.accID and
50>                 i._Object_key != a._Object_key and
51>                 a._MGIType_key = 2)
52>   begin
53>     print "The Accession ID '%1!' is associated with another Marker.", @accID
54>   end
55> end
56> 
1> 
2> drop trigger ACC_Accession_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'ACC_Accession_Delete', because it doesn't exist in the
system catalogs.
1> 
2> create trigger ACC_Accession_Delete
3> on ACC_Accession
4> for delete
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   /* If deleting MGI Image Pixel number, then nullify X/Y Dimensions of IMG_Image record TR#134 */
10> 
11>   if (select _LogicalDB_key from deleted) = 19
12>   begin
13>     update IMG_Image
14>     set IMG_Image.xDim = null, 
15>         IMG_Image.yDim = null
16>     from deleted, IMG_Image
17>     where deleted._Object_key = IMG_Image._Image_key
18>   end
19> 
20>   /* If deleting Sequence ID from Molecular Segment */
21>   /* and the same Sequence ID exists for one of the Segment's Markers... */
22> 
23>   declare @accID varchar(30)
24>   select @accID = accID from deleted
25> 
26>   if (select _LogicalDB_key from deleted) = 9 and
27>       (select _MGIType_key from deleted) = 3 and
28>       exists (select a._Accession_key
29>               from ACC_Accession a, PRB_Marker pm, deleted d
30>               where d.accID = a.accID and
31>                 d._Object_key = pm._Probe_key and
32>                 pm._Marker_key = a._Object_key and
33>                 a._MGIType_key = 2)
34>   begin
35>     print "Please review the relationship(s) between the Sequence ID '%1!' and the Molecular Segment's Marker(s).  These relationships may no longer be appropriate.", @accID
36>   end
37> 
38>   /* If deleting the Sequence ID from a Marker */
39>   /* and the same Sequence ID exists for one of the Marker's Segments...*/
40> 
41>   if (select _LogicalDB_key from deleted) = 9 and
42>       (select _MGIType_key from deleted) = 2 and
43>       exists (select a._Accession_key
44>               from ACC_Accession a, PRB_Marker pm, deleted d
45>               where d.accID = a.accID and
46>                 d._Object_key = pm._Marker_key and
47>                 pm._Probe_key = a._Object_key and
48>                 a._MGIType_key = 3)
49>   begin
50>     print "Please review the relationship(s) between the Sequence ID '%1!' and its Molecular Segments.  These relationships may no longer be appropriate.", @accID
51>   end
52> end
53> 
1> 
2> drop trigger ACC_AccessionReference_Delete
1> 
2> create trigger ACC_AccessionReference_Delete
3> on ACC_AccessionReference
4> for delete
5> as
6> 
7> /* If AccID is not referenced by other References in ACC_AccessionReference,
8>    then delete AccID from ACC_Accesion table too.
9> */
10>  
11> if (select count(*) from ACC_AccessionReference a, deleted d
12>     where a._Accession_key = d._Accession_key) = 0
13> begin
14>     delete ACC_Accession 
15>     from ACC_Accession a, deleted d
16>     where a._Accession_key = d._Accession_key
17> end
18> 
1> 
2> checkpoint
1> 
2> drop trigger ACC_LogicalDB_Delete 
1> 
2> create trigger ACC_LogicalDB_Delete 
3> on ACC_LogicalDB
4> for delete
5> as
6> 
7> if (select count(*)
8>         from deleted, ACC_Accession
9>         where ACC_Accession._LogicalDB_key = deleted._LogicalDB_key) > 0
10>  
11> begin
12>     rollback transaction
13>     raiserror 99999 "Logical DB is referenced in Accession Record(s)"
14>     return
15> end
16> 
17> delete ACC_ActualDB from ACC_ActualDB, deleted
18> where ACC_ActualDB._LogicalDB_key = deleted._LogicalDB_key
19> 
1>  
2>  
3> drop trigger ACC_LogicalDB_Update 
1> 
2> create trigger  ACC_LogicalDB_Update
3> on ACC_LogicalDB
4> for update
5> as
6> 
7> if update(_Species_key) and
8>    (select _Species_key from deleted) != (select _Species_key from inserted) and
9>    (select count (*) from ACC_Accession, inserted
10>     where ACC_Accession._LogicalDB_key = inserted._LogicalDB_key) > 0
11> begin
12>     rollback transaction
13>     raiserror 99999 "Cannot update Species because Accession numbers exist for this Logical DB."
14>     return
15> end
16>  
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger BIB_Refs_Insert
1>  
2> create trigger BIB_Refs_Insert
3> on BIB_Refs
4> for insert
5> as
6>  
7> declare @pgs varchar(30)
8> select @pgs = pgs from inserted
9> 
10> /* Determine if new record constitutes a duplicate record */
11> /* within the Reference (BIB_Refs) table. */
12> /* Parameters to check are journal, year, volume and pages */
13>  
14> /* Mouse News Letter references are ignored because more than one */
15> /* reference can appear on the same page within this journal. */
16>   
17> if (select journal from inserted) != 'Mouse News Lett'
18> begin
19> 
20>   /* If pages in format "x", check for pages = x and pages like "x-%" */
21>   /* If pages in format "x-y", check for pages = x and pages like "x-%" */
22> 
23>   /* Strip off first page */
24>   if charindex("-", @pgs) > 0
25>   begin
26>     select @pgs = substring(@pgs, 1, charindex("-", @pgs) - 1)
27>   end
28> 
29>   if (select count(BIB_Refs._Refs_key) from BIB_Refs, inserted
30>       where BIB_Refs.journal = inserted.journal and
31>             BIB_Refs.year = inserted.year and
32>             BIB_Refs.vol = inserted.vol and
33>             (BIB_Refs.pgs = @pgs or BIB_Refs.pgs like @pgs + "-%")) > 1
34>   begin
35>     rollback transaction
36>     raiserror 99999 "Reference Already Exists"
37>     return
38>   end
39> end
40> 
41> declare @key integer
42> select @key = _Refs_key from inserted
43> exec ACC_assignMGI @key, "Reference"
44> 
45> if (@@error != 0)
46> begin
47>   rollback transaction
48>   return
49> end
50> 
1> 
2> drop trigger BIB_Refs_Update
1>  
2> create trigger BIB_Refs_Update
3> on BIB_Refs
4> for update
5> as
6>  
7> update BIB_Refs 
8> set modification_date = getdate()
9> from BIB_Refs, inserted
10> where BIB_Refs._Refs_key = inserted._Refs_key
11>  
1>  
2> drop trigger BIB_Refs_Delete
1> 
2> create trigger BIB_Refs_Delete
3> on BIB_Refs
4> for delete
5> as
6> 
7> /* Before deleting a record, verify that the J# is not being */
8> /* referenced elsewhere in the database. */
9> 
10> if (select count(*) from deleted
11>     where deleted.dbs like "%Nomen%") > 0
12> begin
13>         rollback transaction
14>         raiserror 99999 "J# is referenced in Nomenclature Record(s)"
15>     return
16> end
17> 
18> if (select count(*) from MRK_History, deleted
19>     where MRK_History._Refs_key = deleted._Refs_key) > 0
20> begin
21>         rollback transaction
22>         raiserror 99999 "J# is referenced in Marker Record(s)"
23>     return
24> end
25> 
26> if (select count(*) from HMD_Homology, deleted
27>          where HMD_Homology._Refs_key = deleted._Refs_key) > 0
28> begin
29>         rollback transaction
30>         raiserror 99999 "J# is referenced in Homology Record(s)"
31>     return
32> end
33> 
34> if (select count(*) from MLC_Reference, deleted
35>          where MLC_Reference._Refs_key = deleted._Refs_key) > 0
36> begin
37>         rollback transaction
38>         raiserror 99999 "J# is referenced in MLC Record(s)"
39>     return
40> end
41> 
42> if (select count(*) from MLC_Reference_edit, deleted
43>          where MLC_Reference_edit._Refs_key = deleted._Refs_key) > 0
44> begin
45>         rollback transaction
46>         raiserror 99999 "J# is referenced in MLC Edit Record(s)"
47>     return
48> end
49> 
50> if (select count(*) from MLD_Expts, deleted
51>          where MLD_Expts._Refs_key = deleted._Refs_key) > 0
52> begin
53>         rollback transaction
54>         raiserror 99999 "J# is referenced in Mapping Record(s)"
55>     return
56> end
57> 
58> if (select count(*) from PRB_Reference, deleted
59>          where PRB_Reference._Refs_key = deleted._Refs_key) > 0
60> begin
61>         rollback transaction
62>         raiserror 99999 "J# is referenced in Probe Record(s)"
63>     return
64> end
65> 
66> if (select count(*) from PRB_Source, deleted
67>          where PRB_Source._Refs_key = deleted._Refs_key) > 0
68> begin
69>         rollback transaction
70>         raiserror 99999 "J# is referenced in Probe Source Record(s)"
71>     return
72> end
73> 
74> if (select count(*) from GXD_Index, deleted
75>          where GXD_Index._Refs_key = deleted._Refs_key) > 0
76> begin
77>         rollback transaction
78>         raiserror 99999 "J# is referenced in GXD Index Record(s)"
79>     return
80> end
81> 
82> if (select count(*) from GXD_Antibody, deleted
83>          where GXD_Antibody._Refs_key = deleted._Refs_key) > 0
84> begin
85>         rollback transaction
86>         raiserror 99999 "J# is referenced in GXD Antibody Record(s)"
87>     return
88> end
89> 
90> if (select count(*) from GXD_AntibodyAlias, deleted
91>          where GXD_AntibodyAlias._Refs_key = deleted._Refs_key) > 0
92> begin
93>         rollback transaction
94>         raiserror 99999 "J# is referenced in GXD Antibody Alias Record(s)"
95>     return
96> end
97> 
98> if (select count(*) from GXD_Assay, deleted
99>          where GXD_Assay._Refs_key = deleted._Refs_key) > 0
100> begin
101>         rollback transaction
102>         raiserror 99999 "J# is referenced in GXD Assay Record(s)"
103>    return
104> end
105> 
106> if (select count(*) from IMG_Image, deleted
107>          where IMG_Image._Refs_key = deleted._Refs_key) > 0
108> begin
109>         rollback transaction
110>         raiserror 99999 "J# is referenced in GXD Image Record(s)"
111>    return
112> end
113> 
114> delete BIB_Books from BIB_Books, deleted
115> where BIB_Books._Refs_key = deleted._Refs_key
116> 
117> delete BIB_Notes from BIB_Notes, deleted
118> where BIB_Notes._Refs_key = deleted._Refs_key
119> 
120> delete ACC_Accession
121> from ACC_Accession a, ACC_MGIType m, deleted
122> where a._Object_key = deleted._Refs_key
123> and a._MGIType_key = m._MGIType_key
124> and m.name = "Reference"
125> 
1> 
2> drop trigger BIB_ReviewStatus_Delete
1> 
2> create trigger BIB_ReviewStatus_Delete
3> on BIB_ReviewStatus
4> for delete
5> as
6> 
7> /* Before deleting a record, verify that the Status is not being */
8> /* referenced elsewhere in the database. */
9> 
10> if (select count(*) from BIB_Refs, deleted
11>     where BIB_Refs._ReviewStatus_key = deleted._ReviewStatus_key) > 0
12> begin
13>         rollback transaction
14>         raiserror 99999 "Review Status is referenced in Reference Record(s)"
15>     return
16> end
17> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger CRS_Cross_Delete
1> 
2> create trigger CRS_Cross_Delete
3> on CRS_Cross
4> for delete
5> as
6> 
7> /* Disallow removal of a record if the Cross is referenced in MLDP */
8> 
9> if (select count(*) from MLD_Matrix, deleted
10>     where MLD_Matrix._Cross_key = deleted._Cross_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Cross is referenced in MLDP Record(s)"
14>     return
15> end
16> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger GXD_Genotype_Delete
1> 
2> create trigger GXD_Genotype_Delete
3> on GXD_Genotype
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> /*if (select count(*) from GXD_GelLane, deleted */
10> /*    where GXD_GelLane._Genotype_key = deleted._Genotype_key) > 0 */
11> /*begin */
12> /*        rollback transaction */
13> /*        raiserror 99999 "Genotype is referenced in Gel Lane Record(s)" */
14> /*  return */
15> /*end */
16> 
17> /*if (select count(*) from GXD_Specimen, deleted */
18> /*    where GXD_Specimen._Genotype_key = deleted._Genotype_key) > 0 */
19> /*begin */
20> /*        rollback transaction */
21> /*        raiserror 99999 "Genotype is referenced in Specimen Record(s)" */
22> /*  return */
23> /*end */
24> 
25> /*if (select count(*) from GXD_Expression, deleted */
26> /*    where GXD_Expression._Genotype_key = deleted._Genotype_key) > 0 */
27> /*begin */
28> /*        rollback transaction */
29> /*        raiserror 99999 "Genotype is referenced in Expression Results (cache) Record(s)" */
30> /*  return */
31> /*end */
32> 
33> delete GXD_AllelePair from GXD_AllelePair, deleted
34> where GXD_AllelePair._Genotype_key = deleted._Genotype_key
35>  
1> 
2> drop trigger GXD_Antigen_Insert
1>  
2> create trigger GXD_Antigen_Insert
3> on GXD_Antigen
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Antigen */
8>  
9> declare @key integer
10> select @key = _Antigen_key from inserted
11> exec ACC_assignMGI @key, "Antigen"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18> 
1>  
2> drop trigger GXD_Antigen_Delete
1> 
2> create trigger GXD_Antigen_Delete
3> on GXD_Antigen
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if (select count(*) from GXD_Antibody, deleted
10>     where GXD_Antibody._Antigen_key = deleted._Antigen_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antigen is referenced in Antibody Record(s)"
14>     return
15> end
16> 
17> /* If Probe Source Name is null, then Anonymous Source */
18> /* If Anonymous Source, delete upon deletion of Antigen */
19>  
20> if (select count(GXD_Antigen._Source_key) from GXD_Antigen, deleted
21>     where GXD_Antigen._Source_key = deleted._Source_key) = 0
22> begin
23>         delete PRB_Source from PRB_Source, deleted
24>         where PRB_Source._Source_key = deleted._Source_key
25>               and PRB_Source.name is null
26> end
27>  
28> delete ACC_Accession 
29> from ACC_Accession a, ACC_MGIType m, deleted
30> where a._Object_key = deleted._Antigen_key
31> and a._MGIType_key = m._MGIType_key
32> and m.name = "Antigen"
33>   
1> 
2> drop trigger GXD_Antibody_Insert
1>  
2> create trigger GXD_Antibody_Insert
3> on GXD_Antibody
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Antibody */
8>  
9> declare @key integer
10> select @key = _Antibody_key from inserted
11> exec ACC_assignMGI @key, "Antibody"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1>  
2> drop trigger GXD_Antibody_Delete
1> 
2> create trigger GXD_Antibody_Delete
3> on GXD_Antibody
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if (select count(*) from GXD_AntibodyPrep, deleted
10>     where GXD_AntibodyPrep._Antibody_key = deleted._Antibody_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody is referenced in Antibody Prep Record(s)"
14>     return
15> end
16> 
17> delete GXD_AntibodyMarker from GXD_AntibodyMarker, deleted
18> where GXD_AntibodyMarker._Antibody_key = deleted._Antibody_key
19>  
20> delete ACC_Accession
21> from ACC_Accession a, ACC_MGIType m, deleted
22> where a._Object_key = deleted._Antibody_key
23> and a._MGIType_key = m._MGIType_key
24> and m.name = "Antibody"
25>  
1> 
2> /* GXD_Structure */
3> 
4> 
5> drop trigger GXD_Structure_Insert
1> 
2> create trigger GXD_Structure_Insert
3> on GXD_Structure
4> for insert
5> as
6> 
7> /* Ensure that _Parent_key of inserted exists as a _Structure_key and
8>    that parent has the same _Stage_key as inserted, if _Parent_key != NULL */
9> 
10> if (select _Parent_key from inserted) != NULL
11> begin
12>     if (select count(*) 
13>         from GXD_Structure s, inserted
14>         where inserted._Parent_key = s._Structure_key
15>         and inserted._Stage_key = s._Stage_key) != 1
16>     begin
17>        rollback transaction
18>        raiserror 99999 "GXD_Structure_Insert: Specified parent Structure does not exist"
19>        return
20>     end
21> end
22> 
23> declare @treeDepth integer
24> select @treeDepth = 1  /* assume that we are adding a child of a Stage node */
25> 
26> /* if the assumption doesn't hold, then the following query will set the
27>    current child's treeDepth */ 
28> 
29> 
30> /* find out the depth of the parent structure */
31> select @treeDepth = s.treeDepth + 1
32> from GXD_Structure s, inserted
33> where s._Structure_key = inserted._Parent_key 
34> 
35> /* update the inserted node */
36> update GXD_Structure
37> set treeDepth = @treeDepth
38> from GXD_Structure s, inserted
39> where s._Structure_key = inserted._Structure_key
40> 
41> if @@error != 0
42> begin
43>   rollback transaction
44>   raiserror 99999 "GXD_Structure_Insert: Update of treeDepth failed"
45>   return
46> end
47> 
48> /* incrementally modify the closure */
49> 
50> declare @inp integer  /* inserted node's parent */
51> select @inp = _Parent_key from inserted
52> 
53> /* _Parent_key will be null for an immediate child of a stage root,
54>    this node, by definition will not have any entries in the closure table,
55>    since it is a root node as far as the database is concerned */ 
56> 
57> if @inp != NULL
58> begin
59>    
60>    declare ancest_cursor cursor
61>    for select c._Structure_key
62>        from GXD_StructureClosure c
63>        where c._Descendent_key = @inp
64>    
65>    declare @sk integer
66>    declare @isk integer
67>    select @isk = _Structure_key from inserted  
68>    
69>    open ancest_cursor
70>    fetch ancest_cursor into @sk
71>    while (@@sqlstatus = 0)
72>    begin
73>       /* for each ancestor, insert ancestor's _Structure_key, inserted's 
74>          _Structure_key in GXD_StructureClosure */ 
75>       insert into GXD_StructureClosure (_Structure_key, _Descendent_key) 
76>              values (@sk, @isk)
77>       if @@error != 0
78>       begin
79>          rollback transaction
80>          raiserror 99999 "GXD_Structure_Insert: Incremental insert on closure table failed"
81>          close ancest_cursor
82>          return
83>       end
84>       fetch ancest_cursor into @sk
85>    end
86>    close ancest_cursor
87>    
88>    /* finally, insert the inserted node's _Parent_key and the inserted node's
89>       _Structure_key into the closure table */
90>    
91>    insert into GXD_StructureClosure (_Structure_key, _Descendent_key)
92>        values (@inp, @isk)
93>    if @@error != 0
94>    begin
95>       rollback transaction
96>       raiserror 99999 "GXD_Structure_Insert: Incremental insert on closure table failed"
97>       return
98>    end
99> end
100> 
101> /* Do not compute the printName for the inserted structure here!
102>    this will be taken care of by the GXD_StructureName triggers.
103>    The name records must be in place before a printName recomputation
104>    can be done. */ 
105> 
106> 
1> 
2> drop trigger GXD_Structure_Update
1> 
2> create trigger GXD_Structure_Update
3> on GXD_Structure
4> for update
5> as
6>    update GXD_Structure
7>    set s.modification_date = getdate()  
8>    from GXD_Structure s, inserted
9>    where s._Structure_key = inserted._Structure_key 
10> 
11>    /* make certain that printStop bits don't get cleared on Structures
12>       that are children of the Stage root nodes */
13> 
14>    if exists (select printStop 
15>               from inserted
16>               where printStop = 0 
17>               and _Parent_key = NULL)
18>    begin
19>         rollback transaction
20>         raiserror 99999 "GXD_Structure_Update: Cannot clear printStop on child of stage root"
21>         return
22>    end
23> 
24>    /* recalculate printStops on those structures where printStop has
25>       been changed */
26>  
27>    declare pstop_cursor cursor
28>    for select inserted._Structure_key
29>        from deleted, inserted
30>        where deleted.printStop != inserted.printStop
31>        and deleted._Structure_key = inserted._Structure_key
32>  
33>    declare @sk integer
34>    open pstop_cursor
35>    fetch pstop_cursor into @sk
36>    while (@@sqlstatus = 0)
37>    begin
38>        exec GXD_ComputePrintNamesFrom @sk
39>        if @@error != 0
40>        begin
41>            rollback transaction
42>            raiserror 99999 "GXD_Structure_Update: GXD_ComputePrintNamesFrom fail
43> ed"
44>            close pstop_cursor
45>            return
46>        end
47>        fetch pstop_cursor into @sk
48>    end
49>    close pstop_cursor
50> 
1> 
2> drop trigger GXD_Structure_Delete
1> 
2> create trigger GXD_Structure_Delete
3> on GXD_Structure
4> for delete
5> as
6> 
7> /* Disallow deletion if record is not an MGI-added record */
8> 
9> if (select count(*) 
10>     from deleted
11>     where edinburghkey != NULL) > 0
12> begin
13>         rollback transaction
14>         raiserror 99999 "GXD_Structure_Delete: Structure is not an MGI-added record"
15>     return
16> end
17> 
18> /* Disallow deletion if record is not a leaf node, i.e. it has descendents */
19> 
20> if (select count(*) from GXD_StructureClosure, deleted
21>     where GXD_StructureClosure._Structure_key = deleted._Structure_key) > 0
22> begin
23>         rollback transaction
24>         raiserror 99999 "GXD_Structure_Delete: Structure is not a leaf node; it has descendents"
25>         return
26> end
27> 
28> /* Disallow deletion if record is referenced elsewhere */
29> 
30> if (select count(*) from GXD_ISResultStructure, deleted
31>     where GXD_ISResultStructure._Structure_key = deleted._Structure_key) > 0
32> begin
33>         rollback transaction
34>         raiserror 99999 "GXD_Structure_Delete: Structure is referenced in InSitu Result Record(s)"
35>         return
36> end
37>  
38> if (select count(*) from GXD_GelLaneStructure, deleted
39>     where GXD_GelLaneStructure._Structure_key = deleted._Structure_key) > 0
40> begin
41>         rollback transaction
42>         raiserror 99999 "GXD_Structure_Delete: Structure is referenced in Gel Lane Structure Record(s)"
43>         return
44> end
45> 
46> if (select count(*) from GXD_Expression, deleted
47>     where GXD_Expression._Structure_key = deleted._Structure_key) > 0
48> begin
49>         rollback transaction
50>         raiserror 99999 "GXD_Structure_Delete: Structure is referenced in Expression Results (cache) Record(s)"
51>         return
52> end
53> 
54> /* incrementally modify the closure */
55> delete GXD_StructureClosure 
56> from GXD_StructureClosure sc, deleted
57> where sc._Descendent_key = deleted._Structure_key
58> 
59> if @@error != 0
60> begin
61>     rollback transaction
62>     raiserror 99999 "GXD_Structure_Delete: Delete of closure records failed"
63>     return
64> end
65> 
66> /* cascade deletes into the StructureName table */
67> delete GXD_StructureName
68> from GXD_StructureName sn, deleted
69> where sn._Structure_key = deleted._Structure_key
70> 
71> if @@error != 0
72> begin
73>     rollback transaction
74>     raiserror 99999 "GXD_Structure_Delete: Cascaded delete of StructureNames failed"
75>     return
76> end
77> 
1> 
2> /* GXD_StructureName */
3> 
4> drop trigger GXD_StructureName_Insert
1> 
2> create trigger GXD_StructureName_Insert
3> on GXD_StructureName
4> for insert
5> as
6> 
7> /* ensure that the structure specified exists */
8> if not exists(select * 
9>               from GXD_Structure s, inserted
10>               where s._Structure_key = inserted._Structure_key)
11> begin
12>     rollback transaction
13>     raiserror 99999 "GXD_StructureName_Insert: Inserted StructureName specifies a non-existent Structure"
14>     return
15> end
16> 
17> /* look for duplicate (structure key, structure) tuples */
18> 
19> if (select count(*) from 
20>    GXD_StructureName sn, inserted
21>    where sn._Structure_key = inserted._Structure_key
22>    and sn.structure = inserted.structure) >  1
23> begin
24>     rollback transaction
25>     raiserror 99999 "GXD_StructureName_Insert: Inserted StructureName has duplicate structure attribute"
26>     return
27> end
28> 
29> /* Prevent two children from having the same preferred name */
30> 
31> 
32> if (select count(*)
33>     from GXD_Structure s1, GXD_Structure s2, GXD_StructureName sn2, inserted
34>     where s1._Parent_key = s2._Parent_key
35>     and sn2._StructureName_key = s2._StructureName_key
36>     and inserted._StructureName_key = s1._StructureName_key 
37>     and inserted.structure = sn2.structure) > 1
38> begin
39>     rollback transaction
40>     raiserror 99999 "GXD_StructureName_Insert: Parent node cannot have two children with the same preferred name"
41>     return
42> end
43> 
44> /* call stored procedure that recalculates printNames, if a preferred
45>    structure name is changed.  Preferred StructureNames are those
46>    that are referred to by a record in GXD_Structure */
47> 
48> declare updatesk_cursor cursor
49> for select s._Structure_key 
50>     from GXD_Structure s, inserted
51>     where s._StructureName_key = inserted._StructureName_key
52> 
53> declare @isk integer
54> 
55> open updatesk_cursor
56> fetch updatesk_cursor into @isk
57> 
58> while (@@sqlstatus = 0)
59> begin
60>    exec GXD_ComputePrintNamesFrom @isk 
61>    if @@error != 0
62>    begin
63>         rollback transaction
64>         raiserror 99999 "GXD_StructureName_Insert: GXD_ComputePrintNamesFrom failed"
65>         close updatesk_cursor
66>         return
67>    end
68>    fetch updatesk_cursor into @isk
69> end
70> 
71> close updatesk_cursor
72> 
1> 
2> drop trigger GXD_StructureName_Update
1> 
2> create trigger GXD_StructureName_Update
3> on GXD_StructureName
4> for update
5> as
6> 
7> if (select count(*) from GXD_Structure s, inserted
8>     where s._Structure_key = inserted._Structure_key) !=
9>    (select count(*) from inserted)
10> begin
11>     rollback transaction
12>     raiserror 99999 "GXD_StructureName_Update: Non-existent Structure in StructureName record"
13>     return
14> end
15> 
16> 
17> if (select count(*) from 
18>     GXD_StructureName sn, inserted
19>     where sn._Structure_key = inserted._Structure_key
20>     and sn.structure = inserted.structure) > 
21>    (select count(*) from inserted)
22> begin
23>     rollback transaction
24>     raiserror 99999 "GXD_StructureName_Update: Inserted StructureName has duplicate structure attribute"
25>     return
26> end
27> 
28> update GXD_StructureName
29> set sn.modification_date = getdate()  
30> from GXD_StructureName sn, inserted
31> where sn._Structure_key = inserted._Structure_key 
32> 
33> /* call stored procedure that recalculates printNames, if a preferred
34>    structure name is changed.  Preferred StructureNames are those
35>    that are referred to by a record in GXD_Structure */
36> 
37> declare updatesk_cursor cursor
38> for select s._Structure_key 
39>     from GXD_Structure s, inserted
40>     where s._StructureName_key = inserted._StructureName_key
41> 
42> declare @isk integer
43> 
44> open updatesk_cursor
45> fetch updatesk_cursor into @isk
46> 
47> while (@@sqlstatus = 0)
48> begin
49>    exec GXD_ComputePrintNamesFrom @isk 
50>    if @@error != 0
51>    begin
52>         rollback transaction
53>         raiserror 99999 "GXD_StructureName_Update: GXD_ComputePrintNamesFrom failed"
54>         close updatesk_cursor
55>         return
56>    end
57>    fetch updatesk_cursor into @isk
58> end
59> 
60> close updatesk_cursor
61> 
1> 
2> drop trigger GXD_StructureName_Delete
1> 
2> create trigger GXD_StructureName_Delete
3> on GXD_StructureName
4> for delete
5> as
6> 
7> /* check to see if a Structure references the StructureNames being deleted */
8> 
9> if (select count(*) from GXD_Structure, deleted
10>     where GXD_Structure._StructureName_key = deleted._StructureName_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "GXD_StructureName_Delete: Structure Name is referenced in Structure Record(s)"
14>     return
15> end
16> 
1> 
2> /* GXD_StructureClosure */
3> 
4> drop trigger GXD_StructureClosure_Insert
1> 
2> create trigger GXD_StructureClosure_Insert
3> on GXD_StructureClosure
4> for insert
5> as
6> 
7> /* check to see if a Structure exists for the inserted structure keys */
8> if not exists(select * 
9>               from GXD_Structure s, inserted
10>               where s._Structure_key = inserted._Structure_key)
11> begin
12>     rollback transaction
13>     raiserror 99999 "GXD_StructureClosure_Insert: Non-existent Structure in StructureClosure record"
14>     return
15> end
1> 
2> drop trigger GXD_StructureClosure_Update
1> 
2> create trigger GXD_StructureClosure_Update
3> on GXD_StructureClosure
4> for update 
5> as
6> 
7> /* check to see if a Structure exists for the updated structure keys */
8> 
9> if (select count(*) 
10>     from GXD_Structure s, inserted 
11>     where s._Structure_key = inserted._Structure_key) !=
12>    (select count(*) from inserted)
13> begin
14>     rollback transaction
15>     raiserror 99999 "GXD_StructureClosure_Update: Non-existent Structure in StructureClosure record"
16>     return
17> end
1> drop trigger GXD_StructureClosure_Delete
1> 
2> create trigger GXD_StructureClosure_Delete
3> on GXD_StructureClosure
4> for delete
5> as
6> 
7> if (select count(*) from GXD_Structure, deleted
8>     where GXD_Structure._Structure_key = deleted._Descendent_key) > 0
9> begin
10>         rollback transaction
11>         raiserror 99999 "GXD_StructureClosure_Delete: Structure is referenced in GXD_Structure"
12>         return
13> end
14> 
1> 
2> /* GXD_TheilerStage */
3> 
4> drop trigger GXD_TheilerStage_Delete
1> 
2> create trigger GXD_TheilerStage_Delete
3> on GXD_TheilerStage
4> for delete
5> as
6> 
7> /* Totally disallow deletions of these records ??? */
8> 
9> rollback transaction
10> raiserror 99999 "Cannot delete Theiler Stage Record(s)"
11> return
12> 
13> if (select count(*) from GXD_Structure, deleted
14>     where GXD_Structure._Stage_key = deleted._Stage_key) > 0
15> begin
16>         rollback transaction
17>         raiserror 99999 "Theiler Stage is referenced in Structure Record(s)"
18>         return
19> end
20> 
1> 
2> drop trigger GXD_ProbePrep_Delete
1> 
2> create trigger GXD_ProbePrep_Delete
3> on GXD_ProbePrep
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if (select count(*) from GXD_Assay, deleted
10>     where GXD_Assay._ProbePrep_key = deleted._ProbePrep_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Probe Prep is referenced in Assay Record(s)"
14>         return
15> end
16> 
1> 
2> drop trigger GXD_AntibodyPrep_Delete
1> 
2> create trigger GXD_AntibodyPrep_Delete
3> on GXD_AntibodyPrep
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if (select count(*) from GXD_Assay, deleted
10>     where GXD_Assay._AntibodyPrep_key = deleted._AntibodyPrep_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody Prep is referenced in Assay Record(s)"
14>         return
15> end
16> 
1> 
2> drop trigger GXD_Assay_Insert
1>  
2> create trigger GXD_Assay_Insert
3> on GXD_Assay
4> for insert
5> as
6>  
7> declare @key integer
8> select @key = _Assay_key from inserted
9> 
10> /* Assign MGI Accession number for Assay */
11> exec ACC_assignMGI @key, "Assay"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
19> /* Insert entry in Reference bucket if it doesn't already exist */
20>  
21> if (select count(MRK_Reference._Marker_key) from MRK_Reference, inserted
22>     where MRK_Reference._Marker_key = inserted._Marker_key and
23>           MRK_Reference._Refs_key = inserted._Refs_key) = 0
24> begin
25>   insert MRK_Reference (_Marker_key, _Refs_key, auto) 
26>   select _Marker_key, _Refs_key, 1 from inserted
27>   where _Refs_key is not null
28> end
29> 
1>  
2> drop trigger GXD_Assay_Update
1>  
2> create trigger GXD_Assay_Update
3> on GXD_Assay
4> for update
5> as
6>  
7> /* Insert entry in Reference bucket if it doesn't already exist */
8>  
9> if @@rowcount = 1
10>    and
11>    (update(_Refs_key) or update(_Marker_key))
12>    and
13>    (select count(MRK_Reference._Marker_key) from MRK_Reference, inserted
14>     where MRK_Reference._Marker_key = inserted._Marker_key and
15>           MRK_Reference._Refs_key = inserted._Refs_key) = 0
16> begin
17>         insert MRK_Reference (_Marker_key, _Refs_key, auto) 
18>         select _Marker_key, _Refs_key, 1 from inserted
19>         where _Refs_key is not null
20> end
21>  
22> declare @key integer
23> select @key = _Assay_key from inserted
24> 
25> /* Update Expression Cache for Assay */
26> /* The update of a GXD_Assay record should be called AFTER any updates to GXD detail records */
27> 
28> exec GXD_loadCacheByAssay @key
29> 
1>  
2> drop trigger GXD_Assay_Delete
1> 
2> create trigger GXD_Assay_Delete
3> on GXD_Assay
4> for delete
5> as
6> 
7> delete GXD_Specimen from GXD_Specimen, deleted
8> where GXD_Specimen._Assay_key = deleted._Assay_key
9>  
10> delete GXD_GelLane from GXD_GelLane, deleted
11> where GXD_GelLane._Assay_key = deleted._Assay_key
12>  
13> delete GXD_GelRow from GXD_GelRow, deleted
14> where GXD_GelRow._Assay_key = deleted._Assay_key
15>  
16> delete GXD_AssayNote from GXD_AssayNote, deleted
17> where GXD_AssayNote._Assay_key = deleted._Assay_key
18>  
19> delete GXD_Expression from GXD_Expression, deleted
20> where GXD_Expression._Assay_key = deleted._Assay_key
21>  
22> delete GXD_ProbePrep from GXD_ProbePrep, deleted
23> where GXD_ProbePrep._ProbePrep_key = deleted._ProbePrep_key
24> 
25> delete GXD_AntibodyPrep from GXD_AntibodyPrep, deleted
26> where GXD_AntibodyPrep._AntibodyPrep_key = deleted._AntibodyPrep_key
27> 
28> delete ACC_Accession
29> from ACC_Accession a, ACC_MGIType m, deleted
30> where a._Object_key = deleted._Assay_key
31> and a._MGIType_key = m._MGIType_key
32> and m.name = "Assay"
33>  
1> 
2> drop trigger GXD_GelLane_Delete
1> 
2> create trigger GXD_GelLane_Delete
3> on GXD_GelLane
4> for delete
5> as
6> 
7> delete GXD_GelLaneStructure from GXD_GelLaneStructure, deleted
8> where GXD_GelLaneStructure._GelLane_key = deleted._GelLane_key
9>  
10> delete GXD_GelBand from GXD_GelBand, deleted
11> where GXD_GelBand._GelLane_key = deleted._GelLane_key
12> 
13> /* If Genotypes are specific to each specimen... */
14> 
15> if (select count(*) from GXD_GelLane, deleted
16>     where GXD_GelLane._Genotype_key = deleted._Genotype_key) = 0
17> begin
18>     delete GXD_Genotype from GXD_Genotype, deleted
19>     where GXD_Genotype._Genotype_key = deleted._Genotype_key
20>           and GXD_Genotype._Genotype_key >= 0
21> end
22> 
1> 
2> drop trigger GXD_GelRow_Insert
1> 
2> create trigger GXD_GelRow_Insert
3> on GXD_GelRow
4> for insert
5> as
6> 
7> if (select size from inserted) is not null and
8>    (select _GelUnits_key from inserted) < 0
9> begin
10>   rollback transaction
11>   raiserror 99999 "If Gel Row Size is entered, Gel Row Units must be specified."
12>   return
13> end
14> 
1> 
2> drop trigger GXD_GelRow_Update
1> 
2> create trigger GXD_GelRow_Update
3> on GXD_GelRow
4> for update
5> as
6> 
7> if (select size from inserted) is not null and
8>    (select _GelUnits_key from inserted) < 0
9> begin
10>   rollback transaction
11>   raiserror 99999 "If Gel Row Size is entered, Gel Row Units must be specified."
12>   return
13> end
14> 
1> 
2> drop trigger GXD_GelRow_Delete
1> 
2> create trigger GXD_GelRow_Delete
3> on GXD_GelRow
4> for delete
5> as
6> 
7> delete GXD_GelBand from GXD_GelBand, deleted
8> where GXD_GelBand._GelRow_key = deleted._GelRow_key
9> 
1> 
2> drop trigger GXD_Specimen_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'GXD_Specimen_Delete', because it doesn't exist in the
system catalogs.
1> 
2> create trigger GXD_Specimen_Delete
3> on GXD_Specimen
4> for delete
5> as
6> 
7> /* If Genotypes are specific to each specimen... */
8> 
9> if (select count(*) from GXD_Specimen, deleted
10>     where GXD_Specimen._Genotype_key = deleted._Genotype_key) = 0
11> begin
12>     delete GXD_Genotype from GXD_Genotype, deleted
13>     where GXD_Genotype._Genotype_key = deleted._Genotype_key
14>           and GXD_Genotype._Genotype_key >= 0
15> end
16> 
17> delete GXD_InSituResult from GXD_InSituResult, deleted
18> where GXD_InSituResult._Specimen_key = deleted._Specimen_key
19> 
1> 
2> drop trigger GXD_InSituResult_Delete
1> 
2> create trigger GXD_InSituResult_Delete
3> on GXD_InSituResult
4> for delete
5> as
6> 
7> delete GXD_InSituResultImage from GXD_InSituResultImage, deleted
8> where GXD_InSituResultImage._Result_key = deleted._Result_key
9> 
10> delete GXD_ISResultStructure from GXD_ISResultStructure, deleted
11> where GXD_ISResultStructure._Result_key = deleted._Result_key
12> 
1> 
2> drop trigger GXD_Index_Delete
1> 
2> create trigger GXD_Index_Delete
3> on GXD_Index
4> for delete
5> as
6> 
7> delete GXD_Index_Stages from GXD_Index_Stages, deleted
8> where GXD_Index_Stages.index_id = deleted.index_id
9> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger GXD_AntibodyClass_Delete
1> 
2> create trigger GXD_AntibodyClass_Delete
3> on GXD_AntibodyClass
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if (select count(*) from GXD_Antibody, deleted
10>     where GXD_Antibody._AntibodyClass_key = deleted._AntibodyClass_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody Class is referenced in Antibody Record(s)"
14>     return
15> end
16> 
1> 
2> drop trigger GXD_AntibodyType_Delete
1>  
2> create trigger GXD_AntibodyType_Delete
3> on GXD_AntibodyType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from GXD_Antibody, deleted
10>     where GXD_Antibody._AntibodyType_key = deleted._AntibodyType_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody Type is referenced in Antibody Record(s)"
14>         return
15> end
16>  
1> 
2> drop trigger GXD_AssayType_Delete
1>  
2> create trigger GXD_AssayType_Delete
3> on GXD_AssayType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from GXD_Assay, deleted
10>     where GXD_Assay._AssayType_key = deleted._AssayType_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Assay Type is referenced in Assay Record(s)"
14>         return
15> end
16>  
17> if (select count(*) from GXD_Expression, deleted
18>     where GXD_Expression._AssayType_key = deleted._AssayType_key) > 0
19> begin
20>         rollback transaction
21>         raiserror 99999 "Assay Type is referenced in Expression Results (cache) Record(s)"
22>         return
23> end
24>  
1>  
2> drop trigger GXD_EmbeddingMethod_Delete
1>  
2> create trigger GXD_EmbeddingMethod_Delete
3> on GXD_EmbeddingMethod
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from GXD_Specimen, deleted
10>     where GXD_Specimen._Embedding_key = deleted._Embedding_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Embedding Method is referenced in Specimen Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_FixationMethod_Delete
1>  
2> create trigger GXD_FixationMethod_Delete
3> on GXD_FixationMethod
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from GXD_Specimen, deleted
10>     where GXD_Specimen._Fixation_key = deleted._Fixation_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Fixation Method is referenced in Specimen Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_GelRNAType_Delete
1>  
2> create trigger GXD_GelRNAType_Delete
3> on GXD_GelRNAType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from GXD_GelLane, deleted
10>     where GXD_GelLane._GelRNAType_key = deleted._GelRNAType_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Gel RNA Type is referenced in Gel Lane Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_GelUnits_Delete
1>  
2> create trigger GXD_GelUnits_Delete
3> on GXD_GelUnits
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from GXD_GelRow, deleted
10>     where GXD_GelRow._GelUnits_key = deleted._GelUnits_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Gel Unit is referenced in Gel Row Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_GelControl_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'GXD_GelControl_Delete', because it doesn't exist in the
system catalogs.
1>  
2> create trigger GXD_GelControl_Delete
3> on GXD_GelControl
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from GXD_GelLane, deleted
10>     where GXD_GelLane._GelControl_key = deleted._GelControl_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Gel Control is referenced in Gel Lane Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_LabelCoverage_Delete
1>  
2> create trigger GXD_LabelCoverage_Delete
3> on GXD_LabelCoverage
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from GXD_ProbePrep, deleted
10>     where GXD_ProbePrep._Coverage_key = deleted._Coverage_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Label Coverage is referenced in Probe Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Pattern_Delete
1>  
2> create trigger GXD_Pattern_Delete
3> on GXD_Pattern
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from GXD_InSituResult, deleted
10>     where GXD_InSituResult._Pattern_key = deleted._Pattern_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Expression Pattern is referenced in InSitu Result Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Label_Delete
1>  
2> create trigger GXD_Label_Delete
3> on GXD_Label
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from GXD_AntibodyPrep, deleted
10>     where GXD_AntibodyPrep._Label_key = deleted._Label_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Label is referenced in Antibody Prep Record(s)"
14>     return
15> end
16> 
17> if (select count(*) from GXD_ProbePrep, deleted
18>     where GXD_ProbePrep._Label_key = deleted._Label_key) > 0
19> begin
20>         rollback transaction
21>         raiserror 99999 "Label is referenced in Probe Prep Record(s)"
22>         return
23> end
24>  
1>  
2> drop trigger GXD_ProbeSense_Delete
1>  
2> create trigger GXD_ProbeSense_Delete
3> on GXD_ProbeSense
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from GXD_ProbePrep, deleted
10>     where GXD_ProbePrep._Sense_key = deleted._Sense_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Probe Sense is referenced in Probe Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Secondary_Delete
1>  
2> create trigger GXD_Secondary_Delete
3> on GXD_Secondary
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from GXD_AntibodyPrep, deleted
10>     where GXD_AntibodyPrep._Secondary_key = deleted._Secondary_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Secondary is referenced in Antibody Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Strength_Delete
1>  
2> create trigger GXD_Strength_Delete
3> on GXD_Strength
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from GXD_InSituResult, deleted
10>     where GXD_InSituResult._Strength_key = deleted._Strength_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Strength is referenced in InSitu Result Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_VisualizationMethod_Delete
1>  
2> create trigger GXD_VisualizationMethod_Delete
3> on GXD_VisualizationMethod
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from GXD_ProbePrep, deleted
10>     where GXD_ProbePrep._Visualization_key = deleted._Visualization_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Visualization Method is referenced in Probe Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger IMG_FieldType_Delete
1>  
2> create trigger IMG_FieldType_Delete
3> on IMG_FieldType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if (select count(*) from IMG_ImagePane, deleted
10>     where IMG_ImagePane._FieldType_key = deleted._FieldType_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Image Field Type is referenced in Image Pane Record(s)"
14>         return
15> end
16>  
1>  
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger HMD_Class_Delete
1> 
2> create trigger HMD_Class_Delete
3> on HMD_Class
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete HMD_Homology from HMD_Homology, deleted
10> where HMD_Homology._Class_key = deleted._Class_key
11> 
1> 
2> drop trigger HMD_Homology_Delete
1> 
2> create trigger HMD_Homology_Delete
3> on HMD_Homology
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete HMD_Homology_Marker from HMD_Homology_Marker, deleted
10> where HMD_Homology_Marker._Homology_key = deleted._Homology_key
11> 
12> delete HMD_Homology_Assay from HMD_Homology_Assay, deleted
13> where HMD_Homology_Assay._Homology_key = deleted._Homology_key
14> 
15> delete HMD_Notes from HMD_Notes, deleted
16> where HMD_Notes._Homology_key = deleted._Homology_key
17> 
1> 
2> drop trigger HMD_Homology_Marker_Insert
1> 
2> create trigger HMD_Homology_Marker_Insert
3> on HMD_Homology_Marker
4> for insert
5> as
6> 
7> /* If Chromosome record for inserted Homology does not exist in MRK_Chromosome */
8> /* for the Marker species then insert the chromosome into MRK_Chromosome. */
9> /* MRK_Chromosome is used to sequentially order the Chromosome values within */
10> /* a given Species for sorting in Homology, reports, Oxford Grids, etc. */
11> 
12> if (select count(MRK_Chromosome.chromosome) 
13>     from MRK_Chromosome, inserted, MRK_Marker
14>     where inserted._Marker_key = MRK_Marker._Marker_key
15>     and MRK_Marker._Species_key = MRK_Chromosome._Species_key
16>     and MRK_Marker.chromosome = MRK_Chromosome.chromosome) = 0
17> begin
18>     /* Get next available sequence number */
19>     declare @nextseq integer
20>     select @nextseq = max(MRK_Chromosome.sequenceNum) + 1 
21>     from MRK_Chromosome, MRK_Marker, inserted
22>     where inserted._Marker_key = MRK_Marker._Marker_key
23>           and MRK_Marker._Species_key = MRK_Chromosome._Species_key
24> 
25>     if @nextseq is NULL or @nextseq = 0
26>     begin
27>     select @nextseq = 1
28>     end
29> 
30>     insert into MRK_Chromosome (_Species_key, chromosome, sequenceNum)
31>     select MRK_Marker._Species_key, MRK_Marker.chromosome, @nextseq
32>     from MRK_Marker, inserted
33>     where inserted._Marker_key = MRK_Marker._Marker_key
34> 
35> /*          print "Please verify the Chromosome order for the Species record just added.\nThis can be reviewed using the Species editing screen."
36> */
37> 
38> end
39> 
1> 
2> drop trigger HMD_Assay_Delete
1> 
2> create trigger HMD_Assay_Delete
3> on HMD_Assay
4> for delete
5> as
6> 
7> /* Disallow removal of the homology assay if it is being referenced in homology */
8> 
9> if (select count(*) from HMD_Homology_Assay, deleted
10>     where HMD_Homology_Assay._Assay_key = deleted._Assay_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Assay is referenced in Homology Record(s)"
14>     return
15> end
16>  
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger IMG_Image_Insert
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'IMG_Image_Insert', because it doesn't exist in the
system catalogs.
1>  
2> create trigger IMG_Image_Insert
3> on IMG_Image
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Image */
8>  
9> declare @key integer
10> select @key = _Image_key from inserted
11> exec ACC_assignMGI @key, "Image"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1>  
2> drop trigger IMG_Image_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'IMG_Image_Delete', because it doesn't exist in the
system catalogs.
1> 
2> create trigger IMG_Image_Delete
3> on IMG_Image
4> for delete
5> as
6> 
7> delete IMG_ImageNote from IMG_ImageNote, deleted
8> where IMG_ImageNote._Image_key = deleted._Image_key
9>  
10> delete IMG_ImagePane from IMG_ImagePane, deleted
11> where IMG_ImagePane._Image_key = deleted._Image_key
12>  
13> delete ACC_Accession
14> from ACC_Accession a, ACC_MGIType m, deleted
15> where a._Object_key = deleted._Image_key
16> and a._MGIType_key = m._MGIType_key
17> and m.name = "Image"
18>  
1> 
2> drop trigger IMG_ImagePane_Delete
1> 
2> create trigger IMG_ImagePane_Delete
3> on IMG_ImagePane
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if (select count(*) from GXD_Assay, deleted
10>     where GXD_Assay._ImagePane_key = deleted._ImagePane_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Image Pane is referenced in Assay Record(s)"
14>     return
15> end
16> 
17> if (select count(*) from GXD_InSituResultImage, deleted
18>     where GXD_InSituResultImage._ImagePane_key = deleted._ImagePane_key) > 0
19> begin
20>         rollback transaction
21>         raiserror 99999 "Image Pane is referenced in InSitu Result Record(s)"
22>     return
23> end
24> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger MLD_Marker_Update
1> 
2> create trigger MLD_Marker_Update
3> on MLD_Marker
4> for update
5> as
6> 
7> /* If updating the Reference, propagate update to appropriate tables */
8> 
9> if update(_Refs_key)
10> begin
11>     update MLD_Expts
12>       set _Refs_key = inserted._Refs_key
13>       from MLD_Expts, inserted, deleted
14>       where MLD_Expts._Refs_key = deleted._Refs_key
15> 
16>     update MLD_Notes
17>       set _Refs_key = inserted._Refs_key
18>       from MLD_Notes, inserted, deleted
19>       where MLD_Notes._Refs_key = deleted._Refs_key
20> end
21> 
22> /* If the Marker in the Primary list is modified, then propagate */
23> /* the changes to the gene list of each experiment of the reference */
24> 
25> if update(_Marker_key)
26> begin
27>     update MLD_Expt_Marker
28>           set _Marker_key = inserted._Marker_key
29>       from MLD_Expt_Marker, MLD_Expts, inserted, deleted
30>       where MLD_Expts._Refs_key = inserted._Refs_key and
31>             MLD_Expts._Expt_key = MLD_Expt_Marker._Expt_key and
32>             MLD_Expt_Marker._Marker_key = deleted._Marker_key
33> end
34> 
1> 
2> drop trigger MLD_Expts_Insert
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MLD_Expts_Insert', because it doesn't exist in the
system catalogs.
1> 
2> create trigger MLD_Expts_Insert
3> on MLD_Expts
4> for insert
5> as
6> 
7> /* Assign MGI Accession number for each Experiment */
8> 
9> declare @key integer
10> select @key = _Expt_key from inserted
11> exec ACC_assignMGI @key, "Experiment"
12> 
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1> 
2> drop trigger MLD_Expts_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'MLD_Expts_Delete', because it doesn't exist in the
system catalogs.
1> 
2> create trigger MLD_Expts_Delete
3> on MLD_Expts
4> for delete
5> as
6> 
7> /* Re-order the tag numbers for experiments if one is deleted */
8> 
9> update MLD_Expts
10> set MLD_Expts.tag = MLD_Expts.tag - 1
11> from MLD_Expts, deleted
12> where MLD_Expts._Refs_key = deleted._Refs_key
13> and MLD_Expts.exptType = deleted.exptType
14> and MLD_Expts.tag > deleted.tag
15> 
16> /* Delete entries in all dependent experiment tables */
17> 
18> delete MLD_Expt_Marker from MLD_Expt_Marker, deleted
19> where MLD_Expt_Marker._Expt_key = deleted._Expt_key
20> 
21> delete MLD_Expt_Notes from MLD_Expt_Notes, deleted
22> where MLD_Expt_Notes._Expt_key = deleted._Expt_key
23> 
24> delete MLD_FISH from MLD_FISH, deleted
25> where MLD_FISH._Expt_key = deleted._Expt_key
26> 
27> delete MLD_FISH_Region from MLD_FISH_Region, deleted
28> where MLD_FISH_Region._Expt_key = deleted._Expt_key
29> 
30> delete MLD_Hybrid from MLD_Hybrid, deleted
31> where MLD_Hybrid._Expt_key = deleted._Expt_key
32> 
33> delete MLD_Concordance from MLD_Concordance, deleted
34> where MLD_Concordance._Expt_key = deleted._Expt_key
35> 
36> delete MLD_InSitu from MLD_InSitu, deleted
37> where MLD_InSitu._Expt_key = deleted._Expt_key
38> 
39> delete MLD_ISRegion from MLD_ISRegion, deleted
40> where MLD_ISRegion._Expt_key = deleted._Expt_key
41> 
42> delete MLD_Matrix from MLD_Matrix, deleted
43> where MLD_Matrix._Expt_key = deleted._Expt_key
44> 
45> delete MLD_MC2point from MLD_MC2point, deleted
46> where MLD_MC2point._Expt_key = deleted._Expt_key
47> 
48> delete MLD_MCDataList from MLD_MCDataList, deleted
49> where MLD_MCDataList._Expt_key = deleted._Expt_key
50> 
51> delete MLD_RI from MLD_RI, deleted
52> where MLD_RI._Expt_key = deleted._Expt_key
53> 
54> delete MLD_RIData from MLD_RIData, deleted
55> where MLD_RIData._Expt_key = deleted._Expt_key
56> 
57> delete MLD_RI2Point from MLD_RI2Point, deleted
58> where MLD_RI2Point._Expt_key = deleted._Expt_key
59> 
60> delete MLD_Hit from MLD_Hit, deleted
61> where MLD_Hit._Expt_key = deleted._Expt_key
62> 
63> delete MLD_Contig from MLD_Contig, deleted
64> where MLD_Contig._Expt_key = deleted._Expt_key
65> 
66> delete MLD_Statistics from MLD_Statistics, deleted
67> where MLD_Statistics._Expt_key = deleted._Expt_key
68> 
69> delete ACC_Accession
70> from ACC_Accession a, ACC_MGIType m, deleted
71> where a._Object_key = deleted._Expt_key
72> and a._MGIType_key = m._MGIType_key
73> and m.name = "Experiment"
74>  
1> 
2> drop trigger MLD_Expt_Marker_Insert
1>  
2> create trigger MLD_Expt_Marker_Insert
3> on MLD_Expt_Marker
4> for insert
5> as
6>  
7> /* If the chromosome in the Marker table is UN, then...  */
8>  
9> if (select count(*) from MRK_Marker, MLD_Expts, inserted
10>     where MLD_Expts._Expt_key = inserted._Expt_key and
11>     MRK_Marker._Marker_key = inserted._Marker_key and
12>     MRK_Marker.chromosome = "UN") > 0
13> begin
14>  
15>     /* Update the chromosome to the MLDP chromosome assignment */
16>  
17>     update MRK_Marker
18>     set chromosome = MLD_Expts.chromosome
19>     from MRK_Marker, MLD_Expts, inserted
20>     where MLD_Expts._Expt_key = inserted._Expt_key and
21>           MRK_Marker._Marker_key = inserted._Marker_key
22> end
23>  
1> 
2> drop trigger MLD_Expt_Marker_Update
1> 
2> create trigger MLD_Expt_Marker_Update
3> on MLD_Expt_Marker
4> for update
5> as
6> 
7> /* If modifying Assay type and this is the only instance of the */
8> /* Assay type in MGD, then remove it from the Assay table */
9> 
10> if update(_Assay_Type_key) and 
11>    (select count(*) from MLD_Expt_Marker, deleted
12>     where MLD_Expt_Marker._Assay_Type_key = deleted._Assay_Type_key) = 0
13> begin
14>   delete MLD_Assay_Types from MLD_Assay_Types, deleted
15>   where MLD_Assay_Types._Assay_Type_key = deleted._Assay_Type_key
16> end
17> 
18> if update(_Marker_key)
19> begin
20>     /* If the chromosome in the Marker table is UN, then...  */
21> 
22>     if (select count(*) from MRK_Marker, MLD_Expts, inserted
23>             where MLD_Expts._Expt_key = inserted._Expt_key and
24>         MRK_Marker._Marker_key = inserted._Marker_key and 
25>         MRK_Marker.chromosome = "UN") > 0
26>     begin
27> 
28>       /* Update the chromosome to the MLDP chromosome assignment */
29> 
30>       update MRK_Marker 
31>       set chromosome = MLD_Expts.chromosome
32>       from MRK_Marker, MLD_Expts, inserted
33>           where MLD_Expts._Expt_key = inserted._Expt_key and
34>             MRK_Marker._Marker_key = inserted._Marker_key
35>     end
36> 
37>     /* Propagate modification of Marker to experiment tables */
38> 
39>     update MLD_Concordance 
40>           set _Marker_key = inserted._Marker_key
41>       from MLD_Concordance, inserted, deleted
42>       where MLD_Concordance._Expt_key = inserted._Expt_key and
43>             MLD_Concordance._Marker_key = deleted._Marker_key
44> 
45>     update MLD_MC2point 
46>           set _Marker_key_1 = inserted._Marker_key
47>       from MLD_MC2point, inserted, deleted
48>       where MLD_MC2point._Expt_key = inserted._Expt_key and
49>             MLD_MC2point._Marker_key_1 = deleted._Marker_key
50> 
51>     update MLD_MC2point 
52>           set _Marker_key_2 = inserted._Marker_key
53>       from MLD_MC2point, inserted, deleted
54>       where MLD_MC2point._Expt_key = inserted._Expt_key and
55>             MLD_MC2point._Marker_key_2 = deleted._Marker_key
56> 
57>     update MLD_RIData 
58>           set _Marker_key = inserted._Marker_key
59>       from MLD_RIData, inserted, deleted
60>       where MLD_RIData._Expt_key = inserted._Expt_key and
61>             MLD_RIData._Marker_key = deleted._Marker_key
62> 
63>     update MLD_RI2Point 
64>           set _Marker_key_1 = inserted._Marker_key
65>       from MLD_RI2Point, inserted, deleted
66>       where MLD_RI2Point._Expt_key = inserted._Expt_key and
67>             MLD_RI2Point._Marker_key_1 = deleted._Marker_key
68> 
69>     update MLD_RI2Point 
70>           set _Marker_key_2 = inserted._Marker_key
71>       from MLD_RI2Point, inserted, deleted
72>       where MLD_RI2Point._Expt_key = inserted._Expt_key and
73>             MLD_RI2Point._Marker_key_2 = deleted._Marker_key
74> 
75>         update MLD_Statistics
76>           set _Marker_key_1 = inserted._Marker_key
77>           from MLD_Statistics, inserted, deleted
78>           where MLD_Statistics._Expt_key = inserted._Expt_key and
79>                 MLD_Statistics._Marker_key_1 = deleted._Marker_key
80> 
81>         update MLD_Statistics
82>           set _Marker_key_2 = inserted._Marker_key
83>           from MLD_Statistics, inserted, deleted
84>           where MLD_Statistics._Expt_key = inserted._Expt_key and
85>                 MLD_Statistics._Marker_key_2 = deleted._Marker_key
86> 
87>         update MLD_Distance
88>           set _Marker_key_1 = inserted._Marker_key
89>           from MLD_Distance, inserted, deleted
90>           where MLD_Distance._Expt_key = inserted._Expt_key and
91>                 MLD_Distance._Marker_key_1 = deleted._Marker_key
92> 
93>         update MLD_Distance
94>           set _Marker_key_2 = inserted._Marker_key
95>           from MLD_Distance, inserted, deleted
96>           where MLD_Distance._Expt_key = inserted._Expt_key and
97>                 MLD_Distance._Marker_key_2 = deleted._Marker_key
98> 
99> end
100> 
1> 
2> drop trigger MLD_Matrix_Delete
1> 
2> create trigger MLD_Matrix_Delete
3> on MLD_Matrix
4> for delete
5> as
6> 
7> /* Remove entries from Cross table upon deletion of Matrix */
8> /* record, if the cross is not a named (i.e. specific) Cross */
9> 
10> if (select count(CRS_Cross._Cross_key) from CRS_Cross, deleted 
11>     where CRS_Cross._Cross_key = deleted._Cross_key and CRS_Cross.whoseCross is null) > 0
12> begin
13>     delete CRS_Cross from CRS_Cross, deleted
14>     where CRS_Cross._Cross_key = deleted._Cross_key
15> end
16> 
1> 
2> drop trigger MLD_Contig_Delete
1> 
2> create trigger MLD_Contig_Delete
3> on MLD_Contig
4> for delete
5> as
6> 
7> /* Delete records in dependent tables */
8> 
9> delete MLD_ContigProbe from MLD_ContigProbe, deleted
10> where MLD_ContigProbe._Contig_key = deleted._Contig_key
11> 
1> 
2> drop trigger MLD_RI_Insert
1> 
2> create trigger MLD_RI_Insert
3> on MLD_RI
4> for insert
5> as
6> 
7> update MLD_RI
8> set designation = RI_RISet.designation,
9>     origin = RI_RISet.origin,
10>     abbrev1 = RI_RISet.abbrev1,
11>     abbrev2 = RI_RISet.abbrev2
12> from MLD_RI, RI_RISet, inserted
13> where MLD_RI._Expt_key = inserted._Expt_key and
14>       inserted._RISet_key = RI_RISet._RISet_key
1> 
2> drop trigger MLD_RI_Update
1> 
2> create trigger MLD_RI_Update
3> on MLD_RI
4> for update
5> as
6> 
7> /* If modifying RI key in MLDP table, then */
8> /* set appropriate column values in MLDP table */
9> /* as they appear in the RI table */
10> 
11> if update (_RISet_key)
12> begin
13>   update MLD_RI
14>   set designation = RI_RISet.designation,
15>       origin = RI_RISet.origin,
16>       abbrev1 = RI_RISet.abbrev1,
17>       abbrev2 = RI_RISet.abbrev2
18>   from MLD_RI, RI_RISet, inserted
19>   where MLD_RI._Expt_key = inserted._Expt_key and
20>     inserted._RISet_key = RI_RISet._RISet_key
21> end
22> 
1> 
2> drop trigger MLD_Assay_Types_Delete
1> 
2> create trigger MLD_Assay_Types_Delete
3> on MLD_Assay_Types
4> for delete
5> as
6> 
7> /* Disallow removal of an Assay which is referenced in MLDP */
8> 
9> if (select count(*) from MLD_Expt_Marker, deleted
10>     where MLD_Expt_Marker._Assay_Type_key = deleted._Assay_Type_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Assay is referenced in MLDP Record(s)"
14>     return
15> end
16> 
1> 
2> drop trigger MLD_InSitu_Insert
1> 
2> create trigger MLD_InSitu_Insert
3> on MLD_InSitu
4> for insert
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if (select MRK_Marker.cytogeneticOffset 
13>     from MRK_Marker, MLD_Expt_Marker, inserted
14>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key
15>       and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
16> begin
17>     update MRK_Marker
18>     set cytogeneticOffset = inserted.band
19>     from MRK_Marker, MLD_Expt_Marker, inserted
20>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
21>           and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
22> end
23> 
1> 
2> drop trigger MLD_InSitu_Update
1> 
2> create trigger MLD_InSitu_Update
3> on MLD_InSitu
4> for update
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if update(band)
13> begin
14>     if (select MRK_Marker.cytogeneticOffset 
15>         from MRK_Marker, MLD_Expt_Marker, inserted
16>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
17>               and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
18>     begin
19>             update MRK_Marker
20>             set cytogeneticOffset = inserted.band
21>             from MRK_Marker, MLD_Expt_Marker, inserted
22>             where inserted._Expt_key = MLD_Expt_Marker._Expt_key
23>                   and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
24>     end
25> end
26> 
1> 
2> drop trigger MLD_FISH_Insert
1> 
2> create trigger MLD_FISH_Insert
3> on MLD_FISH
4> for insert
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> /* If more than one Marker is defined in the experiment, then we can't */
13> /* assign any cytogenetic band information because we don't know which */
14> /* Marker is the relevant Marker */
15> 
16> if (select count(*) from MLD_Expt_Marker, inserted
17>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key) > 1
18> begin
19>     return
20> end
21> 
22> if (select MRK_Marker.cytogeneticOffset 
23>     from MRK_Marker, MLD_Expt_Marker, inserted
24>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key
25>       and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
26> begin
27>     update MRK_Marker
28>     set cytogeneticOffset = inserted.band
29>     from MRK_Marker, MLD_Expt_Marker, inserted
30>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
31>           and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
32> end
33> 
1> 
2> drop trigger MLD_FISH_Update
1> 
2> create trigger MLD_FISH_Update
3> on MLD_FISH
4> for update
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if update(band)
13> begin
14>     /* If more than one Marker is defined in the experiment, then we can't */
15>     /* assign any cytogenetic band information because we don't know which */
16>     /* Marker is the relevant Marker */
17> 
18>     if (select count(*) from MLD_Expt_Marker, inserted
19>                 where inserted._Expt_key = MLD_Expt_Marker._Expt_key) > 1
20>     begin
21>             return
22>     end
23> 
24>     if (select MRK_Marker.cytogeneticOffset 
25>         from MRK_Marker, MLD_Expt_Marker, inserted
26>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
27>               and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
28>     begin
29>             update MRK_Marker
30>             set cytogeneticOffset = inserted.band
31>             from MRK_Marker, MLD_Expt_Marker, inserted
32>             where inserted._Expt_key = MLD_Expt_Marker._Expt_key
33>                   and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
34>     end
35> end
36> 
1> 
2> drop trigger MLD_Hybrid_Insert
1> 
2> create trigger MLD_Hybrid_Insert
3> on MLD_Hybrid
4> for insert
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if (select MRK_Marker.cytogeneticOffset 
13>     from MRK_Marker, MLD_Expt_Marker, inserted
14>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key
15>       and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
16> begin
17>     update MRK_Marker
18>     set cytogeneticOffset = inserted.band
19>     from MRK_Marker, MLD_Expt_Marker, inserted
20>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
21>           and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
22> end
23> 
1> 
2> drop trigger MLD_Hybrid_Update
1> 
2> create trigger MLD_Hybrid_Update
3> on MLD_Hybrid
4> for update
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if update(band)
13> begin
14>     if (select MRK_Marker.cytogeneticOffset 
15>         from MRK_Marker, MLD_Expt_Marker, inserted
16>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
17>               and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
18>     begin
19>             update MRK_Marker
20>             set cytogeneticOffset = inserted.band
21>             from MRK_Marker, MLD_Expt_Marker, inserted
22>             where inserted._Expt_key = MLD_Expt_Marker._Expt_key
23>                   and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
24>     end
25> end
26> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger MRK_Marker_Insert
1> 
2> create trigger MRK_Marker_Insert
3> on MRK_Marker
4> for insert
5> as
6> 
7> /* For Mouse Species, insert records for Accession #, Name bucket, Symbol bucket, Current Symbol */
8> /* For Other Species, insert record for Accession # */
9> 
10> if (select _Species_key from inserted) = 1
11> begin
12>     insert MRK_Name (_Marker_key, _Marker_Type_key, name) 
13>             select _Marker_key, _Marker_Type_key, name from inserted
14>     insert MRK_Symbol (_Marker_key, _Marker_Type_key, symbol) 
15>             select _Marker_key, _Marker_Type_key, symbol from inserted
16>     insert MRK_Current (_Current_key, _Marker_key) 
17>             select _Marker_key, _Marker_key from inserted
18> 
19>     declare @key integer
20>     select @key = _Marker_key from inserted
21>     exec ACC_assignMGI @key, "Marker"
22> 
23>     if (@@error != 0)
24>     begin
25>       rollback transaction
26>       return
27>     end
28> 
29> end
30> 
1> 
2> drop trigger MRK_Marker_Update
1> 
2> create trigger MRK_Marker_Update
3> on MRK_Marker
4> for update
5> as
6> 
7> /* If not Mouse, disallow duplicate Species/Symbol records */
8> 
9> if (select _Species_key from inserted) != 1
10> begin
11>     if update(symbol) and
12>            (select count(*) from MRK_Marker, inserted 
13>         where inserted._Species_key = MRK_Marker._Species_key and
14>               inserted.symbol = MRK_Marker.symbol) > 1
15>     begin
16>             rollback transaction
17>             raiserror 99999 "Marker Symbol For This Species Already Exists.\nDelete Existing Row And Add A New Row For This Symbol."
18>             return
19>     end
20>     return
21> end
22> 
23> /* If updating chromosome and changing from unknown to known, update offset to -1 */
24> 
25> if (select _Species_key from inserted) = 1 and update (chromosome)
26> begin
27>        if ((select chromosome from deleted) = "RE" or
28>            (select chromosome from deleted) = "UN") and
29>            (select chromosome from inserted) != "RE" and
30>            (select chromosome from inserted) != "UN" and
31>            (select chromosome from inserted) != "W"
32>     begin
33>             update MRK_Offset set offset = -1
34>             from inserted
35>             where inserted._Marker_key = MRK_Offset._Marker_key and MRK_Offset.source = 0
36>     end
37> end
38> 
39> /* If updating symbol or Marker Type, check for duplicates and update Symbol bucket */
40> 
41> if (update (symbol) or update(_Marker_Type_key)) and
42>    not exists (select s.symbol from MRK_Symbol s, inserted i
43>            where s._Marker_key = i._Marker_key and
44>                  s._Marker_Type_key = i._Marker_Type_key and
45>                  s.symbol = i.symbol)
46> begin
47>     update MRK_Symbol 
48>     set symbol = inserted.symbol, _Marker_Type_key = inserted._Marker_Type_key
49>     from MRK_Symbol, inserted, deleted
50>     where MRK_Symbol._Marker_key = inserted._Marker_key and 
51>           MRK_Symbol._Marker_Type_key = deleted._Marker_Type_key and
52>           MRK_Symbol.symbol = deleted.symbol
53> end
54> 
55> /* If updating name, update Name bucket */
56> 
57> if update (name) and 
58>    not exists (select n.name from MRK_Name n, inserted i
59>            where n._Marker_key = i._Marker_key and
60>                  n._Marker_Type_key = i._Marker_Type_key and
61>                  n.name = i.name)
62> begin
63>     if (select chromosome from inserted) != "W"
64>     begin
65>             update MRK_Name set name = inserted.name
66>             from MRK_Name, inserted, deleted
67>             where MRK_Name._Marker_key = inserted._Marker_key and
68>                   MRK_Name._Marker_Type_key = deleted._Marker_Type_key and
69>                   MRK_Name.name = deleted.name
70>     end
71> end
72> 
1> 
2> drop trigger MRK_Marker_Delete
1> 
2> create trigger MRK_Marker_Delete
3> on MRK_Marker
4> for delete
5> as
6> 
7> /* Disallow deletion if Marker is currently referenced elsewhere */
8> 
9> if (select count(MRK_Alias._Alias_key) from MRK_Alias, deleted
10>     where MRK_Alias._Alias_key = deleted._Marker_key) > 0
11> begin
12>     rollback transaction
13>     raiserror 99999 "Marker Symbol is referenced in Alias Record(s)"
14>     return
15> end
16> 
17> /* Symbol is a Current Symbol of itself */
18> 
19> if (select count(MRK_Current._Current_key) from MRK_Current, deleted
20>          where MRK_Current._Current_key = deleted._Marker_key) > 1
21> begin
22>     rollback transaction
23>     raiserror 99999 "Marker Symbol is referenced in Current Symbol Record(s)"
24>     return
25> end
26> 
27> if (select count(MRK_History._History_key) from MRK_History, deleted
28>          where MRK_History._History_key = deleted._Marker_key and
29>                MRK_History._Marker_key != deleted._Marker_key) > 0
30> begin
31>     rollback transaction
32>     raiserror 99999 "Marker Symbol is referenced in History Record(s)"
33>     return
34> end
35> 
36> if (select count(PRB_Marker._Marker_key) from PRB_Marker, deleted
37>          where PRB_Marker._Marker_key = deleted._Marker_key) > 0
38> begin
39>     rollback transaction
40>     raiserror 99999 "Marker Symbol is referenced in Probe Marker Record(s)"
41>     return
42> end
43> 
44> if (select count(PRB_RFLV._Marker_key) from PRB_RFLV, deleted
45>          where PRB_RFLV._Marker_key = deleted._Marker_key) > 0
46> begin
47>     rollback transaction
48>     raiserror 99999 "Marker Symbol is referenced in Probe RFLV Record(s)"
49>     return
50> end
51> 
52> if (select count(MLD_Marker._Marker_key) from MLD_Marker, deleted
53>          where MLD_Marker._Marker_key = deleted._Marker_key) > 0
54> begin
55>     rollback transaction
56>     raiserror 99999 "Marker Symbol is referenced in MLDP Marker Record(s)"
57>     return
58> end
59> 
60> if (select count(MLD_Expt_Marker._Marker_key) from MLD_Expt_Marker, deleted
61>          where MLD_Expt_Marker._Marker_key = deleted._Marker_key) > 0
62> begin
63>     rollback transaction
64>     raiserror 99999 "Marker Symbol is referenced in MLDP Experiment Marker Record(s)"
65>     return
66> end
67> 
68> if (select count(MLD_Concordance._Marker_key) from MLD_Concordance, deleted
69>          where MLD_Concordance._Marker_key = deleted._Marker_key) > 0
70> begin
71>     rollback transaction
72>     raiserror 99999 "Marker Symbol is referenced in MLDP Hybrid Concordance Record(s)"
73>     return
74> end
75> 
76> if (select count(MLD_MC2point._Marker_key_1) from MLD_MC2point, deleted
77>          where MLD_MC2point._Marker_key_1 = deleted._Marker_key) > 0
78> begin
79>     rollback transaction
80>     raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
81>     return
82> end
83> 
84> if (select count(MLD_MC2point._Marker_key_2) from MLD_MC2point, deleted
85>          where MLD_MC2point._Marker_key_2 = deleted._Marker_key) > 0
86> begin
87>     rollback transaction
88>     raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
89>     return
90> end
91> 
92> if (select count(MLD_RIData._Marker_key) from MLD_RIData, deleted
93>          where MLD_RIData._Marker_key = deleted._Marker_key) > 0
94> begin
95>     rollback transaction
96>     raiserror 99999 "Marker Symbol is referenced in MLDP RI Data Record(s)"
97>     return
98> end
99> 
100> if (select count(MLD_RI2Point._Marker_key_1) from MLD_RI2Point, deleted
101>          where MLD_RI2Point._Marker_key_1 = deleted._Marker_key) > 0
102> begin
103>    rollback transaction
104>    raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
105>    return
106> end
107> 
108> if (select count(MLD_RI2Point._Marker_key_2) from MLD_RI2Point, deleted
109>          where MLD_RI2Point._Marker_key_2 = deleted._Marker_key) > 0
110> begin
111>    rollback transaction
112>    raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
113>    return
114> end
115> 
116> if (select count(MLD_Distance._Marker_key_1) from MLD_Distance, deleted
117>          where MLD_Distance._Marker_key_1 = deleted._Marker_key) > 0
118> begin
119>    rollback transaction
120>    raiserror 99999 "Marker Symbol is referenced in Physical Mapping Record(s)"
121>    return
122> end
123> 
124> if (select count(MLD_Distance._Marker_key_2) from MLD_Distance, deleted
125>          where MLD_Distance._Marker_key_2 = deleted._Marker_key) > 0
126> begin
127>    rollback transaction
128>    raiserror 99999 "Marker Symbol is referenced in Physical Mapping Record(s)"
129>    return
130> end
131> 
132> if (select count(HMD_Homology_Marker._Marker_key) from HMD_Homology_Marker, deleted
133>          where HMD_Homology_Marker._Marker_key = deleted._Marker_key) > 0
134> begin
135>    rollback transaction
136>    raiserror 99999 "Marker Symbol is referenced in Homology Record(s)"
137>    return
138> end
139> 
140> if (select count(MLC_Text_edit._Marker_key) from MLC_Text_edit, deleted
141>          where MLC_Text_edit._Marker_key = deleted._Marker_key) > 0
142> begin
143>    rollback transaction
144>    raiserror 99999 "Marker Symbol is referenced in MLC Edit Record(s)"
145>    return
146> end
147> 
148> if (select count(MLC_Marker_edit._Marker_key_2) from MLC_Marker_edit, deleted
149>          where MLC_Marker_edit._Marker_key_2 = deleted._Marker_key) > 0
150> begin
151>    rollback transaction
152>    raiserror 99999 "Marker Symbol is referenced in MLC Edit Record(s)"
153>    return
154> end
155> 
156> if (select count(CRS_Matrix._Marker_key) from CRS_Matrix, deleted
157>          where CRS_Matrix._Marker_key = deleted._Marker_key) > 0
158> begin
159>    rollback transaction
160>    raiserror 99999 "Marker Symbol is referenced in Cross Matrix Record(s)"
161>    return
162> end
163> 
164> if (select count(GXD_Index._Marker_key) from GXD_Index, deleted
165>          where GXD_Index._Marker_key = deleted._Marker_key) > 0
166> begin
167>    rollback transaction
168>    raiserror 99999 "Marker Symbol is referenced in GXD Index Record(s)"
169>    return
170> end
171> 
172> if (select count(GXD_AllelePair._Marker_key) from GXD_AllelePair, deleted
173>          where GXD_AllelePair._Marker_key = deleted._Marker_key) > 0
174> begin
175>    rollback transaction
176>    raiserror 99999 "Marker Symbol is referenced in GXD Allele Pair Record(s)"
177>    return
178> end
179> 
180> if (select count(GXD_AntibodyMarker._Marker_key) from GXD_AntibodyMarker, deleted
181>          where GXD_AntibodyMarker._Marker_key = deleted._Marker_key) > 0
182> begin
183>    rollback transaction
184>    raiserror 99999 "Marker Symbol is referenced in GXD Antibody Marker Record(s)"
185>    return
186> end
187> 
188> if (select count(GXD_Assay._Marker_key) from GXD_Assay, deleted
189>          where GXD_Assay._Marker_key = deleted._Marker_key) > 0
190> begin
191>    rollback transaction
192>    raiserror 99999 "Marker Symbol is referenced in GXD Assay Record(s)"
193>    return
194> end
195> 
196> delete MRK_Alias from MRK_Alias, deleted
197> where MRK_Alias._Marker_key = deleted._Marker_key
198> 
199> delete MRK_Allele from MRK_Allele, deleted
200> where MRK_Allele._Marker_key = deleted._Marker_key
201> 
202> delete MRK_Classes from MRK_Classes, deleted
203> where MRK_Classes._Marker_key = deleted._Marker_key
204> 
205> delete MRK_Current from MRK_Current, deleted
206> where MRK_Current._Marker_key = deleted._Marker_key
207> 
208> delete MRK_History from MRK_History, deleted
209> where MRK_History._Marker_key = deleted._Marker_key
210> 
211> delete MRK_Notes from MRK_Notes, deleted
212> where MRK_Notes._Marker_key = deleted._Marker_key
213> 
214> delete MRK_Offset from MRK_Offset, deleted
215> where MRK_Offset._Marker_key = deleted._Marker_key
216> 
217> delete MRK_Other from MRK_Other, deleted
218> where MRK_Other._Marker_key = deleted._Marker_key
219> 
220> delete MRK_Reference from MRK_Reference, deleted
221> where MRK_Reference._Marker_key = deleted._Marker_key
222> 
223> delete MRK_Name from MRK_Name, deleted
224> where MRK_Name._Marker_key = deleted._Marker_key
225> 
226> delete MRK_Symbol from MRK_Symbol, deleted
227> where MRK_Symbol._Marker_key = deleted._Marker_key
228> 
229> delete ACC_Accession
230> from ACC_Accession a, ACC_MGIType m, deleted
231> where a._Object_key = deleted._Marker_key
232> and a._MGIType_key = m._MGIType_key
233> and m.name = "Marker"
234> 
1> 
2> drop trigger MRK_Alias_Insert
1> 
2> create trigger MRK_Alias_Insert
3> on MRK_Alias
4> for insert
5> as
6> 
7> if (select count(MRK_Marker._Marker_key) from MRK_Marker, inserted
8>          where inserted._Marker_key = inserted._Alias_key) > 0
9> begin
10>         rollback transaction
11>         raiserror 99999 "Symbol cannot use itself as an Alias"
12>     return
13> end
14> 
15> /* Append Alias to Symbol bucket */
16> 
17> if (select count(MRK_Symbol._Marker_key) from MRK_Symbol, inserted, MRK_Marker
18>     where MRK_Symbol._Marker_key = inserted._Marker_key and
19>       inserted._Marker_key = MRK_Marker._Marker_key and
20>       MRK_Symbol.symbol = MRK_Marker.symbol and
21>       MRK_Symbol._Marker_Type_key = 4) = 0
22> begin
23>   insert MRK_Symbol (_Marker_key, _Marker_Type_key, symbol) 
24>   select inserted._Marker_key, 4, MRK_Marker.symbol
25>   from inserted, MRK_Marker
26>   where inserted._Alias_key = MRK_Marker._Marker_key
27> end
28> 
1> 
2> drop trigger MRK_Alias_Delete
1> 
2> create trigger MRK_Alias_Delete
3> on MRK_Alias
4> for delete
5> as
6> 
7> /* Delete Alias from Symbol Bucket */
8> 
9> delete MRK_Symbol from MRK_Symbol, MRK_Marker, deleted
10> where MRK_Symbol._Marker_key = deleted._Marker_key and
11>       MRK_Symbol._Marker_Type_key = 4 and
12>       deleted._Alias_key = MRK_Marker._Marker_key and
13>       MRK_Marker.symbol = MRK_Symbol.symbol
14> 
1> 
2> drop trigger MRK_Allele_Insert
1>  
2> create trigger MRK_Allele_Insert
3> on MRK_Allele
4> for insert
5> as
6>  
7> /* Append Allele Symbol to Symbol Bucket */
8> 
9> if (select count(MRK_Symbol._Marker_key) from MRK_Symbol, inserted
10>     where MRK_Symbol._Marker_key = inserted._Marker_key and
11>       MRK_Symbol.symbol = inserted.symbol and
12>       MRK_Symbol._Marker_Type_key = 5) = 0
13> begin
14>   insert MRK_Symbol (_Marker_key, _Marker_Type_key, symbol)
15>   select inserted._Marker_key, 5, inserted.symbol
16>   from inserted
17> end
18>  
19> /* Append Allele Name to Name Bucket */
20> 
21> if (select count(MRK_Name._Marker_key) from MRK_Name, inserted
22>     where MRK_Name._Marker_key = inserted._Marker_key and
23>       MRK_Name.name = inserted.name and
24>       MRK_Name._Marker_Type_key = 5) = 0
25> begin
26>   insert MRK_Name (_Marker_key, _Marker_Type_key, name)
27>   select inserted._Marker_key, 5, inserted.name 
28>   from inserted
29> end
30>  
1>  
2> drop trigger MRK_Allele_Update
1>  
2> create trigger MRK_Allele_Update
3> on MRK_Allele
4> for update
5> as
6>  
7> /* Update entries in Symbol/Name Buckets */
8> 
9> if update(symbol)
10> begin
11>     update MRK_Symbol set symbol = inserted.symbol
12>     from MRK_Symbol, inserted, deleted
13>     where MRK_Symbol._Marker_key = inserted._Marker_key and 
14>           MRK_Symbol._Marker_Type_key = 5 and
15>           MRK_Symbol.symbol = deleted.symbol
16> end
17> 
18> if update(name)
19> begin
20>     update MRK_Name set name = inserted.name
21>     from MRK_Name, inserted, deleted
22>     where MRK_Name._Marker_key = inserted._Marker_key and 
23>           MRK_Name._Marker_Type_key = 5 and
24>           MRK_Name.name = deleted.name
25> end
26> 
1>  
2> drop trigger MRK_Allele_Delete
1>  
2> create trigger MRK_Allele_Delete
3> on MRK_Allele
4> for delete
5> as
6> 
7> /* If Allele is referenced in MLDP, disallow deletion */
8> 
9> if (select count(MLD_Expt_Marker._Allele_key) from MLD_Expt_Marker, deleted
10>     where MLD_Expt_Marker._Allele_key = deleted._Allele_key) > 0
11> begin
12>     rollback transaction
13>     raiserror 99999 "Allele Symbol is referenced in MLDP Record(s)"
14>     return
15> end
16> 
17> /* If Allele is referenced in GXD, disallow deletion */
18> 
19> if (select count(GXD_AllelePair._Allele_key_1) from GXD_AllelePair, deleted
20>     where GXD_AllelePair._Allele_key_1 = deleted._Allele_key) > 0
21> begin
22>     rollback transaction
23>     raiserror 99999 "Allele Symbol is referenced in GXD Allele Pair Record(s)"
24>     return
25> end
26> 
27> if (select count(GXD_AllelePair._Allele_key_2) from GXD_AllelePair, deleted
28>     where GXD_AllelePair._Allele_key_2 = deleted._Allele_key) > 0
29> begin
30>     rollback transaction
31>     raiserror 99999 "Allele Symbol is referenced in GXD Allele Pair Record(s)"
32>     return
33> end
34> 
35> /* Remove entries from Symbol/Name buckets */
36> 
37> delete MRK_Symbol from MRK_Symbol, deleted
38> where MRK_Symbol._Marker_key = deleted._Marker_key and
39> MRK_Symbol._Marker_Type_key = 5 and
40> MRK_Symbol.symbol = deleted.symbol
41>  
42> delete MRK_Name from MRK_Name, deleted
43> where MRK_Name._Marker_key = deleted._Marker_key and
44> MRK_Name._Marker_Type_key = 5 and
45> MRK_Name.name = deleted.name
46> 
1>  
2> drop trigger MRK_Class_Delete
1>  
2> create trigger MRK_Class_Delete
3> on MRK_Class
4> for delete
5> as
6> 
7> /* Disallow deletion if Class is referenced by a Marker */
8>  
9> if (select count(MRK_Classes._Class_key) from MRK_Classes, deleted
10>     where MRK_Classes._Class_key = deleted._Class_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Class is referenced in Marker Record(s)"
14>     return
15> end
16>  
1>  
2> drop trigger MRK_History_Insert
1>  
2> create trigger MRK_History_Insert
3> on MRK_History
4> for insert
5> as
6>  
7> if @@rowcount = 1
8> begin
9>      /* Insert entry in Name bucket if it doesn't already exist */
10> 
11>     if (select count(MRK_Name._Marker_key) from MRK_Name, inserted, MRK_Marker
12>                 where MRK_Name._Marker_key = inserted._Marker_key and
13>               MRK_Name.name = inserted.name and
14>               MRK_Name._Marker_key = MRK_Marker._Marker_key and
15>               MRK_Name._Marker_Type_key = MRK_Marker._Marker_Type_key) = 0
16>        and (select name from inserted) != NULL
17>     begin
18>             insert MRK_Name (_Marker_key, _Marker_Type_key, name)
19>             select inserted._Marker_key, MRK_Marker._Marker_Type_key, inserted.name 
20>             from inserted, MRK_Marker
21>             where inserted._Marker_key = MRK_Marker._Marker_key
22>     end
23> 
24>     /* Insert entry in Reference bucket if it doesn't already exist */
25> 
26>     if (select count(MRK_Reference._Marker_key) from MRK_Reference, inserted
27>                 where MRK_Reference._Marker_key = inserted._Marker_key and
28>               MRK_Reference._Refs_key = inserted._Refs_key) = 0
29>        and (select _Refs_key from inserted) != NULL
30>     begin
31>             insert MRK_Reference (_Marker_key, _Refs_key, auto) 
32>             select _Marker_key, _Refs_key, 1 from inserted
33>             where _Refs_key is not null
34>     end
35> end
36> 
1>  
2> drop trigger MRK_History_Update
1>  
2> create trigger MRK_History_Update
3> on MRK_History
4> for update
5> as
6>  
7> if @@rowcount = 1
8> begin
9> 
10>   /* Update entry in Name bucket if it doesn't already exist */
11> 
12>   if update(name)
13>      and
14>      (select count(MRK_Name._Marker_key) from MRK_Name, inserted, MRK_Marker
15>       where MRK_Name._Marker_key = inserted._Marker_key and
16>         MRK_Name.name = inserted.name and
17>             MRK_Name._Marker_key = MRK_Marker._Marker_key and
18>         MRK_Name._Marker_Type_key = MRK_Marker._Marker_Type_key) = 0
19>      and (select name from inserted) != NULL
20>   begin
21>           update MRK_Name set name = inserted.name
22>           from MRK_Name, inserted, deleted
23>           where MRK_Name._Marker_key = inserted._Marker_key and 
24>             MRK_Name._Marker_Type_key is null and
25>             MRK_Name.name = deleted.name
26>   end
27> 
28>   /* Update entry in Reference bucket if it doesn't already exist */
29> 
30>   if update(_Refs_key)
31>      and
32>      (select count(MRK_Reference._Marker_key) from MRK_Reference, inserted
33>       where MRK_Reference._Marker_key = inserted._Marker_key and
34>         MRK_Reference._Refs_key = inserted._Refs_key) = 0
35>      and (select _Refs_key from inserted) != NULL
36>   begin
37>       insert MRK_Reference (_Marker_key, _Refs_key, auto) 
38>       select _Marker_key, _Refs_key, 1 from inserted
39>       where _Refs_key is not null
40>   end
41> end
42> 
1> 
2> drop trigger MRK_History_Delete
1>  
2> create trigger MRK_History_Delete
3> on MRK_History
4> for delete
5> as
6>  
7> /* Remove entry from Name bucket */
8> 
9> delete MRK_Name from MRK_Name, deleted
10> where MRK_Name._Marker_key = deleted._Marker_key and
11>       MRK_Name._Marker_Type_key is null and
12>       MRK_Name.name = deleted.name
13>  
1>  
2> drop trigger MRK_Other_Insert
1>  
2> create trigger MRK_Other_Insert
3> on MRK_Other
4> for insert
5> as
6>  
7> /* Insert entry into Name bucket */
8> 
9> insert MRK_Name (_Marker_key, _Marker_Type_key, name)
10> select inserted._Marker_key, MRK_Marker._Marker_Type_key, inserted.name 
11> from inserted, MRK_Marker
12> where inserted._Marker_key = MRK_Marker._Marker_key
13>  
1>  
2> drop trigger MRK_Other_Update
1>  
2> create trigger MRK_Other_Update
3> on MRK_Other
4> for update
5> as
6>  
7> if @@rowcount = 1
8> begin
9>      /* Update entry in Name bucket */
10> 
11>     if update(name) and (select name from inserted) != NULL
12>     begin
13>             update MRK_Name set name = inserted.name
14>             from MRK_Name, inserted, deleted
15>             where MRK_Name._Marker_key = inserted._Marker_key and 
16>                     MRK_Name._Marker_Type_key is null and
17>             MRK_Name.name = deleted.name
18>     end
19> end
20> 
1> 
2> drop trigger MRK_Other_Delete
1>  
2> create trigger MRK_Other_Delete
3> on MRK_Other
4> for delete
5> as
6>  
7> /* Delete entry from Name bucket */
8> 
9> delete MRK_Name from MRK_Name, deleted
10> where MRK_Name._Marker_key = deleted._Marker_key and
11>       MRK_Name._Marker_Type_key is null and
12>       MRK_Name.name = deleted.name
13>  
1>  
2> drop trigger MRK_Species_Delete
1> 
2> create trigger MRK_Species_Delete
3> on MRK_Species
4> for delete
5> as
6> 
7> /* Disallow deletion of species which is referenced in MRK_Marker table */
8> 
9> if (select count(MRK_Marker._Marker_key) from MRK_Marker, deleted
10>          where MRK_Marker._Species_key = deleted._Species_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Species is referenced in Marker Record(s)"
14>     return
15> end
16> 
17> /* Delete records in dependent tables */
18> 
19> delete MRK_Chromosome from MRK_Chromosome, deleted
20> where MRK_Chromosome._Species_key = deleted._Species_key
21> 
1> 
2> drop trigger MRK_Types_Delete
1> 
2> create trigger MRK_Types_Delete
3> on MRK_Types
4> for delete
5> as
6> 
7> /* Disallow deletion of Type which is referenced in MRK_Marker table */
8> 
9> if (select count(MRK_Marker._Marker_key) from MRK_Marker, deleted
10>          where MRK_Marker._Marker_Type_key = deleted._Marker_Type_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Marker Type is referenced in Marker Record(s)"
14>     return
15> end
16> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger PRB_Probe_Insert
1>  
2> create trigger PRB_Probe_Insert
3> on PRB_Probe
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Molecular Segment */
8> 
9> declare @key integer
10> select @key = _Probe_key from inserted
11> exec ACC_assignMGI @key, "Segment"
12> 
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1>  
2> drop trigger PRB_Probe_Update
1>  
2> create trigger PRB_Probe_Update
3> on PRB_Probe
4> for update
5> as
6>  
7> if update (_Source_key)
8> begin
9>      /* Delete orphan Anonymous _Source_keys */
10> 
11>     if (select PRB_Source.name from PRB_Source, deleted
12>         where PRB_Source._Source_key = deleted._Source_key) is null
13>         and
14>        (select count(PRB_Probe._Source_key) from PRB_Probe, deleted
15>             where PRB_Probe._Source_key = deleted._Source_key) = 0
16>     begin
17>             delete PRB_Source from PRB_Source, deleted
18>             where PRB_Source._Source_key = deleted._Source_key
19>     end
20> 
21>     /* Update _Source_key for all children of Parent */
22> 
23>     update PRB_Probe set _Source_key = inserted._Source_key
24>     from PRB_Probe, inserted
25>     where PRB_Probe.derivedFrom = inserted._Probe_key
26> end
27> 
1>  
2> drop trigger PRB_Probe_Delete
1> 
2> create trigger PRB_Probe_Delete
3> on PRB_Probe
4> for delete
5> as
6> 
7> /* Disallow deletion if Molecular Segment is referenced elsewhere */
8> 
9> if (select count(PRB_Probe._Probe_key) 
10>     from PRB_Probe, deleted
11>     where PRB_Probe.derivedFrom = deleted._Probe_key) > 0
12> begin
13>         rollback transaction
14>         raiserror 99999 "Probe is referenced as a Parent in Probe record(s)"
15>     return
16> end
17>  
18> if (select count(MLD_Hit._Probe_key) 
19>          from MLD_Hit, deleted
20>          where MLD_Hit._Probe_key = deleted._Probe_key) > 0
21> begin
22>         rollback transaction
23>         raiserror 99999 "Probe is referenced in MLDP Hit record(s)"
24>     return
25> end
26>  
27> if (select count(MLD_Hit._Target_key) 
28>          from MLD_Hit, deleted
29>          where MLD_Hit._Target_key = deleted._Probe_key) > 0
30> begin
31>         rollback transaction
32>         raiserror 99999 "Probe is referenced as a Target in MLDP Hit record(s)"
33>     return
34> end
35>  
36> if (select count(MLD_ContigProbe._Probe_key) 
37>          from MLD_ContigProbe, deleted
38>          where MLD_ContigProbe._Probe_key = deleted._Probe_key) > 0
39> begin
40>         rollback transaction
41>         raiserror 99999 "Probe is referenced in MLDP Contig/Probe record(s)"
42>     return
43> end
44>  
45> if (select count(GXD_ProbePrep._Probe_key) 
46>          from GXD_ProbePrep, deleted
47>          where GXD_ProbePrep._Probe_key = deleted._Probe_key) > 0
48> begin
49>         rollback transaction
50>         raiserror 99999 "Probe is referenced in GXD Probe Prep record(s)"
51>     return
52> end
53> delete PRB_Marker from PRB_Marker, deleted
54> where PRB_Marker._Probe_key = deleted._Probe_key
55> 
56> delete PRB_Notes from PRB_Notes, deleted
57> where PRB_Notes._Probe_key = deleted._Probe_key
58> 
59> delete PRB_Reference from PRB_Reference, deleted
60> where PRB_Reference._Probe_key = deleted._Probe_key
61> 
62> /* If Probe Source Name is null, then Anonymous Source */
63> /* If Anonymous Source, delete upon deletion of Probe */
64> 
65> if (select count(PRB_Probe._Source_key) from PRB_Probe, deleted
66>     where PRB_Probe._Source_key = deleted._Source_key) = 0
67> begin
68>     delete PRB_Source from PRB_Source, deleted
69>     where PRB_Source._Source_key = deleted._Source_key
70>           and PRB_Source.name is null
71> end
72> 
73> delete ACC_AccessionReference 
74> from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m, deleted
75> where a._Object_key = deleted._Probe_key
76> and a._MGIType_key = m._MGIType_key
77> and m.name = "Segment"
78> and a._Accession_key = ar._Accession_key
79>  
80> delete ACC_Accession 
81> from ACC_Accession a, ACC_MGIType m, deleted
82> where a._Object_key = deleted._Probe_key
83> and a._MGIType_key = m._MGIType_key
84> and m.name = "Segment"
85>  
1> 
2> drop trigger PRB_Allele_Delete
1> 
2> create trigger PRB_Allele_Delete
3> on PRB_Allele
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete PRB_Allele_Strain from PRB_Allele_Strain, deleted
10> where PRB_Allele_Strain._Allele_key = deleted._Allele_key
11> 
1> 
2> drop trigger PRB_Marker_Insert
1> 
2> create trigger PRB_Marker_Insert
3> on PRB_Marker
4> for insert
5> as
6> 
7> if @@rowcount = 1
8> begin
9>      /* Relationship must be 'H' for Probes of non-mouse source */
10> 
11>     if (select count(*) from inserted i, PRB_Probe p, PRB_Source s
12>                     where i._Probe_key = p._Probe_key
13>             and p.DNAtype != 'primer'
14>             and p._Source_key = s._Source_key
15>             and s.species not in ('mouse, laboratory')
16>             and (i.relationship != 'H' or i.relationship is null)) > 0
17>     begin
18>             rollback transaction
19>             raiserror 99999 "Relationship Must be 'H'"
20>             return
21>     end
22> 
23>     /* Relationship 'P' can only be used during an EST bulk load */
24> 
25>     if (select relationship from inserted) = 'P'
26>     begin
27>             rollback transaction
28>             raiserror 99999 "Relationship 'P' can only be used during EST load"
29>             return
30>     end
31> 
32>     /* If adding encoding Marker to a Molecular Segment and */
33>     /* Molecular Segment contains a Seq ID and */
34>     /* the Marker is not associated with the Seq ID */
35> 
36>     if (select relationship from inserted) = 'E'
37>     begin
38>             if not exists (select a1.accID
39>                from ACC_Accession a1, ACC_Accession a2, inserted i
40>                where a1._MGIType_key = 3 and 
41>                      a1. _LogicalDB_key = 9 and 
42>                      a1._Object_key = i._Probe_key and
43>                      a1.accID = a2.accID and
44>                      a2._MGIType_key = 2 and
45>                      a2._LogicalDB_key = 9 and
46>                      a2._Object_key = i._Marker_key)
47> 
48>             begin
49>                     print "The Sequence ID(s) for this Molecular Segment should probably be added to the encoding, updated Marker."
50>             end
51> 
52>     end
53> end
54> 
1> 
2> drop trigger PRB_Marker_Update
1>  
2> create trigger PRB_Marker_Update
3> on PRB_Marker
4> for update
5> as
6>  
7> if update(_Marker_key)
8> begin
9>      update PRB_RFLV
10>     set _Marker_key = inserted._Marker_key
11>     from PRB_RFLV, PRB_Reference, inserted, deleted
12>     where inserted._Probe_key = PRB_Reference._Probe_key
13>           and PRB_Reference._Reference_key = PRB_RFLV._Reference_key
14>           and PRB_RFLV._Marker_key = deleted._Marker_key
15> end
16> 
17> if @@rowcount = 1
18> begin
19> 
20>     /* Relationship must be 'H' for Probes of non-mouse source */
21> 
22>     if (select count(*) from inserted i, PRB_Probe p, PRB_Source s
23>                     where i._Probe_key = p._Probe_key
24>             and p.DNAtype != 'primer'
25>             and p._Source_key = s._Source_key
26>             and s.species not in ('mouse, laboratory')
27>             and (i.relationship != 'H' or i.relationship is null)) > 0
28>     begin
29>             rollback transaction
30>             raiserror 99999 "Relationship Must be 'H'"
31>             return
32>     end
33> 
34>     /* Allow update of 'P' to other relationship */
35>     /* Disallow update of other relationship to 'P' */
36>     /* Only check on individual inserts */
37> 
38>     if ((select relationship from inserted) = 'P'
39>         and (select _Marker_key from inserted) = (select _Marker_key from deleted))
40>        or
41>        ((select _Marker_key from inserted) != (select _Marker_key from deleted)
42>         and (select relationship from inserted) = 'P'
43>         and (select relationship from deleted) != 'P')
44>     begin
45>             rollback transaction
46>             raiserror 99999 "Relationship 'P' can only be used during EST load"
47>             return
48>     end
49> 
50>         /* If updating to an encoding Marker for a Molecular Segment and */
51>         /* Molecular Segment contains a Seq ID and */
52>         /* the Marker is not associated with the Seq ID */
53>  
54>         if update(relationship) and (select relationship from inserted) = 'E'
55>         begin
56>                 if not exists (select a1.accID
57>                    from ACC_Accession a1, ACC_Accession a2, inserted i
58>                    where a1._MGIType_key = 3 and
59>                          a1. _LogicalDB_key = 9 and
60>                          a1._Object_key = i._Probe_key and
61>                          a1.accID = a2.accID and
62>                          a2._MGIType_key = 2 and
63>                          a2._LogicalDB_key = 9 and
64>                          a2._Object_key = i._Marker_key)
65>  
66>                 begin
67>                         print "The Sequence ID(s) for this Molecular Segment should probably be added to the encoding, updated Marker."
68>                 end
69>     end 
70> 
71>         /* If updating to an non-encoding Marker for a Molecular Segment and */
72>         /* Molecular Segment contains a Seq ID and */
73>         /* the Marker is associated with the Seq ID */
74>  
75>         if update(relationship) and 
76>        (select relationship from deleted) = 'E' and
77>            (select relationship from inserted) != 'E'
78>         begin
79>                 if exists (select a1.accID
80>                    from ACC_Accession a1, ACC_Accession a2, inserted i
81>                    where a1._MGIType_key = 3 and
82>                          a1. _LogicalDB_key = 9 and
83>                          a1._Object_key = i._Probe_key and
84>                          a1.accID = a2.accID and
85>                          a2._MGIType_key = 2 and
86>                          a2._LogicalDB_key = 9 and
87>                          a2._Object_key = i._Marker_key)
88>  
89>                 begin
90>                         print "Please review the relationship(s) between the updated Marker and its Seq IDs.  These relationships may no longer be appropriate."
91>                 end
92>     end 
93> end
94> 
1> 
2> drop trigger PRB_Marker_Delete
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the trigger 'PRB_Marker_Delete', because it doesn't exist in the
system catalogs.
1>  
2> create trigger PRB_Marker_Delete
3> on PRB_Marker
4> for delete
5> as
6> 
7> if @@rowcount = 1
8> begin
9>         /* If deleting an encoding Marker from a Molecular Segment and */
10>         /* Molecular Segment contains a Seq ID and */
11>         /* the Marker is associated with the Seq ID */
12>  
13>         if (select relationship from deleted) = 'E'
14>         begin
15>                 if exists (select a1.accID
16>                    from ACC_Accession a1, ACC_Accession a2, deleted d
17>                    where a1._MGIType_key = 3 and
18>                          a1. _LogicalDB_key = 9 and
19>                          a1._Object_key = d._Probe_key and
20>                          a1.accID = a2.accID and
21>                          a2._MGIType_key = 2 and
22>                          a2._LogicalDB_key = 9 and
23>                          a2._Object_key = d._Marker_key)
24>  
25>                 begin
26>                         print "Please review the relationship(s) between the deleted Marker and its Seq IDs.  These relationships may no longer be appropriate."
27>                 end
28>     end 
29> 
30> end
31> 
1>  
2> drop trigger PRB_Reference_Delete
1> 
2> create trigger PRB_Reference_Delete
3> on PRB_Reference
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete PRB_Alias from PRB_Alias, deleted
10> where PRB_Alias._Reference_key = deleted._Reference_key
11> 
12> delete PRB_Ref_Notes from PRB_Ref_Notes, deleted
13> where PRB_Ref_Notes._Reference_key = deleted._Reference_key
14> 
15> delete PRB_RFLV from PRB_RFLV, deleted
16> where PRB_RFLV._Reference_key = deleted._Reference_key
17> 
18> delete ACC_AccessionReference 
19> from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m, deleted
20> where a._Object_key = deleted._Probe_key
21> and a._MGIType_key = m._MGIType_key
22> and m.name = "Segment"
23> and a._Accession_key = ar._Accession_key
24> and ar._Refs_key = deleted._Refs_key
25>  
1> 
2> drop trigger PRB_RFLV_Delete
1> 
2> create trigger PRB_RFLV_Delete
3> on PRB_RFLV
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete PRB_Allele from PRB_Allele, deleted
10> where PRB_Allele._RFLV_key = deleted._RFLV_key
11> 
1> 
2> drop trigger PRB_Source_Insert
1> 
2> create trigger PRB_Source_Insert
3> on PRB_Source
4> for insert
5> as
6> 
7> /* The same exact logic to prevent invalid Age values must */
8> /* be used in the update trigger as well */
9> 
10> /* Ignore multi-row data */
11> 
12> if @@rowcount > 1
13> begin
14>     return
15> end
16> 
17> declare @age varchar(50)
18> select @age = inserted.age from inserted
19> 
20> /* If tissue = 'unfertilized egg', then age must be 'Not Applicable' */
21> 
22> if (select PRB_Tissue.tissue
23>     from PRB_Tissue, inserted
24>     where inserted._Tissue_key = PRB_Tissue._Tissue_key) = "unfertilized egg"
25>    and @age != "Not Applicable"
26> begin
27>         rollback transaction
28>         raiserror 99999 "Age for this tissue MUST be Not Applicable"
29>     return
30> end
31> 
32> /* If age is 'Not Applicable', then tissue must be 'unfertilized egg' */
33> 
34> if @age = "Not Applicable"
35>    and
36>    (select PRB_Tissue.tissue
37>     from PRB_Tissue, inserted
38>     where inserted._Tissue_key = PRB_Tissue._Tissue_key) != "unfertilized egg"
39> begin
40>         rollback transaction
41>         raiserror 99999 "Age for this tissue CANNOT be Not Applicable"
42>     return
43> end
44> 
45> /* Separate agePrefix from ageSuffix (numerics) */
46> 
47> declare @agePrefix varchar(50)
48> declare @ageSuffix varchar(50)
49> declare @idx integer
50> 
51> select @agePrefix = @age
52> select @idx = patindex("%[0-9]%", @age)
53> 
54> if @idx > 0
55> begin
56>     select @agePrefix = substring(@age, 1, @idx - 1)
57>     select @ageSuffix = substring(@age, @idx, char_length(@age))
58> end
59> 
60> /* If age is one of the following prefixes, then there can be no numeric values */
61> 
62> if @agePrefix in ('Not Specified', 'Not Applicable', 'embryonic', 'perinatal',
63>     'postnatal', 'postnatal newborn', 'postnatal immature', 'postnatal adult')
64>    and @ageSuffix is not null
65> begin
66>         rollback transaction
67>         raiserror 99999 "The Age value specified CANNOT contain numeric values"
68>     return
69> end
70> 
71> /* If age is one of the following prefixes, then there must be numeric values */
72> 
73> if @agePrefix in ('embryonic day', 'postnatal day', 'postnatal week',
74>     'postnatal month', 'postnatal year')
75>    and @ageSuffix is null
76> begin
77>         rollback transaction
78>         raiserror 99999 "The Age value specified MUST contain numeric values"
79>     return
80> end
81> 
1> 
2> drop trigger PRB_Source_Update
1> 
2> create trigger PRB_Source_Update
3> on PRB_Source
4> for update
5> as
6> 
7> /* The same exact logic to prevent invalid Age values must */
8> /* be used in the insert trigger as well */
9> 
10> /* Ignore multi-row data */
11> 
12> if @@rowcount > 1
13> begin
14>     return
15> end
16> 
17> declare @age varchar(50)
18> select @age = inserted.age from inserted
19> 
20> /* If tissue = 'unfertilized egg', then age must be 'Not Applicable' */
21> 
22> if (select PRB_Tissue.tissue
23>     from PRB_Tissue, inserted
24>     where inserted._Tissue_key = PRB_Tissue._Tissue_key) = "unfertilized egg"
25>    and @age != "Not Applicable"
26> begin
27>         rollback transaction
28>         raiserror 99999 "Age for this tissue MUST be Not Applicable"
29>     return
30> end
31> 
32> /* If age is 'Not Applicable', then tissue must be 'unfertilized egg' */
33> 
34> if @age = "Not Applicable"
35>    and
36>    (select PRB_Tissue.tissue
37>     from PRB_Tissue, inserted
38>     where inserted._Tissue_key = PRB_Tissue._Tissue_key) != "unfertilized egg"
39> begin
40>         rollback transaction
41>         raiserror 99999 "Age for this tissue CANNOT be Not Applicable"
42>     return
43> end
44> 
45> /* Separate agePrefix from ageSuffix (numerics) */
46> 
47> declare @agePrefix varchar(50)
48> declare @ageSuffix varchar(50)
49> declare @idx integer
50> 
51> select @agePrefix = @age
52> select @idx = patindex("%[0-9]%", @age)
53> 
54> if @idx > 0
55> begin
56>     select @agePrefix = substring(@age, 1, @idx - 1)
57>     select @ageSuffix = substring(@age, @idx, char_length(@age))
58> end
59> 
60> /* If age is one of the following prefixes, then there can be no numeric values */
61> 
62> if @agePrefix in ('Not Specified', 'Not Applicable', 'embryonic', 'perinatal',
63>     'postnatal', 'postnatal newborn', 'postnatal immature', 'postnatal adult')
64>    and @ageSuffix is not null
65> begin
66>         rollback transaction
67>         raiserror 99999 "The Age value specified CANNOT contain numeric values"
68>     return
69> end
70> 
71> /* If age is one of the following prefixes, then there must be numeric values */
72> 
73> if @agePrefix in ('embryonic day', 'postnatal day', 'postnatal week',
74>     'postnatal month', 'postnatal year')
75>    and @ageSuffix is null
76> begin
77>         rollback transaction
78>         raiserror 99999 "The Age value specified MUST contain numeric values"
79>     return
80> end
81> 
1> 
2> drop trigger PRB_Source_Delete
1> 
2> create trigger PRB_Source_Delete
3> on PRB_Source
4> for delete
5> as
6> 
7> /* Disallow deletion if Source is referenced elsewhere */
8> 
9> if (select count(PRB_Probe._Source_key) from PRB_Probe, deleted
10>          where PRB_Probe._Source_key = deleted._Source_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Probe Library is referenced in Probe Record(s)"
14>     return
15> end
16>  
17> if (select count(GXD_Antigen._Source_key) from GXD_Antigen, deleted
18>          where GXD_Antigen._Source_key = deleted._Source_key) > 0
19> begin
20>         rollback transaction
21>         raiserror 99999 "Probe Library is referenced in GXD Antigen Record(s)"
22>     return
23> end
24>  
1> 
2> drop trigger PRB_Strain_Insert
1> 
2> create trigger PRB_Strain_Insert
3> on PRB_Strain
4> for insert
5> as
6> 
7> if (select count(*) from PRB_Strain, inserted
8>          where PRB_Strain.strain = inserted.strain) > 1
9> begin
10>         print "Potential Duplicate Strain Found"
11> end
12>  
1> 
2> drop trigger PRB_Strain_Update
1> 
2> create trigger PRB_Strain_Update
3> on PRB_Strain
4> for update
5> as
6> 
7> if (select count(*) from PRB_Strain, inserted
8>          where PRB_Strain.strain = inserted.strain) > 1
9> begin
10>         print "Potential Duplicate Strain Found"
11> end
12>  
13> update PRB_Strain 
14> set modification_date = getdate()
15> from PRB_Strain, inserted
16> where PRB_Strain._Strain_key = inserted._Strain_key
17> 
1> 
2> drop trigger PRB_Strain_Delete
1> 
2> create trigger PRB_Strain_Delete
3> on PRB_Strain
4> for delete
5> as
6> 
7> /* Disallow deletion if Strain is referenced elsewhere */
8> 
9> if (select count(PRB_Source._Strain_key) from PRB_Source, deleted
10>     where PRB_Source._Strain_key = deleted._Strain_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Strain is referenced in Probe Library Record(s)"
14>     return
15> end
16> 
17> if (select count(PRB_Allele_Strain._Strain_key) from PRB_Allele_Strain, deleted
18>          where PRB_Allele_Strain._Strain_key = deleted._Strain_key) > 0
19> begin
20>         rollback transaction
21>         raiserror 99999 "Strain is referenced in RFLP Record(s)"
22>     return
23> end
24> if (select count(MLD_FISH._Strain_key) from MLD_FISH, deleted
25>          where MLD_FISH._Strain_key = deleted._Strain_key) > 0
26> begin
27>         rollback transaction
28>         raiserror 99999 "Strain is referenced in FISH Record(s)"
29>     return
30> end
31>  
32> if (select count(MLD_InSitu._Strain_key) from MLD_InSitu, deleted
33>          where MLD_InSitu._Strain_key = deleted._Strain_key) > 0
34> begin
35>         rollback transaction
36>         raiserror 99999 "Strain is referenced in InSitu Record(s)"
37>     return
38> end
39>  
40> if (select count(CRS_Cross._femaleStrain_key) from CRS_Cross, deleted
41>          where CRS_Cross._femaleStrain_key = deleted._Strain_key) > 0
42> begin
43>         rollback transaction
44>         raiserror 99999 "Strain is referenced in Cross Record(s)"
45>     return
46> end
47>  
48> if (select count(CRS_Cross._maleStrain_key) from CRS_Cross, deleted
49>          where CRS_Cross._maleStrain_key = deleted._Strain_key) > 0
50> begin
51>         rollback transaction
52>         raiserror 99999 "Strain is referenced in Cross Record(s)"
53>     return
54> end
55>  
56> if (select count(CRS_Cross._StrainHO_key) from CRS_Cross, deleted
57>          where CRS_Cross._StrainHO_key = deleted._Strain_key) > 0
58> begin
59>         rollback transaction
60>         raiserror 99999 "Strain is referenced in Cross Record(s)"
61>     return
62> end
63>  
64> if (select count(CRS_Cross._StrainHT_key) from CRS_Cross, deleted
65>          where CRS_Cross._StrainHT_key = deleted._Strain_key) > 0
66> begin
67>         rollback transaction
68>         raiserror 99999 "Strain is referenced in Cross Record(s)"
69>     return
70> end
71>  
72> if (select count(GXD_Genotype._Strain_key) from GXD_Genotype, deleted
73>          where GXD_Genotype._Strain_key = deleted._Strain_key) > 0
74> begin
75>         rollback transaction
76>         raiserror 99999 "Strain is referenced in GXD Genotype Record(s)"
77>     return
78> end
79>  
1> 
2> drop trigger PRB_Tissue_Delete
1> 
2> create trigger PRB_Tissue_Delete
3> on PRB_Tissue
4> for delete
5> as
6> 
7> /* Disallow deletion if Tissue is referenced elsewhere */
8> 
9> if (select count(PRB_Source._Tissue_key) from PRB_Source, deleted
10>     where PRB_Source._Tissue_key = deleted._Tissue_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Tissue is referenced in Probe Library Record(s)"
14>     return
15> end
16>  
1> 
2> drop trigger PRB_Vector_Types_Delete
1> 
2> create trigger PRB_Vector_Types_Delete
3> on PRB_Vector_Types
4> for delete
5> as
6> 
7> /* Disallow deletion if Vector_Types is referenced elsewhere */
8> 
9> if (select count(PRB_Probe._Vector_key) from PRB_Probe, deleted
10>     where PRB_Probe._Vector_key = deleted._Vector_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Vector Type is referenced in Probe Record(s)"
14>     return
15> end
16>  
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop trigger RI_RISet_Update
1> 
2> create trigger RI_RISet_Update
3> on RI_RISet
4> for update
5> as
6> 
7> /* Update origin, designation, abbreviation values in individual */
8> /* experiment records whenever the "master" RI record is changed. */
9> /* The fields in the MLD_RI table are actually obsolete and should */
10> /* be removed from this table. */
11> 
12> update MLD_RI
13> set origin = inserted.origin, 
14>     designation = inserted.designation,
15>     abbrev1 = inserted.abbrev1,
16>     abbrev2 = inserted.abbrev2
17> from MLD_RI, inserted
18> where MLD_RI._RISet_key = inserted._RISet_key
19> 
1> 
2> drop trigger RI_RISet_Delete
1> 
2> create trigger RI_RISet_Delete
3> on RI_RISet
4> for delete
5> as
6> 
7> /* Disallow deletion if RI Set is referenced elsewhere */
8> 
9> if (select count(*) from MLD_RI, deleted
10>     where MLD_RI._RISet_key = deleted._RISet_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "RI is referenced in MLDP Record(s)"
14>     return
15> end
16> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure ACC_resetMax
1> 
2> create procedure ACC_resetMax
3>   @objectKey int,
4>   @mgiType varchar(80),
5>   @prefixPart varchar(20) = "MGI:"
6> as
7> 
8> /* If deleting object which is using the maxNumericPart 
9>    from ACC_AccessionMax, then reset the maxNumericPart
10>    so there aren't so many holes.  During withdrawals,
11>    new Marker symbols may not receive MGI accession numbers,
12>    but the MRK_Marker insert trigger will always insert one
13> */
14> 
15> declare @numericPart int
16> select @numericPart = a.numericPart 
17> from ACC_Accession a, ACC_MGIType m
18> where a._Object_key = @objectKey
19> and a.prefixPart = @prefixPart
20> and a._MGIType_key = m._MGIType_key
21> and m.name = @mgiType
22> 
23> if (select maxNumericPart from ACC_AccessionMax where prefixPart = @prefixPart) = @numericPart
24> begin
25>     update ACC_AccessionMax
26>     set maxNumericPart = maxNumericPart - 1
27>     where prefixPart = @prefixPart
28> end
29> 
1> 
2> grant execute on ACC_resetMax to progs
1> 
2> grant execute on ACC_resetMax to editors
1> 
2> drop procedure ACC_findMax
1> 
2> create procedure ACC_findMax
3>   @prefixPart varchar(20) = "MGI:"
4> as
5> 
6> /* Return maxNumericPart for given prefixPart */
7> 
8> select maxNumericPart
9> from ACC_AccessionMax
10> where prefixPart = @prefixPart
1> 
2> grant execute on ACC_findMax to progs
1> 
2> grant execute on ACC_findMax to editors
1> 
2> grant execute on ACC_findMax to public
1> 
2> drop procedure ACC_assignMGI
1> 
2> create procedure ACC_assignMGI
3>   @objectKey int,
4>   @mgiType varchar(80),
5>   @prefixPart varchar(20) = "MGI:",
6>   @nextMGI int = -1,
7>   @preferred int = 1
8> as
9> 
10> /* Assign MGI or J accession number
11>    Allow override of J accession number
12>    Increment ACC_AccessionMax.maxNumericPart
13> */
14> 
15> declare @nextACC int
16> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
17> 
18> declare @mgiTypeKey int
19> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
20> 
21> if @nextMGI = -1
22> begin
23>     select @nextMGI = maxNumericPart + 1 
24>     from ACC_AccessionMax where prefixPart = @prefixPart
25> end
26> else if @prefixPart != "J:"
27> begin
28>     rollback transaction
29>     raiserror 99999 "Cannot override generation of MGI accession number"
30>     return
31> end
32> 
33> declare @accID varchar(30)
34> select @accID = @prefixPart + convert(varchar(20), @nextMGI)
35> 
36> insert into ACC_Accession 
37> (_Accession_key, accID, prefixPart, numericPart, 
38> _LogicalDB_key, _Object_key, _MGIType_key, preferred)
39> values(@nextACC, @accID, @prefixPart, @nextMGI, 1, @objectKey, @mgiTypeKey, @preferred)
40> 
41> if (select maxNumericPart from ACC_AccessionMax
42>     where prefixPart = @prefixPart) <= @nextMGI
43> begin
44>     update ACC_AccessionMax 
45>     set maxNumericPart = @nextMGI 
46>     where prefixPart = @prefixPart
47> end
48> 
1> 
2> grant execute on ACC_assignMGI to progs
1> 
2> grant execute on ACC_assignMGI to editors
1> 
2> drop procedure ACC_assignJ
1> 
2> create procedure ACC_assignJ
3>   @objectKey int,
4>   @nextMGI int = -1
5> as
6> 
7> if @nextMGI != -1
8> begin
9>      declare @exists int
10>     select @exists = count(*) from BIB_Acc_View
11>                where prefixPart = "J:" and 
12>            numericPart = @nextMGI
13>     if @exists > 0
14>     begin
15>             rollback transaction
16>             raiserror 99999 "This J Number is already in use"
17>             return
18>     end
19> end
20> 
21> exec ACC_assignMGI @objectKey, "Reference", "J:", @nextMGI
22> 
1> 
2> grant execute on ACC_assignJ to progs
1> 
2> grant execute on ACC_assignJ to editors
1> 
2> drop procedure ACCRef_insert
1>  
2> create procedure ACCRef_insert
3>   @accKey int,
4>   @refsKey int
5> as
6>  
7> /* Insert record into ACC_AccessionReference table */
8> 
9> insert into ACC_AccessionReference
10> (_Accession_key, _Refs_key)
11> values(@accKey, @refsKey)
12> 
1>  
2> grant execute on ACCRef_insert to progs
1>  
2> grant execute on ACCRef_insert to editors
1>  
2> drop procedure ACC_insert
1>  
2> create procedure ACC_insert
3>   @objectKey int,
4>   @accID varchar(30),
5>   @logicalDB int,
6>   @mgiType varchar(80),
7>   @refsKey int = -1,
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* Insert record into master Accession table. */
13> /* If reference is given, insert record into Accession Reference table. */
14> 
15> if @accID is null
16>     return
17> 
18> declare @nextACC int
19> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
20>  
21> declare @mgiTypeKey int
22> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
23>  
24> declare @prefixPart varchar(20)
25> declare @numericPart int
26> exec ACC_split @accID, @prefixPart out, @numericPart out
27>                                                   
28> insert into ACC_Accession
29> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
30> values(@nextACC, @accID, @prefixPart, @numericPart, @logicalDB, @objectKey, @mgiTypeKey, @private, @preferred)
31> 
32> if @refsKey != -1
33> begin
34>     exec ACCRef_insert @nextACC, @refsKey
35> end
36> 
1>  
2> grant execute on ACC_insert to progs
1>  
2> grant execute on ACC_insert to editors
1>  
2> drop procedure ACC_insert_bySpecies
1>  
2> create procedure ACC_insert_bySpecies
3>   @objectKey int,
4>   @accID varchar(30),
5>   @speciesKey int
6> as
7>  
8> /* Insert record into master Accession table for a given species */
9> 
10> if @accID is null
11>     return
12> 
13> declare @logicalDBKey int
14> select @logicalDBKey = _LogicalDB_key from ACC_LogicalDB 
15> where _Species_key = @speciesKey
16>  
17> declare @private int
18> select @private = 0
19> 
20> exec ACC_insert @objectKey, @accID, @logicalDBKey, "Marker", -1, 1, @private
21>  
1>  
2> grant execute on ACC_insert_bySpecies to progs
1>  
2> grant execute on ACC_insert_bySpecies to editors
1>  
2> drop procedure ACCRef_process
1>  
2> create procedure ACCRef_process
3>   @objectKey int,
4>   @refsKey int,
5>   @accID varchar(30),
6>   @logicalDB int,
7>   @mgiType varchar(80)
8> as
9>  
10> /* If the Object/Acc ID pair already exists, then use that _Accession_key */
11> /* and simply insert a new ACC_AccessionReference record (ACCRef_insert) */
12> /* Else, create a new ACC_Accession and ACC_AccessionReference record (ACC_insert) */
13> 
14> declare @accKey integer
15> select @accKey = a._Accession_key 
16> from ACC_Accession a, ACC_MGIType m
17> where accID = @accID
18> and a._Object_key = @objectKey
19> and a._MGIType_key = m._MGIType_key
20> and m.name = @mgiType
21> and a._LogicalDB_key = @logicalDB
22> 
23> if @accKey is not null
24>     exec ACCRef_insert @accKey, @refsKey
25> else
26>     exec ACC_insert @objectKey, @accID, @logicalDB, @mgiType, @refsKey
27> 
1>  
2> grant execute on ACCRef_process to progs
1>  
2> grant execute on ACCRef_process to editors
1>  
2> drop procedure ACC_update
1>  
2> create procedure ACC_update
3>   @accKey int,
4>   @accID varchar(30),
5>   @origRefsKey int = -1,
6>   @refsKey int = -1
7> as
8>  
9> /* Update the Accession record for a given Accession key */
10> 
11> if @accID is null
12> begin
13>     exec ACC_delete_byAccKey @accKey
14> end
15> else
16> begin
17>     declare @prefixPart varchar(20)
18>     declare @numericPart int
19>     exec ACC_split @accID, @prefixPart out, @numericPart out
20>                                                   
21>     if (@prefixPart = "J:" or substring(@prefixPart,1,4) = "MGD-")
22>     begin
23>             if (select count(*) from ACC_Accession
24>                 where numericPart = @numericPart and
25>                       prefixPart = @prefixPart) >= 1
26>             begin
27>                     rollback transaction
28>                     raiserror 99999 "Duplicate MGI Accession Number"
29>                     return
30>             end
31>     end
32> 
33>     update ACC_Accession
34>     set accID = @accID, 
35>             prefixPart = @prefixPart, 
36>             numericPart = @numericPart,
37>             modification_date = getdate()
38>     where _Accession_key = @accKey
39> 
40>     if @refsKey > 0
41>     begin
42>             update ACC_AccessionReference
43>             set _Refs_key = @refsKey
44>             where _Accession_key = @accKey and
45>                   _Refs_key = @origRefsKey
46>     end
47> end
48> 
1>  
2> grant execute on ACC_update to progs
1>  
2> grant execute on ACC_update to editors
1>  
2> drop procedure ACC_delete_byObject
1> 
2> create procedure ACC_delete_byObject
3>   @objectKey int,
4>   @mgiType varchar(80)
5> as
6> 
7> /* May have to reset the MGI or J: Max part */
8> 
9> exec ACC_resetMax @objectKey, @mgiType
10> exec ACC_resetMax @objectKey, @mgiType, "J:"
11> 
12> /* Delete all ACC_Accession/ACC_AccessionReference records for a given Object */
13> 
14> delete ACC_AccessionReference 
15> from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m
16> where a._Object_key = @objectKey
17> and a._MGIType_key = m._MGIType_key
18> and m.name = @mgiType
19> and a._Accession_key = ar._Accession_key
20> 
21> delete ACC_Accession 
22> from ACC_Accession a, ACC_MGIType m
23> where a._Object_key = @objectKey 
24> and a._MGIType_key = m._MGIType_key
25> and m.name = @mgiType
26> 
1>  
2> grant execute on ACC_delete_byObject to progs
1>  
2> grant execute on ACC_delete_byObject to editors
1>  
2> drop procedure ACC_delete_byAccKey
1> 
2> create procedure ACC_delete_byAccKey
3>   @accKey int,
4>   @refsKey int = -1
5> as
6> 
7> /* Delete ACC_Accession/ACC_AccessonReference records for a given _Accession_key */
8> 
9> if @refsKey = -1
10> begin
11>     delete ACC_Accession where _Accession_key = @accKey
12>     delete ACC_AccessionReference where _Accession_key = @accKey
13> end
14> else
15> begin
16> 
17>     delete ACC_AccessionReference 
18>     where _Accession_key = @accKey
19>     and _Refs_key = @refsKey
20> end
21> 
1>  
2> grant execute on ACC_delete_byAccKey to progs
1>  
2> grant execute on ACC_delete_byAccKey to editors
1>  
2> drop procedure ACC_delete_byAccRef
1> 
2> create procedure ACC_delete_byAccRef
3>   @objectKey int,
4>   @refsKey int,
5>   @mgiType varchar(80) = "Segment"
6> as
7> 
8> /* Delete all ACC_AccessonReference records for a given Object/Reference */
9> 
10> delete ACC_AccessionReference 
11> from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m
12> where a._Object_key = @objectKey
13> and a._MGIType_key = m._MGIType_key
14> and m.name = @mgiType
15> and a._Accession_key = ar._Accession_key
16> and ar._Refs_key = @refsKey
17>  
1>  
2> grant execute on ACC_delete_byAccRef to progs
1>  
2> grant execute on ACC_delete_byAccRef to editors
1>  
2> /* 1> declare @prefixPart varchar(20) */
3> /* 2> declare @numericPart int */
4> /* 3> exec ACC_split "MGI:12345", @prefixPart out, @numericPart out */
5> /* 4> go */
6> /* (return status = 0) */
7> /* Return parameters: */
8> /* ---- -----------  */
9> /* MGI:       12345  */
10> 
11> drop procedure ACC_split
1> 
2> create procedure ACC_split
3>   @accID varchar(20),
4>   @prefixPart varchar(20) out,
5>   @numericPart integer out
6> as
7> 
8> declare @temp varchar(20) 
9> declare @suffix varchar(20)
10> declare @acclen integer
11> declare @idx integer
12> 
13> select @acclen = char_length(@accID)
14> select @temp = reverse(@accID)
15> select @idx  = patindex("%[^0-9]%",@temp)
16> 
17> /* If @idx = 0, then no prefix */
18> 
19> if @idx = 0
20> begin
21>   select @numericPart = convert(integer, @accID)
22>   select @prefixPart = NULL
23> end
24> 
25> else
26> 
27> begin
28>   select @prefixPart = reverse(substring(@temp,@idx,@acclen-@idx+1))
29>   select @suffix = substring(@accID,
30>                              char_length(@prefixPart)+1,
31>                              @acclen - char_length(@prefixPart))
32> 
33>   if @suffix is not NULL
34>      select @numericPart = convert(integer, @suffix)
35>   else
36>      select @numericPart = NULL
37> end
38> 
1> 
2> grant execute on ACC_split to progs
1>  
2> grant execute on ACC_split to editors
1>  
2> grant execute on ACC_split to public
1>  
2> drop procedure ACC_fetch_byLogical
1>  
2> create procedure ACC_fetch_byLogical
3>   @objectKey integer,
4>   @mgiType varchar(80),
5>   @logicalDB varchar(80) = "MGI"
6> as
7>  
8> select a.accID, a.prefixPart, a.numericPart
9> from ACC_Accession a, ACC_MGIType m, ACC_LogicalDB l
10> where a._Object_key = @objectKey
11> and a._MGIType_key = m._MGIType_key
12> and m.name = @mgiType
13> and a._LogicalDB_key = l._LogicalDB_key
14> and l.name = @logicalDB
15> 
1>  
2> grant execute on ACC_fetch_byLogical to progs
1>  
2> grant execute on ACC_fetch_byLogical to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure BIB_byJnum
1> 
2> create procedure BIB_byJnum
3>   @jnum      integer
4> as
5> 
6> /* Selects _Refs_key and short citation for given */
7> /* numeric J: (ex. BIB_byJnum 12345) */
8> 
9> select b._Refs_key, b.short_citation 
10> from BIB_View b, BIB_Acc_View ba
11> where ba.numericPart = @jnum
12> and ba.prefixPart = "J:"
13> and ba._Object_key = b._Refs_key
1> 
2> grant execute on BIB_byJnum to progs
1> 
2> grant execute on BIB_byJnum to public
1> 
2> drop procedure BIB_HMD_Exists
1> 
2> create procedure BIB_HMD_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of Homology records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from HMD_Homology where _Refs_key = @key
10> 
1> 
2> grant execute on BIB_HMD_Exists to public
1> 
2> drop procedure BIB_MLC_Exists
1> 
2> create procedure BIB_MLC_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of MLC records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from MLC_Reference where _Refs_key = @key
10> union
11> select count(*) from MLC_Reference_edit where _Refs_key = @key
12> 
1> 
2> grant execute on BIB_MLC_Exists to public
1> 
2> drop procedure BIB_MLD_Exists
1> 
2> create procedure BIB_MLD_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of Mapping records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from MLD_Marker where _Refs_key = @key
10> 
1> 
2> grant execute on BIB_MLD_Exists to public
1> 
2> drop procedure BIB_PRB_Exists
1> 
2> create procedure BIB_PRB_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of Molecular Segment records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from PRB_Reference where _Refs_key = @key
10> 
1> 
2> grant execute on BIB_PRB_Exists to public
1> 
2> drop procedure BIB_GXD_Exists
1> 
2> create procedure BIB_GXD_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of GXD index records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from GXD_Index where _Refs_key = @key
10> union
11> select count(*) from GXD_Assay where _Refs_key = @key
12> 
1> 
2> grant execute on BIB_GXD_Exists to public
1> 
2> drop procedure BIB_getYear
1> 
2> create procedure BIB_getYear
3>   @dateStr varchar(30)
4> as
5> 
6> /* Given input string of a date, split out the 4-digit year */
7> 
8> declare @year integer
9> declare @idx integer
10>  
11> select @idx = patindex("%[0-9][0-9][0-9][0-9]%", @dateStr)
12>  
13> if @idx = 0
14> begin
15>         select @year = NULL
16> end
17> else
18> begin
19>         select @year = convert(int, substring(@dateStr, @idx, 4))
20> end
21>  
22> select @year
23> 
1> 
2> grant execute on BIB_getYear to progs
1>  
2> grant execute on BIB_getYear to editors
1>  
2> grant execute on BIB_getYear to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure GXD_loadCacheByAssay
1> 
2> create procedure GXD_loadCacheByAssay
3>   @assayKey int
4> as
5> 
6> /*
7>  * Load the GXD_Expression (cache) table for the given Assay
8>  * Should be called after any modification to any table within
9>  * the GXD_Assay hierarchy.
10>  */
11> 
12> /* Delete any pre-existing cache results for given assay */
13> 
14> delete from GXD_Expression where _Assay_key = @assayKey
15> 
16> /* Retrieve values from GXD_Assay Table for given Assay */
17> 
18> declare @assayTypeKey int   /* Assay Type Key */
19> declare @markerKey int              /* Marker Key */
20> declare @isGelAssay int             /* Is Assay Type a Gel Assay? */
21> 
22> select @assayTypeKey = a._AssayType_key,
23>        @markerKey = a._Marker_key,
24>        @isGelAssay = t.isGelAssay
25> from GXD_Assay a, GXD_AssayType t
26> where a._Assay_key = @assayKey
27> and a._AssayType_key = t._AssayType_key
28> 
29> /* Variables to hold values needed for cache table from Gel/InSitu Results */
30> 
31> declare @laneKey int
32> declare @specimenKey int
33> declare @resultKey int
34> declare @structureKey int
35> declare @genotypeKey int
36> declare @controlKey int
37> declare @age varchar(50)
38> declare @ageMin float
39> declare @ageMax float
40> 
41> declare @isExpressed int    /* was any expression detected? */
42> 
43> /*
44>  * If Assay is a Gel:
45>  *   For each Gel Lane:
46>  *     If Gel Lane is not a Control:
47>  *       If any Gel Bands in the Gel Lane have strength != "Absent":
48>  *         expressed = yes
49>  *       Else:
50>  *         expressed = no
51>  *       For each Structure associated with Gel Lane:
52>  *     Insert into cache table
53>  * Else If Assay is InSitu:
54>  *   For each Specimen:
55>  *     For each Specimen Result:
56>  *       For each Structure associated with Result:
57>  *         If any Result has strength != "Absent" and != "Not Applicable":
58>  *           expressed = yes
59>  *         Else:
60>  *           expressed = no
61>  *     Insert into cache table
62>  */
63> 
64> /* If Assay is a Gel */
65> 
66> if (@isGelAssay = 1)
67> begin
68> 
69>   declare lane_cursor cursor for
70>   select _GelLane_key, _Genotype_key, _GelControl_key, age, ageMin, ageMax
71>   from GXD_GelLane
72>   where _Assay_key = @assayKey
73>   for read only
74>  
75>   open lane_cursor
76>   fetch lane_cursor into @laneKey, @genotypeKey, @controlKey, @age, @ageMin, @ageMax
77>  
78>   /* For each Gel Lane */
79> 
80>   while (@@sqlstatus = 0)
81>   begin
82> 
83>     /* If Gel Lane is not a Control (control = No) */
84> 
85>     if (@controlKey = 1)
86>     begin
87> 
88>       /* If any Gel Bands in the Gel Lane have strength != "Absent":
89>        *   expressed = yes
90>        * Else:
91>        *   expressed = no
92>       */
93> 
94>       if (select count(b._GelBand_key) 
95>       from GXD_GelBand b, GXD_GelLane l, GXD_Strength s
96>       where l._Assay_key = @assayKey
97>       and l._GelLane_key = @laneKey
98>       and l._GelLane_key = b._GelLane_key
99>       and b._Strength_key = s._Strength_key
100>      and s.strength != "Absent") > 0
101>       begin
102>    select @isExpressed = 1
103>       end
104>       else
105>       begin
106>    select @isExpressed = 0
107>       end
108> 
109>       declare structure_cursor cursor for
110>       select _Structure_key from GXD_GelLaneStructure where _GelLane_key = @laneKey
111>       for read only
112> 
113>       open structure_cursor
114>       fetch structure_cursor into @structureKey
115> 
116>       /* For each Structure associated with Gel Lane */
117> 
118>       while (@@sqlstatus = 0)
119>       begin
120> 
121>         /* Insert into cache table */
122> 
123>    insert GXD_Expression 
124>         select max(_Expression_key) + 1, 
125>           @assayKey, @assayTypeKey, @genotypeKey, @markerKey, @structureKey,
126>           @isExpressed, @age, @ageMin, @ageMax, getdate(), getdate()
127>    from GXD_Expression
128> 
129>         fetch structure_cursor into @structureKey
130>       end
131>       close structure_cursor
132>       deallocate cursor structure_cursor
133>     end
134>     fetch lane_cursor into @laneKey, @genotypeKey, @controlKey, @age, @ageMin, @ageMax
135>   end
136>  
137>   close lane_cursor
138>   deallocate cursor lane_cursor
139> end
140> 
141> /* If Assay is a InSitu */
142> 
143> else
144> begin
145>   declare specimen_cursor cursor for
146>   select _Specimen_key, _Genotype_key, age, ageMin, ageMax
147>   from GXD_Specimen
148>   where _Assay_key = @assayKey
149>   for read only
150> 
151>   open specimen_cursor
152>   fetch specimen_cursor into @specimenKey, @genotypeKey, @age, @ageMin, @ageMax
153> 
154>   /* For each Specimen */
155> 
156>   while (@@sqlstatus = 0)
157>   begin
158>     declare result_cursor cursor for
159>     select _Result_key
160>     from GXD_InSituResult
161>     where _Specimen_key = @specimenKey
162>     for read only
163> 
164>     open result_cursor
165>     fetch result_cursor into @resultKey
166> 
167>     /* For each Specimen Result */
168> 
169>     while (@@sqlstatus = 0)
170>     begin
171> 
172>       /* If Result has strength != "Absent" and != "Not Applicable":
173>        *   expressed = yes
174>        * Else:
175>        *   expressed = no
176>       */
177> 
178>       if (select count(r._Strength_key)
179>      from GXD_InSituResult r, GXD_Strength s
180>      where r._Result_key = @resultKey
181>      and r._Strength_key = s._Strength_key
182>      and s.strength != "Absent"
183>      and s.strength != "Not Applicable") = 1
184>       begin
185>    select @isExpressed = 1
186>       end
187>       else
188>       begin
189>    select @isExpressed = 0
190>       end
191> 
192>       declare structure_cursor cursor for
193>       select _Structure_key
194>       from GXD_ISResultStructure
195>       where _Result_key = @resultKey
196>       for read only
197> 
198>       open structure_cursor
199>       fetch structure_cursor into @structureKey
200> 
201>       /* For each Structure associated with a Result */
202> 
203>       while (@@sqlstatus = 0)
204>       begin
205> 
206>         /* Insert into cache table */
207> 
208>    insert GXD_Expression 
209>         select max(_Expression_key) + 1, 
210>           @assayKey, @assayTypeKey, @genotypeKey, @markerKey, @structureKey,
211>           @isExpressed, @age, @ageMin, @ageMax, getdate(), getdate()
212>    from GXD_Expression
213> 
214>         fetch structure_cursor into @structureKey
215>       end
216>       close structure_cursor
217>       deallocate cursor structure_cursor
218> 
219>       /* Retrieve next Result */
220> 
221>       fetch result_cursor into @resultKey
222>     end
223> 
224>     close result_cursor
225>     deallocate cursor result_cursor
226> 
227>     /* Retrieve next Specimen */
228> 
229>     fetch specimen_cursor into @specimenKey, @genotypeKey, @age, @ageMin, @ageMax
230>   end
231> 
232>   close specimen_cursor
233>   deallocate cursor specimen_cursor
234> end
235>  
1> 
2> grant execute on GXD_loadCacheByAssay to progs
1> 
2> grant execute on GXD_loadCacheByAssay to editors
1> 
2> drop procedure GXD_loadCacheAll
1> 
2> create procedure GXD_loadCacheAll
3> as
4> 
5> /*
6>  * Load the GXD_Expression (cache) table for all Assays
7>  */
8> 
9> declare @assaykey int
10> 
11> declare assay_cursor cursor for
12> select _Assay_key from GXD_Assay
13> for read only
14>  
15> open assay_cursor
16> fetch assay_cursor into @assaykey
17> 
18> while (@@sqlstatus = 0)
19> begin
20>   exec GXD_loadCacheByAssay @assayKey
21>   fetch assay_cursor into @assaykey
22> end
23> 
24> close assay_cursor
25> deallocate cursor assay_cursor
26> 
1> 
2> grant execute on GXD_loadCacheAll to progs
1> 
2> grant execute on GXD_loadCacheAll to editors
1> 
2> 
3> drop procedure IMG_setPDO
1> 
2> create procedure IMG_setPDO (
3>      @pixID int = NULL, 
4>      @xDim int, 
5>      @yDim int, 
6>      @image_key int
7> ) as 
8> /* If image_key is valid and a PIX foreign accession number
9>    doesnot already exist for the _Image_key and the PIX: accession
10>    ID doesnot already exist, the new ID is added to ACC_Accession
11>    and the x,y dim update the image record.
12>    ASSUMES:
13>    - _LogicalDB_key for "MGI Image Archive" is 19,
14>    - _MGIType_key for mgi Image objects is 9
15>    REQUIRES:
16>    - four integer inputs
17>    - _Image_key exists
18>    - _Image_key is not referenced by an existing PIX:#
19>    - PIX:# does not exist (referencing another _Image_key)
20> */
21> 
22> declare @accID varchar(80), @prefix varchar(4), @imageLDB int, @imageType int
23> 
24> select @prefix = 'PIX:', 
25>        @imageLDB = 19,
26>        @imageType = 9
27> 
28> if @pixID is NULL or @image_key is NULL or @xDim is NULL or @yDim is NULL
29>   BEGIN
30>     rollback transaction
31>     raiserror 99999 "All four arguments must be non-NULL."
32>     return
33>   END
34> else
35>     select @accID = @prefix + convert(varchar(10), @pixID)
36> 
37> /* ck for missing image rec */
38> if not exists (select 1 from IMG_Image where _Image_key = @image_key)
39>   BEGIN
40>     rollback transaction
41>     raiserror 99999 "%1! _Image_key does not exist.", @image_key
42>     return
43>   END
44> 
45> /* check that this PIX:# does not already exist */
46> if exists (select 1 from ACC_Accession 
47>    where accID = @accID and _MGIType_key = @imageType
48>    and _LogicalDB_key = @imageLDB 
49>    )
50>   BEGIN
51>     rollback transaction
52>     raiserror 99999 "%1! accession already exists.", @accID
53>     return
54>   END
55> 
56> /* check that image record is not referenced by another PIX:# */
57> if exists (select 1 from ACC_Accession
58>    where _Object_key = @image_key and prefixPart = @prefix
59>    and _LogicalDB_key = @imageLDB and _MGIType_key = @imageType
60>    )
61>   BEGIN
62>     rollback transaction
63>     raiserror 99999 "A PIX: accession already exists for _Image_key %1!.", @image_key
64>     return
65>   END
66> 
67> 
68> /* insert the new PIX: accession record */
69> exec ACC_insert @image_key, 
70>                             @accID, 
71>                             @imageLDB, 
72>                             "Image", 
73>                             -1, 
74>                             1, 
75>                             1
76> 
77> if @@error != 0
78>   BEGIN
79>     rollback transaction
80>     raiserror 99999 "ACC_insert failed."
81>     return  
82>   END
83> 
84> /* set the image dimensions */
85> update IMG_Image set xDim = @xDim, yDim = @yDim
86> where _Image_key = @image_key
87> 
88> if @@error != 0
89>   BEGIN
90>     rollback transaction
91>     raiserror 99999, "Update x,y Dimensions failed."
92>     return
93>   END
94> 
1> 
2> grant execute on IMG_setPDO to progs
1> 
2> grant execute on IMG_setPDO to editors
1> 
2> 
3> /* Structure table stored procs.
4>    Note that these must be executed from within 
5>    a transaction block for rollbacks to work correctly */
6> 
7> drop procedure GXD_SetStructDescPrintName 
1> 
2> create procedure 
3>     GXD_SetStructDescPrintName @structure_key int, @path VARCHAR(255)
4> as
5>        /* Sets the printName of a Structure and all of the descendents 
6>         * that depend on this Structure's printStop status (those descendents
7>         * that do not have printStop set to 1).
8>         *
9>         * definition <current_structure> : 
10>         *          Structure w/_Structure_key = @structure_key  
11>         *
12>         * @structure_key : Structure key of the <current_structure> (the 
13>         *                  structure that might need printName updated)
14>         * @path          : The inclusive path from an ancestor of 
15>         *                  <current_structure> with printStop set to 1. 
16>         *                  This path does not include the <current_structure>'s 
17>         *                  preferred name.
18>         */
19> 
20>        declare @current_prefname VARCHAR(255)
21> 
22>        /* get the preferred name of the current structure */ 
23>        select @current_prefname = sn.structure
24>        from GXD_Structure s, GXD_StructureName sn
25>        where s._Structure_key = @structure_key
26>        and sn._StructureName_key = s._StructureName_key
27> 
28>        /* grow the path using the prefname */
29>        declare @pathlength int
30>        select @pathlength = char_length(@path) + 1 +   /* +1 for ; */
31>                             char_length(@current_prefname)
32>        if @pathlength > 255 
33>        begin
34>             /* truncate the path with an ellipsis. Look for one */
35>             declare @ellipsis int 
36>             declare @numchars_to_remove int
37> 
38>             /* number of characters to remove from @path so we have room
39>                for the ellipsis, ';', and current_prefname */
40>             select @numchars_to_remove = @pathlength - 255 + 3
41> 
42>             select @ellipsis = charindex("...", @path)
43>             if @ellipsis = 0  /* then no ellipsis yet, add one */
44>               begin
45>                  select @path = substring(@path,1,255-@numchars_to_remove)
46>                                 + "..."
47>               end
48>             else
49>               begin
50>                  /* find the ellipsis, and remove text to the right of it */
51>                  select @path = substring(@path,@ellipsis + 3,255) 
52>               end
53>        end
54> 
55>        if char_length(rtrim(@path)) > 0
56>            select @path = rtrim(@path) + ";" + @current_prefname
57>        else
58>            select @path = @current_prefname
59> 
60>        /* update the current node's printName */
61> 
62>        update GXD_Structure
63>        set printName = @path
64>        where _Structure_key = @structure_key 
65> 
66>        if @@error != 0  /* then update failed */ 
67>        begin
68>             raiserror 99999 "GXD_SetStructDescPrintName: Update of printName failed"
69>             rollback transaction
70>             return
71>        end
72>     
73>        /* Now fixup immediate descendent's printNames */
74> 
75>        declare @dek int
76> 
77>        declare desc_cursor cursor 
78>        for select s._Structure_key
79>            from GXD_Structure s
80>            where s._Parent_key = @structure_key 
81>              and s.printStop = 0     /* if printStop is 1, we can ignore it */
82>       
83> 
84>       open desc_cursor
85>       fetch desc_cursor into @dek
86> 
87>       while (@@sqlstatus = 0)
88>       begin 
89>          exec GXD_SetStructDescPrintName @dek, @path
90>          if @@error != 0  /* transaction failed for some reason */
91>          begin
92>             rollback transaction  /* rollback and return */
93>             raiserror 99999 "GXD_SetStructDescPrintName: Recursive call failed"
94>             close desc_cursor
95>             return
96>          end
97>          fetch desc_cursor into @dek 
98>       end
99> 
100>       close desc_cursor
1> 
2> 
3> grant execute on GXD_SetStructDescPrintName to progs
1> 
2> grant execute on GXD_SetStructDescPrintName to editors
1> 
2> 
3> drop procedure GXD_ComputePrintNamesFrom
1> 
2> 
3> create procedure
4>     GXD_ComputePrintNamesFrom  @structure_key int = null
5> as
6>    /* Changes printName for node with _Structure_key = @structure_key,
7>     * and all of its descendents, as appropriate.
8>     *
9>     * uses GXD_SetStructDescPrintName to set descendent's printNames.
10>     */
11> 
12>    if @structure_key is null
13>    begin
14>           rollback transaction
15>           raiserror 99999 "GXD_ComputePrintNamesFrom: Structure key not provided"
16>           return
17>    end
18>    else
19>    begin
20>        declare @printStop bit
21>        declare @path VARCHAR(255)
22>        
23>        /* get the printStop of the specified structure */
24> 
25>        select @printStop = s.printStop
26>               from GXD_Structure s
27>               where s._Structure_key = @structure_key
28> 
29>        /* path to the current node */ 
30>        select @path = ""
31> 
32>        if @printStop = 0 
33>        begin
34>             /* we must determine the path by moving up the tree until
35>                we find an ancestor with a printStop set, accumulating
36>                the path.
37>              */
38>             declare @ansk int  /* ancestor structure key */
39>             declare @aprintStop bit
40>             declare @aprefname VARCHAR(255)
41> 
42>             declare ancest_cursor cursor
43>             for select c._Structure_key
44>                 from GXD_Structure s, GXD_StructureClosure c
45>                 where c._Descendent_key = @structure_key
46>                 and c._Structure_key = s._Structure_key
47>                 order by s.treeDepth desc 
48> 
49>             open ancest_cursor
50>             fetch ancest_cursor into @ansk
51> 
52>             while (@@sqlstatus = 0)
53>             begin
54>                /* we have an ancestor, find out its printStop status */
55>                select @aprintStop = s.printStop, @aprefname = sn.structure
56>                from GXD_Structure s, GXD_StructureName sn
57>                where s._Structure_key = @ansk 
58>                and s._StructureName_key = sn._StructureName_key
59>                   
60>                select @path = ltrim(rtrim(@aprefname)) + @path 
61> 
62>                if @aprintStop = 1   /* found a printStop set */
63>                   break
64>                else                 /* we need to go higher */ 
65>                   select @path = ";" + @path
66> 
67>                fetch ancest_cursor into @ansk  /* get another key */
68>             end
69> 
70>             close ancest_cursor
71>        end
72> 
73>        /* @path is now set appropriately, downto the current node,
74>           but not inclusive of it. Now, fixup all the descendents */ 
75>           
76>        begin transaction
77> 
78>        exec GXD_SetStructDescPrintName @structure_key, @path
79>        if @@error != 0
80>        begin
81>           rollback transaction
82>           raiserror 99999 "GXD_ComputePrintNamesFrom: call to GXD_SetStructDescPrintName failed"
83>           return
84>        end
85>        else
86>           commit transaction
87>    end
1>        
2> grant execute on GXD_ComputePrintNamesFrom to progs
1> 
2> grant execute on GXD_ComputePrintNamesFrom to editors
1> 
2> 
3> drop procedure GXD_SetPreferredName
1> 
2> create procedure GXD_SetPreferredName 
3>      @structure_key int = null, @name varchar(255) = null
4> as
5>    /* 
6>     * Sets the preferred name of the structure whose _Structure_key = 
7>     * @structure_key.  Deletes the StructureName that *was* the preferred
8>     * name iff the current preferred name is different from the one being
9>     * set. Modifies the GXD_Structure and GXD_StructureName
10>     * tables.  Fails if node is not MGI-added (edinburghkey != NULL).
11>     *
12>     * If a StructureName doesn't exist where _Structure_key = @structure_key
13>     * and @name = structure, then a new StructureName record 
14>     * is created with _Structure_key = @structure_key, and structure = @name. 
15>     *
16>     * The _StructureName_key attribute of the structure with _Structure_key = 
17>     * @structure_key is set to point to either the existing or newly-created
18>     * StructureName record.  
19>     *
20>     * Always sets modification_date to getdate(), even if a new structurename
21>     * isn't created.  The ADI relies on this behavior.
22>     *
23>     */
24>    
25>    if @structure_key is null
26>    begin
27>        rollback transaction
28>        raiserror 99999 "GXD_SetPreferredName: Structure key not provided"
29>        return
30>    end
31>     
32>    if @name is null
33>    begin
34>        rollback transaction
35>        raiserror 99999 "GXD_SetPreferredName: Name not provided"
36>        return
37>    end
38> 
39>    if (select edinburghkey 
40>        from GXD_Structure s
41>        where s._Structure_key = @structure_key) != NULL
42>    begin
43>        rollback transaction
44>        raiserror 99999 "GXD_SetPreferredName: Cannot set preferred name for non MGI-added structures"
45>        return
46>    end
47>   
48>    /* determine the current preferred name key */
49>    declare @cpnk integer       /* current structure name key */
50> 
51>    select @cpnk = sn._StructureName_key
52>    from GXD_Structure s, GXD_StructureName sn
53>    where s._Structure_key = @structure_key
54>    and s._Structure_key = sn._Structure_key
55>    and s._StructureName_key = sn._StructureName_key
56> 
57>    declare @ctsn integer 
58>    declare @different integer  /* set to true if our set name !=
59>                                   current preferred name */ 
60>    select @different = 0       /* assume we are changing the 
61>                                   preferred name to the *same* name */
62>  
63>    /* find out how many StructureName entries match our desired preferred
64>       name */
65>    select @ctsn = count(*) 
66>                   from GXD_StructureName
67>                   where _Structure_key = @structure_key
68>                   and structure = @name
69> 
70>    if @ctsn = 0  /* if none, then we must create the StructureName */ 
71>    begin         /* and delete the old one */
72>        select @different = 1  /* set delete flag for current pref. name */
73> 
74>        declare @snk integer
75> 
76>        /* insert the new StructureName */
77>        select @snk = max(_StructureName_key) + 1 from GXD_StructureName
78>        insert into GXD_StructureName (_StructureName_key, _Structure_key,
79>                                       structure, mgiAdded) 
80>        values(@snk, @structure_key, @name, 1)
81> 
82>        if @@error != 0  /* then insert failed */ 
83>        begin
84>             rollback transaction
85>             raiserror 99999 "Insert into GXD_StructureName failed"
86>             return
87>        end
88>       
89>        /* set ctsn to 1, as if the StructureName had been there all along */
90>        select @ctsn = 1
91>    end
92> 
93>    if @ctsn = 1 /* then update GXD_Structure to reference this name */
94>    begin
95>         update GXD_Structure 
96>                   set _StructureName_key = (
97>                       select _StructureName_key 
98>                       from GXD_StructureName
99>                       where _Structure_key = @structure_key
100>                       and structure = @name )
101>                   where _Structure_key = @structure_key
102> 
103>        if @@error != 0  /* then insert failed */ 
104>        begin
105>           rollback transaction
106>          raiserror 99999 "GXD_SetPreferredName: Update of _StructureName_key in GXD_Structure failed"
107>           return
108>        end
109>       
110>        /* we update the structurename's modification date, regardless */ 
111> 
112>        update GXD_StructureName
113>               set modification_date = getdate()
114>               where _StructureName_key = @cpnk
115> 
116>        if @@error != 0  /* then update failed */ 
117>        begin
118>           rollback transaction
119>          raiserror 99999 "GXD_SetPreferredName: Update of modification_date in GXD_Structure failed"
120>           return
121>        end
122> 
123>        /* delete the current structureName, referenced by the structure's
124>           _StructureName_key, if we have a new structureName to point to */
125> 
126>        if @different = 1
127>        begin
128>            delete from GXD_StructureName
129>            where _Structure_key = @structure_key 
130>            and _StructureName_key = @cpnk
131>        
132>            if @@error != 0  /* then insert failed */ 
133>            begin
134>               rollback transaction
135>              raiserror 99999 "GXD_SetPreferredName: Could not delete previous preferred name"
136>               return
137>            end
138>        end
139> 
140>        /* recompute printNames, since the Update trigger cannot without
141>           causing infinite recursive calls */
142> 
143>        exec GXD_ComputePrintNamesFrom @structure_key
144>        if @@error != 0  /* then insert failed */ 
145>        begin
146>           rollback transaction
147>          raiserror 99999 "GXD_SetPreferredName: Call to GXD_ComputePrintNamesFrom failed"
148>           return
149>        end
150>    end
151>    else  /* then greater than 1, an error */
152>    begin
153>      rollback transaction
154>      raiserror 99999 "GXD_SetPreferredName: Duplicate names for structure in GXD_StructureName"
155>      return        
156>    end
157>              
158> 
1> 
2> grant execute on GXD_SetPreferredName to progs
1> 
2> grant execute on GXD_SetPreferredName to editors
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure HMD_getChromosomes
1> 
2> create procedure HMD_getChromosomes
3>                 @_Species_key int = NULL
4> as
5> /*
6>  *   Procedure takes a species key and returns the ordered
7>  *   list of chromosomes.
8>  *
9>  *   DOW Jan 17, 1996
10>  */
11> select chromosome 
12> from MRK_Chromosome 
13> where _Species_key = @_Species_key 
14> order by sequenceNum
1> 
2> grant execute on HMD_getChromosomes to public
1> 
2> drop procedure HMD_getOxfordGrid
1> 
2> create procedure HMD_getOxfordGrid
3>                 @Species1 int = NULL,
4>                 @Species2 int = NULL
5> as
6> 
7> /* Return all Chromosome Pairs/Homology Classes involving Species 1 & Species 2 */
8> /* Include Chromosome UN. To exclude, add the following where clauses */
9> /*       m1.chromosome != 'UN' and   */
10> /*      m2.chromosome != 'UN'       */
11> 
12> select distinct c1 = m1.chromosome, c2 = m2.chromosome, h1._Class_key
13>                 from    MRK_Marker m1,
14>                         MRK_Marker m2,
15>                         HMD_Homology h1,
16>                         HMD_Homology h2,
17>                         HMD_Homology_Marker hm1,
18>                         HMD_Homology_Marker hm2
19>                 where   m1._Species_key = @Species1 and
20>                         m1._Marker_key = hm1._Marker_key and
21>                     hm1._Homology_key = h1._Homology_key and
22>                         h1._Class_key = h2._Class_key and
23>                     h2._Homology_key = hm2._Homology_key and
24>                         hm2._Marker_key = m2._Marker_key and
25>                         m2._Species_key = @Species2 
26> order by c1, c2
27>  
1> 
2> grant execute on HMD_getOxfordGrid to public
1>  
2> drop procedure HMD_hasHomology
1> 
2> create procedure HMD_hasHomology
3>                 @_Marker_key int = NULL,
4>                 @_Refs_key int = NULL
5> as
6> /*
7>  *   Procedure takes either a Marker key or a Ref key,
8>  *   and determines whether not a homology will exists.
9>  *   For a homology to be returned, for a _Class_key,
10>  *  there must be more than one marker.
11>  *
12>  *  DOW Jan 10, 1996
13>  */
14> declare @count int
15> declare @has_Homology int
16> create table #classes
17>         (_Class_key int)
18> 
19> /*
20>  *  has_Homology is the value to be returned.
21>  *  Default is "no homology" 
22>  */ 
23> select @has_Homology = 0
24> 
25> /*  Do with a query using a _Marker_key...  */
26> if (@_Marker_key != NULL and @_Refs_key = NULL)
27>         insert #classes
28>         select h._Class_key
29>         from HMD_Homology h, HMD_Homology_Marker m
30>         where m._Marker_key = @_Marker_key and
31>           m._Homology_key = h._Homology_key
32> /*  ...or a _Refs_key...    */
33> else if (@_Refs_key != NULL and @_Marker_key = NULL)
34>         insert #classes
35>         select _Class_key
36>         from HMD_Homology
37>         where _Refs_key = @_Refs_key
38> /*  ...but not both!!       */
39> else
40> begin
41>     print 'Cannot process with both _Refs_key AND _Marker_key!'
42>     select @has_Homology
43>     return 
44> end
45> 
46> /*
47>  *  Cursor simply does a count of distinct markers(species) in a class
48>  */
49> declare classCount cursor for
50> select count(distinct m._Marker_key)
51> from HMD_Homology h, HMD_Homology_Marker m, #classes c
52> where h._Class_key = c._Class_key
53>       and h._Homology_key = m._Homology_key
54> group by h._Class_key
55> for read only
56> 
57> open classCount
58> 
59> /*  Pull out classes, one by one... */
60> fetch classCount
61>         into @count
62> 
63> /*  Nothing here... bail out!       */
64> if (@@sqlstatus = 2)
65> begin
66>     print 'Nothing found'
67>     select @has_Homology
68>         return 
69> end
70> /*
71>  *  If cursor result is not empty, then process
72>  *  each row to determine if class has a homology
73>  *  including more than one species (marker).
74>  */
75> while (@@sqlstatus = 0)
76> begin
77>         if (@count > 1)
78> /*  There is a valid homology within this class.    */
79>                 select @has_Homology = 1
80> 
81> /*  Fetch next row. */
82>         fetch classCount
83>                 into @count
84> end
85> /*  This select will return the value of @has_Homology as a row of data */
86> select @has_Homology
87> 
88> close classCount
89> 
90> deallocate cursor classCount
1> 
2> grant execute on HMD_hasHomology to public
1>  
2> checkpoint
1> 
2> drop procedure HMD_updateClass
1> 
2> create procedure HMD_updateClass
3>   @_Class_key integer,
4>   @_Refs_key integer,
5>   @isNewClass integer = 1
6> as
7> 
8> /* Merge classes of Homologies which, due to a new Homology record */
9> /* should really be one class (due to transitivity nature of Homology) */
10> 
11> /* For each Class which exists which contains Markers from New Class... */
12> 
13> select _Class_key = @_Class_key
14> into #classes
15> union
16> select distinct h2._Class_key 
17> from HMD_Homology h1, HMD_Homology_Marker hm1, 
18>      HMD_Homology h2, HMD_Homology_Marker hm2
19> where h1._Class_key = @_Class_key and
20>       h1._Homology_key = hm1._Homology_key and
21>       hm1._Marker_key = hm2._Marker_key and
22>       hm2._Homology_key = h2._Homology_key and
23>       h2._Class_key != @_Class_key
24> 
25> /* Select all Species/Symbol pairs from the New Class */
26> 
27> select distinct hm._Marker_key, m._Species_key
28> into #markers
29> from #classes c, HMD_Homology h, HMD_Homology_Marker hm, MRK_Marker m
30> where c._Class_key = h._Class_key and
31>       h._Homology_key = hm._Homology_key and
32>       hm._Marker_key = m._Marker_key
33> 
34> declare @speciesKey integer
35> declare @dupspeciesKey integer
36> declare @do_update integer
37> select @do_update = 1
38> 
39> /* Fetch counts for Species/Symbol pairs */
40> 
41> declare classCount cursor for select _Species_key from #markers group by _Species_key having count(*) > 1
42> open classCount
43> fetch classCount into @speciesKey
44> 
45> while (@@sqlstatus = 0)
46> begin
47>     select @do_update = 0
48>     select @dupspeciesKey = @speciesKey
49>     fetch classCount into @speciesKey
50> end
51> 
52> close classCount
53> deallocate cursor classCount
54> 
55> if (@do_update = 1) /* Merge Classes */
56> begin
57>         update HMD_Homology
58>     set _Class_key = @_Class_key
59>     from #classes c, HMD_Homology h
60>     where c._Class_key = h._Class_key
61> 
62>     /* Return the @_Class_key:@_Refs_key */
63>     select convert(varchar(10), @_Class_key) + ':' + convert(varchar(10), @_Refs_key)
64> end
65> else
66> begin
67>     declare @species varchar(255)
68>     select @species = name from MRK_Species where _Species_key = @dupspeciesKey
69> 
70>     /* Return the @_Class_key:@_Refs_key */
71>     select convert(varchar(10), @_Class_key) + ':' + convert(varchar(10), @_Refs_key)
72> 
73>     /* If this is a new class record, then delete it if there is a conflict */
74>     if (@isNewClass = 1)
75>     begin
76>             delete from HMD_Class where _Class_key = @_Class_key
77>     end
78> 
79>     raiserror 99999 "Another Homology has been detected which conflicts with Species:  %1!", @species
80> 
81> end
82> 
1> 
2> grant execute on HMD_updateClass to progs
1> 
2> grant execute on HMD_updateClass to editors
1> 
2> checkpoint
1> 
2> drop procedure HMD_Cleanup
1> 
2> create procedure HMD_Cleanup
3>   @_Class_key integer,
4>   @_Homology_key integer
5> as
6> 
7> /* Clean up any orphan HMD_Class or HMD_Homology records after deletions */
8> 
9> if (select count(*) from HMD_Homology_Marker where _Homology_key = @_Homology_key) = 0
10> begin
11>     delete HMD_Homology where _Homology_key = @_Homology_key
12> end
13> 
14> if (select count(*) from HMD_Homology where _Class_key = @_Class_key) = 0
15> begin
16>     delete HMD_Class where _Class_key = @_Class_key
17> end
18> 
19> /* Delete all non-mouse, non-human Markers no longer referenced in Homology */
20> 
21> delete MRK_Marker from MRK_Marker m
22> where m._Species_key != 1 and m._Species_key != 2
23>       and not exists 
24>       (select h.* from HMD_Homology_Marker h where m._Marker_key = h._Marker_key)
25> 
1> 
2> grant execute on HMD_Cleanup to progs
1> 
2> grant execute on HMD_Cleanup to editors
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure MGI_Table_Column_Cleanup
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MGI_Table_Column_Cleanup', because it doesn't exist
in the system catalogs.
1> 
2> CREATE PROCEDURE MGI_Table_Column_Cleanup
3> /*
4> JCG: Jan. 7, 1999
5> This procedure attempts to get MGI_Tables and MGI_Columns in sync with
6> sysobjects and syscolumns
7> */
8> 
9> as
10> 
11> /* Make sure that an old temp table with this name doesn't exists */
12> if exists (select name from sysobjects
13>            where name = '#temp_add_table'
14>            and type = 'U')
15>    drop table #temp_add_table
16> 
17> /*
18> NEW TABLE ADDED TO SCHEMA
19> */
20> /* Find tables in sysobjects which are not in MGI_Tables and insert them
21> into a temp table */
22> SELECT
23> MGI_Tables._Table_id, sysobjects.name
24> into #temp_add_table
25> FROM
26> MGI_Tables MGI_Tables, sysobjects sysobjects
27> WHERE
28> MGI_Tables._Table_id =* sysobjects.id
29> AND
30> sysobjects.type='U'
31> ORDER BY
32> sysobjects.name
33> 
34> /* From the temp table, select only those values where the table name is not
35> found in MGI_Tables. */
36> insert into MGI_Tables
37> SELECT object_id(name), NULL, getDate(), getDate()
38> FROM
39> #temp_add_table
40> WHERE
41> _Table_id is NULL
42> 
43> /* Also, find the appropriate columns and put into MGI_Columns so
44> that MGI_Tables and MGI_Columns are in sync */
45> insert into MGI_Columns
46> SELECT object_id(t.name), colid, NULL, NULL, getDate(), getDate()
47> FROM
48> #temp_add_table t, syscolumns c
49> WHERE
50> _Table_id is NULL
51> AND
52> object_id(t.name) = id
53> 
54> if exists (select name from sysobjects
55>            where name = '#temp_add_table'
56>            and type = 'U')
57>    drop table #temp_add_table
58> 
59> /*
60> WHAT IF YOU BCP IN A TRUNCATED COLUMN LIST?
61> THIS SECTION ADDS COLUMN DEFINITIONS FOR TABLES THAT ARE IN MGI_TABLES
62> BUT NOT MGI_COLUMNS - SYNCS COLUMNS WITH TABLES
63> */
64> 
65> if exists (select name from sysobjects
66>            where name = '#temp_update_table'
67>            and type = 'U')
68>    drop table #temp_update_table
69> 
70> SELECT
71> MGI_Columns._Table_id, syscolumns.id, syscolumns.colid
72> into #temp_update_table
73> FROM
74> MGI_Columns MGI_Columns,
75> syscolumns syscolumns,
76> sysobjects sysobjects
77> WHERE
78> syscolumns.id *= MGI_Columns._Table_id
79> and
80> syscolumns.id = sysobjects.id
81> and
82> sysobjects.type = 'U'
83> 
84> insert into MGI_Columns
85> SELECT
86> id, colid, NULL, NULL, getDate(), getDate()
87> FROM
88> #temp_update_table
89> WHERE
90> _Table_id is NULL
91> 
92> if exists (select name from sysobjects
93>            where name = '#temp_update_table'
94>            and type = 'U')
95>    drop table #temp_update_table
96> 
97> /*
98> THIS SECTION DELETES TABLES DEFINITION WHEN A TABLE IS DELETED
99> */
100> 
101> /*Algorithm:
102> 
103> If table not found in sysobjects, delete from MGI_Tables and
104> remove all column entries. Do a join to find _Table_id with no id
105> */
106> 
107> DELETE from MGI_Tables
108> where _Table_id in
109> (select DISTINCT _Table_id
110> from
111> MGI_Tables t, sysobjects o
112> WHERE
113> _Table_id NOT in (select id from sysobjects where type = 'U'))
114> 
115> if exists (select name from sysobjects
116>            where name = '#temp_delete_table'
117>            and type = 'U')
118>    drop table #temp_delete_table
119> 
120> 
121> SELECT DISTINCT _Table_id, id
122> into #temp_delete_table
123> FROM
124> MGI_Columns, sysobjects
125> WHERE
126> _Table_id *= id
127> 
128> /* If there is an id in MGI_Columns which is not in syscolumns then delete its entri
129> es */
130> delete from MGI_Columns
131> WHERE
132> _Table_id in (select _Table_id from #temp_delete_table where id is NULL)
133> 
134> if exists (select name from sysobjects
135>            where name = '#temp_delete_table'
136>            and type = 'U')
137>    drop table #temp_delete_table
138> 
139> RETURN
1> 
2> grant execute on MGI_Table_Column_Cleanup to public
1> 
2> drop procedure MGI_resetSequenceNum
1> 
2> create procedure MGI_resetSequenceNum
3>   @table varchar(255),               /* Table Name */
4>   @key int                   /* Primary key */
5> as
6> 
7> /* Re-order the sequenceNum field so that they are 
8>    continuous and there are no gaps.
9> 
10>    ex. 1,2,5,6,7 would be reordered to 1,2,3,4,5
11> */
12> 
13> declare @pkey int   /* primary key of records to update */
14> declare @oldSeq int /* current sequence number */
15> declare @newSeq int /* new sequence number */
16> select @newSeq = 1
17>  
18> if (@table = "GXD_GelLane")
19> begin
20>   declare seq_cursor cursor for
21>   select _GelLane_key, sequenceNum
22>   from GXD_GelLane
23>   where _Assay_key = @key
24>   order by sequenceNum
25>   for read only
26> end
27> else if (@table = "GXD_GelRow")
28> begin
29>   declare seq_cursor cursor for
30>   select _GelRow_key, sequenceNum
31>   from GXD_GelRow
32>   where _Assay_key = @key
33>   order by sequenceNum
34>   for read only
35> end
36> else if (@table = "GXD_Specimen")
37> begin
38>   declare seq_cursor cursor for
39>   select _Specimen_key, sequenceNum
40>   from GXD_Specimen
41>   where _Assay_key = @key 
42>   order by sequenceNum 
43>   for read only
44> end
45> else if (@table = "GXD_InSituResult")
46> begin
47>   declare seq_cursor cursor for
48>   select _Result_key, sequenceNum
49>   from GXD_InSituResult
50>   where _Specimen_key = @key
51>   order by sequenceNum
52>   for read only
53> end
54> else if (@table = "MRK_History")
55> begin
56>   declare seq_cursor cursor for
57>   select _Marker_key, sequenceNum
58>   from MRK_History
59>   where _Marker_key = @key
60>   order by sequenceNum
61>   for read only
62> end
63> else if (@table = "MLD_Marker")
64> begin
65>   declare seq_cursor cursor for
66>   select _Refs_key, sequenceNum
67>   from MLD_Marker
68>   where _Refs_key = @key
69>   order by sequenceNum
70>   for read only
71> end
72> else if (@table = "MLD_Expt_Marker")
73> begin
74>   declare seq_cursor cursor for
75>   select _Expt_key, sequenceNum
76>   from MLD_Expt_Marker
77>   where _Expt_key = @key
78>   order by sequenceNum
79>   for read only
80> end
81> else if (@table = "MLD_MCDataList")
82> begin
83>   declare seq_cursor cursor for
84>   select _Expt_key, sequenceNum
85>   from MLD_MCDataList
86>   where _Expt_key = @key
87>   order by sequenceNum
88>   for read only
89> end
90> else if (@table = "MLD_MC2point")
91> begin
92>   declare seq_cursor cursor for
93>   select _Expt_key, sequenceNum
94>   from MLD_MC2point
95>   where _Expt_key = @key
96>   order by sequenceNum
97>   for read only
98> end
99> else if (@table = "MLD_RIData")
100> begin
101>   declare seq_cursor cursor for
102>   select _Expt_key, sequenceNum
103>   from MLD_RIData
104>   where _Expt_key = @key
105>   order by sequenceNum
106>   for read only
107> end
108> else if (@table = "MLD_RI2Point")
109> begin
110>   declare seq_cursor cursor for
111>   select _Expt_key, sequenceNum
112>   from MLD_RI2Point
113>   where _Expt_key = @key
114>   order by sequenceNum
115>   for read only
116> end
117> else if (@table = "MLD_FISH_Region")
118> begin
119>   declare seq_cursor cursor for
120>   select _Expt_key, sequenceNum
121>   from MLD_FISH_Region
122>   where _Expt_key = @key
123>   order by sequenceNum
124>   for read only
125> end
126> else if (@table = "MRK_Chromosome")
127> begin
128>   declare seq_cursor cursor for
129>   select _Species_key, sequenceNum
130>   from MRK_Chromosome
131>   where _Species_key = @key
132>   order by sequenceNum
133>   for read only
134> end
135> else if (@table = "MLD_Statistics")
136> begin
137>   declare seq_cursor cursor for
138>   select _Expt_key, sequenceNum
139>   from MLD_Statistics
140>   where _Expt_key = @key
141>   order by sequenceNum
142>   for read only
143> end
144> else
145> begin
146>   return
147> end
148> 
149> open seq_cursor
150> fetch seq_cursor into @pkey, @oldSeq
151>  
152> while (@@sqlstatus = 0)
153> begin
154>   if (@table = "GXD_GelLane")
155>   begin
156>     update GXD_GelLane set sequenceNum = @newSeq
157>       where _GelLane_key = @pkey
158>   end
159>   else if (@table = "GXD_GelRow")
160>   begin
161>     update GXD_GelRow set sequenceNum = @newSeq
162>       where _GelRow_key = @pkey
163>   end
164>   else if (@table = "GXD_Specimen")
165>   begin
166>     update GXD_Specimen set sequenceNum = @newSeq
167>       where _Specimen_key = @pkey
168>   end
169>   else if (@table = "GXD_InSituResult")
170>   begin
171>     update GXD_InSituResult set sequenceNum = @newSeq
172>       where _Result_key = @pkey
173>   end
174>   else if (@table = "MRK_History")
175>   begin
176>     update MRK_History set sequenceNum = @newSeq
177>       where _Marker_key = @pkey and sequenceNum = @oldSeq
178>   end
179>   else if (@table = "MLD_Marker")
180>   begin
181>     update MLD_Marker set sequenceNum = @newSeq
182>       where _Refs_key = @pkey and sequenceNum = @oldSeq
183>   end
184>   else if (@table = "MLD_Expt_Marker")
185>   begin
186>     update MLD_Expt_Marker set sequenceNum = @newSeq
187>       where _Expt_key = @pkey and sequenceNum = @oldSeq
188>   end
189>   else if (@table = "MLD_MCDataList")
190>   begin
191>     update MLD_MCDataList set sequenceNum = @newSeq
192>       where _Expt_key = @pkey and sequenceNum = @oldSeq
193>   end
194>   else if (@table = "MLD_MC2point")
195>   begin
196>     update MLD_MC2point set sequenceNum = @newSeq
197>       where _Expt_key = @pkey and sequenceNum = @oldSeq
198>   end
199>   else if (@table = "MLD_RIData")
200>   begin
201>     update MLD_RIData set sequenceNum = @newSeq
202>       where _Expt_key = @pkey and sequenceNum = @oldSeq
203>   end
204>   else if (@table = "MLD_RI2Point")
205>   begin
206>     update MLD_RI2Point set sequenceNum = @newSeq
207>       where _Expt_key = @pkey and sequenceNum = @oldSeq
208>   end
209>   else if (@table = "MLD_FISH_Region")
210>   begin
211>     update MLD_FISH_Region set sequenceNum = @newSeq
212>       where _Expt_key = @pkey and sequenceNum = @oldSeq
213>   end
214>   else if (@table = "MRK_Chromosome")
215>   begin
216>     update MRK_Chromosome set sequenceNum = @newSeq
217>       where _Species_key = @pkey and sequenceNum = @oldSeq
218>   end
219>   else if (@table = "MLD_Statistics")
220>   begin
221>     update MLD_Statistics set sequenceNum = @newSeq
222>       where _Expt_key = @pkey and sequenceNum = @oldSeq
223>   end
224>   select @newSeq = @newSeq + 1
225>   fetch seq_cursor into @pkey, @oldSeq
226> end
227>  
228> close seq_cursor
229> deallocate cursor seq_cursor
230>  
1> 
2> grant execute on MGI_resetSequenceNum to progs
1> 
2> grant execute on MGI_resetSequenceNum to editors
1> 
2> drop procedure GEN_rowcount
1>  
2> create procedure GEN_rowcount
3>   @table varchar(30)
4> as
5> 
6> select convert(char(10),rowcnt(MAX(doampg)))
7> from sysobjects o, sysindexes i
8> where o.name = @table
9> and o.id = i.id
1> 
2> grant execute on GEN_rowcount to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure Current_Symbol
1> 
2> create procedure Current_Symbol 
3>   @symbol varchar(25)
4> as
5> 
6> 
7> declare item cursor for
8>    select m._Marker_key, m.symbol 
9>    from MRK_Marker m 
10>    where m.symbol = @symbol
11>    and _Species_key = 1
12> 
13> declare @mk int
14> declare @sym varchar(25) 
15> open item 
16> 
17> while (@@sqlstatus = 0)
18> begin
19>    fetch item into @mk, @sym
20>    if (@@sqlstatus = 2) break
21>    select _Current_key = c._Current_key, 
22>           _Marker_key =  c._Marker_key,
23>           current_symbol = m.symbol, 
24>               symbol = @sym
25>    from MRK_Current c, MRK_Marker m
26>    where c._Current_key = m._Marker_key
27>    and m._Species_key = 1
28>    and c._Marker_key = @mk
29> end
30> 
31> close item
32>                     
1> 
2> grant execute on Current_Symbol to public
3> grant execute on Current_Symbol to progs
1> 
2> checkpoint
1> 
2> drop procedure MLC_transfer
1> 
2> create procedure MLC_transfer
3>     @_Marker_key int
4> as
5> /* This proc transfers rows with primary_key = @_Marker_key from the MLC 
6>  * edit tables to the Production MLC tables.  If the MLC_Text_edit table
7>  * does not contain a row with _Marker_key = @_Marker_key, then this is
8>  * a delete that will be propagated to the Production MLC tables.
9>  */
10> 
11> begin transaction
12> 
13> declare @doinsert bit
14> select @doinsert = 1  /* assume we are copying, not deleting */
15> 
16> 
17> /* determine if this is a copy or delete */
18> 
19> if (select count(*) 
20>     from MLC_Text_edit
21>     where _Marker_key = @_Marker_key) = 0
22> begin  /* then we must propagate a delete */
23>     select @doinsert = 0
24> end
25> 
26> 
27> /* make sure to set the textsize to avoid truncation during selects
28>    when copying data between MLC_Text_edit and MLC_Text */
29> 
30> set textsize 500000
31> 
32> /* MLC_Text */
33> 
34> /* delete the rows from the Production table that will be replaced
35>    with rows from the corresponding _edit table */ 
36> 
37> delete from MLC_Text where _Marker_key = @_Marker_key
38> if @@error != 0
39> begin
40>    rollback transaction
41>    raiserror 99999 "Delete from MLC_Text failed, mk = %1!", @_Marker_key
42>    return
43> end
44> 
45> if @doinsert = 1
46> begin
47>    /* insert the updated rows into production tables */ 
48>    insert MLC_Text 
49>    select * from MLC_Text_edit where _Marker_key = @_Marker_key
50> 
51>    if @@error != 0
52>    begin
53>       rollback transaction
54>       raiserror 99999 "Insert into MLC_Text failed, mk = %1!", @_Marker_key
55>       return
56>    end
57> end
58> 
59> /* MLC_Marker */
60> 
61> /* delete the rows from the Production table that will be replaced
62>    with rows from the corresponding _edit table */ 
63> 
64> delete from MLC_Marker where _Marker_key = @_Marker_key
65> if @@error != 0
66> begin
67>    rollback transaction
68>    raiserror 99999 "Delete from MLC_Marker failed, mk = %1!", @_Marker_key
69>    return
70> end
71> 
72> if @doinsert = 1
73> begin
74>    /* insert the updated rows into production tables */ 
75>    insert MLC_Marker 
76>    select * from MLC_Marker_edit where _Marker_key = @_Marker_key
77> 
78>    if @@error != 0
79>    begin
80>       rollback transaction
81>       raiserror 99999 "Insert into MLC_Marker failed, mk = %1!", @_Marker_key
82>       return
83>    end
84> end
85> 
86> 
87> /* MLC_Reference */
88> 
89> /* delete the rows from the Production table that will be replaced
90>    with rows from the corresponding _edit table */ 
91> 
92> delete from MLC_Reference where _Marker_key = @_Marker_key
93> if @@error != 0
94> begin
95>    rollback transaction
96>    raiserror 99999 "Delete from MLC_Reference failed, mk = %1!", @_Marker_key
97>    return
98> end
99> 
100> if @doinsert = 1
101> begin
102>    /* insert the updated rows into production tables */ 
103>    insert MLC_Reference 
104>    select * from MLC_Reference_edit where _Marker_key = @_Marker_key
105> 
106>    if @@error != 0
107>    begin
108>       rollback transaction
109>       raiserror 99999 "Insert into MLC_Reference failed, mk = %1!", @_Marker_key
110>       return
111>    end
112> end
113> 
114> commit transaction
1> 
2> grant execute on MLC_transfer to progs
3> grant execute on MLC_transfer to apd, cml, djr, jblake, plg, rmb
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure MRK_convertAllele
1>  
2> create procedure MRK_convertAllele
3>   @oldKey integer,
4>   @new_symbol varchar(25) = null,
5>   @old_symbol varchar(25) = null,
6>   @alleleOf integer
7> as
8>  
9> /* Remove all Allele symbols from MRK_Symbol table */
10> 
11> delete from MRK_Symbol where _Marker_key = @oldKey and _Marker_Type_key = 5
12> 
13> /* If Old Symbol is NOT allele of New Symbol... */
14> /* Convert new alleles:  */
15> /*  +<oldsymbol>      --> +<newsymbol> */
16> /*  oldallele<allele> --> newsymbol<allele> */
17> /*      oldallele         --> newsymbol         */
18> 
19> if @alleleOf = 0
20> begin
21> 
22> /* Non-Wild Type Allele */
23> /*  oldallele<allele> --> newsymbol<allele> */
24> 
25> update MRK_Allele
26> set symbol = @new_symbol + "<" + substring(symbol, charindex("<", symbol) + 1, char_length(symbol))
27> where _Marker_key = @oldKey and symbol like '%<%' and symbol not like '+%'
28> 
29> /*      oldallele         --> newsymbol         */
30> 
31> update MRK_Allele set symbol = @new_symbol
32> where _Marker_key = @oldKey and symbol = @old_symbol
33> 
34> /* Wild Type Allele */
35> /*  +<oldsymbol>      --> +<newsymbol> */
36> 
37> update MRK_Allele
38> set symbol = '+<' + @new_symbol + '>'
39> where _Marker_key = @oldKey and symbol like '+<' + @old_symbol + '>'
40> 
41> end
42> else
43> begin
44> 
45> /* If Old Symbol is an Allele of New Symbol... */
46> /* Convert new alleles:  */
47> /*  +<oldsymbol>      --> newsymbol<oldsymbol>        */
48> /*  oldallele<allele> --> newsymbol<oldallele-allele> */
49> /*      oldallele         --> newsymbol<oldallele>        */
50> 
51> /* Non Wild Type */
52> /*  oldallele<allele> --> newsymbol<oldallele-allele> */
53> 
54> update MRK_Allele
55> set symbol = @new_symbol + "<" + substring(symbol, 1, charindex("<", symbol) - 1) + "-" + 
56>          substring(symbol, charindex("<", symbol) + 1, char_length(symbol))
57> where _Marker_key = @oldKey and symbol like '%<%' and symbol not like '+%'
58> 
59> /*      oldallele         --> newsymbol<oldallele>        */
60> 
61> update MRK_Allele
62> set symbol = @new_symbol + "<" + symbol + ">"
63> where _Marker_key = @oldKey and symbol not like '%<%' and symbol not like '+%'
64> 
65> /* Wild Type Allele */
66> /*  +<oldsymbol>      --> newsymbol<oldsymbol>        */
67> 
68> update MRK_Allele
69> set symbol = @new_symbol + "<" + substring(symbol, charindex("<", symbol) + 1, char_length(symbol))
70> where _Marker_key = @oldKey and symbol like '+%'
71> 
72> end
73> 
74> /* Insert Allele symbols into MRK_Symbol table */
75> 
76> insert into MRK_Symbol (_Marker_key, _Marker_Type_key, symbol)
77> select _Marker_key, 5, symbol from MRK_Allele where _Marker_key = @oldKey
78> 
1> 
2> grant execute on MRK_convertAllele to djr
1>  
2> grant execute on MRK_convertAllele to progs
1>  
2> drop procedure MRK_copyAcc
1>  
2> create procedure MRK_copyAcc
3>   @oldKey integer,
4>   @newKey integer
5> as
6>  
7> declare @accID varchar(30),
8>      @logicalDB int,
9>      @prefixPart varchar(20)
10> 
11> /* Copy Old non-MGI Accession Number from Old Key to new New Key */
12> /* For each Marker non-MGI Accession number which exists for Old Symbol, */
13> /* Insert the Accession number as non-preferred for the New symbol */
14>  
15> declare acc_cursor cursor for
16> select accID, _LogicalDB_key, prefixPart
17> from ACC_Accession
18> where _Object_key = @oldKey
19> and _MGIType_key = 2
20> for read only
21>  
22> open acc_cursor
23>  
24> fetch acc_cursor into @accID, @logicalDB, @prefixPart
25> 
26> while (@@sqlstatus = 0)
27> begin
28>     /* For MGI Accession numbers, set preferred = 0 */
29> 
30>     if (@logicalDB = 1 and @prefixPart != "MGI:")
31>     begin
32>             execute ACC_insert @newKey, @accID, @logicalDB, "Marker", -1, 0
33>     end
34> 
35>     /* For non-MGI Accession numbers, set preferred = 1 */
36> 
37>     else if (@logicalDB != 1)
38>     begin
39>             execute ACC_insert @newKey, @accID, @logicalDB, "Marker", -1
40>     end
41> 
42>         fetch acc_cursor into @accID, @logicalDB, @prefixPart
43> end
44>  
45> close acc_cursor
46> 
47> deallocate cursor acc_cursor
48> 
1> 
2> grant execute on MRK_copyAcc to djr
1>  
2> grant execute on MRK_copyAcc to progs
1>  
2> drop procedure MRK_copyHistory
1>  
2> create procedure MRK_copyHistory
3>   @oldKey integer,
4>   @newKey integer
5> as
6>  
7> /* Copy Old History into MRK_History for New Key */
8>  
9> declare @maxSeq int
10> select @maxSeq = max(sequenceNum) from MRK_History where _Marker_key = @newKey
11> 
12> if @maxSeq is null
13> begin
14>     select @maxSeq = 0
15> end
16> 
17> select _Marker_key, _History_key, _Refs_key, seq = identity(5), name, note, 
18> event_date, creation_date, modification_date
19> into #historyTemp from MRK_History where _Marker_key = @oldKey
20> order by sequenceNum
21>  
22> insert into MRK_History 
23> (_Marker_key, _History_key, _Refs_key, sequenceNum, name, note, 
24> event_date, creation_date, modification_date)
25> select distinct @newKey, _History_key, _Refs_key, @maxSeq + seq, name, note, 
26> event_date, creation_date, modification_date
27> from #historyTemp
28> 
1>  
2> grant execute on MRK_copyHistory to djr
1>  
2> grant execute on MRK_copyHistory to progs
1>  
2> drop procedure MRK_insertAllele
1>  
2> create procedure MRK_insertAllele
3>   @markerKey integer,
4>   @symbol varchar(20) = null,
5>   @name varchar(255) = null,
6>   @oldSymbol varchar(20) = null
7> as
8> 
9> declare @alleleKey integer
10> select @alleleKey = max(_Allele_key) + 1 from MRK_Allele
11> 
12> /* Insert New Allele into MRK_Allele */
13> 
14> insert MRK_Allele (_Allele_key, _Marker_key, symbol, name)
15> values(@alleleKey, @markerKey, @symbol, @name)
16> 
17> if @oldSymbol is not null
18> begin
19>     update MLD_Expt_Marker set _Allele_key = @alleleKey
20>     where _Marker_key = @markerKey and gene = @oldSymbol
21> end
22> 
1> 
2> grant execute on MRK_insertAllele to djr
1>  
2> grant execute on MRK_insertAllele to progs
1>  
2> drop procedure MRK_insertHistory
1>  
2> create procedure MRK_insertHistory
3>   @oldKey integer,
4>   @newKey integer,
5>   @refKey integer,
6>   @name varchar(255) = null,
7>   @note varchar(255)
8> as
9>  
10> /* Insert New History into MRK_History */
11>  
12> declare @maxSeq int
13> select @maxSeq = max(sequenceNum) from MRK_History where _Marker_key = @newKey
14> 
15> if @maxSeq is null
16> begin
17>     select @maxSeq = 0
18> end
19> 
20> insert MRK_History 
21> (_Marker_key, _History_key, _Refs_key, sequenceNum, name, note, event_date)
22> values(@newKey, @oldKey, @refKey, @maxSeq + 1, @name, @note, getdate())
23> 
1>  
2> grant execute on MRK_insertHistory to djr
1>  
2> grant execute on MRK_insertHistory to progs
1>  
2> drop procedure MRK_updateKeys
1> 
2> create procedure MRK_updateKeys
3>   @oldKey integer,
4>   @newKey integer
5> as
6> 
7> /* Executed during w/drawal process if only 1 new symbol is designated */
8> 
9> /*
10>    Set the preferred bit to 0 for all MGI Acc# brought over from old symbol if
11>    the new symbol already contains a preferred MGI Acc#.
12>    Associate all Accession numbers w/ new symbol.
13> */
14> 
15> if (select count(*) 
16>     from ACC_Accession 
17>     where _MGIType_key = 2 and 
18>       prefixPart = "MGI:" and
19>       _Object_key = @newKey and
20>       preferred = 1) > 0
21> begin
22>     update ACC_Accession 
23>     set _Object_key = @newKey, preferred = 0
24>     where _LogicalDB_key = 1 and _MGIType_key = 2 and _Object_key = @oldKey
25> end
26> 
27> update ACC_Accession 
28> set _Object_key = @newKey
29> where _MGIType_key = 2 and _Object_key = @oldKey
30> 
31> /* Associate aliases, classes, other names, references w/ new symbol */
32> 
33> /* Remove reflexive Alias records, if they exist */
34> 
35> delete from MRK_Alias where _Marker_key = @oldKey and _Alias_key = @newKey
36> delete from MRK_Alias where _Alias_key = @oldKey and _Marker_key = @newKey
37> 
38> update MRK_Alias set _Marker_key = @newKey where _Marker_key = @oldKey
39> update MRK_Alias set _Alias_key = @newKey where _Alias_key = @oldKey
40> update MRK_Allele set _Marker_key = @newKey where _Marker_key = @oldKey
41> update MRK_Anchors set _Marker_key = @newKey where _Marker_key = @oldKey
42> update MRK_Other set _Marker_key = @newKey where _Marker_key = @oldKey
43> 
44> /* MRK_Classes may contain potential duplicates */
45> 
46> insert into MRK_Classes
47> select @newKey, m._Class_key, m.creation_date, m.modification_date
48> from MRK_Classes m
49> where m._Marker_key = @oldKey
50> and not exists (select m2.* from MRK_Classes m2
51> where m2._Marker_key = @newKey
52> and m2._Class_key = m._Class_key)
53> 
54> delete from MRK_Classes where _Marker_key = @oldKey
55> 
56> /* MRK_Name may contain potential duplicates */
57> 
58> insert into MRK_Name
59> select @newKey, m._Marker_Type_key, m.name, m.creation_date, m.modification_date
60> from MRK_Name m
61> where m._Marker_key = @oldKey
62> and not exists (select m2.* from MRK_Name m2
63> where m2._Marker_key = @newKey
64> and m2._Marker_Type_key = m._Marker_Type_key
65> and m2.name = m.name)
66> 
67> delete from MRK_Name where _Marker_key = @oldKey
68> 
69> /* MRK_Reference may contain potential duplicates */
70> 
71> insert into MRK_Reference
72> select @newKey, m._Refs_key, m.auto, m.creation_date, m.modification_date
73> from MRK_Reference m
74> where m._Marker_key = @oldKey
75> and not exists (select m2.* from MRK_Reference m2
76> where m2._Marker_key = @newKey
77> and m2._Refs_key = m._Refs_key)
78> 
79> delete from MRK_Reference where _Marker_key = @oldKey
80> 
81> /* Update all auxiliary references to old symbol w/ new symbol */
82> 
83> update HMD_Homology_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
84> update GXD_AllelePair set _Marker_key = @newKey where _Marker_key = @oldKey
85> update GXD_AntibodyMarker set _Marker_key = @newKey where _Marker_key = @oldKey
86> update GXD_Assay set _Marker_key = @newKey where _Marker_key = @oldKey
87> update GXD_Expression set _Marker_key = @newKey where _Marker_key = @oldKey
88> update GXD_Index set _Marker_key = @newKey where _Marker_key = @oldKey
89> 
90> /* Include MLD_Marker and MLD_Expt_Marker because sometimes Markers are */
91> /* mentioned in one table and not the other */
92> 
93> update MLD_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
94> update MLD_Expt_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
95> update MLD_Concordance set _Marker_key = @newKey where _Marker_key = @oldKey
96> update MLD_Distance set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
97> update MLD_Distance set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
98> update MLD_MC2point set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
99> update MLD_MC2point set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
100> update MLD_RI2Point set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
101> update MLD_RI2Point set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
102> update MLD_Statistics set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
103> update MLD_Statistics set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
104>  
105> /* PRB_Marker may contain potential duplicates */
106> 
107> insert into PRB_Marker
108> select m._Probe_key, @newKey, m.relationship, m.creation_date, m.modification_date
109> from PRB_Marker m
110> where m._Marker_key = @oldKey
111> and not exists (select m2.* from PRB_Marker m2
112> where m2._Marker_key = @newKey
113> and m2._Probe_key = m._Probe_key)
114>   
115> delete from PRB_Marker where _Marker_key = @oldKey
116> update PRB_RFLV set _Marker_key = @newKey where _Marker_key = @oldKey
117> 
118> /* Update MLC tables iff New Symbol entry doesn't exist in MLC */
119> /* Nomenclature updates are propagated to the non-edit tables immediately */
120> 
121> if not exists (select * from MLC_Marker_edit where _Marker_key = @newKey)
122> begin
123>   update MLC_Marker_edit set _Marker_key = @newKey where _Marker_key = @oldKey
124>   update MLC_Reference_edit set _Marker_key = @newKey where _Marker_key = @oldKey
125>   update MLC_Text_edit set _Marker_key = @newKey where _Marker_key = @oldKey
126>   update MLC_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
127>   update MLC_Reference set _Marker_key = @newKey where _Marker_key = @oldKey
128>   update MLC_Text set _Marker_key = @newKey where _Marker_key = @oldKey
129> end
130> 
1> 
2> grant execute on MRK_updateKeys to djr
1> 
2> grant execute on MRK_updateKeys to progs
1> 
2> drop procedure MRK_updateCurrent
1> 
2> create procedure MRK_updateCurrent
3>   @oldKey integer,
4>   @newKey integer
5> as
6> 
7> /* Associate current symbols for all past symbols w/ new symbol */
8> /* Associate alias symbols in MRK_Symbol w/ new symbol */
9> /* Associate allele symbols in MRK_Symbol w/ new symbol */
10> 
11> update MRK_Current set _Current_key = @newKey where _Current_key = @oldKey
12> update MRK_Symbol set _Marker_key = @newKey where _Marker_key = @oldKey and _Marker_Type_key = 4
13> update MRK_Symbol set _Marker_key = @newKey where _Marker_key = @oldKey and _Marker_Type_key = 5
14> 
1> 
2> grant execute on MRK_updateCurrent to djr
1> 
2> grant execute on MRK_updateCurrent to progs
1> 
2> drop procedure MRK_updateOffset
1> 
2> create procedure MRK_updateOffset
3>   @oldKey integer,
4>   @newKey integer
5> as
6> 
7> declare @oldCyto varchar(20)
8> declare @newCyto varchar(20)
9> 
10> declare @oldMGD float
11> declare @newMGD float
12> 
13> declare @oldCC float
14> declare @newCC float
15> 
16> declare @oldMIT float
17> declare @newMIT float
18> 
19> select @oldCyto = cytogeneticOffset from MRK_Marker where _Marker_key = @oldKey
20> select @newCyto = cytogeneticOffset from MRK_Marker where _Marker_key = @newKey
21> 
22> select @oldMGD = offset from MRK_Offset where _Marker_key = @oldKey and source = 0
23> select @oldCC = offset from MRK_Offset where _Marker_key = @oldKey and source = 1
24> select @oldMIT = offset from MRK_Offset where _Marker_key = @oldKey and source = 2
25> 
26> select @newMGD = offset from MRK_Offset where _Marker_key = @newKey and source = 0
27> select @newCC = offset from MRK_Offset where _Marker_key = @newKey and source = 1
28> select @newMIT = offset from MRK_Offset where _Marker_key = @newKey and source = 2
29> 
30> -- If the new symbol lacks an Cytogenetic offset, then use the old symbols' offset
31> 
32> if @newCyto is null
33> begin
34>   update MRK_Marker set cytogeneticOffset = @oldCyto where _Marker_key = @newKey
35> end
36> 
37> -- If the new symbol lacks an MGD offset, then use the old symbols' offset
38> 
39> if @newMGD < 0
40> begin
41>   update MRK_Offset set offset = @oldMGD where _Marker_key = @newKey and source = 0
42> end
43> 
44> -- If the new symbol lacks a CC offset, then use the old symbol's CC offset
45> 
46> if @newCC < 0 and @oldCC > 0
47> begin
48>   update MRK_Offset set offset = @oldCC where _Marker_key = @newKey and source = 1
49> end
50> else if @newCC is null and @oldCC is not null
51> begin
52>   insert MRK_Offset (_Marker_key, source, offset) values(@newKey, 1, @oldCC)
53> end
54> 
55> -- If the new symbol lacks an MIT offset, then use the old symbol's MIT offset
56> 
57> if @newMIT < 0 and @oldMIT > 0
58> begin
59>   update MRK_Offset set offset = @oldMIT where _Marker_key = @newKey and source = 2
60> end
61> else if @newMIT is null and @oldMIT is not null
62> begin
63>   insert MRK_Offset (_Marker_key, source, offset) values(@newKey, 2, @oldMIT)
64> end
65> 
1> 
2> grant execute on MRK_updateOffset to djr
1> 
2> grant execute on MRK_updateOffset to progs
1> 
2> 
3> drop procedure MRK_MaxOffset
1> 
2> create procedure MRK_MaxOffset
3> @chromosome varchar(2),
4> @source int 
5> as
6> select maxOffset = max(o.offset)
7> from MRK_Offset o, MRK_Marker m
8> where o._Marker_key = m._Marker_key
9> and o.source = @source 
10> and m.chromosome = @chromosome 
11> and m._Species_key = 1
1> 
2> grant execute on MRK_MaxOffset to public
1> 
2> 
3> drop procedure MRK_MiniMapMarkers
1> 
2> create procedure MRK_MiniMapMarkers
3> @_Marker_key int,
4> @source int 
5> as
6> /* retrieve data for all anchor markers on the chromosome */
7> select distinct
8> m._Marker_key,
9> m.symbol,
10> m.name,
11> m.chromosome,
12> o.offset,
13> m.cytogeneticOffset
14> from MRK_Marker m, 
15> MRK_Offset o, 
16> MRK_Anchors a
17> where
18> m._Marker_key = a._Marker_key
19> and o.source = @source
20> and o._Marker_key = m._Marker_key
21> and o.offset > -1.0
22> and a.chromosome = (select m.chromosome 
23> from MRK_Marker m
24> where m._Marker_key = @_Marker_key)
25> union
26> /* get the data for the marker itself */
27> select distinct
28> m._Marker_key,
29> m.symbol,
30> m.name,
31> m.chromosome,
32> o.offset,
33> m.cytogeneticOffset
34> from MRK_Marker m,
35> MRK_Offset o
36> where
37> m._Marker_key = @_Marker_key
38> and o.source = @source
39> and o._Marker_key = m._Marker_key
40> and o.offset > -1.0
1> 
2> grant execute on MRK_MiniMapMarkers to public
1> 
2> drop procedure MRK_mergeAllele
1>  
2> create procedure MRK_mergeAllele
3>   @oldAlleleKey int,
4>   @newAlleleKey int
5> as
6> 
7> /*
8>  * Update old Allele key to new Allele key
9>  * in all relevant tables which contain an Allele key.
10>  * When finished, remove the Allele record for the old
11>  * Allele key.
12> */
13> 
14> update GXD_AllelePair
15> set _Allele_key_1 = @newAlleleKey
16> where _Allele_key_1 = @oldAlleleKey
17> 
18> update GXD_AllelePair
19> set _Allele_key_2 = @newAlleleKey
20> where _Allele_key_2 = @oldAlleleKey
21> 
22> update MLD_Expt_Marker
23> set _Allele_key = @newAlleleKey
24> where _Allele_key = @oldAlleleKey
25> 
26> delete from MRK_Allele
27> where _Allele_key = @oldAlleleKey
28> 
1> 
2> grant execute on MRK_mergeAllele to editors
1>  
2> grant execute on MRK_mergeAllele to progs
1>  
2> drop procedure MRK_isAnchor
1>  
2> create procedure MRK_isAnchor
3>   @key int
4> as
5> 
6> /* Determine if Marker key exists in MRK_Anchors table */
7> 
8> declare @found int
9> select @found = count(*) from MRK_Anchors where _Marker_key = @key
10> select @found
11> 
1> 
2> grant execute on MRK_isAnchor to public
1>  
2> drop procedure MRK_breakpointSplit
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRK_breakpointSplit', because it doesn't exist in the
system catalogs.
1> 
2> create procedure MRK_breakpointSplit
3>   @markerKey integer,
4>   @distalCytoBand varchar(20) = null
5> as
6> 
7> /* See TR#120; procedure to split cytogenetic marker into 2 distinct markers */
8> 
9> declare @band varchar(20)
10> declare @symbol varchar(25)
11> declare @name varchar(255)
12> declare @markerType integer
13> declare @idx integer
14> 
15> select @symbol = symbol, @band = cytogeneticOffset, @name = name, @markerType = _Marker_Type_key
16> from MRK_Marker where _Marker_key = @markerKey
17> 
18> if @markerType != 3
19> begin
20>     rollback transaction
21>     raiserror 99999 "Invalid Marker for Breakpoint Split: %1!", @symbol
22>     return
23> end
24> 
25> select @idx = charindex(" & ", @band)
26> 
27> declare @proximalBand varchar(20)
28> declare @distalBand varchar(20)
29> 
30> declare @proximalSymbol varchar(25)
31> declare @distalSymbol varchar(25)
32> 
33> declare @proximalName varchar(255)
34> declare @distalName varchar(255)
35> 
36> declare @proximalKey integer
37> declare @distalKey integer
38> 
39> /* If symbol band is not in the format 'X & Y', then distal band remains NULL */
40> 
41> if @idx = 0
42> begin
43>     select @proximalBand = @band
44>     /* distal band is null */
45> end
46> else
47> begin
48>     select @proximalBand = substring(@band, 1, @idx - 1)
49>     select @distalBand = substring(@band, @idx + 3, char_length(@band))
50> end
51> 
52> /* If caller supplies a distal band, use it */
53> 
54> if @distalCytoBand is not null
55> begin
56>     select @distalBand = @distalCytoBand
57> end
58> 
59> select @proximalSymbol = @symbol + "-p"
60> select @proximalName = @name + ", proximal"
61> select @proximalKey = @markerKey
62> 
63> select @distalSymbol = @symbol + "-d"
64> select @distalName = @name + ", distal"
65> select @distalKey = max(_Marker_key) + 1 from MRK_Marker
66> 
67> /* Update the symbol, name and cytogenetic offset for the current Marker to the proximal symbol */
68> 
69> update MRK_Marker
70> set symbol = @proximalSymbol,
71>     name = @proximalName,
72>     cytogeneticOffset = @proximalBand
73> where _Marker_key = @proximalKey
74> 
75> update MRK_History
76> set name = @proximalName
77> where _Marker_key = @proximalKey
78> and name = @name
79> 
80> /* Copy proximal symbol info to a new distal symbol */
81> 
82> insert into MRK_Marker 
83> (_Marker_key, _Species_key, _Marker_Type_key, symbol, name, chromosome, cytogeneticOffset)
84> select @distalKey, _Species_key, _Marker_Type_key, @distalSymbol, @distalName, chromosome, @distalBand
85> from MRK_Marker where _Marker_key = @proximalKey
86> 
87> /* Notes */
88> insert into MRK_Notes
89> (_Marker_key, sequenceNum, note)
90> select @distalKey, sequenceNum, note
91> from MRK_Notes where _Marker_key = @proximalKey
92> 
93> /* Offset */
94> insert into MRK_Offset
95> (_Marker_key, source, offset)
96> select @distalKey, source, offset
97> from MRK_Offset where _Marker_key = @proximalKey
98> 
99> /* References */
100> insert into MRK_Reference
101> (_Marker_key, _Refs_key, auto)
102> select @distalKey, _Refs_key, auto
103> from MRK_Reference where _Marker_key = @proximalKey
104> 
105> /* History */
106> insert into MRK_History
107> (_Marker_key, _History_key, _Refs_key, sequenceNum, name, note, event_date)
108> select @distalKey, _History_key, _Refs_key, sequenceNum, name, note, event_date
109> from MRK_History where _Marker_key = @proximalKey and _History_key != @proximalKey
110> 
111> insert into MRK_History
112> (_Marker_key, _History_key, _Refs_key, sequenceNum, name, note, event_date)
113> select @distalKey, @distalKey, _Refs_key, sequenceNum, @distalName, note, event_date
114> from MRK_History where _Marker_key = @proximalKey and _History_key = @proximalKey
115> 
116> /* Other Names */
117> select seq = identity(5), name
118> into #otherTmp
119> from MRK_Other where _Marker_key = @proximalKey
120> 
121> declare @maxOther int
122> select @maxOther = max(_Other_key) from MRK_Other
123> 
124> insert into MRK_Other
125> (_Other_key, _Marker_key, name)
126> select @maxOther + seq, @distalKey, name
127> from #otherTmp
128>  
129> /* Accession Numbers */
130> /* Copy all nonMGI preferred Accession numbers of proximal symbol to distal symbol */
131> 
132> select seq = identity(5), a.*
133> into #accTmp
134> from ACC_Accession a where a._Object_key = @proximalKey
135> and a._MGIType_key = 2
136> 
137> declare @maxAcc int
138> select @maxAcc = max(_Accession_key) from ACC_Accession
139> 
140> insert into ACC_Accession
141> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
142> select @maxAcc + seq, accID, prefixPart, numericPart, _LogicalDB_key, @distalKey, _MGIType_key,
143> private, preferred
144> from #accTmp
145> where prefixPart != "MGI:" and preferred != 1
146>  
147> /* Insert Other Name entries for both proximal and distal symbols */
148> 
149> declare @otherKey int
150> select @otherKey = max(_Other_key) + 1 from MRK_Other
151> insert into MRK_Other values(@otherKey, @proximalKey, @symbol, getdate(), getdate())
152> insert into MRK_Other values(@otherKey + 1, @distalKey, @symbol, getdate(), getdate())
153> 
154> select @proximalKey, @proximalSymbol
155> select @distalKey, @distalSymbol
156> 
1> 
2> grant execute on MRK_breakpointSplit to djr
1> 
2> grant execute on MRK_breakpointSplit to progs
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure MRKXfer_count_MLD
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_count_MLD', because it doesn't exist in the
system catalogs.
1>  
2> create procedure MRKXfer_count_MLD
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Markers in MLDP for marker/reference pair */
8> 
9> select count(*) from MLD_Marker
10> where _Marker_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_MLD to public
1>  
2> drop procedure MRKXfer_MLD
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_MLD', because it doesn't exist in the system
catalogs.
1>  
2> create procedure MRKXfer_MLD
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return MGI Experiment Accession numbers for marker/reference pair */
8> 
9> select distinct e._Expt_key 
10> into #expts
11> from MLD_Marker m, MLD_Expts e
12> where m._Marker_key = @markerKey and
13>       m._Refs_key = @refKey and
14>       m._Refs_key = e._Refs_key
15> 
16> select distinct a.mgiID
17> from #expts t, MLD_Summary_View a
18> where t._Expt_key = a._Object_key
19> 
1> 
2> grant execute on MRKXfer_MLD to public
1>  
2> drop procedure MRKXfer_count_HMD
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_count_HMD', because it doesn't exist in the
system catalogs.
1>  
2> create procedure MRKXfer_count_HMD
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Homology records for marker/reference pair */
8> 
9> select count(r._Refs_key) from HMD_Homology_Marker m, HMD_Homology r
10> where m._Marker_key = @markerKey and
11>       m._Homology_Key = r._Homology_key and
12>       r._Refs_key = @refKey
13> 
1> 
2> grant execute on MRKXfer_count_HMD to public
1>  
2> drop procedure MRKXfer_count_GXDIndex
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_count_GXDIndex', because it doesn't exist in
the system catalogs.
1>  
2> create procedure MRKXfer_count_GXDIndex
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Index records for marker/reference pair */
8> 
9> select count(_Refs_key) from GXD_Index
10> where _Marker_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_GXDIndex to public
1>  
2> drop procedure MRKXfer_count_GXDAntibody
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_count_GXDAntibody', because it doesn't exist
in the system catalogs.
1>  
2> create procedure MRKXfer_count_GXDAntibody
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Antibody records for marker/reference pair */
8> 
9> select a._Refs_key
10> into #count
11> from GXD_Antibody a, GXD_AntibodyMarker am
12> where a._Refs_key = @refKey and 
13>       a._Antibody_key = am._Antibody_key and
14>       am._Marker_key = @markerKey
15> union
16> select a._Refs_key
17> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
18> where a._Antibody_key = am._Antibody_key and 
19>       am._Marker_key = @markerKey and 
20>       a._Antibody_key = aa._Antibody_key and 
21>       aa._Refs_key = @refKey
22> 
23> select count(*) from #count
24> 
1> 
2> grant execute on MRKXfer_count_GXDAntibody to public
1>  
2> drop procedure MRKXfer_count_GXDAntibodyAssay
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_count_GXDAntibodyAssay', because it doesn't
exist in the system catalogs.
1>  
2> create procedure MRKXfer_count_GXDAntibodyAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Assay records which use the Antibody for marker/reference pair
8>    to detect the Marker.
9> */
10>  
11> select a._Antibody_key 
12> into #antibody
13> from GXD_Antibody a, GXD_AntibodyMarker am
14> where a._Refs_key = @refKey and
15>       a._Antibody_key = am._Antibody_key and
16>       am._Marker_key = @markerKey
17> union
18> select a._Antibody_key
19> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
20> where a._Antibody_key = am._Antibody_key and
21>       am._Marker_key = @markerKey and
22>       a._Antibody_key = aa._Antibody_key and
23>       aa._Refs_key = @refKey
24>  
25> select count(a._Assay_key)
26> from #antibody p, GXD_AntibodyPrep xa, GXD_Assay a
27> where p._Antibody_key = xa._Antibody_key and
28>       xa._AntibodyPrep_key = a._AntibodyPrep_key and
29>       a._Marker_key = @markerKey
30> 
1>  
2> grant execute on MRKXfer_count_GXDAntibodyAssay to public
1>  
2> drop procedure MRKXfer_GXDAntibodyAssay
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_GXDAntibodyAssay', because it doesn't exist
in the system catalogs.
1>  
2> create procedure MRKXfer_GXDAntibodyAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Assay records which use the Antibody for marker/reference pair
8>    to detect the Marker.
9> */
10>  
11> select a._Antibody_key
12> into #antibody
13> from GXD_Antibody a, GXD_AntibodyMarker am
14> where a._Refs_key = @refKey and
15>       a._Antibody_key = am._Antibody_key and
16>       am._Marker_key = @markerKey
17> union
18> select a._Antibody_key
19> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
20> where a._Antibody_key = am._Antibody_key and
21>       am._Marker_key = @markerKey and
22>       a._Antibody_key = aa._Antibody_key and
23>       aa._Refs_key = @refKey
24>  
25> select a._Assay_key
26> into #assay
27> from #antibody p, GXD_AntibodyPrep xa, GXD_Assay a
28> where p._Antibody_key = xa._Antibody_key and
29>       xa._AntibodyPrep_key = a._AntibodyPrep_key and
30>       a._Marker_key = @markerKey
31>  
32> select a.mgiID
33> from #assay t, GXD_Assay_Summary_View a
34> where t._Assay_key = a._Object_key
35> 
1>  
2> grant execute on MRKXfer_GXDAntibodyAssay to public
1>  
2> drop procedure MRKXfer_GXDAntibody
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_GXDAntibody', because it doesn't exist in the
system catalogs.
1>  
2> create procedure MRKXfer_GXDAntibody
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return MGI Antibody Accession numbers for marker/reference pair */
8> 
9> select a._Antibody_key 
10> into #antibody
11> from GXD_Antibody a, GXD_AntibodyMarker am
12> where a._Refs_key = @refKey and
13>       a._Antibody_key = am._Antibody_key and
14>       am._Marker_key = @markerKey
15> union
16> select a._Antibody_key
17> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
18> where a._Antibody_key = am._Antibody_key and
19>       am._Marker_key = @markerKey and
20>       a._Antibody_key = aa._Antibody_key and
21>       aa._Refs_key = @refKey
22>  
23> select a.mgiID
24> from #antibody t, GXD_Antibody_Summary_View a
25> where t._Antibody_key = a._Object_key
26> 
1>  
2> grant execute on MRKXfer_GXDAntibody to public
1>  
2> drop procedure MRKXfer_count_GXDAssay
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_count_GXDAssay', because it doesn't exist in
the system catalogs.
1>  
2> create procedure MRKXfer_count_GXDAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Assay records for marker/reference pair */
8> 
9> select count(_Refs_key) from GXD_Assay
10> where _Marker_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_GXDAssay to public
1>  
2> drop procedure MRKXfer_GXDAssay
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_GXDAssay', because it doesn't exist in the
system catalogs.
1>  
2> create procedure MRKXfer_GXDAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return MGI Assay Accession numbers for marker/reference pair */
8> 
9> select _Assay_key
10> into #assay
11> from GXD_Assay
12> where _Marker_key = @markerKey and
13>       _Refs_key = @refKey
14> 
15> select a.mgiID
16> from #assay t, GXD_Assay_Summary_View a
17> where t._Assay_key = a._Object_key
18> 
1>  
2> grant execute on MRKXfer_GXDAssay to public
1>  
2> drop procedure MRKXfer_count_MLC
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_count_MLC', because it doesn't exist in the
system catalogs.
1>  
2> create procedure MRKXfer_count_MLC
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of MLC Text records for marker/reference pair */
8> 
9> select count(m._Marker_key) 
10> from MLC_Text_edit m, MLC_Reference_edit r
11> where m._Marker_key = @markerKey
12> and m._Marker_key = r._Marker_key
13> and r._Refs_key = @refKey
14> 
1> 
2> grant execute on MRKXfer_count_MLC to public
1>  
2> drop procedure MRKXfer_count_PRB
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_count_PRB', because it doesn't exist in the
system catalogs.
1>  
2> create procedure MRKXfer_count_PRB
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Probe records for marker/reference pair */
8> 
9> select count(distinct p.name) from PRB_Probe p, PRB_Marker m, PRB_Reference r
10> where m._Marker_key = @markerKey and
11>       m._Probe_key = r._Probe_key and
12>       r._Refs_key = @refKey and
13>       m._Probe_key = p._Probe_key
14> 
1> 
2> grant execute on MRKXfer_count_PRB to public
1>  
2> drop procedure MRKXfer_PRB
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_PRB', because it doesn't exist in the system
catalogs.
1>  
2> create procedure MRKXfer_PRB
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for marker/reference pair */
8> 
9> select distinct p.name, p._Probe_key
10> from PRB_Probe p, PRB_Marker m, PRB_Reference r
11> where m._Marker_key = @markerKey and
12>       m._Probe_key = r._Probe_key and
13>       r._Refs_key = @refKey and
14>       m._Probe_key = p._Probe_key
15>  
1>  
2> grant execute on MRKXfer_PRB to public
1> 
2> drop procedure MRKXfer_count_PRBAssay
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_count_PRBAssay', because it doesn't exist in
the system catalogs.
1>  
2> create procedure MRKXfer_count_PRBAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for Assays which use Probe to detect Marker */
8> 
9> select distinct p.name, p._Probe_key
10> into #probe
11> from PRB_Probe p, PRB_Marker m, PRB_Reference r
12> where m._Marker_key = @markerKey and
13>       m._Probe_key = r._Probe_key and
14>       r._Refs_key = @refKey and
15>       m._Probe_key = p._Probe_key
16>  
17> select count(a._Assay_key)
18> from #probe p, GXD_ProbePrep xp, GXD_Assay a
19> where p._Probe_key = xp._Probe_key and
20>       xp._ProbePrep_key = a._ProbePrep_key and
21>       a._Marker_key = @markerKey
22> 
1> 
2> grant execute on MRKXfer_count_PRBAssay to public
1> 
2> drop procedure MRKXfer_PRBAssay
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_PRBAssay', because it doesn't exist in the
system catalogs.
1>  
2> create procedure MRKXfer_PRBAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for Assays which use Probe to detect Marker */
8> 
9> select distinct p.name, p._Probe_key
10> into #probe
11> from PRB_Probe p, PRB_Marker m, PRB_Reference r
12> where m._Marker_key = @markerKey and
13>       m._Probe_key = r._Probe_key and
14>       r._Refs_key = @refKey and
15>       m._Probe_key = p._Probe_key
16>  
17> select a._Assay_key
18> into #assay
19> from #probe p, GXD_ProbePrep xp, GXD_Assay a
20> where p._Probe_key = xp._Probe_key and
21>       xp._ProbePrep_key = a._ProbePrep_key and
22>       a._Marker_key = @markerKey
23> 
24> select a.mgiID
25> from #assay t, GXD_Assay_Summary_View a
26> where t._Assay_key = a._Object_key
27> 
1> 
2> grant execute on MRKXfer_PRBAssay to public
1> 
2> drop procedure MRKXfer_count_PRBReference
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_count_PRBReference', because it doesn't exist
in the system catalogs.
1>  
2> create procedure MRKXfer_count_PRBReference
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Probes for marker/reference pair */
8> /* which contain more than one reference */
9>  
10> select distinct p._Probe_key, p.name
11> into #probe
12> from PRB_Probe p, PRB_Marker m, PRB_Reference r
13> where m._Marker_key = @markerKey and
14>       m._Probe_key = r._Probe_key and
15>       r._Refs_key = @refKey and
16>       m._Probe_key = p._Probe_key
17>  
18> select distinct t._Probe_key
19> into #count
20> from #probe t, PRB_Reference r
21> where t._Probe_key = r._Probe_key
22> group by t._Probe_key
23> having count(*) > 1
24>  
25> select count(*) from #count
26> 
1>  
2> grant execute on MRKXfer_count_PRBReference to public
1>  
2> drop procedure MRKXfer_PRBReference
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_PRBReference', because it doesn't exist in
the system catalogs.
1>  
2> create procedure MRKXfer_PRBReference
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for marker/reference pair */
8> /* which contain more than one reference */
9> 
10> 
11> select distinct p._Probe_key, p.name
12> into #probe
13> from PRB_Probe p, PRB_Marker m, PRB_Reference r
14> where m._Marker_key = @markerKey and
15>       m._Probe_key = r._Probe_key and
16>       r._Refs_key = @refKey and
17>       m._Probe_key = p._Probe_key
18>  
19> select t.name, t._Probe_key
20> from #probe t, PRB_Reference r
21> where t._Probe_key = r._Probe_key
22> group by t._Probe_key
23> having count(*) > 1
24> 
1>  
2> grant execute on MRKXfer_PRBReference to public
1> 
2> drop procedure MRKXfer_count_PRBNote
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_count_PRBNote', because it doesn't exist in
the system catalogs.
1>  
2> create procedure MRKXfer_count_PRBNote
3>   @probeKey integer,
4>   @marker varchar(25)
5> as
6>  
7> /* Return number of Probe Notes for probe/marker pair */
8> 
9> select count(_Probe_key) 
10> from PRB_Notes
11> where _Probe_key = @probeKey and
12>       note like "%" + @marker + "%"
13> 
1>  
2> grant execute on MRKXfer_count_PRBNote to public
1> 
2> drop procedure MRKXfer_count_MRKAccession
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_count_MRKAccession', because it doesn't exist
in the system catalogs.
1>  
2> create procedure MRKXfer_count_MRKAccession
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Markers with accession/reference pair */
8> 
9> select count(*) from MRK_AccRef_View
10> where _Object_key = @markerKey and
11>       _Refs_key = @refKey
12> 
Msg 208, Level 16, State 1:
Procedure 'MRKXfer_count_MRKAccession', Line 9:
MRK_AccRef_View not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRKXfer_count_MRKAccession to public
Msg 208, Level 16, State 2:
Line 2:
MRKXfer_count_MRKAccession not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1>  
2> drop procedure MRKXfer_MRKAccession
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_MRKAccession', because it doesn't exist in
the system catalogs.
1>  
2> create procedure MRKXfer_MRKAccession
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Accession numbers for marker/reference pair */
8>  
9> select distinct accID
10> from MRK_AccRef_View
11> where _Object_key = @markerKey and
12>       _Refs_key = @refKey
13>  
Msg 208, Level 16, State 1:
Procedure 'MRKXfer_MRKAccession', Line 9:
MRK_AccRef_View not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1>  
2> grant execute on MRKXfer_MRKAccession to public
Msg 208, Level 16, State 2:
Line 2:
MRKXfer_MRKAccession not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1>  
2> drop procedure MRKXfer_update
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the procedure 'MRKXfer_update', because it doesn't exist in the
system catalogs.
1> 
2> create procedure MRKXfer_update
3>   @oldMarkerKey integer,
4>   @newMarkerKey integer,
5>   @refKey integer
6> as
7> 
8> /* Update Mapping */
9> 
10> update MLD_Marker 
11> set _Marker_key = @newMarkerKey,
12>     modification_date = getdate()
13> where _Marker_key = @oldMarkerKey and 
14>       _Refs_key = @refKey
15>  
16> /* Select Probes which contain Marker/Reference pair */
17> 
18> select m._Probe_key, m._Marker_key
19> into #probe
20> from PRB_Marker m, PRB_Reference r
21> where m._Marker_key = @oldMarkerKey and 
22>       m._Probe_key = r._Probe_key and 
23>       r._Refs_key = @refKey
24> 
25> /* Select the Antibodies which contain the Marker/Reference pair */
26> 
27> select a._Antibody_key 
28> into #antibody
29> from GXD_Antibody a, GXD_AntibodyMarker am
30> where a._Refs_key = @refKey and
31>       a._Antibody_key = am._Antibody_key and
32>       am._Marker_key = @oldMarkerKey
33> union
34> select a._Antibody_key
35> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
36> where a._Antibody_key = am._Antibody_key and
37>       am._Marker_key = @oldMarkerKey and
38>       a._Antibody_key = aa._Antibody_key and
39>       aa._Refs_key = @refKey
40>  
41> /* Select GXD Assays which contain Probes/Markers involved in update */
42> /* Union */
43> /* Select GXD Assays which contain Antibodys/Markers involved in update */
44> /* Union */
45> /* Select GXD Assays which contain Marker/Reference pair */
46> 
47> select a._Assay_key
48> into #assay
49> from #probe p, GXD_ProbePrep xp, GXD_Assay a
50> where p._Probe_key = xp._Probe_key and
51>       xp._ProbePrep_key = a._ProbePrep_key and
52>       a._Marker_key = @oldMarkerKey
53> union
54> select a._Assay_key
55> from #antibody p, GXD_AntibodyPrep xa, GXD_Assay a
56> where p._Antibody_key = xa._Antibody_key and
57>       xa._AntibodyPrep_key = a._AntibodyPrep_key and
58>       a._Marker_key = @oldMarkerKey
59> union
60> select a._Assay_key
61> from GXD_Assay a
62> where a._Marker_key = @oldMarkerKey and
63>       a._Refs_key = @refKey
64> 
65> /* Update the GXD Assay records */
66> 
67> update GXD_Assay
68> set _Marker_key = @newMarkerKey,
69>     modification_date = getdate()
70> from #assay a, GXD_Assay gxd
71> where a._Assay_key = gxd._Assay_key
72> 
73> /* Update the GXD_Expression records */
74> 
75> declare @assayKey integer
76> declare assay_cursor cursor for
77>     select _Assay_key from #assay 
78>     for read only
79>  
80> open assay_cursor
81> fetch assay_cursor into @assayKey
82>  
83> while (@@sqlstatus = 0)
84> begin
85>   exec GXD_loadCacheByAssay @assayKey
86>   fetch assay_cursor into @assayKey
87> end
88>  
89> close assay_cursor
90> deallocate cursor assay_cursor
91> 
92> /* Update the Probes */
93> 
94> update PRB_Marker 
95> set _Marker_key = @newMarkerKey,
96>     modification_date = getdate()
97> from #probe p, PRB_Marker m
98> where p._Probe_key = m._Probe_key and 
99>       p._Marker_key = m._Marker_key
100>  
101> /* Update the GXD Antibodies */
102> 
103> update GXD_AntibodyMarker
104> set _Marker_key = @newMarkerKey,
105>     modification_date = getdate()
106> from #antibody a, GXD_AntibodyMarker am
107> where a._Antibody_key = am._Antibody_key
108> 
109> /* Update the GXD Antibody Aliases */
110> 
111> update GXD_AntibodyMarker
112> set _Marker_key = @newMarkerKey,
113>     modification_date = getdate()
114> from #antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
115> where a._Antibody_key = am._Antibody_key and 
116>       am._Marker_key = @oldMarkerKey and 
117>       a._Antibody_key = aa._Antibody_key and 
118>       aa._Refs_key = @refKey
119> 
120> /* Update the GXD Index */
121> 
122> update GXD_Index 
123> set _Marker_key = @newMarkerKey,
124>     modification_date = getdate()
125> where _Marker_key = @oldMarkerKey and 
126>       _Refs_key = @refKey
127>  
1> 
2> grant execute on MRKXfer_update to djr
1> 
2> grant execute on MRKXfer_update to progs
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop procedure PRB_mergeStrain
1>  
2> create procedure PRB_mergeStrain
3>   @oldStrainKey int,
4>   @newStrainKey int
5> as
6> 
7> /*
8>  * Update old Strain key to new Strain key
9>  * in all relevant tables which contain a Strain key.
10>  * When finished, remove the Strain record for the old
11>  * Strain key.
12> */
13> 
14> if (select count(*) from PRB_Allele_Strain where _Strain_key in (@oldStrainKey, @newStrainkey)
15>     group by _Allele_key having count(*) > 1) > 0
16> begin
17>     declare @alleleKey integer
18>     declare @probe varchar(255)
19>     declare @jnum varchar(100)
20> 
21>     declare allele_cursor cursor for
22>     select distinct _Allele_key
23>     from PRB_Allele_Strain
24>     where _Strain_key in (@oldStrainKey, @newStrainkey)
25>         group by _Allele_key having count(*) > 1
26>     for read only
27>  
28>     open allele_cursor
29>  
30>     fetch allele_cursor into @alleleKey
31>  
32>     while (@@sqlstatus = 0)
33>     begin
34>             select @probe = p.name, @jnum = b.accID
35>             from PRB_Allele a, PRB_RFLV v, PRB_Reference  r, PRB_Probe p, BIB_Acc_View b
36>             where a._Allele_key = @alleleKey and
37>                   a._RFLV_key = v._RFLV_key and
38>                   v._Reference_key = r._Reference_key and
39>                   r._Probe_key = p._Probe_key and
40>                   r._Refs_key = b._Object_key and
41>                   b.prefixPart = 'J:'
42> 
43>             rollback transaction
44>             raiserror 99999 "This merge would create a duplicate entry for Probe '%1!', %2!", @probe, @jnum
45>             return
46>     end
47>  
48>     close allele_cursor
49>  
50>     deallocate cursor allele_cursor
51> 
52> end
53> 
54> update PRB_Source
55> set _Strain_key = @newStrainKey
56> where _Strain_key = @oldStrainKey
57> 
58> update PRB_Allele_Strain
59> set _Strain_key = @newStrainKey
60> where _Strain_key = @oldStrainKey
61> 
62> update MLD_FISH
63> set _Strain_key = @newStrainKey
64> where _Strain_key = @oldStrainKey
65> 
66> update MLD_InSitu
67> set _Strain_key = @newStrainKey
68> where _Strain_key = @oldStrainKey
69> 
70> update CRS_Cross
71> set _femaleStrain_key = @newStrainKey
72> where _femaleStrain_key = @oldStrainKey
73> 
74> update CRS_Cross
75> set _maleStrain_key = @newStrainKey
76> where _maleStrain_key = @oldStrainKey
77> 
78> update CRS_Cross
79> set _StrainHO_key = @newStrainKey
80> where _StrainHO_key = @oldStrainKey
81> 
82> update CRS_Cross
83> set _StrainHT_key = @newStrainKey
84> where _StrainHT_key = @oldStrainKey
85> 
86> update GXD_Genotype
87> set _Strain_key = @newStrainKey
88> where _Strain_key = @oldStrainKey
89> 
90> delete from PRB_Strain
91> where _Strain_key = @oldStrainKey
92> 
1> 
2> grant execute on PRB_mergeStrain to editors
1>  
2> grant execute on PRB_mergeStrain to progs
1>  
2> drop procedure PRB_mergeStandardStrain
1>  
2> create procedure PRB_mergeStandardStrain
3>   @strain varchar(255),
4>   @fromStandard int = 0,
5>   @toStandard int = 1
6> as
7>  
8> /* Given a Strain, merge all of the records into one Strain.
9>  *
10>  * Merge all Non-Standard Strains into the Standard Strain (default)
11>  * (exec PRB_mergeStandardStrain "Strain")
12>  *
13>  * OR
14>  *
15>  * Merge all Standard Strains into the Non-Standard Strain
16>  * (exec PRB_mergeStandardStrain "Strain", 1, 0)
17>  *
18> */
19> 
20> declare @newStrainKey integer
21> declare @oldStrainKey integer
22> 
23> if (select count(_Strain_key) from PRB_Strain
24>     where strain = @strain and standard = @toStandard) > 1
25> begin
26>     rollback transaction
27>     raiserror 99999 "More than one designation exists for Strain: %1!", @strain
28>     return
29> end
30> 
31> if (select count(_Strain_key) from PRB_Strain
32>     where strain = @strain and standard = @toStandard) = 0
33> begin
34>     rollback transaction
35>     raiserror 99999 "No correct designation exists for Strain: %1!", @strain
36>     return
37> end
38> 
39> select @newStrainKey = _Strain_key from PRB_Strain
40> where strain = @strain and standard = @toStandard
41> 
42> declare strain_cursor cursor for
43> select _Strain_key
44> from PRB_Strain
45> where strain = @strain and standard = @fromStandard
46> for read only
47>  
48> open strain_cursor
49>  
50> fetch strain_cursor into @oldStrainKey
51>  
52> while (@@sqlstatus = 0)
53> begin
54>     exec PRB_mergeStrain @oldStrainKey, @newStrainKey
55>         fetch strain_cursor into @oldStrainKey
56> end
57>  
58> close strain_cursor
59>  
60> deallocate cursor strain_cursor
61>  
1> 
2> grant execute on PRB_mergeStandardStrain to editors
1>  
2> grant execute on PRB_mergeStandardStrain to progs
1>  
2> drop procedure PRB_getStrainReferences
1>  
2> create procedure PRB_getStrainReferences
3>   @strainKey int,
4>   @countOnly int = 0
5> as
6> 
7> /* Select all References and Data Sets for given Strain */
8>  
9> select distinct e._Refs_key, dataSet = 'Mapping'
10> into #references
11> from MLD_Expts e, MLD_InSitu m
12> where e._Expt_key = m._Expt_key
13> and m._Strain_key = @strainKey
14> union
15> select distinct e._Refs_key, dataSet = 'Mapping'
16> from MLD_Expts e, MLD_FISH m
17> where e._Expt_key = m._Expt_key
18> and m._Strain_key = @strainKey
19> union
20> select distinct e._Refs_key, dataSet = 'Mapping'
21> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
22> where e._Expt_key = m._Expt_key
23> and m._Cross_key = c._Cross_key
24> and c._femaleStrain_key = @strainKey
25> union
26> select distinct e._Refs_key, dataSet = 'Mapping'
27> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
28> where e._Expt_key = m._Expt_key
29> and m._Cross_key = c._Cross_key
30> and c._maleStrain_key = @strainKey
31> union
32> select distinct e._Refs_key, dataSet = 'Mapping'
33> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
34> where e._Expt_key = m._Expt_key
35> and m._Cross_key = c._Cross_key
36> and c._StrainHO_key = @strainKey
37> union
38> select distinct e._Refs_key, dataSet = 'Mapping'
39> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
40> where e._Expt_key = m._Expt_key
41> and m._Cross_key = c._Cross_key
42> and c._StrainHT_key = @strainKey
43> union
44> select distinct a._Refs_key, dataSet = 'Expression'
45> from GXD_Genotype s, GXD_Expression x, GXD_Assay a
46> where s._Strain_key = @strainKey
47> and s._Genotype_key = x._Genotype_key
48> and x._Assay_key = a._Assay_key
49> union
50> select distinct r._Refs_key, dataSet = 'RFLP'
51> from PRB_Reference r, PRB_RFLV v, PRB_Allele a, PRB_Allele_Strain s
52> where r._Reference_key = v._Reference_key
53> and v._RFLV_key = a._RFLV_key
54> and a._Allele_key = s._Allele_key
55> and s._Strain_key = @strainKey
56>  
57> if @countOnly = 1
58> begin
59>     select count(*) from #references
60> end
61> else
62> begin
63>     select a.jnumID, r.dataSet
64>     from #references r, BIB_View a
65>     where r._Refs_key = a._Refs_key
66>     order by a.jnum
67> end
68> 
1> 
2> grant execute on PRB_getStrainReferences to public
1>  
2> drop procedure PRB_getStrainDataSets
1>  
2> create procedure PRB_getStrainDataSets
3>   @strainKey int,
4>   @countOnly int = 0
5> as
6> 
7> /* Select all Probes and Data Sets for given Strain */
8>  
9> select _Source_key into #source from PRB_Source
10> where _Strain_key = @strainKey
11> order by _Source_key
12> 
13> if (select count(*) from #source) = 0
14> begin
15>     return
16> end
17> 
18> create unique clustered index index_Source_key on #source(_Source_key) with sorted_data
19> 
20> select p._Probe_key, dataSet = 'Molecular Segment'
21> into #probes
22> from PRB_Probe p, #source s
23> where p._Source_key = s._Source_key
24> union
25> select a._Antigen_key, dataSet = 'Antigen'
26> from GXD_Antigen a, #source s
27> where a._Source_key = s._Source_key
28> 
29> if @countOnly = 1
30> begin
31>     select count(*) from #probes
32> end
33> else
34> begin
35>     select a.accID, p.dataSet
36>     from #probes p, PRB_Acc_View a
37>     where p.dataSet = 'Molecular Segment'
38>     and p._Probe_key = a._Object_key
39>     and a.prefixPart = 'MGI:'
40>     and a.preferred = 1
41>     union
42>     select a.accID, p.dataSet
43>     from #probes p, GXD_Antigen_Acc_View a
44>     where p.dataSet = 'Antigen'
45>     and p._Probe_key = a._Object_key
46>     and a.prefixPart = 'MGI:'
47>     and a.preferred = 1
48>     order by a.accID
49> end
50> 
1> 
2> grant execute on PRB_getStrainDataSets to public
1>  
2> drop procedure PRB_mergeTissue
1>  
2> create procedure PRB_mergeTissue
3>   @oldTissueKey int,
4>   @newTissueKey int
5> as
6> 
7> /*
8>  * Update old Tissue key to new Tissue key
9>  * in all relevant tables which contain a Tissue key.
10>  * When finished, remove the Tissue record for the old
11>  * Tissue key.
12> */
13> 
14> update PRB_Source
15> set _Tissue_key = @newTissueKey
16> where _Tissue_key = @oldTissueKey
17> 
18> delete from PRB_Tissue
19> where _Tissue_key = @oldTissueKey
20> 
1> 
2> grant execute on PRB_mergeTissue to editors
1>  
2> grant execute on PRB_mergeTissue to progs
1>  
2> drop procedure PRB_mergeStandardTissue
1>  
2> create procedure PRB_mergeStandardTissue
3>   @tissue varchar(255),
4>   @fromStandard int = 0,
5>   @toStandard int = 1
6> as
7>  
8> /* Given a Tissue, merge all of the records into one Tissue.
9>  *
10>  * Merge all Non-Standard Tissues into the Standard Tissue (default)
11>  * (exec PRB_mergeStandardTissue "Tissue")
12>  *
13>  * OR
14>  *
15>  * Merge all Standard Tissues into the Non-Standard Tissue
16>  * (exec PRB_mergeStandardTissue "Tissue", 1, 0)
17>  *
18> */
19> 
20> declare @newTissueKey integer
21> declare @oldTissueKey integer
22> 
23> if (select count(_Tissue_key) from PRB_Tissue
24>     where tissue = @tissue and standard = @toStandard) > 1
25> begin
26>     rollback transaction
27>     raiserror 99999 "More than one designation exists for Tissue: %1!", @tissue
28>     return
29> end
30> 
31> if (select count(_Tissue_key) from PRB_Tissue
32>     where tissue = @tissue and standard = @toStandard) = 0
33> begin
34>     rollback transaction
35>     raiserror 99999 "No correct designation exists for Tissue: %1!", @tissue
36>     return
37> end
38> 
39> select @newTissueKey = _Tissue_key from PRB_Tissue
40> where tissue = @tissue and standard = @toStandard
41> 
42> declare tissue_cursor cursor for
43> select _Tissue_key
44> from PRB_Tissue
45> where tissue = @tissue and standard = @fromStandard
46> for read only
47>  
48> open tissue_cursor
49>  
50> fetch tissue_cursor into @oldTissueKey
51>  
52> while (@@sqlstatus = 0)
53> begin
54>     exec PRB_mergeTissue @oldTissueKey, @newTissueKey
55>         fetch tissue_cursor into @oldTissueKey
56> end
57>  
58> close tissue_cursor
59>  
60> deallocate cursor tissue_cursor
61>  
1> 
2> grant execute on PRB_mergeStandardTissue to editors
1>  
2> grant execute on PRB_mergeStandardTissue to progs
1>  
2> drop procedure PRB_getTissueDataSets
1>  
2> create procedure PRB_getTissueDataSets
3>   @tissueKey int,
4>   @countOnly int = 0
5> as
6> 
7> /* Select all Data Sets for given Tissue */
8>  
9> select _Source_key into #source from PRB_Source
10> where _Tissue_key = @tissueKey
11> order by _Source_key
12> 
13> if (select count(*) from #source) = 0
14> begin
15>     return
16> end
17> 
18> create unique clustered index index_Source_key on #source(_Source_key) with sorted_data
19> 
20> select dataKey = p._Probe_key, dataSet = 'Molecular Segment'
21> into #datasets
22> from PRB_Probe p, #source s
23> where p._Source_key = s._Source_key
24> union
25> select dataKey = a._Antigen_key, dataSet = 'Antigen'
26> from GXD_Antigen a, #source s
27> where a._Source_key = s._Source_key
28> 
29> if @countOnly = 1
30> begin
31>     select count(*) from #datasets
32> end
33> else
34> begin
35>     select a.accID, d.dataSet, a.numericPart
36>     from #datasets d, PRB_Acc_View a
37>     where d.datakey = a._Object_key
38>     and a.prefixPart = 'MGI:'
39>     and a.preferred = 1
40>     union
41>     select a.accID, d.dataSet, a.numericPart
42>     from #datasets d, GXD_Antigen_Acc_View a
43>     where d.datakey = a._Object_key
44>     and a.prefixPart = 'MGI:'
45>     and a.preferred = 1
46>     order by a.numericPart
47> end
48> 
1> 
2> grant execute on PRB_getTissueDataSets to public
1>  
2> checkpoint
1> 
2> drop procedure PRB_insertReference
1> 
2> create procedure PRB_insertReference
3>      @refKey integer,
4>      @probeKey integer,
5>      @holder varchar(40)
6> as
7> 
8> /* Insert record into PRB_Reference if _Refs_key/_Probe_key pair does not already exist */
9> 
10> if (select count(*) from PRB_Reference 
11>     where _Refs_key = @refKey and _Probe_key = @probeKey) > 0
12> begin
13>     return
14> end
15> 
16> declare @maxReferenceKey integer
17> select @maxReferenceKey = max(_Reference_key) + 1 from PRB_Reference
18> 
19> insert into PRB_Reference
20> values (@maxReferenceKey, @probeKey, @refKey, @holder, 0, 0, getdate(), getdate())
21> 
1> 
2> grant execute on PRB_insertReference to editors
1> 
2> grant execute on PRB_insertReference to progs
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view ACC_View
1> 
2> create view ACC_View
3> as
4> select a.*, MGIType = m.name,
5> LogicalDB = l.name, l.description, l._Species_key,
6> ActualDB = d.name, d.url, d.allowsMultiple, d.delimiter
7> from ACC_Accession a, ACC_MGIType m, ACC_LogicalDB l, ACC_ActualDB d
8> where a._MGIType_key = m._MGIType_key
9> and a._LogicalDB_Key = l._LogicalDB_key
10> and l._LogicalDB_key = d._LogicalDB_key
11> and d.active = 1
1> 
2> grant select on ACC_View to public
1>  
2> drop view ACC_LogicalDB_View
1> 
2> create view ACC_LogicalDB_View
3> as
4> select a.*, species = s.name
5> from ACC_LogicalDB a, MRK_Species s
6> where a._Species_key *= s._Species_key
1> 
2> grant select on ACC_LogicalDB_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view BIB_Acc_View
1> 
2> create view BIB_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 1
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on BIB_Acc_View to public
1>  
2> /* BIB_All_View contains all BIB_Refs records, their J#s */
3> /* a long citation and a short citation */
4> 
5> drop view BIB_All_View
1>  
2> create view BIB_All_View
3> as
4> select r.*, 
5> reviewStatus = s.name,
6> jnumID = a.accID, jnum = a.numericPart,
7> citation = r.journal + " " + r.date + ";" + r.vol + "(" + r.issue + "):" + r.pgs,
8> short_citation = r._primary + ", " + r.journal + " " + r.date + ";" + 
9> r.vol + "(" + r.issue + "):" + r.pgs
10> from BIB_Refs r, BIB_ReviewStatus s, ACC_Accession a
11> where r._ReviewStatus_key = s._ReviewStatus_key
12> and r._Refs_key = a._Object_key
13> and a._MGIType_key = 1
14> and a.prefixPart =  "J:"
15> and a.preferred = 1
1>  
2> grant select on BIB_All_View to public
1>  
2> /* BIB_View contains all non-Submission BIB_Refs records, */
3> /* their J#s, a long citation and a short citation */
4> /* Submission references are not currently accessible on the Web */
5> 
6> drop view BIB_View
1> 
2> create view BIB_View
3> as
4> select r.*,
5> reviewStatus = s.name,
6> jnumID = a.accID, jnum = a.numericPart,
7> citation = r.journal + " " + r.date + ";" + r.vol + "(" + r.issue + "):" + r.pgs,
8> short_citation = r._primary + ", " + r.journal + " " + r.date + ";" + 
9> r.vol + "(" + r.issue + "):" + r.pgs
10> from BIB_Refs r, BIB_ReviewStatus s, ACC_Accession a
11> where r._ReviewStatus_key = s._ReviewStatus_key
12> and r._Refs_key = a._Object_key
13> and a._MGIType_key = 1
14> and a.prefixPart =  "J:"
15> and a.preferred = 1
16> and (journal != 'Submission' or journal is null)
1> 
2> grant select on BIB_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view CRS_Cross_View
1> 
2> create view CRS_Cross_View
3> as
4> select c.*, display = whoseCross + " [Type " + type + " (" + abbrevHO + "/" + abbrevHT + ")]",
5> femaleStrain = s1.strain, maleStrain = s2.strain,
6> strainHO = s3.strain, strainHT = s4.strain
7> from CRS_Cross c, PRB_Strain s1, PRB_Strain s2, PRB_Strain s3, PRB_Strain s4
8> where c._femaleStrain_key = s1._Strain_key
9> and c._maleStrain_key = s2._Strain_key
10> and c._StrainHO_key = s3._Strain_key
11> and c._StrainHT_key = s4._Strain_key
1> 
2> grant select on CRS_Cross_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view GXD_Antigen_Acc_View
1>  
2> create view GXD_Antigen_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 7
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on GXD_Antigen_Acc_View to public
1> 
2> drop view GXD_Antibody_Acc_View
1>  
2> create view GXD_Antibody_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 6
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on GXD_Antibody_Acc_View to public
1> 
2> drop view GXD_Assay_Acc_View
1>  
2> create view GXD_Assay_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 8
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on GXD_Assay_Acc_View to public
1> 
2> drop view GXD_Antigen_View
1> 
2> create view GXD_Antigen_View
3> as
4> select g.*, mgiID = a.accID, a.prefixPart, a.numericPart,
5> s.species, s.age, s.sex, s.cellLine, library = s.name,
6> s.description, s._Refs_key, s._Strain_key, s.strain, s._Tissue_key, s.tissue
7> from GXD_Antigen g, GXD_Antigen_Acc_View a, PRB_Source_View s
8> where g._Antigen_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and a.preferred = 1
11> and g._Source_key = s._Source_key
1> 
2> grant select on GXD_Antigen_View to public
1>  
2> drop view GXD_Antibody_View
1>  
2> create view GXD_Antibody_View
3> as
4> select ab.*, mgiID = a.accID, a.prefixPart, a.numericPart, 
5> ac.class, ap.antibodyType, ag.antigenName
6> from GXD_Antibody ab, GXD_Antibody_Acc_View a, GXD_AntibodyClass ac, GXD_AntibodyType ap, GXD_Antigen ag
7> where ab._Antibody_key = a._Object_key
8> and a.prefixPart = "MGI:"
9> and a.preferred = 1
10> and ab._AntibodyClass_key = ac._AntibodyClass_key
11> and ab._AntibodyType_key = ap._AntibodyType_key
12> and ab._Antigen_key *= ag._Antigen_key
1>  
2> grant select on GXD_Antibody_View to public
1>  
2> drop view GXD_AntibodyRef_View
1>  
2> create view GXD_AntibodyRef_View
3> as
4> select a._Antibody_key, a._Refs_key, c.jnumID, c.jnum, c.short_citation
5> from GXD_Antibody a, BIB_All_View c
6> where a._Refs_key = c._Refs_key
1>  
2> grant select on GXD_AntibodyRef_View to public
1>  
2> drop view GXD_AntibodyAntigen_View
1>  
2> create view GXD_AntibodyAntigen_View
3> as
4> select ab._Antibody_key, ab.antibodyName, ag.*
5> from GXD_Antibody ab, GXD_Antigen_View ag
6> where ab._Antigen_key = ag._Antigen_key
1>  
2> grant select on GXD_AntibodyAntigen_View to public
1>  
2> drop view GXD_AntibodyMarker_View
1>  
2> create view GXD_AntibodyMarker_View
3> as
4> select a._Antibody_key, a.antibodyName, am._Marker_key, m.symbol, m.chromosome
5> from GXD_Antibody a, GXD_AntibodyMarker am, MRK_Marker m
6> where a._Antibody_key = am._Antibody_key
7> and am._Marker_key = m._Marker_key
1>  
2> grant select on GXD_AntibodyMarker_View to public
1>  
2> drop view GXD_AntibodyAlias_View
1>  
2> create view GXD_AntibodyAlias_View
3> as
4> select a.antibodyName, aa.*
5> from GXD_Antibody a, GXD_AntibodyAlias aa
6> where a._Antibody_key = aa._Antibody_key
1>  
2> grant select on GXD_AntibodyAlias_View to public
1>  
2> drop view GXD_AntibodyAliasRef_View
1>  
2> create view GXD_AntibodyAliasRef_View
3> as
4> select a.antibodyName, aa.*, c.jnumID, c.jnum, c.short_citation
5> from GXD_Antibody a, GXD_AntibodyAlias aa, BIB_All_View c
6> where a._Antibody_key = aa._Antibody_key
7> and aa._Refs_key = c._Refs_key
1>  
2> grant select on GXD_AntibodyAliasRef_View to public
1>  
2> drop view GXD_Assay_View
1> 
2> create view GXD_Assay_View
3> as
4> select g.*, mgiID = ac.accID, ac.prefixPart, ac.numericPart,
5> aty.assayType, aty.isRNAAssay, aty.isGelAssay,
6> m.symbol, m.chromosome, m.name,
7> c.jnumID, c.jnum, c.short_citation
8> from GXD_Assay g, GXD_Assay_Acc_View ac, GXD_AssayType aty, MRK_Marker m, BIB_All_View c
9> where g._Assay_key = ac._Object_key
10> and ac.prefixPart = "MGI:"
11> and ac.preferred = 1
12> and g._AssayType_key = aty._AssayType_key
13> and g._Marker_key = m._Marker_key
14> and g._Refs_key = c._Refs_key
1> 
2> grant select on GXD_Assay_View to public
1> 
2> drop view GXD_AntibodyPrep_View
1> 
2> create view GXD_AntibodyPrep_View
3> as
4> select a._Assay_key, ap.*, s.secondary, l.label, ab.antibodyName, ac.accID
5> from GXD_Assay a, GXD_AntibodyPrep ap, GXD_Secondary s, GXD_Label l,
6> GXD_Antibody ab, ACC_Accession ac
7> where a._AntibodyPrep_key = ap._AntibodyPrep_key
8> and ap._Secondary_key = s._Secondary_key
9> and ap._Label_key = l._Label_key
10> and ap._Antibody_key = ab._Antibody_key
11> and ab._Antibody_key = ac._Object_key
12> and ac._MGIType_key = 6
13> and ac.prefixPart = "MGI:"
14> and ac.preferred = 1
1> 
2> grant select on GXD_AntibodyPrep_View to public
1> 
2> drop view GXD_ProbePrep_View
1>  
2> create view GXD_ProbePrep_View
3> as
4> select a._Assay_key, pp.*, s.sense, l.label, c.coverage, v.visualization, probeName = p.name, ac.accID
5> from GXD_Assay a, GXD_ProbePrep pp, GXD_ProbeSense s, GXD_Label l, GXD_LabelCoverage c, GXD_VisualizationMethod v,
6> PRB_Probe p, ACC_Accession ac
7> where a._ProbePrep_key = pp._ProbePrep_key
8> and pp._Sense_key = s._Sense_key
9> and pp._Label_key = l._Label_key
10> and pp._Coverage_key = c._Coverage_key
11> and pp._Visualization_key = v._Visualization_key
12> and pp._Probe_key = p._Probe_key
13> and p._Probe_key = ac._Object_key
14> and ac._MGIType_key = 3
15> and ac.prefixPart = "MGI:"
16> and ac.preferred = 1
1>  
2> grant select on GXD_ProbePrep_View to public
1>  
2> drop view GXD_Genotype_View
1>  
2> create view GXD_Genotype_View
3> as
4> select g.*, s.strain
5> from GXD_Genotype g, PRB_Strain s
6> where g._Strain_key = s._Strain_key
1>  
2> grant select on GXD_Genotype_View to public
1>  
2> drop view GXD_AllelePair_View
1> 
2> create view GXD_AllelePair_View
3> as
4> select a.*, m.symbol, allele1 = a1.symbol, allele2 = a2.symbol
5> from GXD_AllelePair a, MRK_Marker m, MRK_Allele a1, MRK_Allele a2
6> where a._Marker_key = m._Marker_key
7> and a._Allele_key_1 = a1._Allele_key
8> and a._Allele_key_2 *= a2._Allele_key
1> 
2> grant select on GXD_AllelePair_View to public
1> 
2> drop view GXD_Specimen_View
1> 
2> create view GXD_Specimen_View
3> as
4> select s.*, e.embeddingMethod, f.fixation, g.strain
5> from GXD_Specimen s, GXD_EmbeddingMethod e, GXD_FixationMethod f, GXD_Genotype_View g
6> where s._Embedding_key = e._Embedding_key
7> and s._Fixation_key = f._Fixation_key
8> and s._Genotype_key = g._Genotype_key
1> 
2> grant select on GXD_Specimen_View to public
1> 
2> drop view GXD_InSituResult_View
1> 
2> create view GXD_InSituResult_View
3> as
4> select r.*, s.strength, p.pattern
5> from GXD_InSituResult r, GXD_Strength s, GXD_Pattern p
6> where r._Strength_key = s._Strength_key
7> and r._Pattern_key = p._Pattern_key
1> 
2> grant select on GXD_InSituResult_View to public
1> 
2> drop view GXD_ISResultImage_View
1> 
2> create view GXD_ISResultImage_View
3> as
4> /* figurepaneLabel is the concatenation of figureLabel and paneLabel for display purposes */
5> select r._Specimen_key, r.sequenceNum, i.*, figurepaneLabel = m.figureLabel + convert(varchar(10), p.paneLabel), 
6> p._Image_key, p.paneLabel, m.figureLabel, m.xDim, m.yDim
7> from GXD_InSituResult r, GXD_InSituResultImage i, IMG_ImagePane p, IMG_Image m
8> where r._Result_key = i._Result_key
9> and i._ImagePane_key = p._ImagePane_key
10> and p._Image_key = m._Image_key
1> 
2> grant select on GXD_ISResultImage_View to public
1> 
2> drop view GXD_GelLane_View
1> 
2> create view GXD_GelLane_View
3> as
4> /* sampleAmount_str is a string version of sampleAmount without trailing zeroes for display purposes */
5> select l.*, t.rnaType, g.strain, c.gelLaneContent,
6> sampleAmount_str = ltrim(str(l.sampleAmount,10,2))
7> from GXD_GelLane l, GXD_GelRNAType t, GXD_Genotype_View g, GXD_GelControl c
8> where l._GelRNAType_key = t._GelRNAType_key
9> and l._Genotype_key = g._Genotype_key
10> and l._GelControl_key = c._GelControl_key
1> 
2> grant select on GXD_GelLane_View to public
1> 
2> drop view GXD_GelRow_View
1> 
2> create view GXD_GelRow_View
3> as
4> /* size_str is a string version of size without trailing zeroes for display purposes */
5> select l.*, size_str = ltrim(str(l.size,10,2)), u.units
6> from GXD_GelRow l, GXD_GelUnits u
7> where l._GelUnits_key = u._GelUnits_key
1> 
2> grant select on GXD_GelRow_View to public
1> 
2> drop view GXD_GelBand_View
1> 
2> create view GXD_GelBand_View
3> as
4> select b.*, s.strength, l._Assay_key, laneNum = l.sequenceNum, rowNum = r.sequenceNum
5> from GXD_GelBand b, GXD_Strength s, GXD_GelLane l, GXD_GelRow r
6> where b._Strength_key = s._Strength_key
7> and b._GelLane_key = l._GelLane_key
8> and b._GelRow_key = r._GelRow_key
1> 
2> grant select on GXD_GelBand_View to public
1> 
2> drop view GXD_GelLaneStructure_View
1> 
2> create view GXD_GelLaneStructure_View
3> as
4> select l._Assay_key, l.sequenceNum, g.*, s.printName, t.stage, t._Stage_key,
5> dbName = "[DB]:  Stage" + convert(varchar(5), t.stage) + ";" + s.printName
6> from GXD_GelLane l, GXD_GelLaneStructure g, GXD_Structure s, GXD_TheilerStage t
7> where l._GelLane_key = g._GelLane_key
8> and g._Structure_key = s._Structure_key
9> and s._Stage_key = t._Stage_key
1> 
2> grant select on GXD_GelLaneStructure_View to public
1> 
2> drop view GXD_ISResultStructure_View
1> 
2> create view GXD_ISResultStructure_View
3> as
4> select r._Specimen_key, r.sequenceNum, g.*, s.printName, t.stage, t._Stage_key,
5> dbName = "[DB]:  Stage" + convert(varchar(5), t.stage) + ";" + s.printName
6> from GXD_InSituResult r, GXD_ISResultStructure g, GXD_Structure s, GXD_TheilerStage t
7> where r._Result_key = g._Result_key
8> and g._Structure_key = s._Structure_key
9> and s._Stage_key = t._Stage_key
1> 
2> grant select on GXD_ISResultStructure_View to public
1> 
2> drop view GXD_Index_View
1> 
2> create view GXD_Index_View
3> as
4> select i.*, m.symbol, c.jnumID, c.jnum, c.short_citation
5> from GXD_Index i, MRK_Marker m, BIB_All_View c
6> where i._Marker_key = m._Marker_key
7> and i._Refs_key = c._Refs_key
1> 
2> grant select on GXD_Index_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view HMD_Homology_View
1> 
2> create view HMD_Homology_View
3> as
4> select r._Class_key, r._Refs_key, r.creation_date, r.modification_date,
5> classRef = convert(varchar(10), r._Class_key) + ':' + convert(varchar(10), r._Refs_key),
6> h._Homology_key, h._Marker_key,
7> m.symbol, m.name, m.chromosome, m.cytogeneticOffset,
8> m._Species_key, m.species, m.commonName, m.latinName,
9> b.jnumID, b.jnum, b.short_citation,
10> o.offset
11> from HMD_Homology r, HMD_Homology_Marker h, 
12> MRK_Marker_View m, BIB_View b, MRK_Offset o
13> where r._Homology_key = h._Homology_key
14> and h._Marker_key = m._Marker_key
15> and r._Refs_key = b._Refs_key
16> and h._Marker_key *= o._Marker_key
17> and o.source = 0
1> 
2> grant select on HMD_Homology_View to public
1> 
2> drop view HMD_Homology_Assay_View
1> 
2> create view HMD_Homology_Assay_View
3> as
4> select h.*, a.assay
5> from HMD_Homology_Assay h, HMD_Assay a
6> where h._Assay_key = a._Assay_key
1> 
2> grant select on HMD_Homology_Assay_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view IMG_Image_Acc_View
1>  
2> create view IMG_Image_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 9
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on IMG_Image_Acc_View to public
1> 
2> drop view IMG_Image_View
1> 
2> create view IMG_Image_View
3> as
4> select i.*, mgiID = a.accID, a.prefixPart, a.numericPart,
5> c.jnumID, c.jnum, c.short_citation
6> from IMG_Image i, IMG_Image_Acc_View a, BIB_All_View c
7> where i._Image_key = a._Object_key
8> and a.prefixPart = "MGI:"
9> and a.preferred = 1
10> and i._Refs_key = c._Refs_key
1> 
2> grant select on IMG_Image_View to public
1> 
2> drop view IMG_ImagePane_View
1> 
2> create view IMG_ImagePane_View
3> as
4> select i.*, f.fieldType
5> from IMG_ImagePane i, IMG_FieldType f
6> where i._FieldType_key = f._FieldType_key
1> 
2> grant select on IMG_ImagePane_View to public
1> 
2> drop view IMG_ImagePaneRef_View
1> 
2> create view IMG_ImagePaneRef_View
3> as
4> select r._Image_key, r._Refs_key, i._ImagePane_key, paneLabel = r.figureLabel + i.paneLabel,
5> c.jnumID, c.jnum, c.short_citation
6> from IMG_Image r, IMG_ImagePane i, BIB_All_View c
7> where r._Image_key = i._Image_key
8> and r._Refs_key = c._Refs_key
1> 
2> grant select on IMG_ImagePaneRef_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view MGI_Table_Column_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'MGI_Table_Column_View', because it doesn't exist in the
system catalogs.
1> 
2> create view MGI_Table_Column_View
3> as 
4> SELECT _Table_id = t._Table_id, table_name = o.name, table_description = t.description,
5> column_name = c.name, _Column_id = cc._Column_id, column_description = cc.description,
6> example = cc.example, t.creation_date, t.modification_date
7> FROM
8> syscolumns c, MGI_Columns cc, sysobjects o, MGI_Tables t
9> WHERE
10> o.id = t._Table_id AND cc._Column_id = c.colid AND
11> o.id = c.id AND cc._Table_id = t._Table_id AND ((o.type='U'))
1> 
2> grant select on MGI_Table_Column_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view MLD_Acc_View
1>  
2> create view MLD_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 4
7> and a._LogicalDB_key = l._LogicalDB_key
1>  
2> grant select on MLD_Acc_View to public
1>  
2> drop view MLD_Marker_View
1> 
2> create view MLD_Marker_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, g.*, m.symbol, c._primary, c.authors
5> from BIB_View c, MLD_Marker g, MRK_Marker m
6> where g._Refs_key = c._Refs_key
7> and g._Marker_key = m._Marker_key
1> 
2> grant select on MLD_Marker_View to public
1> 
2> drop view MLD_Expt_View
1> 
2> create view MLD_Expt_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, x.*, c._primary, c.authors, 
5> mgiID = a.accID, a.prefixPart, a.numericPart
6> from BIB_View c, MLD_Expts x, MLD_Acc_View a
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and a.preferred = 1
1> 
2> grant select on MLD_Expt_View to public
1> 
2> drop view MLD_Expt_Marker_View
1> 
2> create view MLD_Expt_Marker_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, m.symbol, x.exptType, x.tag, e.*, 
5> allele = al.symbol, assay = a.description, c._primary, c.authors
6> from BIB_View c, MLD_Expts x, MLD_Expt_Marker e, MRK_Allele al, MLD_Assay_Types a, MRK_Marker m
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key = m._Marker_key
10> and e._Allele_key *= al._Allele_key
11> and e._Assay_Type_key = a._Assay_Type_key
1> 
2> grant select on MLD_Expt_Marker_View to public
1> 
2> drop view MLD_FISH_View
1> 
2> create view MLD_FISH_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, s.strain, c._primary, c.authors
5> from BIB_View c, MLD_Expts x, MLD_FISH e, PRB_Strain s
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Strain_key = s._Strain_key
1> 
2> grant select on MLD_FISH_View to public
1> 
2> drop view MLD_Hybrid_View
1> 
2> create view MLD_Hybrid_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, c._primary, c.authors 
5> from BIB_View c, MLD_Expts x, MLD_Hybrid e
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
1> 
2> grant select on MLD_Hybrid_View to public
1> 
2> drop view MLD_Concordance_View
1> 
2> create view MLD_Concordance_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, m.symbol, c._primary, c.authors 
5> from BIB_View c, MLD_Expts x, MLD_Concordance e, MRK_Marker m
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Marker_key *= m._Marker_key
1> 
2> grant select on MLD_Concordance_View to public
1> 
2> drop view MLD_InSitu_View
1> 
2> create view MLD_InSitu_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, s.strain, c._primary, c.authors
5> from BIB_View c, MLD_Expts x, MLD_InSitu e, PRB_Strain s
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Strain_key = s._Strain_key
1> 
2> grant select on MLD_InSitu_View to public
1> 
2> drop view MLD_Matrix_View
1> 
2> create view MLD_Matrix_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, x.tag,
5> e._Expt_key, e.female, e.female2, e.male, e.male2,
6> s.*,
7> femaleStrain = s1.strain, maleStrain = s2.strain,
8> strainHO = s3.strain, strainHT = s4.strain,
9> c._primary, c.authors
10> from BIB_View c, MLD_Expts x, MLD_Matrix e, CRS_Cross s,
11> PRB_Strain s1, PRB_Strain s2, PRB_Strain s3, PRB_Strain s4
12> where c._Refs_key = x._Refs_key
13> and x._Expt_key = e._Expt_key
14> and e._Cross_key = s._Cross_key
15> and s._femaleStrain_key = s1._Strain_key
16> and s._maleStrain_key = s2._Strain_key
17> and s._StrainHO_key = s3._Strain_key
18> and s._StrainHT_key = s4._Strain_key
1> 
2> grant select on MLD_Matrix_View to public
1> 
2> drop view MLD_MC2point_View
1> 
2> create view MLD_MC2point_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, c._primary, c.authors 
6> from BIB_View c, MLD_Expts x, MLD_MC2point e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_MC2point_View to public
1> 
2> drop view MLD_Statistics_View
1> 
2> create view MLD_Statistics_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, x.exptType, x.tag, c._primary, c.authors
6> from BIB_View c, MLD_Expts x, MLD_Statistics e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_Statistics_View to public
1> 
2> drop view MLD_Distance_View
1> 
2> create view MLD_Distance_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, c._primary, c.authors
6> from BIB_View c, MLD_Expts x, MLD_Distance e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_Distance_View to public
1> 
2> drop view MLD_RI_View
1> 
2> create view MLD_RI_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, x.tag, e._Expt_key, e.RI_IdList, 
5> s._RISet_key, s.origin, s.designation, abbrev1 = rtrim(s.abbrev1), abbrev2 = rtrim(s.abbrev2), 
6> c._primary, c.authors 
7> from BIB_View c, MLD_Expts x, MLD_RI e, RI_RISet s
8> where c._Refs_key = x._Refs_key
9> and x._Expt_key = e._Expt_key
10> and e._RISet_key *= s._RISet_key
1> 
2> grant select on MLD_RI_View to public
1> 
2> drop view MLD_RIData_View
1> 
2> create view MLD_RIData_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, m.symbol, c._primary, c.authors 
5> from BIB_View c, MLD_Expts x, MLD_RIData e, MRK_Marker m
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Marker_key = m._Marker_key
1> 
2> grant select on MLD_RIData_View to public
1> 
2> drop view MLD_RI2Point_View
1> 
2> create view MLD_RI2Point_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, c._primary, c.authors 
6> from BIB_View c, MLD_Expts x, MLD_RI2Point e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_RI2Point_View to public
1> 
2> drop view MLD_Hit_View
1>  
2> create view MLD_Hit_View
3> as
4> select x.*, probeKey = h._Probe_key, probe = p1.name, 
5> targetKey = h._Target_key, target = p2.name
6> from MLD_Expts x, MLD_Hit h, PRB_Probe p1, PRB_Probe p2
7> where x._Expt_key = h._Expt_key
8> and h._Probe_key = p1._Probe_key
9> and h._Target_key = p2._Probe_key
1>  
2> grant select on MLD_Hit_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view MRK_Acc_View
1> 
2> create view MRK_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 2
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on MRK_Acc_View to public
1>  
2> drop view MRK_Marker_View
1>  
2> create view MRK_Marker_View
3> as
4> select m.*, 
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species
7> from MRK_Marker m, MRK_Species s
8> where m._Species_key = s._Species_key
1> 
2> grant select on MRK_Marker_View to public
1>  
2> drop view MRK_Mouse_View
1>  
2> create view MRK_Mouse_View
3> as
4> select m.*, o.offset, offset_str = str(o.offset,10,2),
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> mgiID = a.accID, a.prefixPart, a.numericPart, a._Accession_key,
8> markerType = t.name
9> from MRK_Marker m, MRK_Offset o, MRK_Species s, MRK_Acc_View a, MRK_Types t
10> where m._Species_key = 1
11> and m._Marker_key = o._Marker_key
12> and o.source = 0
13> and m._Species_key = s._Species_key
14> and m._Marker_key = a._Object_key
15> and a.prefixPart = "MGI:"
16> and a.preferred = 1
17> and m._Marker_Type_key = t._Marker_Type_key
1> 
2> grant select on MRK_Mouse_View to public
1>  
2> drop view MRK_NonMouse_View
1> 
2> create view MRK_NonMouse_View
3> as
4> select m.*,
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> a.accID, a._Accession_key
8> from MRK_Marker m, MRK_Species s, MRK_Acc_View a
9> where m._Species_key != 1
10> and m._Species_key = s._Species_key
11> and m._Marker_key = a._Object_key
1> 
2> grant select on MRK_NonMouse_View to public
1> 
2> drop view MRK_Alias_View
1> 
2> create view MRK_Alias_View
3> as
4> select a.*, alias = m1.symbol, m2.symbol
5> from MRK_Alias a, MRK_Marker m1, MRK_Marker m2
6> where a._Marker_key = m2._Marker_key
7> and a._Alias_key = m1._Marker_key
1> 
2> grant select on MRK_Alias_View to public
1> 
2> drop view MRK_Classes_View
1> 
2> create view MRK_Classes_View
3> as
4> select c.*, m.symbol, l.name
5> from MRK_Classes c, MRK_Marker m, MRK_Class l
6> where c._Marker_key = m._Marker_key
7> and c._Class_key = l._Class_key
1> 
2> grant select on MRK_Classes_View to public
1> 
2> drop view MRK_History_View
1> 
2> create view MRK_History_View
3> as
4> select h.*, event_display = convert(char(10), h.event_date, 101), history = m1.symbol, m2.symbol
5> from MRK_History h, MRK_Marker m1, MRK_Marker m2
6> where h._Marker_key = m2._Marker_key
7> and h._History_key = m1._Marker_key
1> 
2> grant select on MRK_History_View to public
1> 
2> drop view MRK_History_Ref_View
1>  
2> create view MRK_History_Ref_View
3> as
4> select h.*, event_display = convert(char(10), h.event_date, 101), 
5> history = m1.symbol, m2.symbol,
6> b.jnumID, b.jnum, b.short_citation
7> from MRK_History h, MRK_Marker m1, MRK_Marker m2, BIB_View b
8> where h._Marker_key = m2._Marker_key
9> and h._History_key = m1._Marker_key
10> and h._Refs_key = b._Refs_key
1>  
2> grant select on MRK_History_Ref_View to public
1>  
2> drop view MRK_Current_View
1> 
2> create view MRK_Current_View
3> as
4> select c.*, current_symbol = m1.symbol, m2.symbol, m1.chromosome, m1._Marker_Type_key
5> from MRK_Current c, MRK_Marker m1, MRK_Marker m2
6> where c._Marker_key = m2._Marker_key
7> and c._Current_key = m1._Marker_key
1> 
2> grant select on MRK_Current_View to public
1> 
2> drop view MRK_Anchors_View
1> 
2> create view MRK_Anchors_View
3> as
4> select a.*, m.symbol
5> from MRK_Anchors a, MRK_Marker m
6> where a._Marker_key = m._Marker_key
1> 
2> grant select on MRK_Anchors_View to public
1> 
2> drop view MRK_Reference_View
1> 
2> create view MRK_Reference_View
3> as
4> select r.*, m.symbol, b.jnumID, b.jnum, b.short_citation
5> from MRK_Reference r, MRK_Marker m, BIB_View b
6> where r._Marker_key = m._Marker_key
7> and r._Refs_key = b._Refs_key
1> 
2> grant select on MRK_Reference_View to public
1> 
2> drop view MRK_AccRef_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'MRK_AccRef_View', because it doesn't exist in the system
catalogs.
1>  
2> create view MRK_AccRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, ar._Refs_key, b.jnum, b.short_citation
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, BIB_All_View b
6> where a._MGIType_key = 2
7> and a._Accession_key = ar._Accession_key
8> and a._LogicalDB_key = l._LogicalDB_key
9> and a._MGIType_key = m._MGIType_key
10> and ar._Refs_key = b._Refs_key
1>  
2> grant select on MRK_AccRef_View to public
1> 
2> drop view MRK_AccNoRef_View
Msg 3701, Level 11, State 1:
Line 2:
Cannot drop the view 'MRK_AccNoRef_View', because it doesn't exist in the system
catalogs.
1>  
2> create view MRK_AccNoRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name,
5> subType = mt.name,
6> description = ma.symbol + ", " + ma.name + ", Chr " + ma.chromosome
7> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, MRK_Marker ma, MRK_Types mt
8> where a._MGIType_key = 2
9> and a._LogicalDB_key = l._LogicalDB_key
10> and a._MGIType_key = m._MGIType_key
11> and a._Object_key = ma._Marker_key
12> and ma._Marker_Type_key = mt._Marker_Type_key
13> and not exists (select r.* from ACC_AccessionReference r
14> where a._Accession_key = r._Accession_key)
1>  
2> grant select on MRK_AccNoRef_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view PRB_Acc_View
1> 
2> create view PRB_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 3
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on PRB_Acc_View to public
1> 
2> drop view PRB_AccNoRef_View
1> 
2> create view PRB_AccNoRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, description = p.name
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, PRB_Probe p
6> where a._MGIType_key = 3
7> and a._LogicalDB_key = l._LogicalDB_key
8> and a._MGIType_key = m._MGIType_key
9> and a._Object_key = p._Probe_key
10> and not exists (select r.* from ACC_AccessionReference r
11> where a._Accession_key = r._Accession_key)
1> 
2> grant select on PRB_AccNoRef_View to public
1> 
2> drop view PRB_AccRef_View
1> 
2> create view PRB_AccRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, r._Reference_key
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, PRB_Reference r
6> where a._Accession_key = ar._Accession_key
7> and a._LogicalDB_key = l._LogicalDB_key
8> and a._MGIType_key = m._MGIType_key
9> and a._Object_key = r._Probe_key
10> and ar._Refs_key = r._Refs_key
1> 
2> grant select on PRB_AccRef_View to public
1> 
2> drop view PRB_Source_View
1>  
2> create view PRB_Source_View
3> as
4> select p.*, s.strain, sStandard = s.standard, t.tissue, tStandard = t.standard
5> from PRB_Source p, PRB_Strain s, PRB_Tissue t
6> where p._Strain_key = s._Strain_key 
7> and p._Tissue_key = t._Tissue_key 
1> 
2> grant select on PRB_Source_View to public
1>  
2> drop view PRB_View
1> 
2> create view PRB_View
3> as
4> select p.*, v.vectorType, mgiID = a.accID, a.prefixPart, a.numericPart,
5> s.species, s.age, s.sex, s.cellLine, library = s.name,
6> s.description, s._Refs_key, s._Strain_key, s.strain, s._Tissue_key, s.tissue
7> from PRB_Probe p, PRB_Acc_View a, PRB_Source_View s, PRB_Vector_Types v
8> where p._Probe_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and a.preferred = 1
11> and p._Vector_key = v._Vector_key
12> and p._Source_key = s._Source_key
1> 
2> grant select on PRB_View to public
1> 
2> drop view PRB_Primer_View
1>  
2> create view PRB_Primer_View
3> as
4> select p._Probe_key, p.name,
5> p.regionCovered,
6> p.regionCovered2,
7> p.DNAtype, p.primer1sequence, p.primer2sequence,
8> p.repeatUnit, p.productSize, p.moreProduct,
9> p.creation_date, p.modification_date,
10> mgiID = a.accID, a.prefixPart, a.numericPart
11> from PRB_Probe p, PRB_Acc_View a
12> where p.DNAtype = "primer"
13> and p._Probe_key = a._Object_key
14> and a.prefixPart = "MGI:"
1>   
2> grant select on PRB_Primer_View to public
1>     
2> drop view PRB_Probe_View
1>  
2> create view PRB_Probe_View
3> as
4> select p._Probe_key, p.name,
5> p.regionCovered,
6> p.regionCovered2,
7> p.insertSize, p.DNAtype,
8> p.derivedFrom, parentClone = p2.name,
9> p._Vector_key, v.vectorType, p.insertSite,
10> p.creation_date, p.modification_date,
11> s._Source_key, sourceName = s.name, s._Refs_key,
12> s.species, s.age, s.sex, s.cellLine, s._Strain_key, s.strain, s._Tissue_key, s.tissue,
13> mgiID = a.accID, a.prefixPart, a.numericPart
14> from PRB_Probe p, PRB_Acc_View a, PRB_Source_View s, PRB_Vector_Types v, PRB_Probe p2
15> where p.DNAtype != "primer"
16> and p._Probe_key = a._Object_key
17> and a.prefixPart = "MGI:"
18> and p._Source_key = s._Source_key
19> and p._Vector_key = v._Vector_key
20> and p.derivedFrom *= p2._Probe_key
1> 
2> grant select on PRB_Probe_View to public
1>  
2> drop view PRB_Parent_View
1> 
2> create view PRB_Parent_View
3> as
4> select p._Probe_key, p.name, a.accID, accPrefix = a.prefixPart, accNumeric = a.numericPart,
5> parentKey = p2._Probe_key, parentClone = p2.name,
6> parentID = a2.accID, parentPrefix = a2.prefixPart, parentNumeric = a2.numericPart
7> from PRB_Probe p, PRB_Acc_View a, PRB_Probe p2, PRB_Acc_View a2
8> where p._Probe_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and p.derivedFrom = p2._Probe_key
11> and p2._Probe_key = a2._Object_key
12> and a2.prefixPart = "MGI:"
1> 
2> grant select on PRB_Parent_View to public
1> 
2> drop view PRB_Marker_View
1> 
2> create view PRB_Marker_View
3> as
4> select g._Probe_key, p.name, g._Marker_key, m.symbol, m.chromosome, g.relationship
5> from PRB_Probe p, PRB_Marker g, MRK_Marker m
6> where p._Probe_key = g._Probe_key
7> and g._Marker_key = m._Marker_key
1> 
2> grant select on PRB_Marker_View to public
1> 
2> drop view PRB_Reference_View
1> 
2> create view PRB_Reference_View
3> as
4> select c.jnum, c.jnumID, c.short_citation, r.*
5> from PRB_Reference r, BIB_All_View c
6> where r._Refs_key = c._Refs_key
1> 
2> grant select on PRB_Reference_View to public
1> 
2> drop view PRB_RFLV_View
1> 
2> create view PRB_RFLV_View
3> as
4> select r.*, a._Allele_key, a.allele, a.fragments, s.strain, m.symbol, s._Strain_key
5> from PRB_RFLV r, PRB_Allele a, PRB_Allele_Strain p, PRB_Strain s, MRK_Marker m
6> where r._RFLV_key = a._RFLV_key
7> and a._Allele_key = p._Allele_key
8> and p._Strain_key = s._Strain_key
9> and r._Marker_key = m._Marker_key
1> 
2> grant select on PRB_RFLV_View to public
1> 
2> drop view PRB_SourceRef_View
1>  
2> create view PRB_SourceRef_View
3> as
4> select p.*, c.jnumID, c.jnum, c.short_citation
5> from PRB_Source_View p, BIB_All_View c
6> where p._Refs_key = c._Refs_key
1> 
2> grant select on PRB_SourceRef_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> drop view BIB_Summary_All_View
1> 
2> create view BIB_Summary_All_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
8> from ACC_Accession a, ACC_Accession a2, BIB_Refs b
9> where a._MGIType_key = 1
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 1
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = b._Refs_key
1> 
2> grant select on BIB_Summary_All_View to public
1>  
2> drop view BIB_Summary_View
1> 
2> create view BIB_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
8> from ACC_Accession a, ACC_Accession a2, BIB_Refs b
9> where a._MGIType_key = 1
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 1
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = b._Refs_key
17> and (b.journal != 'Submission' or b.journal is null)
1> 
2> grant select on BIB_Summary_View to public
1>  
2> drop view MRK_Summary_View
1>  
2> create view MRK_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = mt.name,
7> description = m.symbol + ", " + m.name + ", Chr " + m.chromosome
8> from ACC_Accession a, ACC_Accession a2, MRK_Marker m, MRK_Types mt
9> where a._MGIType_key = 2
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 2
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = m._Marker_key
17> and m._Species_key = 1
18> and m._Marker_Type_key = mt._Marker_Type_key
1>  
2> grant select on MRK_Summary_View to public
1>  
2> drop view HMD_Summary_View
1>  
2> create view HMD_Summary_View
3> as
4> select a.*,
5> mgiID = null,
6> subType = mt.name,
7> description = m.symbol + ", " + m.name + ", Chr " + m.chromosome
8> from ACC_Accession a, MRK_Marker m, MRK_Types mt
9> where a._MGIType_key = 2
10> and a.private = 0
11> and a._Object_key = m._Marker_key
12> and m._Species_key != 1
13> and m._Marker_Type_key = mt._Marker_Type_key
1>  
2> grant select on HMD_Summary_View to public
1> 
2> drop view PRB_Summary_View
1>  
2> create view PRB_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = p.DNAtype,
7> description = p.name
8> from ACC_Accession a, ACC_Accession a2, PRB_Probe p
9> where a._MGIType_key = 3
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 3
14> and a2.prefixPart = "MGI:"
15> and a._Object_key = p._Probe_key
1>  
2> grant select on PRB_Summary_View to public
1>  
2> drop view MLD_Summary_View
1>  
2> create view MLD_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = e.exptType,
7> description = b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
8> from ACC_Accession a, ACC_Accession a2, MLD_Expts e, BIB_Refs b
9> where a._MGIType_key = 4
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 4
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = e._Expt_key
17> and e._Refs_key = b._Refs_key
1>  
2> grant select on MLD_Summary_View to public
1>  
2> drop view GXD_Antibody_Summary_View
1>  
2> create view GXD_Antibody_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = t.antibodyType,
7> description = g.antibodyName
8> from ACC_Accession a, ACC_Accession a2, GXD_Antibody g, GXD_AntibodyType t
9> where a._MGIType_key = 6
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 6
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = g._Antibody_key
17> and g._AntibodyType_key = t._AntibodyType_key
1>  
2> grant select on GXD_Antibody_Summary_View to public
1>  
2> drop view GXD_Antigen_Summary_View
1>  
2> create view GXD_Antigen_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = g.antigenName
8> from ACC_Accession a, ACC_Accession a2, GXD_Antigen g
9> where a._MGIType_key = 7
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 7
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = g._Antigen_key
1>  
2> grant select on GXD_Antigen_Summary_View to public
1> 
2> drop view GXD_Assay_Summary_View
1>  
2> create view GXD_Assay_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = t.assayType,
7> description = m.symbol
8> from ACC_Accession a, ACC_Accession a2, GXD_Assay g, GXD_AssayType t, MRK_Marker m
9> where a._MGIType_key = 8
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 8
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = g._Assay_key
17> and g._AssayType_key = t._AssayType_key
18> and g._Marker_key = m._Marker_key
1>   
2> grant select on GXD_Assay_Summary_View to public
1> 
2> drop view IMG_Image_Summary_View
1>  
2> create view IMG_Image_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = g.figureLabel + " " + 
8> b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
9> from ACC_Accession a, ACC_Accession a2, IMG_Image g, BIB_Refs b
10> where a._MGIType_key = 9
11> and a.private = 0
12> and a._Object_key = a2._Object_key
13> and a2._LogicalDB_key = 1
14> and a2._MGIType_key = 9
15> and a2.prefixPart = "MGI:"
16> and a2.preferred = 1
17> and a._Object_key = g._Image_key
18> and g._Refs_key = b._Refs_key
1>  
2> grant select on IMG_Image_Summary_View to public
1> 
2> checkpoint
setenv DSQUERY MGD
setenv MGD mgd
set scripts = /opt/sybase/admin/permissions
/opt/sybase/admin/permissions/ACC.grant MGD mgd
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12633.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12633.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> grant all on ACC_Accession to progs
1> 
2> grant all on ACC_Accession to editors
1> 
2> grant select on ACC_Accession to public
1> 
2> grant all on ACC_AccessionMax to progs
1> 
2> grant all on ACC_AccessionMax to editors
1> 
2> grant select on ACC_AccessionMax to public
1> 
2> grant all on ACC_AccessionReference to progs
1> 
2> grant all on ACC_AccessionReference to editors
1> 
2> grant select on ACC_AccessionReference to public
1> 
2> grant all on ACC_ActualDB to progs
1> 
2> grant select on ACC_ActualDB to public
1> 
2> grant all on ACC_LogicalDB to progs
1> 
2> grant select on ACC_LogicalDB to public
1> 
2> grant all on ACC_MGIType to progs
1> 
2> grant select on ACC_MGIType to public
1> 
2> checkpoint
rm /tmp/12633.sql
/opt/sybase/admin/permissions/BIB.grant MGD mgd
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12643.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12643.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> revoke all on BIB_Books from progs
1> 
2> revoke all on BIB_Books from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on BIB_Books to progs
1> 
2> grant all on BIB_Books to rmb, djr, neb, jeo, mgm, jjm
1> 
2> grant select on BIB_Books to public
1> 
2> revoke all on BIB_Notes from progs
1> 
2> revoke all on BIB_Notes from editors
1> 
2> grant all on BIB_Notes to progs
1> 
2> grant all on BIB_Notes to editors 
1> 
2> grant all on BIB_Notes to rmb, djr, neb, jeo, mgm, jjm
1> 
2> grant select on BIB_Notes to public
1> 
2> revoke all on BIB_Refs from progs
1> 
2> revoke all on BIB_Refs from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on BIB_Refs to progs
1> 
2> grant all on BIB_Refs to rmb, djr, neb, jeo, mgm, jjm, sr, ljm, apd, cml, wjb
1> 
2> grant update on BIB_Refs to editors
1> 
2> grant select on BIB_Refs to public
1> 
2> revoke all on BIB_ReviewStatus from progs
1>  
2> revoke all on BIB_ReviewStatus from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1>  
2> grant all on BIB_ReviewStatus to progs
1>  
2> grant all on BIB_ReviewStatus to rmb, djr, neb, jeo, mgm, jjm, sr, ljm
1>  
2> grant update on BIB_ReviewStatus to editors
1>  
2> grant select on BIB_ReviewStatus to public
1> 
2> checkpoint
rm /tmp/12643.sql
/opt/sybase/admin/permissions/CRS.grant MGD mgd
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12653.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12653.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> revoke all on CRS_Cross from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on CRS_Progeny from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on CRS_References from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on CRS_Typings from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on CRS_Cross to progs
1> 
2> grant all on CRS_Cross to jjm, plg, neb, djr, dbradt, sr
1> 
2> grant select on CRS_Cross to public
1> 
2> grant select on CRS_Matrix to public
1>  
2> grant all on CRS_Matrix to progs
1> 
2> grant all on CRS_Matrix to jjm, plg, neb, djr, dbradt, sr
1> 
2> grant all on CRS_Progeny to progs
1> 
2> grant all on CRS_Progeny to jjm, plg, neb, djr, dbradt, sr
1> 
2> grant select on CRS_Progeny to public
1> 
2> grant all on CRS_References to progs
1> 
2> grant all on CRS_References to jjm, plg, neb, djr, dbradt, sr
1> 
2> grant select on CRS_References to public
1> 
2> grant all on CRS_Typings to progs
1> 
2> grant all on CRS_Typings to jjm, plg, neb, djr, dbradt, sr
1> 
2> grant select on CRS_Typings to public
1> 
2> checkpoint
rm /tmp/12653.sql
/opt/sybase/admin/permissions/GXD.grant MGD mgd
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12663.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12663.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> grant all on GXD_Index to progs
1> 
2> grant all on GXD_Index to gxd_itest
Msg 4604, Level 16, State 1:
Line 2:
There is no such user gxd_itest.
1> 
2> grant all on GXD_Index_Stages to gxd_itest
Msg 4604, Level 16, State 1:
Line 2:
There is no such user gxd_itest.
1> 
2> grant select on GXD_Index to public
1> 
2> grant all on GXD_Index_Stages to progs
1> 
2> grant select on GXD_Index_Stages to public
1> 
2> grant all on GXD_Index to sfr, djr, jms, let, dph, dab, ksf
1>  
2> grant all on GXD_Index_Stages to sfr, djr, jms, let, dph, dab, ksf
1> 
2> /*New GXD Schema */
3> 
4> grant select on GXD_Genotype to public
1> 
2> grant select on GXD_AllelePair to public
1> 
2> grant select on GXD_Antigen to public
1> 
2> grant select on GXD_Antibody to public
1> 
2> grant select on GXD_AntibodyClass to public
1> 
2> grant select on GXD_AntibodyType to public
1> 
2> grant select on GXD_AntibodyAlias to public
1> 
2> grant select on GXD_AntibodyMarker to public
1> 
2> grant select on GXD_Structure to public
1> 
2> grant select on GXD_StructureName to public
1> 
2> grant select on GXD_TheilerStage to public
1> 
2> grant select on GXD_StructureClosure to public
1> 
2> grant select on GXD_ProbePrep to public
1> 
2> grant select on GXD_ProbeSense to public
1> 
2> grant select on GXD_Label to public
1> 
2> grant select on GXD_LabelCoverage to public
1> 
2> grant select on GXD_VisualizationMethod to public
1> 
2> grant select on GXD_AntibodyPrep to public
1> 
2> grant select on GXD_Secondary to public
1> 
2> grant select on GXD_AntibodyLabel to public
Msg 208, Level 16, State 2:
Line 2:
GXD_AntibodyLabel not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant select on GXD_Assay to public
1> 
2> grant select on GXD_AssayType to public
1> 
2> grant select on IMG_ImagePane to public
1> 
2> grant select on IMG_ImageNote to public
1> 
2> grant select on GXD_AssayNote to public
1> 
2> grant select on GXD_GelLane to public
1> 
2> grant select on GXD_GelControl to public
1> 
2> grant select on GXD_GelRNAType to public
1> 
2> grant select on GXD_GelLaneStructure to public
1> 
2> grant select on GXD_GelRow to public
1> 
2> grant select on GXD_GelUnits to public
1> 
2> grant select on GXD_GelBand to public
1> 
2> grant select on GXD_Strength to public
1> 
2> grant select on GXD_Specimen to public
1> 
2> grant select on GXD_EmbeddingMethod to public
1> 
2> grant select on GXD_FixationMethod to public
1> 
2> grant select on GXD_InSituResult to public
1> 
2> grant select on GXD_Pattern to public
1> 
2> grant select on GXD_ISResultStructure to public
1> 
2> grant select on GXD_InSituResultImage to public
1> 
2> grant select on GXD_Expression to public
1> 
2> grant select on IMG_Image to public
1>  
2> grant select on IMG_ImageNote to public
1> 
2> grant select on IMG_FieldType to public
1> 
2> grant all on GXD_Genotype to progs
1> 
2> grant all on GXD_AllelePair to progs
1> 
2> grant all on GXD_Antigen to progs
1> 
2> grant all on GXD_Antibody to progs
1> 
2> grant all on GXD_AntibodyAlias to progs
1> 
2> grant all on GXD_AntibodyClass to progs
1> 
2> grant all on GXD_AntibodyType to progs
1> 
2> grant all on GXD_AntibodyMarker to progs
1> 
2> grant all on GXD_Structure to progs
1> 
2> grant all on GXD_StructureName to progs
1> 
2> grant all on GXD_StructureClosure to progs
1> 
2> grant all on GXD_TheilerStage to progs
1> 
2> grant all on GXD_ProbePrep to progs
1> 
2> grant all on GXD_ProbeSense to progs
1> 
2> grant all on GXD_Label to progs
1> 
2> grant all on GXD_LabelCoverage to progs
1> 
2> grant all on GXD_VisualizationMethod to progs
1> 
2> grant all on GXD_AntibodyPrep to progs
1> 
2> grant all on GXD_Secondary to progs
1> 
2> grant all on GXD_AntibodyLabel to progs
Msg 208, Level 16, State 2:
Line 2:
GXD_AntibodyLabel not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Assay to progs
1> 
2> grant all on GXD_AssayType to progs
1> 
2> grant all on GXD_AssayNote to progs
1> 
2> grant all on GXD_GelLane to progs
1> 
2> grant all on GXD_GelControl to progs
1> 
2> grant all on GXD_GelRNAType to progs
1> 
2> grant all on GXD_GelLaneStructure to progs
1> 
2> grant all on GXD_GelRow to progs
1> 
2> grant all on GXD_GelBand to progs
1> 
2> grant all on GXD_Strength to progs
1> 
2> grant all on GXD_GelUnits to progs
1> 
2> grant all on GXD_Specimen to progs
1> 
2> grant all on GXD_EmbeddingMethod to progs
1> 
2> grant all on GXD_FixationMethod to progs
1> 
2> grant all on GXD_InSituResult to progs
1> 
2> grant all on GXD_ISResultStructure to progs
1> 
2> grant all on GXD_InSituResultImage to progs
1> 
2> grant all on GXD_Pattern to progs
1> 
2> grant all on GXD_Expression to progs
1> 
2> grant all on IMG_Image to progs
1> 
2> grant all on IMG_ImageNote to progs
1> 
2> grant all on IMG_ImagePane to progs
1> 
2> grant all on IMG_FieldType to progs
1> 
2> grant all on GXD_Assay_Alt to jms, let, dph, dab, ksf
Msg 208, Level 16, State 2:
Line 2:
GXD_Assay_Alt not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelLane_View to jms, let, dph, dab, ksf
1> 
2> grant all on IMG_ImagePane_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_ISResultImage_View to jms, let, dph, dab, ksf
1> 
2> grant all on IMG_Image_View to jms, let, dph, dab, ksf
1> 
2> grant all on IMG_Image_Acc_View to jms, let, dph, dab, ksf
1> 
2> grant all on IMG_ImagePaneRef_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_InSituResult_View to jms, let, dph, dab, ksf
1> 
2> grant all on IMG_Image_Summary_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Assay_Summary_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Antigen_Summary_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Antibody_Summary_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Specimen_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_AllelePair_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Genotype_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_ProbePrep_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_AntibodyPrep_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Assay_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_AntibodyAliasRef_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_AntibodyAlias_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_AntibodyMarker_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_AntibodyAntigen_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_AntibodyRef_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Antibody_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Antigen_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Assay_Acc_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Antibody_Acc_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Antigen_Acc_View to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Index_Stages to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Index to jms, let, dph, dab, ksf
1> 
2> grant all on IMG_FieldType to jms, let, dph, dab, ksf
1> 
2> grant all on IMG_ImagePane to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Expression to jms, let, dph, dab, ksf, djr
1> 
2> grant all on GXD_Pattern to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_InSituResultImage to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_ISResultStructure to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_InSituResult to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Structure to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_FixationMethod to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_EmbeddingMethod to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Specimen to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_GelUnits to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Strength to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_GelBand to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_GelRow to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_GelLaneStructure to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_GelRNAType to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_GelLane to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_GelControl to djr, jms, jsb, let, dph, dab, ksf
Msg 4604, Level 16, State 1:
Line 2:
There is no such user jsb.
1> 
2> grant all on GXD_AssayType to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Assay to jms, let, dph, dab, ksf, djr
1> 
2> grant all on GXD_Secondary to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_AntibodyPrep to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_VisualizationMethod to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_LabelCoverage to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Label to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_ProbeSense to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_ProbePrep to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_TheilerStage to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Antibody to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_StructureClosure to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_StructureName to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_AntibodyMarker to jms, let, dph, dab, ksf, djr
1> 
2> grant all on GXD_AntibodyType to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_AntibodyClass to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_AntibodyAlias to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Antigen to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_Genotype to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_AssayNote to jms, let, dph, dab, ksf
1> 
2> grant all on IMG_Image to jms, let, dph, dab, ksf
1> 
2> grant all on IMG_ImageNote to jms, let, dph, dab, ksf
1> 
2> grant all on GXD_AllelePair to jms, let, dph, dab, ksf
1> 
2> /* End GXD Schema */
3> 
4> checkpoint
rm /tmp/12663.sql
/opt/sybase/admin/permissions/HMD.grant MGD mgd
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12673.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12673.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> revoke all on HMD_Assay from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on HMD_Assay to progs
1>  
2> grant all on HMD_Assay to plg, djr, sfr, jjm
1>  
2> grant select on HMD_Assay to public
1> 
2> revoke all on HMD_Class from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant select on HMD_Class to public
1> 
2> grant all on HMD_Class to plg, djr, sfr, jjm
1> 
2> grant all on HMD_Class to progs
1> 
2> revoke all on HMD_Homology_Assay from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> revoke all on HMD_Notes from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on HMD_Homology to progs
1> 
2> grant all on HMD_Homology to plg, djr, sfr, jjm
1> 
2> grant select on HMD_Homology to public
1> 
2> grant all on HMD_Homology_Assay to progs
1> 
2> grant all on HMD_Homology_Assay to plg, djr, sfr, jjm
1> 
2> grant select on HMD_Homology_Assay to public
1> 
2> revoke all on HMD_Homology_Marker from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant select on HMD_Homology_Marker to public
1> 
2> grant all on HMD_Homology_Marker to plg, djr, sfr, jjm
1> 
2> grant all on HMD_Homology_Marker to progs
1> 
2> grant all on HMD_Notes to progs
1> 
2> grant all on HMD_Notes to plg, djr, sfr, jjm
1> 
2> grant select on HMD_Notes to public
1> 
2> checkpoint
rm /tmp/12673.sql
/opt/sybase/admin/permissions/MLC.grant MGD mgd
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12683.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12683.sql
Password: 
1> 
2> use mgd
1>    
2> checkpoint
1> 
2> grant all on MLC_Text to progs
1> 
2> grant all on MLC_Text to djr, mgm
1> 
2> grant select on MLC_Text to public
1> 
2> grant all on MLC_Reference to progs
1> 
2> grant all on MLC_Reference to djr, mgm 
1> 
2> grant select on MLC_Reference to public
1> 
2> grant all on MLC_History to progs
Msg 208, Level 16, State 2:
Line 2:
MLC_History not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLC_History to djr, mgm 
Msg 208, Level 16, State 2:
Line 2:
MLC_History not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant select on MLC_History to public
Msg 208, Level 16, State 2:
Line 2:
MLC_History not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLC_Marker to progs
1> 
2> grant all on MLC_Marker to djr, mgm
1> 
2> grant select on MLC_Marker to public
1> 
2> checkpoint
rm /tmp/12683.sql
/opt/sybase/admin/permissions/MLC_edit.grant MGD mgd
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12693.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12693.sql
Password: 
1> 
2> use mgd
1>    
2> checkpoint
1> 
2> grant all on MLC_Text_edit to progs
1> 
2> grant all on MLC_Text_edit to cml, apd, rmb, djr, jblake, mgm, gld
1> 
2> grant select on MLC_Text_edit to public
1> 
2> grant all on MLC_Reference_edit to progs
1> 
2> grant all on MLC_Reference_edit to cml, apd, rmb, djr, jblake, mgm, gld
1> 
2> grant select on MLC_Reference_edit to public
1> 
2> grant all on MLC_History_edit to progs
Msg 208, Level 16, State 2:
Line 2:
MLC_History_edit not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLC_History_edit to cml, apd, rmb, djr, jblake, mgm, gld 
Msg 208, Level 16, State 2:
Line 2:
MLC_History_edit not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant select on MLC_History_edit to public
Msg 208, Level 16, State 2:
Line 2:
MLC_History_edit not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLC_Lock_edit to progs
1> 
2> grant all on MLC_Lock_edit to cml, apd, rmb, djr, jblake, mgm, gld 
1> 
2> grant all on MLC_Marker_edit to progs
1> 
2> grant all on MLC_Marker_edit to cml, apd, rmb, djr, jblake, mgm, gld 
1> 
2> grant execute on MLC_transfer to cml, apd, rmb, jblake, progs 
1> 
2> checkpoint
rm /tmp/12693.sql
/opt/sybase/admin/permissions/MLD.grant MGD mgd
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12703.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12703.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> revoke all on MLD_Assay_Types from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_Assay_Types to progs
1> 
2> grant all on MLD_Assay_Types to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_Assay_Types to public
1> 
2> revoke all on MLD_Concordance from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_Concordance to progs
1> 
2> grant all on MLD_Concordance to plg, djr, dbradt, sr, jjm, neb
1> 
2> grant select on MLD_Concordance to public
1> 
2> revoke all on MLD_Distance from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_Distance to progs
1> 
2> grant all on MLD_Distance to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_Distance to public
1> 
2> revoke all on MLD_Expt_Marker from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_Expt_Marker to progs
1> 
2> grant all on MLD_Expt_Marker to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_Expt_Marker to public
1> 
2> revoke all on MLD_Expt_Notes from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_Expt_Notes to progs
1> 
2> grant all on MLD_Expt_Notes to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_Expt_Notes to public
1> 
2> revoke all on MLD_Expts from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_Expts to progs
1> 
2> grant all on MLD_Expts to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_Expts to public
1> 
2> grant select on MLD_Hit to public
1> 
2> revoke all on MLD_Marker from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_Marker to progs
1> 
2> grant all on MLD_Marker to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_Marker to public
1> 
2> revoke all on MLD_Contig from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_Contig to progs
1> 
2> grant all on MLD_Contig to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_Contig to public
1> 
2> revoke all on MLD_ContigProbe from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_ContigProbe to progs
1> 
2> grant all on MLD_ContigProbe to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_ContigProbe to public
1> 
2> revoke all on MLD_FISH from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_FISH to progs
1> 
2> grant all on MLD_FISH to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_FISH to public
1> 
2> revoke all on MLD_FISH_Region from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_FISH_Region to progs
1> 
2> grant all on MLD_FISH_Region to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_FISH_Region to public
1> 
2> revoke all on MLD_Hybrid from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_Hybrid to progs
1> 
2> grant all on MLD_Hybrid to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_Hybrid to public
1> 
2> revoke all on MLD_InSitu from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_InSitu to progs
1> 
2> grant all on MLD_InSitu to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_InSitu to public
1> 
2> revoke all on MLD_ISRegion from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_ISRegion to progs
1> 
2> grant all on MLD_ISRegion to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_ISRegion to public
1> 
2> revoke all on MLD_Matrix from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_Matrix to progs
1> 
2> grant all on MLD_Matrix to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_Matrix to public
1> 
2> revoke all on MLD_MC2point from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_MC2point to progs
1> 
2> grant all on MLD_MC2point to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_MC2point to public
1> 
2> revoke all on MLD_MCDataList from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_MCDataList to progs
1> 
2> grant all on MLD_MCDataList to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_MCDataList to public
1> 
2> revoke all on MLD_Notes from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_Notes to progs
1> 
2> grant all on MLD_Notes to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_Notes to public
1> 
2> revoke all on MLD_PhysMap from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_PhysMap to progs
1> 
2> grant all on MLD_PhysMap to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_PhysMap to public
1> 
2> revoke all on MLD_RI from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_RI to progs
1> 
2> grant all on MLD_RI to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_RI to public
1> 
2> revoke all on MLD_RI2Point from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_RI2Point to progs
1> 
2> grant all on MLD_RI2Point to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_RI2Point to public
1> 
2> revoke all on MLD_RIData from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_RIData to progs
1> 
2> grant all on MLD_RIData to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_RIData to public
1> 
2> revoke all on MLD_Statistics from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on MLD_Statistics to progs
1> 
2> grant all on MLD_Statistics to plg, djr, dbradt, sr, jjm, neb 
1> 
2> grant select on MLD_Statistics to public
1> 
2> checkpoint
rm /tmp/12703.sql
/opt/sybase/admin/permissions/MRK.grant MGD mgd
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12713.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12713.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> grant all on MRK_Alias to progs
1> 
2> grant all on MRK_Alias to djr, ljm
1> 
2> grant select on MRK_Alias to public
1> 
2> grant all on MRK_Allele to progs
1> 
2> grant all on MRK_Allele to djr, let, dab, ksf, jms, dph, ljm
1> 
2> grant select on MRK_Allele to public
1> 
2> grant all on MRK_Anchors to progs
1> 
2> grant all on MRK_Anchors to djr, ljm
1> 
2> grant select on MRK_Anchors to public
1> 
2> grant all on MRK_Chromosome to progs
1> 
2> grant all on MRK_Chromosome to djr, plg, sfr, ljm
1> 
2> grant select on MRK_Chromosome to public
1> 
2> grant all on MRK_Class to progs
1> 
2> grant all on MRK_Class to cml, apd, djr, jblake, ljm
1> 
2> grant select on MRK_Class to public
1> 
2> grant all on MRK_Classes to progs
1> 
2> grant all on MRK_Classes to cml, apd, djr, jblake, rmb, ljm
1> 
2> grant select on MRK_Classes to public
1> 
2> grant all on MRK_Current to progs
1> 
2> grant all on MRK_Current to djr, ljm
1> 
2> grant select on MRK_Current to public
1> 
2> grant all on MRK_History to progs
1> 
2> grant all on MRK_History to djr, ljm
1> 
2> grant select on MRK_History to public
1> 
2> grant all on MRK_Marker to progs
1> 
2> grant all on MRK_Marker to djr, plg, sfr, ljm, jjm, sr
1> 
2> grant update on MRK_Marker to lglass
1> 
2> grant select on MRK_Marker to public
1> 
2> grant all on MRK_Name to progs
1> 
2> grant all on MRK_Name to djr, ljm
1> 
2> grant select on MRK_Name to public
1> 
2> grant all on MRK_Notes to progs
1> 
2> grant all on MRK_Notes to djr, ljm
1> 
2> grant select on MRK_Notes to public
1> 
2> grant all on MRK_Offset to progs
1> 
2> grant all on MRK_Offset to djr, plg, sfr, ljm, jjm
1> 
2> grant select on MRK_Offset to public
1> 
2> grant all on MRK_Other to progs
1> 
2> grant all on MRK_Other to djr, ljm
1> 
2> grant select on MRK_Other to public
1> 
2> grant all on MRK_Reference to progs
1> 
2> grant all on MRK_Reference to djr, ljm
1> 
2> grant select on MRK_Reference to public
1> 
2> grant all on MRK_Species to djr, plg, sfr, ljm, jjm
1> 
2> grant all on MRK_Species to progs
1> 
2> grant select on MRK_Species to public
1> 
2> grant all on MRK_Symbol to progs
1> 
2> grant all on MRK_Symbol to djr, ljm
1> 
2> grant select on MRK_Symbol to public
1> 
2> grant all on MRK_Types to progs
1> 
2> grant all on MRK_Types to djr, ljm
1> 
2> grant select on MRK_Types to public
1> 
2> checkpoint
rm /tmp/12713.sql
/opt/sybase/admin/permissions/PRB.grant MGD mgd
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12723.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12723.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> revoke all on PRB_Alias from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Alias to progs
1> 
2> grant all on PRB_Alias to rmb, djr, neb, plg, sfr, ksf, mlp, jjm, let 
1> 
2> grant select on PRB_Alias to public
1> 
2> revoke all on PRB_Allele from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Allele to progs
1> 
2> grant all on PRB_Allele to rmb, djr, neb, plg, sfr, ksf, mlp, jjm, let 
1> 
2> grant select on PRB_Allele to public
1> 
2> revoke all on PRB_Allele_Strain from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Allele_Strain to progs
1> 
2> grant all on PRB_Allele_Strain to rmb, djr, neb, plg, sfr, ksf, mlp, jjm, let 
1> 
2> grant select on PRB_Allele_Strain to public
1> 
2> revoke all on PRB_Marker from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Marker to progs
1> 
2> grant all on PRB_Marker to rmb, djr, neb, plg, sfr, ksf, mlp, jjm, let 
1> 
2> grant select on PRB_Marker to public
1> 
2> revoke all on PRB_Notes from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Notes to progs
1> 
2> grant all on PRB_Notes to rmb, djr, neb, plg, sfr, ksf, mlp, jjm, let 
1> 
2> grant select on PRB_Notes to public
1> 
2> revoke all on PRB_Probe from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Probe to progs
1> 
2> grant all on PRB_Probe to rmb, djr, neb, plg, sfr, ksf, mlp, jjm, let 
1> 
2> grant select on PRB_Probe to public
1> 
2> revoke all on PRB_Ref_Notes from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Ref_Notes to progs
1> 
2> grant all on PRB_Ref_Notes to rmb, djr, neb, plg, sfr, ksf, mlp, jjm, let 
1> 
2> grant select on PRB_Ref_Notes to public
1> 
2> revoke all on PRB_Reference from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Reference to progs
1> 
2> grant all on PRB_Reference to dab, dph, jms, rmb, djr, neb, plg, sfr, ksf, mlp, jjm, let 
1> 
2> grant select on PRB_Reference to public
1> 
2> revoke all on PRB_RFLV from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_RFLV to progs
1> 
2> grant all on PRB_RFLV to dab, rmb, djr, neb, plg, sfr, ksf, mlp, jjm, let 
1> 
2> grant select on PRB_RFLV to public
1> 
2> revoke all on PRB_Source from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1>  
2> grant all on PRB_Source to progs
1>  
2> grant all on PRB_Source to dab, rmb, djr, neb, plg, sfr, ksf, mlp, jjm, let, jms, dph
1>  
2> grant select on PRB_Source to public
1> 
2> revoke all on PRB_Strain from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Strain to progs
1> 
2> grant all on PRB_Strain to mlp
1> 
2> grant insert on PRB_Strain to editors
1> 
2> grant select on PRB_Strain to public
1> 
2> revoke all on PRB_Tissue from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on PRB_Tissue to progs
1>  
2> grant all on PRB_Tissue to dab, rmb, djr, neb, plg, sfr, ksf, mlp, jjm, let
1>  
2> grant select on PRB_Tissue to public
1> 
2> grant all on PRB_Vector_Types to progs
1> 
2> grant all on PRB_Vector_Types to dab, rmb, djr, neb, plg, sfr, ksf, mlp, jjm, let
1> 
2> grant select on PRB_Vector_Types to public
1> 
2> checkpoint
rm /tmp/12723.sql
/opt/sybase/admin/permissions/RI.grant MGD mgd
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12733.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12733.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> revoke all on RI_RISet from editors
Some or all of the specified privileges were not revoked because, they were not
granted, or they were granted by some other user.
1> 
2> grant all on RI_RISet to progs
1> 
2> grant all on RI_RISet to plg, djr, sr
1> 
2> grant select on RI_RISet to public
1> 
2> grant select on RI_Summary to public
1> 
2> grant select on RI_Summary_Expt_Ref to public
1> 
2> checkpoint
rm /tmp/12733.sql
/opt/sybase/admin/permissions/MISC.grant MGD mgd
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12743.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12743.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> grant all on MGI_Tables to progs
1> 
2> grant select on MGI_Tables to public
1> 
2> /* Changed table to MGI_Columns
3> grant all on MGD_Comments to progs
4> */
5> 
6> /*
7> grant select on  MGD_Comments to public
8> */
9> 
10> grant all on MGI_Columns to progs
1> 
2> grant select on MGI_Columns to public
1> 
2> grant select on MGD_LastLoad to public
1> 
2> grant all on IDDS_TimeStamp to progs
1>  
2> grant select on IDDS_TimeStamp to public
1> 
2> grant all on IDDS_SysNum to progs
1>  
2> grant select on IDDS_SysNum to public
1> 
2> checkpoint
rm /tmp/12743.sql
/opt/sybase/admin/permissions/SYS.grant MGD mgd
setenv DSQUERY MGD
set scripts = ~sybase/admin
set sql = /tmp/12753.sql
cat
/opt/sybase/admin/dbo_sql /tmp/12753.sql
Password: 
1> 
2> use mgd
1> 
2> checkpoint
1> 
2> grant select on  sysobjects to public
1> 
2> grant select on  sysindexes to public
1> 
2> grant select on  syscolumns to public
1> 
2> grant select on  systypes to public
1> 
2> grant select on  sysprocedures to public
1> 
2> grant select on  syscomments to public
1> 
2> grant select on  syssegments to public
1> 
2> grant select on  syslogs to public
1> 
2> grant select on  sysprotects to public
1> 
2> grant select on  sysusers to public
1> 
2> grant select on  sysalternates to public
1> 
2> grant select on  sysdepends to public
1> 
2> grant select on  syskeys to public
1> 
2> grant select on  sysgams to public
1> 
2> grant select on  sysusermessages  to public
1> 
2> grant select on  sysreferences to public
1> 
2> grant select on  sysconstraints to public
1> 
2> grant select on  systhresholds to public
1> 
2> grant select on  sysroles to public
1> 
2> grant select on  sysattributes to public
1> 
2> grant select on  syspartitions to public
1> 
2> checkpoint
rm /tmp/12753.sql
sybase@kelso:3> exit
sybase@kelso:4> 
script done on Tue Apr 06 08:30:48 1999
