#!/bin/csh -f
# This file was generated automatically -- edit with care.
set scripts = $SYBASE/admin
set sql = /tmp/$$.sql
set password = $scripts/.mgd_dbo_password
#if (($MGD_DST_SRV == "MGD") && ($MGD_DST_DB == "mgd")) then
#	echo "Sorry -- you cannot use this script with the production database"
#	exit(1)
#endif
setenv DSQUERY $MGD_DST_SRV
cat > $sql << EOSQL
use $MGD_DST_DB
go
drop procedure HMD_updateClass
go
                                                                                                                                                                                                                                                               
create procedure HMD_updateClass
  @_Class_key integer,
  @_Homology_key integer
as

/* For each Class which exists which contains Markers from New Class... */

select _Class_key = @_Class_key
into #classes
union
select distinct h2._Class_key 
from HMD_Homology h1, HMD_Homology h2, MRK_Marker m
where h1._Class_key = @_Class_key and
      h1._Marker_key = h2._Marker_key and
      h2._Class_key != @_Class_key and
      h2._Marker_key = m._Marker_key

select distinct h._Marker_key, m._Species_key
into #markers
from #classes c, HMD_Homology h, MRK_Marker m
where c._Class_key = h._Class_key and
      h._Marker_key = m._Marker_key

declare @count integer
declare @do_update integer
select @do_update = 1

/* Fetch counts for Species/Symbol pairs */

declare classCount cursor for select count(*) from #markers group by _Species_key

open classCount

fetch classCount into @count

if (@@sqlstatus != 0)
begin
	close classCount
	deallocate cursor classCount
	return
end

while (@@sqlstatus = 0)
begin
	/* If > 1 reference to a Species/Symbol pair, don't update */

	if (@count > 1)
	begin
		select @do_update = 0
	end

	fetch classCount into @count
end

close classCount

deallocate cursor classCount

if (@do_update = 1) /* Merge Classes */
begin
        update HMD_Homology
	set _Class_key = @_Class_key
	from #classes c, HMD_Homology h
	where c._Class_key = h._Class_key
end
else
begin
	delete from HMD_Reference where _Homology_key = @_Homology_key
	delete from HMD_Homology where _Homology_key = @_Homology_key
	raiserror 99999 "A Homology class has been detected which conflicts with this data.\n"
end

                                                                                                                                                                               
go
grant execute on HMD_updateClass to public
go
drop procedure ACC_delete_byAccKey
go
                                                                                                                                                                                                                                                               
create procedure ACC_delete_byAccKey
  @accKey int,
  @refsKey int = -1
as

/* Delete ACC_Accession/ACC_AccessonReference records for a given _Accession_key */

if @refsKey = -1
begin
	delete ACC_Accession where _Accession_key = @accKey
	delete ACC_AccessionReference where _Accession_key = @accKey
end
else
begin

	delete ACC_AccessionReference 
	where _Accession_key = @accKey
	and _Refs_key = @refsKey
end

                                                                                                   
go
grant execute on ACC_delete_byAccKey to public
go
drop procedure ACC_split
go
                                                                                                                                                                                                                                                               
create procedure ACC_split
  @accID varchar(20),
  @prefixPart varchar(20) out,
  @numericPart integer out
as

declare @temp varchar(20) 
declare @suffix varchar(20)
declare @acclen integer
declare @idx integer

select @acclen = char_length(@accID)
select @temp = reverse(@accID)
select @idx  = patindex("%[^0-9]%",@temp)

/* If @idx = 0, then no prefix */

if @idx = 0
begin
  select @numericPart = convert(integer, @accID)
  select @prefixPart = NULL
end

else

begin
  select @prefixPart = reverse(substring(@temp,@idx,@acclen-@idx+1))
  select @suffix = substring(@accID,
                             char_length(@prefixPart)+1,
                             @acclen - char_length(@prefixPart))

  if @suffix is not NULL
     select @numericPart = convert(integer, @suffix)
  else
     select @numericPart = NULL
end

                                                                                                                                                                                                      
go
grant execute on ACC_split to public
go
drop procedure sp_mgdcomments2
go
                                                                                                                                                                                                                                                               /* Start of main procedure here */
create procedure sp_mgdcomments2 @objectype varchar(2), @objname varchar(10) as
/* Object is the table, view, etc. */
/* Objectype is the type of object */
declare @object varchar(30)
declare @objectid int
declare @rows char(10)
declare @column_name char(50)
declare @msg char(45)
/* Set up cursor for fetch */
declare item cursor for 
select name from sysobjects
where name like @objname + '%'
order by name
open item
/* Create a web page format */
print '<h1>MGD Database Schema</h1><P>' 
print '<H3><LI><A HREF =  "mgd_schema.html"> Return to Main Menu</A></H3>'
print '<PRE>'
while (@@sqlstatus = 0)
begin
fetch item into @object
select @objectid = (select id from sysobjects where name = @object)
if (@@sqlstatus > 0)   			/* Check for end of data */
goto finish 
/*		select @objectype = (select type from sysobjects where name = @object)*/
if @objectype = 'U'
begin	
print " "
print "<h2><hr>"
print @object
print "</h2><i>User Table</i>"
select @rows = (select convert(char(10),rowcnt(MAX(doampg))) from sysindexes,
sysobjects where sysobjects.id = sysindexes.id and sysindexes.id = @objectid)
select @msg ='There are ' + convert(char(6),@rows) + 'rows'
print @msg	
print "<hr>"
end
else
if @objectype = 'V'
begin
print " "
print "<h2><hr>"
print @object
print "</h2><i>View</i>"
print "<hr>"
end
select @objectid = (select id from sysobjects where name = @object)
select @objectype = (select type from sysobjects where name = @object)
/* Get the column information here */
if (@objectype = 'U' or @objectype = 'V')
begin
/* Update mgd_comments so that it knows all existing tables and columns */
insert mgd_comments 
select @object, col.name, " ", " " from syscolumns col, systypes typ
where col.id = @objectid and typ.name = (select name from systypes typp where
typp.type = col.type) and col.name not in (select col_name from mgd_comments
comm where comm.table_name = @object and comm.col_name = col.name)
/* Select Query Here: Note col.status indicates if NULLS are allowed or not */
select colname = convert(char(20),col.name), Data_type =
convert(char(10),typ.name), Lengths = col.length, Nulls = "NOT NULL", Comments
= convert(char(100),description) from syscolumns col, systypes typ,
mgd_comments com where col.id = @objectid and col.status = 0 and com.table_name
= @object and com.col_name = col.name and typ.name = (select name from systypes
typp where typp.type = col.type)
union
select colname = convert(char(20),col.name), Data_type =
convert(char(10),typ.name), Lengths = col.length, Nulls = "NULL", Comments =
convert(char(100),description) from syscolumns col, systypes typ, mgd_comments
com where col.id = @objectid and col.status > 0 and com.table_name = @object
and com.col_name = col.name and typ.name = (select name from systypes typp
where typp.type = col.type)  
order by colname
end
end
finish:
close item
deallocate cursor item
print '</PRE>'
print '<HR><H3><LI><A HREF = "mgd_schema.html"> Return to Main Menu</A></H3>'
                                                                                                                                                                                                                                                       
go
grant execute on sp_mgdcomments2 to public
go
drop procedure showall
go
                                                                                                                                                                                                                                                               create procedure showall as
/* Object is the table, view, etc. */
/* Objectype is the type of object */
declare @object varchar(30)
declare @objectid int
declare @objectype char(1)
declare @rows char(10)
declare @column_name char(50)
declare @msg char(45)
/* Set up cursor for fetch */
declare item cursor for 
select name from sysobjects
order by name
open item
/* Create a web page format */
print '<PRE>'
print '<h1>MGD Database Schema</h1><P>'
print '<H2><LI><A HREF = "schema.html"> Return to Main Menu</A></H2>'
while (@@sqlstatus = 0)
begin
fetch item into @object
select @objectid = (select id from sysobjects where name = @object)
if (@@sqlstatus > 0)   			/* Check for end of data */
goto finish
select @objectype = (select type from sysobjects where name = @object)
if @objectype = 'U'
begin	
print " "
print "<h2><hr>"
print @object
print "</h2><i>User Table</i>"
select @rows = (select convert(char(10),rowcnt(MAX(doampg))) from 
sysindexes, sysobjects where sysobjects.id = sysindexes.id and 
sysindexes.id = @objectid)
select @msg ='There are ' + convert(char(6),@rows) + 'rows'
print @msg	
print "<hr>"
end
else
if @objectype = 'V'
begin
print " "
print "<h2><hr>"
print @object
print "</h2><i>View</i>"
print "<hr>"
end
select @objectid = (select id from sysobjects where name = @object)
select @objectype = (select type from sysobjects where name = @object)
/* Get the column information here */
if (@objectype = 'U' or @objectype = 'V')
begin
/* Update mgd_comments so that it knows all existing tables and columns */
insert mgd_comments 
select @object, col.name, " ", " " from syscolumns col, systypes typ
where col.id =@objectid 
and typ.name = (select name from systypes typp where typp.type = col.type) 
and col.name not in (select col_name from mgd_comments comm where 
comm.table_name = @object and comm.col_name = col.name)
/* Select Query Here: Note col.status indicates if NULLS are allowed
or not */
select colname = convert(char(20),col.name), Data_type = convert(char(10),
typ.name), Lengths = col.length, Nulls = "NOT NULL", Comments = 
convert(char(100),description) from syscolumns col, systypes typ, 
mgd_comments com where col.id = @objectid and col.status = 0 and 
com.table_name = @object and com.col_name = col.name and typ.name = (select 
name from systypes typp where typp.type = col.type)
union
select colname = convert(char(20),col.name), Data_type = convert(char(10),
typ.name), Lengths = col.length, Nulls = "NULL", Comments = 
convert(char(100),description) from syscolumns col, systypes typ, 
mgd_comments com where
col.id = @objectid and col.status > 0 and com.table_name = @object and 
com.col_name = col.name and typ.name = (select name from systypes typp 
where typp.type = col.type)  
order by colname
end
end
finish:
close item
deallocate cursor item
                                                                                                                                                                              
go
grant execute on showall to public
go
drop procedure Map1Marker
go
                                                                                                                                                                                                                                                               
create procedure Map1Marker
        @markerClass varchar(255),
        @_Marker_key int,
        @source int
as
select distinct
        class = @markerClass,
        method = "__init__",
        m._Marker_key,
        m.symbol,
        m.name,
	m.chromosome,
        o.offset,
        m.cytogeneticOffset
from
        MRK_Marker m,
        MRK_Offset o
where
        m._Marker_key = @_Marker_key
        and o.source = @source
        and o._Marker_key = m._Marker_key
        and o.offset > -1.0

           
go
grant execute on Map1Marker to public
go
drop procedure BIB_HMD_Exists
go
                                                                                                                                                                                                                                                               
create procedure BIB_HMD_Exists
  @key integer
as

select count(*) from HMD_Reference where _Refs_key = @key

                                                                                                                                                
go
grant execute on BIB_HMD_Exists to public
go
drop procedure sp_table_names
go
                                                                                                                                                                                                                                                               /* Start of main procedure here */
create procedure sp_table_names as
/* Object is the table, view, etc. */
/* Objectype is the type of object */
declare @object varchar(30)
declare @objectid int
declare @objectype char(1)
declare @rows char(10)
declare @column_name char(50)
declare @msg char(45)
select name from sysobjects
where type = 'U'
order by name
                                                                                                                                            
go
grant execute on sp_table_names to public
go
drop procedure ACC_insert
go
                                                                                                                                                                                                                                                                
create procedure ACC_insert
  @objectKey int,
  @accID varchar(30),
  @logicalDB int,
  @mgiType varchar(80),
  @refsKey int = -1,
  @preferred int = 1,
  @private int = 0
as
 
if @accID is null
	return

declare @nextACC int
select @nextACC = max(_Accession_key) + 1 from ACC_Accession
 
declare @mgiTypeKey int
select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
 
declare @prefixPart varchar(20)
declare @numericPart int
exec ACC_split @accID, @prefixPart out, @numericPart out
						      
insert into ACC_Accession
(_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
values(@nextACC, @accID, @prefixPart, @numericPart, @logicalDB, @objectKey, @mgiTypeKey, @private, @preferred)

if @refsKey != -1
begin
	exec ACCRef_insert @nextACC, @refsKey
end

                                                                                                                                                                                          
go
grant execute on ACC_insert to public
go
drop procedure MRK_convertAllele
go
                                                                                                                                                                                                                                                                
create procedure MRK_convertAllele
  @oldKey integer,
  @new_symbol varchar(25) = null,
  @old_symbol varchar(25) = null,
  @alleleOf integer
as
 
/* Remove all Allele symbols from MRK_Symbol table */

delete from MRK_Symbol where _Marker_key = @oldKey and _Marker_Type_key = 5

/* If Old Symbol is NOT allele of New Symbol... */
/* Convert new alleles:  oldallele<allele> --> newsymbol<allele> */
/*                       oldallele         --> newsymbol         */

if @alleleOf = 0
begin

update MRK_Allele
set symbol = @new_symbol + "<" + substring(symbol, charindex("<", symbol) + 1, char_length(symbol))
where _Marker_key = @oldKey and symbol like '%<%'

update MRK_Allele set symbol = @new_symbol
where _Marker_key = @oldKey and symbol not like '%<%' and symbol = @old_symbol

end
else
begin

/* If Old Symbol is an Allele of New Symbol... */
/* Convert new alleles:  oldallele<allele> --> newsymbol<oldallele-allele> */
/*                       oldallele         --> newsymbol<oldallele>        */

update MRK_Allele
set symbol = @new_symbol + "<" + substring(symbol, 1, charindex("<", symbol) - 1) + "-" + 
	     substring(symbol, charindex("<", symbol) + 1, char_length(symbol))
where _Marker_key = @oldKey and symbol like '%<%'

update MRK_Allele
set symbol = @new_symbol + "<" + symbol + ">"
where _Marker_key = @oldKey and symbol not like '%<%'

end

/* Insert Allele symbols into MRK_Symbol table */

insert into MRK_Symbol select _Marker_key, 5, symbol from MRK_Allele where _Marker_key = @oldKey

                
go
grant execute on MRK_convertAllele to public
go
drop procedure ACC_delete_byAccRef
go
                                                                                                                                                                                                                                                               
create procedure ACC_delete_byAccRef
  @objectKey int,
  @refsKey int,
  @mgiType varchar(80) = "Segment"
as

/* Delete all ACC_AccessonReference records for a given Object/Reference */

delete ACC_AccessionReference 
from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m
where a._Object_key = @objectKey
and a._MGIType_key = m._MGIType_key
and m.name = @mgiType
and a._Accession_key = ar._Accession_key
and ar._Refs_key = @refsKey
 
                                                                  
go
grant execute on ACC_delete_byAccRef to public
go
drop procedure BIB_PRB_Exists
go
                                                                                                                                                                                                                                                               
create procedure BIB_PRB_Exists
  @key integer
as

select count(*) from PRB_Reference where _Refs_key = @key

                                                                                                                                                
go
grant execute on BIB_PRB_Exists to public
go
drop procedure ACC_update
go
                                                                                                                                                                                                                                                                
create procedure ACC_update
  @accKey int,
  @accID varchar(30)
as
 
if @accID is null
begin
	exec ACC_delete_byAccKey @accKey
end
else
begin
	declare @prefixPart varchar(20)
	declare @numericPart int
	exec ACC_split @accID, @prefixPart out, @numericPart out
						      
	if (@prefixPart = "J:" or substring(@prefixPart,1,4) = "MGD-")
	begin
		if (select count(*) from ACC_Accession
	    	    where accID = @accID and
			  prefixPart = @prefixPart) >= 1
		begin
			rollback transaction
			raiserror 99999 "Duplicate MGI Accession Number"
			return
		end
	end

	update ACC_Accession
  	set accID = @accID, 
      	prefixPart = @prefixPart, 
      	numericPart = @numericPart,
      	modificationDate = getdate()
  	where _Accession_key = @accKey
end

            
go
grant execute on ACC_update to public
go
drop procedure MRK_insertHistory
go
                                                                                                                                                                                                                                                                
create procedure MRK_insertHistory
  @oldKey integer,
  @newKey integer,
  @refKey integer,
  @name varchar(255) = null,
  @note varchar(255)
as
 
/* Insert New History into MRK_History */
 
declare @maxSeq int
select @maxSeq = max(sequenceNum) from MRK_History where _Marker_key = @newKey

if @maxSeq is null
begin
	select @maxSeq = 0
end

insert MRK_History (_Marker_key, _History_key, _Refs_key, sequenceNum, name, note)
values(@newKey, @oldKey, @refKey, @maxSeq + 1, @name, @note)

                      
go
grant execute on MRK_insertHistory to public
go
drop procedure sp_mgdcomments
go
                                                                                                                                                                                                                                                               /* Start of main procedure here */
create procedure sp_mgdcomments as
/* Object is the table, view, etc. */
/* Objectype is the type of object */
declare @object varchar(30)
declare @objectid int
declare @objectype char(1)
declare @rows char(10)
declare @column_name char(50)
declare @msg char(45)
/* Set up cursor for fetch */
declare item cursor for 
select name from sysobjects
order by name
open item
/* Create a web page format */
print '<h1>MGD Database Schema</h1><P>' 
print '<H3><LI><A HREF = "schema.html"> Return to Main Menu</A></H3>'
print '<PRE>'
while (@@sqlstatus = 0)
begin
fetch item into @object
select @objectid = (select id from sysobjects where name = @object)
if (@@sqlstatus > 0)   			/* Check for end of data */
goto finish
select @objectype = (select type from sysobjects where name = @object)
if @objectype = 'U'
begin	
print " "
print "<h2><hr>"
print @object
print "</h2><i>User Table</i>"
select @rows = (select convert(char(10),rowcnt(MAX(doampg))) from sysindexes,
sysobjects where sysobjects.id = sysindexes.id and sysindexes.id = @objectid)
select @msg ='There are ' + convert(char(6),@rows) + 'rows'
print @msg	
print "<hr>"
end
else
if @objectype = 'V'
begin
print " "
print "<h2><hr>"
print @object
print "</h2><i>View</i>"
print "<hr>"
end
select @objectid = (select id from sysobjects where name = @object)
select @objectype = (select type from sysobjects where name = @object)
/* Get the column information here */
if (@objectype = 'U' or @objectype = 'V')
begin
/* Update mgd_comments so that it knows all existing tables and columns */
insert mgd_comments 
select @object, col.name, " ", " " from syscolumns col, systypes typ
where col.id = @objectid 
and typ.name = (select name from systypes typp where typp.type = col.type) and
col.name not in (select col_name from mgd_comments comm where comm.table_name =
@object and comm.col_name = col.name)
/* Select Query Here: Note col.status indicates if NULLS are allowed
or not */
select colname = convert(char(20),col.name), Data_type =
convert(char(10),typ.name), Lengths = col.length, Nulls = "NOT NULL", Comments
= convert(char(100),description) from syscolumns col, systypes typ,
mgd_comments com where col.id = @objectid and col.status = 0 and com.table_name
= @object and com.col_name = col.name and typ.name = (select name from systypes
typp where typp.type = col.type)
union
select colname = convert(char(20),col.name), Data_type =
convert(char(10),typ.name), Lengths = col.length, Nulls = "NULL", Comments =
convert(char(100),description) from syscolumns col, systypes typ, mgd_comments
com where
col.id = @objectid and col.status > 0 and com.table_name = @object and
com.col_name = col.name and typ.name = (select name from systypes typp where
typp.type = col.type)  
order by colname
end
end
finish:
close item
deallocate cursor item
print '</PRE>'
print '<HR><H3><LI><A HREF = "schema.html"> Return to Main Menu</A></H3>'
                                                     
go
grant execute on sp_mgdcomments to public
go
drop procedure sp_schema
go
                                                                                                                                                                                                                                                               /* Start of main procedure here */
create procedure sp_schema as
/* Object is the table, view, etc. */
/* Objectype is the type of object */
declare @object varchar(30)
declare @objectid int
declare @objectype char(1)
declare @rows char(10)
declare @column_name char(50)
declare @msg char(45)
/* Set up cursor for fetch */
declare item cursor for 
select name from sysobjects
order by name
open item
while (@@sqlstatus = 0)
begin
fetch item into @object
select @objectid = (select id from sysobjects where name = @object)
if (@@sqlstatus > 0)   			/* Check for end of data */
goto finish
select @objectype = (select type from sysobjects where name = @object)
if @objectype = 'U'
begin	
print @object
select @rows = (select convert(char(10),rowcnt(MAX(doampg))) from sysindexes,
sysobjects where sysobjects.id = sysindexes.id and sysindexes.id = @objectid)
select @msg ='There are ' + convert(char(6),@rows) + 'rows'
print @msg	
end
else
if @objectype = 'V'
begin
print @object
end
select @objectid = (select id from sysobjects where name = @object)
select @objectype = (select type from sysobjects where name = @object)
/* Get the column information here */
if (@objectype = 'U' or @objectype = 'V')
begin
/* Update mgd_comments so that it knows all existing tables and columns */
insert mgd_comments 
select @object, col.name, " ", " " from syscolumns col, systypes typ
where col.id = @objectid 
and typ.name = (select name from systypes typp where typp.type = col.type) and
col.name not in (select col_name from mgd_comments comm where comm.table_name =
@object and comm.col_name = col.name)
/* Select Query Here: Note col.status indicates if NULLS are allowed
or not */
select colname = convert(char(20),col.name), Data_type =
convert(char(10),typ.name), Lengths = col.length, Nulls = "NOT NULL", Comments
= convert(char(100),description) from syscolumns col, systypes typ,
mgd_comments com where col.id = @objectid and col.status = 0 and com.table_name
= @object and com.col_name = col.name and typ.name = (select name from systypes
typp where typp.type = col.type)
union
select colname = convert(char(20),col.name), Data_type =
convert(char(10),typ.name), Lengths = col.length, Nulls = "NULL", Comments =
convert(char(100),description) from syscolumns col, systypes typ, mgd_comments
com where
col.id = @objectid and col.status > 0 and com.table_name = @object and
com.col_name = col.name and typ.name = (select name from systypes typp where
typp.type = col.type)  
order by colname
end
end
finish:
close item
deallocate cursor item
                                                                                                                                                                                                      
go
grant execute on sp_schema to public
go
drop procedure sp__tablespace
go
                                                                                                                                                                                                                                                               create procedure sp__tablespace
as
/* 
** This procedure copyright 1995 The SQL Workshop Ltd.
** The code is freely distributable, but please leave this comment intact.
** simon walker
** siwalker@cix.compulink.co.uk
*/
set nocount on
declare @page_size int 
select	@page_size = low
from	master..spt_values
where	type = "E"
and	number = 1
/*
** first how big is the database?
*/
declare	@dbdatasize	int,
@dblogsize	int
select	@dbdatasize = round((@page_size * convert(float,sum(size))) / 1048576,
0)
from	master..sysusages
where	dbid = db_id()
and	(segmap & 4 != 4 or segmap & 7 = 7)
select	@dblogsize = round((@page_size * convert(float,sum(size))) / 1048576, 0)
from	master..sysusages
where	dbid = db_id()
and	segmap & 4 = 4 
and	segmap & 7 != 7
if @dblogsize is NULL
select	"database" = db_name(),
"data size" = str(@dbdatasize)+ " MB", 
"log size" = "no separate log"
else
select	"database" = db_name(),
"data size" = str(@dbdatasize)+ " MB", 
"log size" = str(@dblogsize)+ " MB"
print ''
/*
** total space used summary
*/
declare	@totrespgs numeric,
@totdatpgs numeric,
@totidxpgs numeric,
@tottxtpgs numeric,
@totlogpgs numeric
select	@totrespgs = sum(reserved_pgs(id, doampg) + reserved_pgs(id, ioampg)),
@totdatpgs = sum(data_pgs(id,doampg)),
@totidxpgs = sum(data_pgs(id,ioampg))
from	sysindexes
where	id != 8
select	@tottxtpgs = isnull(sum(data_pgs(id,ioampg)),0)
from	sysindexes
where	id != 8
and	indid = 255
select	@totlogpgs = reserved_pgs(id, doampg)
from	sysindexes
where	id = 8
select	'reserved kb'	= @totrespgs * @page_size / 1024,
'data     kb'	= @totdatpgs * @page_size / 1024,
'index    kb'	= (@totidxpgs - @tottxtpgs) * @page_size / 1024,
'text/image kb'	= @tottxtpgs * @page_size / 1024,
'unused   kb'	= (@totrespgs - @totdatpgs - @totidxpgs) * @page_size / 1024,
'data free kb'	= (@dbdatasize * 1024) - (@totrespgs * @page_size / 1024),
'log reserved kb' = @totlogpgs * @page_size / 1024,	
'log free kb'	= isnull(str((@dblogsize  * 1024) - (@totlogpgs * @page_size /
1024),11), 'n/a')
print ''
/* 
** now detail for each table 
*/
select	name	= o.name,
id	= o.id,
nrows	= sum(rowcnt(i.doampg)),
reserved= sum((reserved_pgs(i.id, i.doampg) + reserved_pgs(i.id, i.ioampg)) *
2048 / 1024),
data	= sum(data_pgs(i.id, i.doampg)) * 2048 / 1024,
indx	= sum(data_pgs(i.id, i.ioampg)) * 2048 / 1024,
txt	= 0,
unused	= sum(((reserved_pgs(i.id, i.doampg) + reserved_pgs(i.id, i.ioampg)) -
(data_pgs(i.id, i.doampg) + data_pgs(i.id, i.ioampg)))) * 2048 / 1024
into	#space
from	sysobjects o, 
sysindexes i
where	i.id = o.id
group by o.name
update	#space
set	indx = indx - data_pgs(i.id, ioampg) * 2048 / 1024,
txt  = data_pgs(i.id, ioampg) * 2048 / 1024
from	#space,
sysindexes i
where	indid = 255
and	#space.id = i.id
select	name,
'rows' = nrows,
'reserved kb' = reserved,
'data     kb' = data,
'index    kb' = indx,
'text     kb' = txt,
'unused   kb' = unused
from	#space
order by reserved desc, name asc
return (0)
                             
go
grant execute on sp__tablespace to public
go
drop procedure ACC_findMax
go
                                                                                                                                                                                                                                                               
create procedure ACC_findMax
  @prefixPart varchar(20) = "MGI:"
as

/* Return maxNumericPart for given prefixPart */

select maxNumericPart
from ACC_AccessionMax
where prefixPart = @prefixPart
                                                             
go
grant execute on ACC_findMax to public
go
drop procedure HMD_hasHomology
go
                                                                                                                                                                                                                                                               
create procedure HMD_hasHomology
                @_Marker_key int = NULL,
                @_Refs_key int = NULL
as
/*
 * 	Procedure takes either a Marker key or a Ref key,
 *	and determines whether not a homology will exists.
 *	For a homology to be returned, for a _Class_key,
 *	there must be more than one marker.
 *
 *	DOW Jan 10, 1996
 */
declare @count int
declare @has_Homology int
create table #classes
        (_Class_key int)

/*
 *	has_Homology is the value to be returned.
 *	Default is "no homology" 
 */	
select @has_Homology = 0

/*	Do with a query using a _Marker_key...	*/
if (@_Marker_key != NULL and @_Refs_key = NULL)
        insert #classes
        select _Class_key
        from HMD_Homology
        where _Marker_key = @_Marker_key
/*	...or a _Refs_key...	*/
else if (@_Refs_key != NULL and @_Marker_key = NULL)
        insert #classes
        select _Class_key
        from HMD_Homology h, HMD_Reference r
        where h._Homology_key = r._Homology_key and
              r._Refs_key = @_Refs_key
/*	...but not both!!	*/
else
begin
	print 'Cannot process with both _Refs_key AND _Marker_key!'
	select @has_Homology
	return 
end

/*
 *	Cursor simply does a count of distinct markers(species) in a class
 */
declare classCount cursor for
select count(distinct h._Marker_key)
from HMD_Homology h, #classes c
where h._Class_key = c._Class_key
group by h._Class_key

open classCount

/*	Pull out classes, one by one...	*/
fetch classCount
        into @count

/*	Nothing here... bail out!	*/
if (@@sqlstatus = 2)
begin
	print 'Nothing found'
	select @has_Homology
        return 
end
/*
 * 	If cursor result is not empty, then process
 * 	each row to determine if class has a homology
 * 	including more than one species (marker).
 */
while (@@sqlstatus = 0)
begin
        if (@count > 1)
/*	There is a valid homology within this class.	*/
                select @has_Homology = 1

/*	Fetch next row.	*/
        fetch classCount
                into @count
end
/*	This select will return the value of @has_Homology as a row of data */
select @has_Homology

close classCount

deallocate cursor classCount
                                                                                                                                                                           
go
grant execute on HMD_hasHomology to public
go
drop procedure MRK_updateOffset
go
                                                                                                                                                                                                                                                               
create procedure MRK_updateOffset
  @oldKey integer,
  @newKey integer
as

declare @oldCyto varchar(20)
declare @newCyto varchar(20)

declare @oldMGD float
declare @newMGD float

declare @oldCC float
declare @newCC float

declare @oldMIT float
declare @newMIT float

select @oldCyto = cytogeneticOffset from MRK_Marker where _Marker_key = @oldKey
select @newCyto = cytogeneticOffset from MRK_Marker where _Marker_key = @newKey

select @oldMGD = offset from MRK_Offset where _Marker_key = @oldKey and source = 0
select @oldCC = offset from MRK_Offset where _Marker_key = @oldKey and source = 1
select @oldMIT = offset from MRK_Offset where _Marker_key = @oldKey and source = 2

select @newMGD = offset from MRK_Offset where _Marker_key = @newKey and source = 0
select @newCC = offset from MRK_Offset where _Marker_key = @newKey and source = 1
select @newMIT = offset from MRK_Offset where _Marker_key = @newKey and source = 2

-- If the new symbol lacks an Cytogenetic offset, then use the old symbols' offset

if @newCyto is null
begin
  update MRK_Marker set cytogeneticOffset = @oldCyto where _Marker_key = @newKey
end

-- If the new symbol lacks an MGD offset, then use the old symbols' offset

if @newMGD < 0
begin
  update MRK_Offset set offset = @oldMGD where _Marker_key = @newKey and source = 0
end

-- If the new symbol lacks a CC offset, then use the old symbol's CC offset

if @newCC < 0 and @oldCC > 0
begin
  update MRK_Offset set offset = @oldCC where _Marker_key = @newKey and source = 1
end
else if @newCC is null and @oldCC is not null
begin
  insert into MRK_Offset values(@newKey, 1, @oldCC)
end

-- If the new symbols lacks an MIT offset, then use the old symbol's MIT offset

if @newMIT < 0 and @oldMIT > 0
begin
  update MRK_Offset set offset = @oldMIT where _Marker_key = @newKey and source = 2
end
else if @newMIT is null and @oldMIT is not null
begin
  insert into MRK_Offset values(@newKey, 2, @oldMIT)
end

-- So, now we can null the Cytogenetic offset for the old symbol

update MRK_Marker set cytogeneticOffset = null where _Marker_key = @oldKey

-- So, now we can drop the CC/MIT offsets for the old symbol

delete from MRK_Offset where _Marker_key = @oldKey and source > 0

                                                                                         
go
grant execute on MRK_updateOffset to public
go
drop procedure BIB_byJnum
go
                                                                                                                                                                                                                                                               
create procedure BIB_byJnum
  @jnum	integer
as

select b._Refs_key, b.short_citation 
from BIB_View b, BIB_Acc_View ba
where ba.numericPart = @jnum
and ba._Object_key = b._Refs_key
                                                                         
go
grant execute on BIB_byJnum to public
go
drop procedure ACCRef_insert
go
                                                                                                                                                                                                                                                                
create procedure ACCRef_insert
  @accKey int,
  @refsKey int
as
 
insert into ACC_AccessionReference
(_Accession_key, _Refs_key)
values(@accKey, @refsKey)

                                                                                                 
go
grant execute on ACCRef_insert to public
go
drop procedure MLD_RefsbyMarker
go
                                                                                                                                                                                                                                                               
create procedure MLD_RefsbyMarker
  @markerKey integer
as

select distinct 'J#' + ltrim(str(jnum)) + ", " + short_citation 
from MLD_Marker_View
where _Marker_key = @markerKey
order by short_citation
                                                      
go
grant execute on MLD_RefsbyMarker to public
go
drop procedure sp_fieldinfo
go
                                                                                                                                                                                                                                                               create procedure sp_fieldinfo @object varchar(30), @field varchar(30) as
declare @id int
declare @nulls int
declare @tx varchar(15)
declare @name varchar(30)
declare @length int
declare @lgth varchar(10)
declare @nullout varchar(10)
select @id = count(id) from sysobjects 
where name = ltrim(rtrim(@object))
if @id = 0
begin
print 'Object not found'
return 5 
end
else
begin
select @id = id from sysobjects 
where name = ltrim(rtrim(@object))
select @name = ltrim(rtrim(col.name)), @tx = ltrim(rtrim(typ.name)), @nulls =
col.status, @length = col.length
from syscolumns col, systypes typ
where
col.id = @id 
and
col.name = @field 
and
typ.usertype = col.usertype
if @nulls > 0
select @nullout = "NULL"
else 
select @nullout = "NOT NULL"
select @lgth = ltrim(rtrim(convert(varchar(10), @length)))
print "%1! %2! %3! %4!", @name, @tx, @lgth, @nullout
end
                                                                                                                                    
go
grant execute on sp_fieldinfo to public
go
drop procedure sp_rowcount_summary
go
                                                                                                                                                                                                                                                               create procedure sp_rowcount_summary as
declare @object varchar(30)
declare @objectid int
declare @objectype char(1)
declare @rows char(10)
declare @msg char(45)
declare item cursor for 
select name from sysobjects
where type = 'U'
order by name
open item
while 1=1 
begin
fetch item into @object
if (@@sqlstatus = 2)   								goto finish
exec sp_rowcount @object
end
finish:
close item
deallocate cursor item
                                                                               
go
grant execute on sp_rowcount_summary to public
go
drop procedure sp_objectinfo
go
                                                                                                                                                                                                                                                               create procedure sp_objectinfo @object char(30) as
declare @objectid int
declare @colname char(20)
declare @data_type char(10)
declare @lengths char(5)
declare @nulls int
declare @comments char(100)
declare @line char(250)
declare @ndx char(30)
select @objectid = (select id from sysobjects where name = @object)
print @object
declare item1 cursor for
select convert(char(25),col.name), convert(char(10),typ.name),
convert(char(5),col.length), col.status, description 
from 
syscolumns col, systypes typ, mgd_comments com
where 
col.id = @objectid and com.table_name = @object and com.col_name = col.name and
typ.name = (select name from systypes typp where typp.type = col.type)
open item1
fetch item1 into @colname, @data_type, @lengths, @nulls, @comments
if @nulls = 0 
select @line = @colname+" "+ @data_type+" "+ @lengths+" "+"NULL    "+" "+
@comments
else
select @line = @colname+" "+ @data_type+" "+ @lengths+" "+"NOT NULL"+" "+
@comments
print @line
while (@@sqlstatus != 2)
begin
fetch item1 into @colname, @data_type, @lengths, @nulls, @comments
if (@@sqlstatus = 2) goto finish
if @nulls = 0 
select @line = @colname+" "+ @data_type+" "+ @lengths+" "+"NULL"+" "+ @comments
else
select @line = @colname+" "+ @data_type+" "+ @lengths+" "+ "NOT NULL"+" "+
@comments
print @line
end
finish:
close item1
deallocate cursor item1
                                                                                                                                                          
go
grant execute on sp_objectinfo to public
go
drop procedure BIB_MLD_Exists
go
                                                                                                                                                                                                                                                               
create procedure BIB_MLD_Exists
  @key integer
as

select count(*) from MLD_Marker where _Refs_key = @key

                                                                                                                                                   
go
grant execute on BIB_MLD_Exists to public
go
drop procedure ACCRef_process
go
                                                                                                                                                                                                                                                                
create procedure ACCRef_process
  @objectKey int,
  @refsKey int,
  @accID varchar(30),
  @logicalDB int,
  @mgiType varchar(80)
as
 
declare @accKey integer
select @accKey = a._Accession_key 
from ACC_Accession a, ACC_MGIType m
where accID = @accID
and a._Object_key = @objectKey
and a._MGIType_key = m._MGIType_key
and m.name = @mgiType
and a._LogicalDB_key = @logicalDB
select @accKey

if @accKey is not null
	exec ACCRef_insert @accKey, @refsKey
else
	exec ACC_insert @objectKey, @accID, @logicalDB, @mgiType, @refsKey

                                                                                                                                                                                                                                               
go
grant execute on ACCRef_process to public
go
drop procedure MRK_insertAllele
go
                                                                                                                                                                                                                                                                
create procedure MRK_insertAllele
  @markerKey integer,
  @symbol varchar(20) = null,
  @name varchar(255) = null,
  @oldSymbol varchar(20) = null
as

declare @alleleKey integer
select @alleleKey = max(_Allele_key) + 1 from MRK_Allele

/* Insert New Allele into MRK_Allele */

insert into MRK_Allele values(@alleleKey, @markerKey, @symbol, @name)

if @oldSymbol is not null
begin
	update MLD_Expt_Marker set _Allele_key = @alleleKey
	where _Marker_key = @markerKey and gene = @oldSymbol
end

                
go
grant execute on MRK_insertAllele to public
go
drop procedure ACC_resetMax
go
                                                                                                                                                                                                                                                               
create procedure ACC_resetMax
  @objectKey int,
  @mgiType varchar(80),
  @prefixPart varchar(20) = "MGI:"
as

/* If deleting object which is using the maxNumericPart 
   from ACC_AccessionMax, then reset the maxNumericPart
   so there aren't so many holes.  During withdrawals,
   new Marker symbols may not receive MGI accession numbers,
   but the MRK_Marker insert trigger will always insert one
*/

declare @numericPart int
select @numericPart = a.numericPart 
from ACC_Accession a, ACC_MGIType m
where a._Object_key = @objectKey
and a.prefixPart = @prefixPart
and a._MGIType_key = m._MGIType_key
and m.name = @mgiType

if (select maxNumericPart from ACC_AccessionMax where prefixPart = @prefixPart) = @numericPart
begin
	update ACC_AccessionMax
	set maxNumericPart = maxNumericPart - 1
	where prefixPart = @prefixPart
end

                                                                                                                                                                                              
go
grant execute on ACC_resetMax to public
go
drop procedure HMD_getOxfordGrid
go
                                                                                                                                                                                                                                                               
create procedure HMD_getOxfordGrid
                @Species1 int = NULL,
                @Species2 int = NULL
as

/* Return all Chromosome Pairs/Homology Classes involving Species 1 & Species 2 */
/* Include Chromosome UN. To exclude, add the following where clauses */
/*	    m1.chromosome != 'UN' and	*/
/*	    m2.chromosome != 'UN'	*/

select distinct c1 = m1.chromosome, c2 = m2.chromosome, h1._Class_key
                from    MRK_Marker m1,
                        MRK_Marker m2,
                        HMD_Homology h1,
                        HMD_Homology h2
                where   m1._Species_key = @Species1 and
                        m1._Marker_key = h1._Marker_key and
                        h1._Class_key = h2._Class_key and
                        h2._Marker_key = m2._Marker_key and
                        m2._Species_key = @Species2 
order by c1, c2
 
                                                                                                                                                  
go
grant execute on HMD_getOxfordGrid to public
go
drop procedure MRK_updateCurrent
go
                                                                                                                                                                                                                                                               
create procedure MRK_updateCurrent
  @oldKey integer,
  @newKey integer
as

/* Associate current symbols for all past symbols w/ new symbol */
/* Associate alias symbols in MRK_Symbol w/ new symbol */
/* Associate allele symbols in MRK_Symbol w/ new symbol */

update MRK_Current set _Current_key = @newKey where _Current_key = @oldKey
update MRK_Symbol set _Marker_key = @newKey where _Marker_key = @oldKey and _Marker_Type_key = 4
update MRK_Symbol set _Marker_key = @newKey where _Marker_key = @oldKey and _Marker_Type_key = 5

                                                                                                                                                                                                                                         
go
grant execute on MRK_updateCurrent to public
go
drop procedure PRB_Parent
go
                                                                                                                                                                                                                                                               create procedure PRB_Parent
@childKey integer,
@parentName varchar(40)
as
select count(m1._Marker_key)
from PRB_Marker m1, PRB_Probe p1, PRB_Probe p2, PRB_Marker m2
where p1._Probe_key = @childKey
and p2.name = @parentName
and p1._Probe_key = m1._Probe_key
and p2._Probe_key = m2._Probe_key
and m1._Marker_key = m2._Marker_key
                                                                                                                                                                            
go
grant execute on PRB_Parent to public
go
drop procedure GEN_rowcount
go
                                                                                                                                                                                                                                                                
create procedure GEN_rowcount
  @table varchar(30)
as

select convert(char(10),rowcnt(MAX(doampg)))
from sysindexes i, sysobjects o1, sysobjects o2
where o1.id = i.id
and i.id = o2.id 
and o2.name = @table

                                              
go
grant execute on GEN_rowcount to public
go
drop procedure ACC_assignJ
go
                                                                                                                                                                                                                                                               
create procedure ACC_assignJ
  @objectKey int,
  @nextMGI int = -1
as

if @nextMGI != -1
begin
	declare @exists int
	select @exists = count(*) from BIB_Acc_View
               where prefixPart = "J:" and 
	       numericPart = @nextMGI
	if @exists > 0
	begin
  		rollback transaction
  		raiserror 99999 "This J Number is already in use"
  		return
	end
end

exec ACC_assignMGI @objectKey, "Reference", "J:", @nextMGI

                                                                                          
go
grant execute on ACC_assignJ to public
go
drop procedure ACC_delete_byObject
go
                                                                                                                                                                                                                                                               
create procedure ACC_delete_byObject
  @objectKey int,
  @mgiType varchar(80)
as

/* May have to reset the MGI or J: Max part */

exec ACC_resetMax @objectKey, @mgiType
exec ACC_resetMax @objectKey, @mgiType, "J:"

/* Delete all ACC_Accession/ACC_AccessionReference records for a given Object */

delete ACC_AccessionReference 
from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m
where a._Object_key = @objectKey
and a._MGIType_key = m._MGIType_key
and m.name = @mgiType
and a._Accession_key = ar._Accession_key

delete ACC_Accession 
from ACC_Accession a, ACC_MGIType m
where a._Object_key = @objectKey 
and a._MGIType_key = m._MGIType_key
and m.name = @mgiType

                                                                                         
go
grant execute on ACC_delete_byObject to public
go
drop procedure MapAnchor
go
                                                                                                                                                                                                                                                               
create procedure MapAnchor
        @markerClass varchar(255),
        @chromosome varchar(2),
        @source int
as
select distinct
        class = @markerClass,
        method = "__init__",
        m._Marker_key,
        m.symbol,
        m.name,
	m.chromosome,
        o.offset,
        m.cytogeneticOffset
from
        MRK_Marker m,
        MRK_Offset o,
	MRK_Anchors a
where
	m._Marker_key = a._Marker_key
        and o.source = @source
        and o._Marker_key = m._Marker_key
        and o.offset > -1.0
        and a.chromosome = @chromosome

                                                                                                                                                                                                                    
go
grant execute on MapAnchor to public
go
drop procedure BIB_MLC_Exists
go
                                                                                                                                                                                                                                                               
create procedure BIB_MLC_Exists
  @key integer
as

select count(*) from MLC_Reference where _Refs_key = @key

                                                                                                                                                
go
grant execute on BIB_MLC_Exists to public
go
drop procedure CustDefaultSegWarning
go
                                                                                                                                                                                                                                                               create procedure CustDefaultSegWarning
as
print "WARNING: There is less than 20MB available in the MGD Database"
                                                                                                                                           
go
grant execute on CustDefaultSegWarning to public
go
drop procedure ACC_insert_bySpecies
go
                                                                                                                                                                                                                                                                
create procedure ACC_insert_bySpecies
  @objectKey int,
  @accID varchar(30),
  @speciesKey int
as
 
if @accID is null
	return

declare @logicalDBKey int
select @logicalDBKey = _LogicalDB_key from ACC_LogicalDB 
where _Species_key = @speciesKey
 
declare @private int

if @speciesKey = 40
	select @private = 1
else
	select @private = 0

exec ACC_insert @objectKey, @accID, @logicalDBKey, "Marker", -1, 1, @private
 
                                                                                            
go
grant execute on ACC_insert_bySpecies to public
go
drop procedure MRK_copyHistory
go
                                                                                                                                                                                                                                                                
create procedure MRK_copyHistory
  @oldKey integer,
  @newKey integer
as
 
/* Copy Old History into MRK_History for New Key */
 
declare @maxSeq int
select @maxSeq = max(sequenceNum) from MRK_History where _Marker_key = @newKey

if @maxSeq is null
begin
	select @maxSeq = 0
end

select _Marker_key, _History_key, _Refs_key, seq = identity(5), name, note, creation_date, modification_date
into #historyTemp from MRK_History where _Marker_key = @oldKey
 
insert into MRK_History (_Marker_key, _History_key, _Refs_key, sequenceNum, name, note, creation_date, modification_date)
select distinct @newKey, _History_key, _Refs_key, @maxSeq + seq, name, note, creation_date, modification_date
from #historyTemp

                                                           
go
grant execute on MRK_copyHistory to public
go
drop procedure Current_Symbol
go
                                                                                                                                                                                                                                                               
create procedure Current_Symbol 
  @symbol varchar(25)
as


declare item cursor for
   select m._Marker_key, m.symbol 
   from MRK_Marker m 
   where m.symbol = @symbol
   and _Species_key = 1

declare @mk int
declare @sym varchar(25) 
open item 

while (@@sqlstatus = 0)
begin
   fetch item into @mk, @sym
   if (@@sqlstatus = 2) break
   select _Current_key = c._Current_key, 
          _Marker_key =  c._Marker_key,
          current_symbol = m.symbol, 
		  symbol = @sym
   from MRK_Current c, MRK_Marker m
   where c._Current_key = m._Marker_key
   and m._Species_key = 1
   and c._Marker_key = @mk
end

close item
			
                                                                                                                                            
go
grant execute on Current_Symbol to public
go
drop procedure procs
go
                                                                                                                                                                                                                                                               create procedure procs as
declare @object varchar(30)
declare @command varchar(50)
declare item cursor for 
select name from sysobjects
where type = "P"
order by name
open item
while (@@sqlstatus != 2)
begin
fetch item into @object
select @command = "sp_helptext " + @object
execute sp_helptext @object
end
finish:
close item
deallocate cursor item
                                                                                                                                                
go
grant execute on procs to public
go
drop procedure sp_tablenames
go
                                                                                                                                                                                                                                                               /* Start of main procedure here */
create procedure sp_tablenames @tname varchar(25) as
/* Object is the table, view, etc. */
/* Objectype is the type of object */
select name from sysobjects
where type = 'U'
and name like @tname + '%'
order by name
                                                                                                                                                                                                                                                            
go
grant execute on sp_tablenames to public
go
drop procedure BIB_GXD_Exists
go
                                                                                                                                                                                                                                                               
create procedure BIB_GXD_Exists
  @key integer
as

select count(*) from GXD_Index where _Refs_key = @key

                                                                                                                                                    
go
grant execute on BIB_GXD_Exists to public
go
drop procedure ACC_fetch
go
                                                                                                                                                                                                                                                               create procedure ACC_fetch
@objectKey int,
@mgiType varchar(80)
as
declare @mgiTypeKey int
select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = "@mgiType"
select _LogicalDB_key, _Accession_key, prefixPart, numericPart, 
accID = prefixPart + convert(varchar(20), numericPart)
from ACC_Accession
where _MGIType_key = @mgiTypeKey
and _Object_key = @objectKey
order by _LogicalDB_key
                                                                                                           
go
grant execute on ACC_fetch to public
go
drop procedure HMD_getChromosomes
go
                                                                                                                                                                                                                                                               create procedure HMD_getChromosomes
                @_Species_key int = NULL
as
/*
 * 	Procedure takes a species key and returns the ordered
 *	list of chromosomes.
 *
 *	DOW Jan 17, 1996
 */
select chromosome 
from MRK_Chromosome 
where _Species_key = @_Species_key 
order by sequenceNum
                                                                                                                                                                                                                             
go
grant execute on HMD_getChromosomes to public
go
drop procedure MRK_updateKeys
go
                                                                                                                                                                                                                                                               
create procedure MRK_updateKeys
  @oldKey integer,
  @newKey integer
as

/* Executed during w/drawal process if only 1 new symbol is designated */

/* Associate all Accession numbers w/ new symbol
   If an Acc# exists for the new symbol, then set the 
   preferred bit for all other Acc# to 0.
   If no Acc# exists for the new symbol, then leave the
   preferred bit alone.
*/

declare @accKey integer
select @accKey = _Accession_key from MRK_Acc_View
where _Object_key = @newKey
and prefixPart = "MGI:"
and preferred = 1

if @accKey is null
begin
	update ACC_Accession 
	set _Object_key = @newKey
	where _MGIType_key = 2 and _Object_key = @oldKey
end
else
begin
	update ACC_Accession 
	set _Object_key = @newKey, preferred = 0
	where _MGIType_key = 2 and _Object_key = @oldKey
end

/* Associate aliases, classes, histories, offsets, other names, references w/ new symbol */

update MRK_Alias set _Marker_key = @newKey where _Marker_key = @oldKey
update MRK_Alias set _Alias_key = @newKey where _Alias_key = @oldKey
update MRK_Allele set _Marker_key = @newKey where _Marker_key = @oldKey
update MRK_Anchors set _Marker_key = @newKey where _Marker_key = @oldKey
update MRK_Classes set _Marker_key = @newKey where _Marker_key = @oldKey
update MRK_Name set _Marker_key = @newKey where _Marker_key = @oldKey
update MRK_Other set _Marker_key = @newKey where _Marker_key = @oldKey
update MRK_Reference set _Marker_key = @newKey where _Marker_key = @oldKey

/* Update all auxiliary references to old symbol w/ new symbol */

update HMD_Homology set _Marker_key = @newKey where _Marker_key = @oldKey
update GXD_Index set _Marker_key = @newKey where _Marker_key = @oldKey

update MLD_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
update MLD_Concordance set _Marker_key = @newKey where _Marker_key = @oldKey
update MLD_Distance set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
update MLD_Distance set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
update MLD_MC2point set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
update MLD_MC2point set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
update MLD_RI2Point set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
update MLD_RI2Point set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
update MLD_Statistics set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
update MLD_Statistics set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
 
/* If the Nomen change would cause duplicates, update RFLV records and remove dups */

select * into #probeduplicates from PRB_Marker 
where _Marker_key = @newKey or _Marker_key = @oldKey
group by _Probe_key having count(*) > 1

if exists (select * from #probeduplicates)
begin
  update PRB_RFLV set _Marker_key = @newKey where _Marker_key = @oldKey
  delete PRB_Marker from PRB_Marker p, #probeduplicates d
     where d._Probe_key = p._Probe_key and
	   d._Marker_key = p._Marker_key
  insert into PRB_Marker (_Probe_key, _Marker_key, relationship) 
	select * from #probeduplicates where _Marker_key = @newKey
end
else
begin
  update PRB_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
end

/* Update MLC Edit tables iff New Symbol entry doesn't exist in MLC */

if not exists (select * from MLC_Marker_edit where _Marker_key = @newKey)
begin
  update MLC_History_edit set _Marker_key = @newKey where _Marker_key = @oldKey
  update MLC_Marker_edit set _Marker_key = @newKey where _Marker_key = @oldKey
  update MLC_Reference_edit set _Marker_key = @newKey where _Marker_key = @oldKey
  update MLC_Text_edit set _Marker_key = @newKey where _Marker_key = @oldKey
end

/* Delete Classes from old symbol which weren't updated because they're duplicates */

delete from MRK_Classes where _Marker_key = @oldKey

                                                             
go
grant execute on MRK_updateKeys to public
go
drop procedure ACC_fetch_byLogical
go
                                                                                                                                                                                                                                                                
create procedure ACC_fetch_byLogical
  @objectKey integer,
  @mgiType varchar(80),
  @logicalDB varchar(80) = "MGI"
as
 
select a.accID, a.prefixPart, a.numericPart
from ACC_Accession a, ACC_MGIType m, ACC_LogicalDB l
where a._Object_key = @objectKey
and a._MGIType_key = m._MGIType_key
and m.name = @mgiType
and a._LogicalDB_key = l._LogicalDB_key
and l.name = @logicalDB

                                                                                                                                      
go
grant execute on ACC_fetch_byLogical to public
go
drop procedure ACC_assignMGI
go
                                                                                                                                                                                                                                                               
create procedure ACC_assignMGI
  @objectKey int,
  @mgiType varchar(80),
  @prefixPart varchar(20) = "MGI:",
  @nextMGI int = -1,
  @preferred int = 1
as

/* Assign MGI or J accession number
   Allow override of J accession number
   Increment ACC_AccessionMax.maxNumericPart
*/

declare @nextACC int
select @nextACC = max(_Accession_key) + 1 from ACC_Accession

declare @mgiTypeKey int
select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType

if @nextMGI = -1
begin
	select @nextMGI = maxNumericPart + 1 
	from ACC_AccessionMax where prefixPart = @prefixPart
end
else if @prefixPart != "J:"
begin
    rollback transaction
    raiserror 99999 "Cannot override generation of MGI accession number"
    return
end

declare @accID varchar(30)
select @accID = @prefixPart + convert(varchar(20), @nextMGI)

insert into ACC_Accession 
(_Accession_key, accID, prefixPart, numericPart, 
_LogicalDB_key, _Object_key, _MGIType_key, preferred)
values(@nextACC, @accID, @prefixPart, @nextMGI, 1, @objectKey, @mgiTypeKey, @preferred)

if (select maxNumericPart from ACC_AccessionMax
    where prefixPart = @prefixPart) <= @nextMGI
begin
	update ACC_AccessionMax 
	set maxNumericPart = @nextMGI 
	where prefixPart = @prefixPart
end

                                       
go
grant execute on ACC_assignMGI to public
go
EOSQL
cat $password | isql -Umgd_dbo -e -i $sql
