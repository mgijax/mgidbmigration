Wed Feb  7 06:00:00 EST 2001
setenv SYBASE /opt/sybase
setenv DATADIR /extra2/sybase
setenv DATABASE mgd_release
setenv BACKUP mgd.backup
setenv DBO mgd_dbo
setenv DBPASSWORD /opt/sybase/admin/.mgd_dbo_password
set sql = /tmp/20644.sql
cat
if ( mgd_dbo != mgd_dbo ) then
cat /opt/sybase/admin/.mgd_dbo_password
isql -SMGD_DEV -Umgd_dbo -i /tmp/20644.sql
Password: 
Backup Server session id is:  25.  Use this value when executing the
'sp_volchanged' system stored procedure after fulfilling any volume change
request from the Backup Server.
Backup Server: 6.28.1.1: Dumpfile name 'mgd01037133CA    ' section number 0001
mounted on disk file '/extra2/sybase/mgd.backup'
Backup Server: 4.58.1.1: Database mgd_release: 51210 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 119316 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 146388 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 225324 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 238324 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 289298 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 326310 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 378400 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 450072 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 498256 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 520786 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 565846 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 623704 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 650332 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 703142 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 746516 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 783976 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 870508 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 914028 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 957040 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1000560 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1043572 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1087092 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1130104 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1173624 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1216636 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1260156 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1303168 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1346688 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1389700 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1433220 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1476232 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1562764 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1606284 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1649296 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1692816 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1735828 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1779348 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1822360 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1865880 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1908892 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1952412 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 1995424 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2038944 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2079394 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2126822 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2182830 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2216448 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2260324 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2309818 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2369216 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2396868 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2444094 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2497752 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2541820 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2586346 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2629106 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2678276 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2728180 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2766758 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2816520 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2877308 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2920828 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2955550 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 2997642 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3058072 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3098526 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3142046 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3185058 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3228578 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3315110 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3358122 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3401642 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3444654 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3488174 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3531186 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3574706 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3617718 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3661238 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3704250 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3747770 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3790782 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3834302 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3877314 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3920834 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 3963846 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4050378 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4093898 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4136910 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4180430 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4222930 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4266450 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4309462 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4352982 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4395994 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4439514 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4482526 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4526046 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4569058 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4608482 kilobytes LOADed.
Backup Server: 4.58.1.1: Database mgd_release: 4608490 kilobytes LOADed.
Backup Server: 3.42.1.1: LOAD is complete (database mgd_release).
Use the ONLINE DATABASE command to bring this database online; SQL Server will
not bring it online automatically.
Database 'mgd_release' is now online.
endif
rm /tmp/20644.sql
/opt/sybase/admin/utilities/mgd_set_perms_dev mgd_release
setenv SYBASE /opt/sybase
setenv DATABASE mgd_release
setenv DBUSER mgd_dbo
setenv DBPASSWORD /opt/sybase/admin/.mgd_dbo_password
set sql = /tmp/20666.sql
cat
cat /opt/sybase/admin/.mgd_dbo_password
isql -SMGD_DEV -Umgd_dbo -e -i /tmp/20666.sql
Password: 
1> 
2> use mgd_release
1> 
2> grant all on ACC_Accession to progs
1> 
2> grant all on ACC_AccessionMax to progs
1> 
2> grant all on ACC_AccessionReference to progs
1> 
2> grant all on ALL_Allele to progs
1> 
2> grant all on ALL_Allele_Mutation to progs
1> 
2> grant all on ALL_Inheritance_Mode to progs
1> 
2> grant all on ALL_Molecular_Mutation to progs
1> 
2> grant all on ALL_Molecular_Note to progs
1> 
2> grant all on ALL_Note to progs
1> 
2> grant all on ALL_Synonym to progs
1> 
2> grant all on ALL_Type to progs
1> 
2> grant all on BIB_Books to progs
1> 
2> grant all on BIB_Notes to progs
1> 
2> grant all on BIB_Refs to progs
1> 
2> grant all on BIB_ReviewStatus to progs
1> 
2> grant all on CRS_Cross to progs
1> 
2> grant all on GXD_AllelePair to progs
1> 
2> grant all on GXD_Antibody to progs
1> 
2> grant all on GXD_AntibodyAlias to progs
1> 
2> grant all on GXD_AntibodyClass to progs
1> 
2> grant all on GXD_AntibodyMarker to progs
1> 
2> grant all on GXD_AntibodyPrep to progs
1> 
2> grant all on GXD_AntibodyType to progs
1> 
2> grant all on GXD_Antigen to progs
1> 
2> grant all on GXD_Assay to progs
1> 
2> grant all on GXD_AssayNote to progs
1> 
2> grant all on GXD_AssayType to progs
1> 
2> grant all on GXD_EmbeddingMethod to progs
1> 
2> grant all on GXD_Expression to progs
1> 
2> grant all on GXD_FixationMethod to progs
1> 
2> grant all on GXD_GelBand to progs
1> 
2> grant all on GXD_GelControl to progs
1> 
2> grant all on GXD_GelLane to progs
1> 
2> grant all on GXD_GelLaneStructure to progs
1> 
2> grant all on GXD_GelRNAType to progs
1> 
2> grant all on GXD_GelRow to progs
1> 
2> grant all on GXD_GelUnits to progs
1> 
2> grant all on GXD_Genotype to progs
1> 
2> grant all on GXD_ISResultStructure to progs
1> 
2> grant all on GXD_InSituResult to progs
1> 
2> grant all on GXD_InSituResultImage to progs
1> 
2> grant all on GXD_Index to progs
1> 
2> grant all on GXD_Index_Stages to progs
1> 
2> grant all on GXD_Label to progs
1> 
2> grant all on GXD_LabelCoverage to progs
1> 
2> grant all on GXD_Pattern to progs
1> 
2> grant all on GXD_ProbePrep to progs
1> 
2> grant all on GXD_ProbeSense to progs
1> 
2> grant all on GXD_Secondary to progs
1> 
2> grant all on GXD_Specimen to progs
1> 
2> grant all on GXD_Strength to progs
1> 
2> grant all on GXD_Structure to progs
1> 
2> grant all on GXD_StructureClosure to progs
1> 
2> grant all on GXD_StructureName to progs
1> 
2> grant all on GXD_TheilerStage to progs
1> 
2> grant all on GXD_VisualizationMethod to progs
1> 
2> grant all on HMD_Assay to progs
1> 
2> grant all on HMD_Class to progs
1> 
2> grant all on HMD_Homology to progs
1> 
2> grant all on HMD_Homology_Assay to progs
1> 
2> grant all on HMD_Homology_Marker to progs
1> 
2> grant all on HMD_Notes to progs
1> 
2> grant all on IMG_FieldType to progs
1> 
2> grant all on IMG_Image to progs
1> 
2> grant all on IMG_ImageNote to progs
1> 
2> grant all on IMG_ImagePane to progs
1> 
2> grant all on MLC_Lock_edit to progs
1> 
2> grant all on MLC_Marker_edit to progs
1> 
2> grant all on MLC_Reference_edit to progs
1> 
2> grant all on MLC_Text_edit to progs
1> 
2> grant all on MLD_Assay_Types to progs
1> 
2> grant all on MLD_Concordance to progs
1> 
2> grant all on MLD_Distance to progs
1> 
2> grant all on MLD_Expt_Marker to progs
1> 
2> grant all on MLD_Expt_Notes to progs
1> 
2> grant all on MLD_Expts to progs
1> 
2> grant all on MLD_FISH to progs
1> 
2> grant all on MLD_FISH_Region to progs
1> 
2> grant references on MLD_Hybrid to progs
1> 
2> grant insert on MLD_Hybrid to progs
1> 
2> grant all on MLD_ISRegion to progs
1> 
2> grant all on MLD_InSitu to progs
1> 
2> grant all on MLD_MC2point to progs
1> 
2> grant all on MLD_MCDataList to progs
1> 
2> grant all on MLD_Marker to progs
1> 
2> grant all on MLD_Matrix to progs
1> 
2> grant all on MLD_Notes to progs
1> 
2> grant all on MLD_PhysMap to progs
1> 
2> grant all on MLD_RI to progs
1> 
2> grant all on MLD_RI2Point to progs
1> 
2> grant all on MLD_RIData to progs
1> 
2> grant all on MLD_Statistics to progs
1> 
2> grant all on MRK_Alias to progs
1> 
2> grant all on MRK_Anchors to progs
1> 
2> grant all on MRK_Chromosome to progs
1> 
2> grant all on MRK_Class to progs
1> 
2> grant all on MRK_Classes to progs
1> 
2> grant all on MRK_Current to progs
1> 
2> grant all on MRK_Event to progs
1> 
2> grant all on MRK_EventReason to progs
1> 
2> grant all on MRK_History to progs
1> 
2> grant all on MRK_Label to progs
1> 
2> grant all on MRK_Marker to progs
1> 
2> grant all on MRK_Notes to progs
1> 
2> grant all on MRK_Offset to progs
1> 
2> grant all on MRK_Other to progs
1> 
2> grant all on MRK_Reference to progs
1> 
2> grant all on MRK_Species to progs
1> 
2> grant all on MRK_Status to progs
1> 
2> grant all on MRK_Types to progs
1> 
2> grant all on PRB_Alias to progs
1> 
2> grant all on PRB_Allele to progs
1> 
2> grant all on PRB_Allele_Strain to progs
1> 
2> grant all on PRB_Marker to progs
1> 
2> grant all on PRB_Notes to progs
1> 
2> grant all on PRB_Probe to progs
1> 
2> grant all on PRB_RFLV to progs
1> 
2> grant all on PRB_Ref_Notes to progs
1> 
2> grant all on PRB_Reference to progs
1> 
2> grant all on PRB_Source to progs
1> 
2> grant all on PRB_Strain to progs
1> 
2> grant all on PRB_Strain_Marker to progs
1> 
2> grant all on PRB_Tissue to progs
1> 
2> grant all on PRB_Vector_Types to progs
1> 
2> grant all on RI_RISet to progs
1> 
2> grant execute on MGI_resetSequenceNum to progs
1> 
2> grant execute on MLC_transfer to progs
1> 
2> grant execute on MRK_copyHistory to progs
1> 
2> grant execute on MRK_mergeWithdrawal to progs
1> 
2> grant execute on MRK_alleleWithdrawal to progs
1> 
2> grant execute on MRK_splitWithdrawal to progs
1> 
2> grant execute on MRK_alleleWithdrawal to progs
1> 
2> grant execute on PRB_mergeTissue to progs
1> 
2> grant execute on PRB_mergeStandardTissue to progs
1> 
2> grant execute on PRB_insertReference to progs
1> 
2> grant execute on MRK_insertHistory to progs
1> 
2> grant execute on MRK_breakpointSplit to progs
1> 
2> grant execute on MRK_addChromosome to progs
1> 
2> grant execute on MRK_reloadReference to progs
1> 
2> grant execute on MRK_reloadLabel to progs
1> 
2> grant execute on ACC_assignJ to progs
1> 
2> grant execute on ACC_assignMGI to progs
1> 
2> grant execute on ACC_delete_byAccKey to progs
1> 
2> grant execute on ACC_delete_byObject to progs
1> 
2> grant execute on ACC_insert to progs
1> 
2> grant execute on ACC_insert_bySpecies to progs
1> 
2> grant execute on ACC_resetMax to progs
1> 
2> grant execute on ACC_update to progs
1> 
2> grant execute on ACCRef_insert to progs
1> 
2> grant execute on ACCRef_process to progs
1> 
2> grant execute on ALL_convertAllele to progs
1> 
2> grant execute on ALL_insertAllele to progs
1> 
2> grant execute on ALL_mergeAllele to progs
1> 
2> grant execute on GXD_loadCacheAll to progs
1> 
2> grant execute on GXD_loadCacheByAssay to progs
1> 
2> grant execute on GXD_SetStructDescPrintName to progs
1> 
2> grant execute on GXD_ComputePrintNamesFrom to progs
1> 
2> grant execute on GXD_SetPreferredName to progs
1> 
2> grant execute on IMG_setPDO to progs
1> 
2> checkpoint
rm /tmp/20666.sql
setenv SYBASE /opt/sybase
setenv DATADIR /extra2/sybase
setenv DATABASE nomen_release
setenv BACKUP nomen.backup
setenv DBO mgd_dbo
setenv DBPASSWORD /opt/sybase/admin/.mgd_dbo_password
set sql = /tmp/20671.sql
cat
if ( mgd_dbo != mgd_dbo ) then
cat /opt/sybase/admin/.mgd_dbo_password
isql -SMGD_DEV -Umgd_dbo -i /tmp/20671.sql
Password: 
Backup Server session id is:  24.  Use this value when executing the
'sp_volchanged' system stored procedure after fulfilling any volume change
request from the Backup Server.
Backup Server: 6.28.1.1: Dumpfile name 'nomen01037137C5  ' section number 0001
mounted on disk file '/extra2/sybase/nomen.backup'
Backup Server: 4.58.1.1: Database nomen_release: 42502 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 54438 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 75274 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 88602 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 92888 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 130064 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 173584 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 216596 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 260116 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 303128 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 346648 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 389660 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 433180 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 476192 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 519712 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 562724 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 563236 kilobytes LOADed.
Backup Server: 4.58.1.1: Database nomen_release: 563244 kilobytes LOADed.
Backup Server: 3.42.1.1: LOAD is complete (database nomen_release).
Caution:  You have set up this database to include space on disk 29 for both
data and the transaction log.  This can make recovery impossible if that disk
fails.
Use the ONLINE DATABASE command to bring this database online; SQL Server will
not bring it online automatically.
User mgd_dbo in database nomen_release has suid 15, which is the same as the
suid of the DBO (as defined in Sysdatabases).  User mgd_dbo will be given suid
-99.
When all load transactions have been completed for database nomen_release, user
mgd_dbo should be given a unique suid.
Database 'nomen_release' is now online.
endif
rm /tmp/20671.sql
/opt/sybase/admin/utilities/mgd_set_perms_dev nomen_release
setenv SYBASE /opt/sybase
setenv DATABASE nomen_release
setenv DBUSER mgd_dbo
setenv DBPASSWORD /opt/sybase/admin/.mgd_dbo_password
set sql = /tmp/20678.sql
cat
cat /opt/sybase/admin/.mgd_dbo_password
isql -SMGD_DEV -Umgd_dbo -e -i /tmp/20678.sql
Password: 
1> 
2> use nomen_release
1> 
2> grant all on ACC_Accession to progs
1> 
2> grant all on ACC_AccessionMax to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_AccessionMax not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on ACC_AccessionReference to progs
1> 
2> grant all on ALL_Allele to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Allele not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Allele_Mutation to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Allele_Mutation not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Inheritance_Mode to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Inheritance_Mode not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Molecular_Mutation to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Molecular_Mutation not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Molecular_Note to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Molecular_Note not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Note to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Note not found. Specify owner.objectname or use sp_help to check whether the
object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Synonym to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Synonym not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Type to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Type not found. Specify owner.objectname or use sp_help to check whether the
object exists (sp_help may produce lots of output).
1> 
2> grant all on BIB_Books to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
BIB_Books not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on BIB_Notes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
BIB_Notes not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on BIB_Refs to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
BIB_Refs not found. Specify owner.objectname or use sp_help to check whether the
object exists (sp_help may produce lots of output).
1> 
2> grant all on BIB_ReviewStatus to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
BIB_ReviewStatus not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on CRS_Cross to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
CRS_Cross not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AllelePair to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AllelePair not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Antibody to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Antibody not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AntibodyAlias to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AntibodyAlias not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AntibodyClass to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AntibodyClass not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AntibodyMarker to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AntibodyMarker not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AntibodyPrep to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AntibodyPrep not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AntibodyType to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AntibodyType not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Antigen to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Antigen not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Assay to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Assay not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AssayNote to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AssayNote not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AssayType to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AssayType not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_EmbeddingMethod to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_EmbeddingMethod not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Expression to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Expression not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_FixationMethod to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_FixationMethod not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelBand to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_GelBand not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelControl to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_GelControl not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelLane to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_GelLane not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelLaneStructure to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_GelLaneStructure not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelRNAType to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_GelRNAType not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelRow to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_GelRow not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelUnits to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_GelUnits not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Genotype to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Genotype not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_ISResultStructure to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_ISResultStructure not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_InSituResult to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_InSituResult not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_InSituResultImage to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_InSituResultImage not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Index to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Index not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Index_Stages to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Index_Stages not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Label to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Label not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_LabelCoverage to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_LabelCoverage not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Pattern to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Pattern not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_ProbePrep to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_ProbePrep not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_ProbeSense to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_ProbeSense not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Secondary to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Secondary not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Specimen to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Specimen not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Strength to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Strength not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Structure to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Structure not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_StructureClosure to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_StructureClosure not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_StructureName to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_StructureName not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_TheilerStage to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_TheilerStage not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_VisualizationMethod to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_VisualizationMethod not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on HMD_Assay to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
HMD_Assay not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on HMD_Class to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
HMD_Class not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on HMD_Homology to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
HMD_Homology not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on HMD_Homology_Assay to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
HMD_Homology_Assay not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on HMD_Homology_Marker to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
HMD_Homology_Marker not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on HMD_Notes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
HMD_Notes not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on IMG_FieldType to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
IMG_FieldType not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on IMG_Image to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
IMG_Image not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on IMG_ImageNote to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
IMG_ImageNote not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on IMG_ImagePane to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
IMG_ImagePane not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLC_Lock_edit to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLC_Lock_edit not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLC_Marker_edit to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLC_Marker_edit not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLC_Reference_edit to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLC_Reference_edit not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLC_Text_edit to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLC_Text_edit not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Assay_Types to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Assay_Types not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Concordance to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Concordance not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Distance to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Distance not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Expt_Marker to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Expt_Marker not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Expt_Notes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Expt_Notes not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Expts to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Expts not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_FISH to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_FISH not found. Specify owner.objectname or use sp_help to check whether the
object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_FISH_Region to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_FISH_Region not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant references on MLD_Hybrid to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Hybrid not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant insert on MLD_Hybrid to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Hybrid not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_ISRegion to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_ISRegion not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_InSitu to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_InSitu not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_MC2point to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_MC2point not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_MCDataList to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_MCDataList not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Marker to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Marker not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Matrix to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Matrix not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Notes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Notes not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_PhysMap to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_PhysMap not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_RI to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_RI not found. Specify owner.objectname or use sp_help to check whether the
object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_RI2Point to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_RI2Point not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_RIData to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_RIData not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Statistics to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Statistics not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Alias to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Alias not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Anchors to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Anchors not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Chromosome to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Chromosome not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Class to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Class not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Classes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Classes not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Current to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Current not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Event to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Event not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_EventReason to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_EventReason not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_History to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_History not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Label to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Label not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Marker to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Marker not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Notes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Notes not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Offset to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Offset not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Other to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Other not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Reference to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Reference not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Species to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Species not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Status to progs
1> 
2> grant all on MRK_Types to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Types not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Alias to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Alias not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Allele to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Allele not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Allele_Strain to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Allele_Strain not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Marker to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Marker not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Notes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Notes not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Probe to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Probe not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_RFLV to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_RFLV not found. Specify owner.objectname or use sp_help to check whether the
object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Ref_Notes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Ref_Notes not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Reference to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Reference not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Source to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Source not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Strain to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Strain not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Strain_Marker to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Strain_Marker not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Tissue to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Tissue not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Vector_Types to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Vector_Types not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on RI_RISet to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
RI_RISet not found. Specify owner.objectname or use sp_help to check whether the
object exists (sp_help may produce lots of output).
1> 
2> grant execute on MGI_resetSequenceNum to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MGI_resetSequenceNum not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MLC_transfer to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLC_transfer not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_copyHistory to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_copyHistory not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_mergeWithdrawal to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_mergeWithdrawal not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_alleleWithdrawal to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_alleleWithdrawal not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_splitWithdrawal to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_splitWithdrawal not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_alleleWithdrawal to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_alleleWithdrawal not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on PRB_mergeTissue to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_mergeTissue not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on PRB_mergeStandardTissue to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_mergeStandardTissue not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on PRB_insertReference to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_insertReference not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_insertHistory to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_insertHistory not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_breakpointSplit to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_breakpointSplit not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_addChromosome to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_addChromosome not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_reloadReference to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_reloadReference not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_reloadLabel to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_reloadLabel not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ACC_assignJ to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_assignJ not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ACC_assignMGI to progs
1> 
2> grant execute on ACC_delete_byAccKey to progs
1> 
2> grant execute on ACC_delete_byObject to progs
1> 
2> grant execute on ACC_insert to progs
1> 
2> grant execute on ACC_insert_bySpecies to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_insert_bySpecies not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ACC_resetMax to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_resetMax not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ACC_update to progs
1> 
2> grant execute on ACCRef_insert to progs
1> 
2> grant execute on ACCRef_process to progs
1> 
2> grant execute on ALL_convertAllele to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_convertAllele not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ALL_insertAllele to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_insertAllele not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ALL_mergeAllele to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_mergeAllele not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on GXD_loadCacheAll to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_loadCacheAll not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on GXD_loadCacheByAssay to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_loadCacheByAssay not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on GXD_SetStructDescPrintName to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_SetStructDescPrintName not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on GXD_ComputePrintNamesFrom to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_ComputePrintNamesFrom not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on GXD_SetPreferredName to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_SetPreferredName not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on IMG_setPDO to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
IMG_setPDO not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> checkpoint
rm /tmp/20678.sql
setenv SYBASE /opt/sybase
setenv DATADIR /extra2/sybase
setenv DATABASE strains_release
setenv BACKUP strains.backup
setenv DBO mgd_dbo
setenv DBPASSWORD /opt/sybase/admin/.mgd_dbo_password
set sql = /tmp/20683.sql
cat
if ( mgd_dbo != mgd_dbo ) then
cat /opt/sybase/admin/.mgd_dbo_password
isql -SMGD_DEV -Umgd_dbo -i /tmp/20683.sql
Password: 
Backup Server session id is:  13.  Use this value when executing the
'sp_volchanged' system stored procedure after fulfilling any volume change
request from the Backup Server.
Backup Server: 6.28.1.1: Dumpfile name 'strains01037137E4' section number 0001
mounted on disk file '/extra2/sybase/strains.backup'
Backup Server: 4.58.1.1: Database strains_release: 43528 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 87048 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 130060 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 173580 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 216592 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 260112 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 303124 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 346644 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 389656 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 433176 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 476188 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 519708 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 562208 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 605728 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 648740 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 692260 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 716838 kilobytes LOADed.
Backup Server: 4.58.1.1: Database strains_release: 716846 kilobytes LOADed.
Backup Server: 3.42.1.1: LOAD is complete (database strains_release).
Use the ONLINE DATABASE command to bring this database online; SQL Server will
not bring it online automatically.
User mgd_dbo in database strains_release has suid 15, which is the same as the
suid of the DBO (as defined in Sysdatabases).  User mgd_dbo will be given suid
-99.
When all load transactions have been completed for database strains_release,
user mgd_dbo should be given a unique suid.
Database 'strains_release' is now online.
endif
rm /tmp/20683.sql
/opt/sybase/admin/utilities/mgd_set_perms_dev strains_release
setenv SYBASE /opt/sybase
setenv DATABASE strains_release
setenv DBUSER mgd_dbo
setenv DBPASSWORD /opt/sybase/admin/.mgd_dbo_password
set sql = /tmp/20697.sql
cat
cat /opt/sybase/admin/.mgd_dbo_password
isql -SMGD_DEV -Umgd_dbo -e -i /tmp/20697.sql
Password: 
1> 
2> use strains_release
1> 
2> grant all on ACC_Accession to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_Accession not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on ACC_AccessionMax to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_AccessionMax not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on ACC_AccessionReference to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_AccessionReference not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Allele to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Allele not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Allele_Mutation to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Allele_Mutation not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Inheritance_Mode to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Inheritance_Mode not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Molecular_Mutation to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Molecular_Mutation not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Molecular_Note to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Molecular_Note not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Note to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Note not found. Specify owner.objectname or use sp_help to check whether the
object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Synonym to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Synonym not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on ALL_Type to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_Type not found. Specify owner.objectname or use sp_help to check whether the
object exists (sp_help may produce lots of output).
1> 
2> grant all on BIB_Books to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
BIB_Books not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on BIB_Notes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
BIB_Notes not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on BIB_Refs to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
BIB_Refs not found. Specify owner.objectname or use sp_help to check whether the
object exists (sp_help may produce lots of output).
1> 
2> grant all on BIB_ReviewStatus to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
BIB_ReviewStatus not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on CRS_Cross to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
CRS_Cross not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AllelePair to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AllelePair not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Antibody to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Antibody not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AntibodyAlias to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AntibodyAlias not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AntibodyClass to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AntibodyClass not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AntibodyMarker to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AntibodyMarker not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AntibodyPrep to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AntibodyPrep not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AntibodyType to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AntibodyType not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Antigen to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Antigen not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Assay to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Assay not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AssayNote to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AssayNote not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_AssayType to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_AssayType not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_EmbeddingMethod to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_EmbeddingMethod not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Expression to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Expression not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_FixationMethod to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_FixationMethod not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelBand to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_GelBand not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelControl to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_GelControl not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelLane to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_GelLane not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelLaneStructure to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_GelLaneStructure not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelRNAType to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_GelRNAType not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelRow to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_GelRow not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_GelUnits to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_GelUnits not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Genotype to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Genotype not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_ISResultStructure to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_ISResultStructure not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_InSituResult to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_InSituResult not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_InSituResultImage to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_InSituResultImage not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Index to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Index not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Index_Stages to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Index_Stages not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Label to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Label not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_LabelCoverage to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_LabelCoverage not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Pattern to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Pattern not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_ProbePrep to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_ProbePrep not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_ProbeSense to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_ProbeSense not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Secondary to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Secondary not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Specimen to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Specimen not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Strength to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Strength not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_Structure to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_Structure not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_StructureClosure to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_StructureClosure not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_StructureName to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_StructureName not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_TheilerStage to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_TheilerStage not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on GXD_VisualizationMethod to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_VisualizationMethod not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on HMD_Assay to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
HMD_Assay not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on HMD_Class to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
HMD_Class not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on HMD_Homology to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
HMD_Homology not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on HMD_Homology_Assay to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
HMD_Homology_Assay not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on HMD_Homology_Marker to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
HMD_Homology_Marker not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on HMD_Notes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
HMD_Notes not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on IMG_FieldType to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
IMG_FieldType not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on IMG_Image to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
IMG_Image not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on IMG_ImageNote to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
IMG_ImageNote not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on IMG_ImagePane to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
IMG_ImagePane not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLC_Lock_edit to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLC_Lock_edit not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLC_Marker_edit to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLC_Marker_edit not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLC_Reference_edit to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLC_Reference_edit not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLC_Text_edit to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLC_Text_edit not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Assay_Types to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Assay_Types not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Concordance to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Concordance not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Distance to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Distance not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Expt_Marker to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Expt_Marker not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Expt_Notes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Expt_Notes not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Expts to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Expts not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_FISH to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_FISH not found. Specify owner.objectname or use sp_help to check whether the
object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_FISH_Region to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_FISH_Region not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant references on MLD_Hybrid to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Hybrid not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant insert on MLD_Hybrid to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Hybrid not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_ISRegion to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_ISRegion not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_InSitu to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_InSitu not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_MC2point to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_MC2point not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_MCDataList to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_MCDataList not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Marker to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Marker not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Matrix to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Matrix not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Notes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Notes not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_PhysMap to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_PhysMap not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_RI to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_RI not found. Specify owner.objectname or use sp_help to check whether the
object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_RI2Point to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_RI2Point not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_RIData to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_RIData not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MLD_Statistics to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLD_Statistics not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Alias to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Alias not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Anchors to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Anchors not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Chromosome to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Chromosome not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Class to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Class not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Classes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Classes not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Current to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Current not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Event to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Event not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_EventReason to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_EventReason not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_History to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_History not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Label to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Label not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Marker to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Marker not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Notes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Notes not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Offset to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Offset not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Other to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Other not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Reference to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Reference not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Species to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Species not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Status to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Status not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on MRK_Types to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_Types not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Alias to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Alias not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Allele to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Allele not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Allele_Strain to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Allele_Strain not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Marker to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Marker not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Notes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Notes not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Probe to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Probe not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_RFLV to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_RFLV not found. Specify owner.objectname or use sp_help to check whether the
object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Ref_Notes to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Ref_Notes not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Reference to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Reference not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Source to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Source not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Strain to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Strain not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Strain_Marker to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Strain_Marker not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Tissue to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Tissue not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant all on PRB_Vector_Types to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_Vector_Types not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant all on RI_RISet to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
RI_RISet not found. Specify owner.objectname or use sp_help to check whether the
object exists (sp_help may produce lots of output).
1> 
2> grant execute on MGI_resetSequenceNum to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MGI_resetSequenceNum not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MLC_transfer to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MLC_transfer not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_copyHistory to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_copyHistory not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_mergeWithdrawal to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_mergeWithdrawal not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_alleleWithdrawal to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_alleleWithdrawal not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_splitWithdrawal to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_splitWithdrawal not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_alleleWithdrawal to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_alleleWithdrawal not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on PRB_mergeTissue to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_mergeTissue not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on PRB_mergeStandardTissue to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_mergeStandardTissue not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on PRB_insertReference to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
PRB_insertReference not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_insertHistory to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_insertHistory not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_breakpointSplit to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_breakpointSplit not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_addChromosome to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_addChromosome not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_reloadReference to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_reloadReference not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on MRK_reloadLabel to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
MRK_reloadLabel not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ACC_assignJ to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_assignJ not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ACC_assignMGI to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_assignMGI not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ACC_delete_byAccKey to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_delete_byAccKey not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ACC_delete_byObject to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_delete_byObject not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ACC_insert to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_insert not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ACC_insert_bySpecies to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_insert_bySpecies not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ACC_resetMax to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_resetMax not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ACC_update to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACC_update not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ACCRef_insert to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACCRef_insert not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ACCRef_process to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ACCRef_process not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ALL_convertAllele to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_convertAllele not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ALL_insertAllele to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_insertAllele not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on ALL_mergeAllele to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
ALL_mergeAllele not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on GXD_loadCacheAll to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_loadCacheAll not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on GXD_loadCacheByAssay to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_loadCacheByAssay not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on GXD_SetStructDescPrintName to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_SetStructDescPrintName not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on GXD_ComputePrintNamesFrom to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_ComputePrintNamesFrom not found. Specify owner.objectname or use sp_help to
check whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on GXD_SetPreferredName to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
GXD_SetPreferredName not found. Specify owner.objectname or use sp_help to check
whether the object exists (sp_help may produce lots of output).
1> 
2> grant execute on IMG_setPDO to progs
Msg 208, Level 16, State 2:
Server 'MGD_DEV', Line 2:
IMG_setPDO not found. Specify owner.objectname or use sp_help to check whether
the object exists (sp_help may produce lots of output).
1> 
2> checkpoint
rm /tmp/20697.sql
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop trigger ACC_Accession_Insert
1> 
2> create trigger ACC_Accession_Insert
3> on ACC_Accession
4> for insert
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   declare @accID varchar(30)
10>   select @accID = accID from inserted
11> 
12>   /* For Nucleotide Sequences, check that it is valid */
13> 
14>   if (select _LogicalDB_key from inserted) = 9 and
15>      (select @accID) not like '[A-Z][0-9][0-9][0-9][0-9][0-9]' and
16>      (select @accID) not like '[A-Z][A-Z][0-9][0-9][0-9][0-9][0-9][0-9]'
17>   begin
18> 	rollback transaction
19> 	raiserror 99999 "Invalid Nucleotide Sequence Accession Number '%1!'.  Number must be single uppercase letter + 5 numbers OR 2 uppercase letters + 6 numbers.", @accID
20> 	return
21>   end
22> 
23>   /* For SWISS-PROT, only allow specific users to edit Accession numbers */
24>   /* Must include users who can perform marker withdrawals */
25> 
26>   if (select _LogicalDB_key from inserted) = 13 and
27>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "cml", "neb", "djr", "dph", "ljm", "lmm")
28>   begin
29> 	rollback transaction
30> 	raiserror 99999 "You do not have permission to edit SWISS-PROT Accession numbers."
31> 	return
32>   end
33> 
34>   /* For LocusLink/RefSeq, only allow specific users to edit Accession numbers */
35>   /* Must include users who can perform marker withdrawals */
36> 
37>   if (select _LogicalDB_key from inserted) in (24, 27) and
38>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "cml", "djr", "ljm", "lmm", "sr")
39>   begin
40> 	rollback transaction
41> 	raiserror 99999 "You do not have permission to edit LocusLink or RefSeq Accession numbers."
42> 	return
43>   end
44> 
45>   /* For InterPro, only allow specific users to edit Accession numbers */
46>   /* Must include users who can perform marker withdrawals */
47> 
48>   if (select _LogicalDB_key from inserted) = 28 and
49>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "cml", "ljm", "lmm", "dph", "hjd")
50>   begin
51> 	rollback transaction
52> 	raiserror 99999 "You do not have permission to edit InterPro Accession numbers."
53> 	return
54>   end
55> 
56>   /* If adding Sequence ID for Molecular Segment */
57>   /* and the Sequence ID does not exist for one of the encoding Markers */
58> 
59>   if (select _LogicalDB_key from inserted) = 9 and
60>       (select _MGIType_key from inserted) = 3
61>   begin
62> 	/* test to see if any markers are specified to encode this segment
63>        (set within the Mol Probes EI's "Chr Marker Relationship" table) */
64>       if exists (select *
65>          from ACC_Accession a, PRB_Marker pm, inserted i
66>          where i._Object_key = pm._Probe_key and
67>          a._Object_key = pm._Marker_key and
68>          a._MGIType_key = 2 and
69>          a._LogicalDB_key = 9 and
70>          pm.relationship = 'E')
71>       begin
72>       /* if so, see if all of them have associated Sequence IDs entered
73>          for the encoding markers (from the Marker EI)*/
74>         if exists (select * 
75>                  from ACC_Accession a2, inserted i
76>                  where i._Object_key = a2._Object_key and
77>                  a2.accID = i.accID and
78>                  a2._MGIType_key = 3 and
79>                  a2.accID not in (select a.accID
80>                                from ACC_Accession a, PRB_Marker pm, inserted i
81>                                where i._Object_key = pm._Probe_key and 
82>                                a._Object_key = pm._Marker_key and
83> 		                       a._MGIType_key = 2 and
84>                                a._LogicalDB_key = 9 and
85>                                pm.relationship = 'E'))
86>         begin
87>            /* No. one or more encodes relationships are missing seq ids */ 
88>      	   print "Sequence IDs for Marker(s) encoding this segment do 
89> not exist for all encodes relationships specified. 
90> Some Sequence ids might need to be added."
91>         end
92>      end
93>   end
94> 
95>   /* If inserting the Sequence or SWISS-PROT ID for a Marker */
96>   /* and the same ID exists for another Marker...*/
97> 
98>   if (select _LogicalDB_key from inserted) in (9, 13) and
99>       (select _MGIType_key from inserted) = 2 and
100>       exists (select a._Accession_key
101>               from ACC_Accession a, inserted i
102>               where i.accID = a.accID and
103> 		    i._Object_key != a._Object_key and
104> 	            a._MGIType_key = 2)
105>   begin
106> 	print "The Accession ID '%1!' is associated with another Marker.", @accID
107>   end
108> 
109> end
110> 
1> 
2> drop trigger ACC_Accession_Update
1> 
2> create trigger ACC_Accession_Update
3> on ACC_Accession
4> for update
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   declare @accID varchar(30)
10>   select @accID = accID from inserted
11> 
12>   /* For Nucleotide Sequences, check that it is valid */
13> 
14>   if (select _LogicalDB_key from inserted) = 9 and
15>      (select @accID) not like '[A-Z][0-9][0-9][0-9][0-9][0-9]' and
16>      (select @accID) not like '[A-Z][A-Z][0-9][0-9][0-9][0-9][0-9][0-9]'
17>   begin
18> 	rollback transaction
19> 	raiserror 99999 "Invalid Nucleotide Sequence Accession Number '%1!'.  Number must be single uppercase letter + 5 numbers OR 2 uppercase letters + 6 numbers.", @accID
20> 	return
21>   end
22> 
23>   /* For SWISS-PROT, only allow specific users to edit Accession numbers */
24>   /* Must include users who can perform marker withdrawals */
25>  
26>   if (select _LogicalDB_key from inserted) = 13 and
27>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "cml", "neb", "dph", "ljm", "lmm")
28>   begin
29>         rollback transaction
30>         raiserror 99999 "You do not have permission to edit SWISS-PROT Accession numbers."
31>         return
32>   end
33>  
34>   /* For LocusLink, only allow specific users to edit Accession numbers */
35>   /* Must include users who can perform marker withdrawals */
36> 
37>   if (select _LogicalDB_key from inserted) in (24, 27) and
38>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "cml", "djr", "ljm", "lmm", "sr")
39>   begin
40> 	rollback transaction
41> 	raiserror 99999 "You do not have permission to edit LocusLink or RefSeq Accession numbers."
42> 	return
43>   end
44> 
45>   /* For InterPro, only allow specific users to edit Accession numbers */
46>   /* Must include users who can perform marker withdrawals */
47> 
48>   if (select _LogicalDB_key from inserted) = 28 and
49>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "cml", "ljm", "lmm", "dph", "hjd")
50>   begin
51> 	rollback transaction
52> 	raiserror 99999 "You do not have permission to edit InterPro Accession numbers."
53> 	return
54>   end
55> 
56>   select @accID = accID from deleted
57> 
58>   /* If updating Sequence ID for Molecular Segment */
59>   /* and the same Sequence ID exists for one of the Segment's Markers... */
60> 
61>   if (select _LogicalDB_key from inserted) = 9 and
62>       (select _MGIType_key from inserted) = 3 and
63>       exists (select a._Accession_key
64>               from ACC_Accession a, PRB_Marker pm, deleted d
65>               where d.accID = a.accID and
66> 		    d._Object_key = pm._Probe_key and
67> 		    pm._Marker_key = a._Object_key and
68> 	            a._MGIType_key = 2)
69>   begin
70> 	print "Please review the relationship(s) between the Sequence ID '%1!' and the Molecular Segment's Marker(s).  These relationships may no longer be appropriate.", @accID
71>   end
72> 
73>   /* If updating the Sequence ID for a Marker */
74>   /* and the same Sequence ID exists for one of the Marker's Segments...*/
75> 
76>   if (select _LogicalDB_key from inserted) = 9 and
77>       (select _MGIType_key from inserted) = 2 and
78>       exists (select a._Accession_key
79>               from ACC_Accession a, PRB_Marker pm, deleted d
80>               where d.accID = a.accID and
81> 		    d._Object_key = pm._Marker_key and
82> 		    pm._Probe_key = a._Object_key and
83> 	            a._MGIType_key = 3)
84>   begin
85> 	print "Please review the relationship(s) between the Sequence ID '%1!' and its Molecular Segments.  These relationships may no longer be appropriate.", @accID
86>   end
87> 
88>   /* If updating the Sequence or SWISS-PROT ID for a Marker */
89>   /* and the same ID exists for another Marker...*/
90> 
91>   if (select _LogicalDB_key from inserted) in (9, 13) and
92>       (select _MGIType_key from inserted) = 2 and
93>       exists (select a._Accession_key
94>               from ACC_Accession a, inserted i
95>               where i.accID = a.accID and
96> 		    i._Object_key != a._Object_key and
97> 	            a._MGIType_key = 2)
98>   begin
99> 	print "The Accession ID '%1!' is associated with another Marker.", @accID
100>   end
101> end
102> 
103> /* If max J: in Acc table does not equal max J: in max table, then re-set max J: in max table */
104> 
105> if exists (select * from inserted where prefixPart = "J:")
106> begin
107>   declare @maxJ int
108>   select @maxJ = max(numericPart) from ACC_Accession(index index_prefixPart) where prefixPart = "J:"
109>   if @maxJ != (select maxNumericPart from ACC_AccessionMax where prefixPart = "J:")
110>   begin
111>     update ACC_AccessionMax
112>     set maxNumericPart = @maxJ
113>     where prefixPart = "J:"
114>   end
115> end
116> 
1> 
2> drop trigger ACC_Accession_Delete
1> 
2> create trigger ACC_Accession_Delete
3> on ACC_Accession
4> for delete
5> as
6> 
7> if @@rowcount = 1
8> begin
9> 
10>   /* For SWISS-PROT, only allow specific users to edit Accession numbers */
11>   /* Must include users who can perform marker withdrawals */
12>  
13>   if (select _LogicalDB_key from deleted) = 13 and
14>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "cml", "neb", "dph", "ljm", "lmm")
15>   begin
16>         rollback transaction
17>         raiserror 99999 "You do not have permission to edit SWISS-PROT Accession numbers."
18>         return
19>   end
20>  
21>   /* For LocusLink, only allow specific users to edit Accession numbers */
22>   /* Must include users who can perform marker withdrawals */
23> 
24>   if (select _LogicalDB_key from deleted) in (24, 27) and
25>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "cml", "djr", "ljm", "lmm", "sr")
26>   begin
27> 	rollback transaction
28> 	raiserror 99999 "You do not have permission to edit LocusLink or RefSeq Accession numbers."
29> 	return
30>   end
31> 
32>   /* For InterPro, only allow specific users to edit Accession numbers */
33>   /* Must include users who can perform marker withdrawals */
34> 
35>   if (select _LogicalDB_key from deleted) = 28 and
36>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "cml", "ljm", "lmm", "dph", "hjd")
37>   begin
38> 	rollback transaction
39> 	raiserror 99999 "You do not have permission to edit InterPro Accession numbers."
40> 	return
41>   end
42> 
43>   /* If deleting MGI Image Pixel number, then nullify X/Y Dimensions of IMG_Image record TR#134 */
44> 
45>   if (select _LogicalDB_key from deleted) = 19
46>   begin
47> 	update IMG_Image
48> 	set IMG_Image.xDim = null, 
49> 	    IMG_Image.yDim = null
50> 	from deleted, IMG_Image
51> 	where deleted._Object_key = IMG_Image._Image_key
52>   end
53> 
54>   /* If deleting Sequence ID from Molecular Segment */
55>   /* and the same Sequence ID exists for one of the Segment's Markers... */
56> 
57>   declare @accID varchar(30)
58>   select @accID = accID from deleted
59> 
60>   if (select _LogicalDB_key from deleted) = 9 and
61>       (select _MGIType_key from deleted) = 3 and
62>       exists (select a._Accession_key
63>               from ACC_Accession a, PRB_Marker pm, deleted d
64>               where d.accID = a.accID and
65> 		    d._Object_key = pm._Probe_key and
66> 		    pm._Marker_key = a._Object_key and
67> 	            a._MGIType_key = 2)
68>   begin
69> 	print "Please review the relationship(s) between the Sequence ID '%1!' and the Molecular Segment's Marker(s).  These relationships may no longer be appropriate.", @accID
70>   end
71> 
72>   /* If deleting the Sequence ID from a Marker */
73>   /* and the same Sequence ID exists for one of the Marker's Segments...*/
74> 
75>   if (select _LogicalDB_key from deleted) = 9 and
76>       (select _MGIType_key from deleted) = 2 and
77>       exists (select a._Accession_key
78>               from ACC_Accession a, PRB_Marker pm, deleted d
79>               where d.accID = a.accID and
80> 		    d._Object_key = pm._Marker_key and
81> 		    pm._Probe_key = a._Object_key and
82> 	            a._MGIType_key = 3)
83>   begin
84> 	print "Please review the relationship(s) between the Sequence ID '%1!' and its Molecular Segments.  These relationships may no longer be appropriate.", @accID
85>   end
86> end
87> 
88> /* If max J: in Acc table does not equal max J: in max table, then re-set max J: in max table */
89> 
90> if exists (select * from deleted where prefixPart = "J:")
91> begin
92>   declare @maxJ int
93>   select @maxJ = max(numericPart) from ACC_Accession(index index_prefixPart) where prefixPart = "J:"
94>   if @maxJ != (select maxNumericPart from ACC_AccessionMax where prefixPart = "J:")
95>   begin
96>     update ACC_AccessionMax
97>     set maxNumericPart = @maxJ
98>     where prefixPart = "J:"
99>   end
100> end
101> 
102> delete ACC_AccessionReference
103> from ACC_AccessionReference a, deleted d
104> where a._Accession_key = d._Accession_key
105> 
1> 
2> drop trigger ACC_AccessionReference_Insert
1> 
2> create trigger ACC_AccessionReference_Insert
3> on ACC_AccessionReference
4> for insert
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   if (select a._MGIType_key from ACC_Accession a, inserted i
10>       where a._Accession_key = i._Accession_key) = 2
11>   begin
12>         /* Insert entry in Marker Reference bucket if it doesn't already exist */
13> 
14>         if not exists (select * from MRK_Reference r, inserted i, ACC_Accession a
15>             where i._Accession_key = a._Accession_key and
16>                   a._Object_key = r._Marker_key and
17>                   r._Refs_key = i._Refs_key)
18>         begin
19>                 insert MRK_Reference (_Marker_key, _Refs_key, auto) 
20>                 select _Object_key, _Refs_key, 1 from inserted i, ACC_Accession a
21>                 where i._Accession_key = a._Accession_key
22>         end
23>   end
24> 
25>   /* For InterPro, only allow use of Reference J:53168 (53672) */
26> 
27>   if (select a._LogicalDB_key from inserted i, ACC_Accession a
28> 	where i._Accession_key = a._Accession_key) = 28 and
29>      (select _Refs_key from inserted) != 53672
30>   begin
31> 	rollback transaction
32> 	raiserror 99999 "You do not have permission to use any reference except J:53168 with InterPro Accession numbers."
33> 	return
34>   end
35> 
36> end
37> 
1> 
2> drop trigger ACC_AccessionReference_Update
1> 
2> create trigger ACC_AccessionReference_Update
3> on ACC_AccessionReference
4> for update
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   if update(_Refs_key) and
10>      (select a._MGIType_key from ACC_Accession a, inserted i
11>       where a._Accession_key = i._Accession_key) = 2
12>   begin
13>         /* Insert entry in Marker Reference bucket if it doesn't already exist */
14> 
15>         if not exists (select * from MRK_Reference r, inserted i, ACC_Accession a
16>             where i._Accession_key = a._Accession_key and
17>                   a._Object_key = r._Marker_key and
18>                   r._Refs_key = i._Refs_key)
19>         begin
20>                 insert MRK_Reference (_Marker_key, _Refs_key, auto) 
21>                 select _Object_key, _Refs_key, 1 from inserted i, ACC_Accession a
22>                 where i._Accession_key = a._Accession_key
23>         end
24>   end
25> 
26>   /* For InterPro, only allow use of Reference J:53168 (53672) */
27> 
28>   if (select a._LogicalDB_key from inserted i, ACC_Accession a
29> 	where i._Accession_key = a._Accession_key) = 28 and
30>      (select _Refs_key from inserted) != 53672
31>   begin
32> 	rollback transaction
33> 	raiserror 99999 "You do not have permission to use any reference except J:53168 with InterPro Accession numbers."
34> 	return
35>   end
36> end
37> 
1> 
2> drop trigger ACC_LogicalDB_Delete 
1> 
2> create trigger ACC_LogicalDB_Delete 
3> on ACC_LogicalDB
4> for delete
5> as
6> 
7> if exists (select * from deleted, ACC_Accession
8>         where ACC_Accession._LogicalDB_key = deleted._LogicalDB_key)
9>  
10> begin
11> 	rollback transaction
12> 	raiserror 99999 "Logical DB is referenced in Accession Record(s)"
13> 	return
14> end
15> 
16> delete ACC_ActualDB from ACC_ActualDB, deleted
17> where ACC_ActualDB._LogicalDB_key = deleted._LogicalDB_key
18> 
1>  
2>  
3> drop trigger ACC_LogicalDB_Update 
1> 
2> create trigger  ACC_LogicalDB_Update
3> on ACC_LogicalDB
4> for update
5> as
6> 
7> if update(_Species_key) and
8>    (select _Species_key from deleted) != (select _Species_key from inserted) and
9>    exists (select * from ACC_Accession, inserted
10>     where ACC_Accession._LogicalDB_key = inserted._LogicalDB_key)
11> begin
12> 	rollback transaction
13> 	raiserror 99999 "Cannot update Species because Accession numbers exist for this Logical DB."
14> 	return
15> end
16>  
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop trigger ALL_Allele_Insert
1> 
2> create trigger ALL_Allele_Insert
3> on ALL_Allele
4> for insert
5> as
6> 
7> declare @key integer
8> select @key = _Allele_key from inserted
9> exec ACC_assignMGI @key, "Allele"
10> 
11> if (@@error != 0)
12> begin
13> 	rollback transaction
14> 	return
15> end
16> 
1> 
2> drop trigger ALL_Allele_Delete
1> 
2> create trigger ALL_Allele_Delete
3> on ALL_Allele
4> for delete
5> as
6> 
7> /* Disallow deletion if Allele is currently referenced elsewhere */
8> 
9> if exists (select * from GXD_AllelePair, deleted
10> 	where GXD_AllelePair._Allele_key_1 = deleted._Allele_key)
11> begin
12> 	rollback transaction
13> 	raiserror 99999 "Allele Symbol is referenced in GXD Allele Pair Record(s)"
14> 	return
15> end
16> 
17> if exists (select * from GXD_AllelePair, deleted
18> 	where GXD_AllelePair._Allele_key_2 = deleted._Allele_key)
19> begin
20> 	rollback transaction
21> 	raiserror 99999 "Allele Symbol is referenced in GXD Allele Pair Record(s)"
22> 	return
23> end
24> 
25> if exists (select * from MLD_Expt_Marker, deleted
26> 	where MLD_Expt_Marker._Allele_key = deleted._Allele_key)
27> begin
28> 	rollback transaction
29> 	raiserror 99999 "Allele Symbol is referenced in Mapping Experiment Marker Record(s)"
30> 	return
31> end
32> 
33> delete ALL_Allele_Mutation from ALL_Allele_Mutation, deleted
34> where ALL_Allele_Mutation._Allele_key = deleted._Allele_key
35> 
36> delete ALL_Molecular_Note from ALL_Molecular_Note, deleted
37> where ALL_Molecular_Note._Allele_key = deleted._Allele_key
38> 
39> delete ALL_Note from ALL_Note, deleted
40> where ALL_Note._Allele_key = deleted._Allele_key
41> 
42> delete ALL_Synonym from ALL_Synonym, deleted
43> where ALL_Synonym._Allele_key = deleted._Allele_key
44> 
45> delete ACC_Accession
46> from ACC_Accession a, ACC_MGIType m, deleted
47> where a._Object_key = deleted._Allele_key
48> and a._MGIType_key = m._MGIType_key
49> and m.name = "Allele"
50> 
1> 
2> drop trigger ALL_Type_Delete
1> 
2> create trigger ALL_Type_Delete
3> on ALL_Type
4> for delete
5> as
6> 
7> /* Disallow deletion of allele type which is referenced in Allele table */
8> 
9> if exists (select * from ALL_Allele, deleted
10>          where ALL_Allele._Allele_Type_key = deleted._Allele_Type_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Allele Type is referenced in Allele Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger ALL_Inheritance_Mode_Delete
1> 
2> create trigger ALL_Inheritance_Mode_Delete
3> on ALL_Inheritance_Mode
4> for delete
5> as
6> 
7> /* Disallow deletion of inheritance mode which is referenced in Allele table */
8> 
9> if exists (select * from ALL_Allele, deleted
10>          where ALL_Allele._Mode_key = deleted._Mode_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Inheritance Mode is referenced in Allele Record(s)"
14> 	return
15> end
16> 
1> 
2> checkpoint
1> 
2> drop trigger ALL_Molecular_Mutation_Delete
1> 
2> create trigger ALL_Molecular_Mutation_Delete
3> on ALL_Molecular_Mutation
4> for delete
5> as
6> 
7> /* Disallow deletion of molecular mutation which is referenced in Allele table */
8> 
9> if exists (select * from ALL_Allele_Mutation, deleted
10>          where ALL_Allele_Mutation._Mutation_key = deleted._Mutation_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Molecular Mutation is referenced in Allele Record(s)"
14> 	return
15> end
16> 
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop trigger BIB_Refs_Insert
1>  
2> create trigger BIB_Refs_Insert
3> on BIB_Refs
4> for insert
5> as
6>  
7> declare @pgs varchar(30)
8> select @pgs = pgs from inserted
9> 
10> /* Determine if new record constitutes a duplicate record */
11> /* within the Reference (BIB_Refs) table. */
12> /* Parameters to check are journal, year, volume and pages */
13>  
14> /* Mouse News Letter references are ignored because more than one */
15> /* reference can appear on the same page within this journal. */
16>   
17> if (select journal from inserted) != 'Mouse News Lett'
18> begin
19> 
20>   /* If pages in format "x", check for pages = x and pages like "x-%" */
21>   /* If pages in format "x-y", check for pages = x and pages like "x-%" */
22> 
23>   /* Strip off first page */
24>   if charindex("-", @pgs) > 0
25>   begin
26>     select @pgs = substring(@pgs, 1, charindex("-", @pgs) - 1)
27>   end
28> 
29>   if (select count(BIB_Refs._Refs_key) from BIB_Refs, inserted
30>       where BIB_Refs.journal = inserted.journal and
31>             BIB_Refs.year = inserted.year and
32>             BIB_Refs.vol = inserted.vol and
33>             (BIB_Refs.pgs = @pgs or BIB_Refs.pgs like @pgs + "-%")) > 1
34>   begin
35>     rollback transaction
36>     raiserror 99999 "Reference Already Exists"
37>     return
38>   end
39> end
40> 
41> declare @key integer
42> select @key = _Refs_key from inserted
43> exec ACC_assignMGI @key, "Reference"
44> 
45> if (@@error != 0)
46> begin
47>   rollback transaction
48>   return
49> end
50> 
1> 
2> drop trigger BIB_Refs_Update
1>  
2> create trigger BIB_Refs_Update
3> on BIB_Refs
4> for update
5> as
6>  
7> update BIB_Refs 
8> set modification_date = getdate()
9> from BIB_Refs, inserted
10> where BIB_Refs._Refs_key = inserted._Refs_key
11>  
1>  
2> drop trigger BIB_Refs_Delete
1> 
2> create trigger BIB_Refs_Delete
3> on BIB_Refs
4> for delete
5> as
6> 
7> /* Before deleting a record, verify that the J# is not being */
8> /* referenced elsewhere in the database. */
9> 
10> if exists (select * from deleted
11>     where deleted.dbs like "%Nomen%")
12> begin
13>         rollback transaction
14>         raiserror 99999 "J# is referenced in Nomenclature Record(s)"
15> 	return
16> end
17> 
18> if exists (select * from ALL_Allele, deleted
19>     where ALL_Allele._Refs_key = deleted._Refs_key)
20> begin
21>         rollback transaction
22>         raiserror 99999 "J# is referenced in Allele Record(s)"
23> 	return
24> end
25> 
26> if exists (select * from ALL_Allele, deleted
27>     where ALL_Allele._Molecular_Refs_key = deleted._Refs_key)
28> begin
29>         rollback transaction
30>         raiserror 99999 "J# is referenced in Allele Record(s)"
31> 	return
32> end
33> 
34> if exists (select * from ALL_Synonym, deleted
35>     where ALL_Synonym._Molecular_Refs_key = deleted._Refs_key)
36> begin
37>         rollback transaction
38>         raiserror 99999 "J# is referenced in Allele Synonym Record(s)"
39> 	return
40> end
41> 
42> if exists (select * from MRK_History, deleted
43>     where MRK_History._Refs_key = deleted._Refs_key)
44> begin
45>         rollback transaction
46>         raiserror 99999 "J# is referenced in Marker History Record(s)"
47> 	return
48> end
49> 
50> if exists (select * from MRK_Other, deleted
51>     where MRK_Other._Refs_key = deleted._Refs_key)
52> begin
53>         rollback transaction
54>         raiserror 99999 "J# is referenced in Marker Other Name Record(s)"
55> 	return
56> end
57> 
58> if exists (select * from HMD_Homology, deleted
59>          where HMD_Homology._Refs_key = deleted._Refs_key)
60> begin
61>         rollback transaction
62>         raiserror 99999 "J# is referenced in Homology Record(s)"
63> 	return
64> end
65> 
66> if exists (select * from MLC_Reference, deleted
67>          where MLC_Reference._Refs_key = deleted._Refs_key)
68> begin
69>         rollback transaction
70>         raiserror 99999 "J# is referenced in MLC Record(s)"
71> 	return
72> end
73> 
74> if exists (select * from MLC_Reference_edit, deleted
75>          where MLC_Reference_edit._Refs_key = deleted._Refs_key)
76> begin
77>         rollback transaction
78>         raiserror 99999 "J# is referenced in MLC Edit Record(s)"
79> 	return
80> end
81> 
82> if exists (select * from MLD_Expts, deleted
83>          where MLD_Expts._Refs_key = deleted._Refs_key)
84> begin
85>         rollback transaction
86>         raiserror 99999 "J# is referenced in Mapping Record(s)"
87> 	return
88> end
89> 
90> if exists (select * from PRB_Reference, deleted
91>          where PRB_Reference._Refs_key = deleted._Refs_key)
92> begin
93>         rollback transaction
94>         raiserror 99999 "J# is referenced in Probe Record(s)"
95> 	return
96> end
97> 
98> if exists (select * from PRB_Source, deleted
99>          where PRB_Source._Refs_key = deleted._Refs_key)
100> begin
101>         rollback transaction
102>         raiserror 99999 "J# is referenced in Probe Source Record(s)"
103> 	return
104> end
105> 
106> if exists (select * from GXD_Index, deleted
107>          where GXD_Index._Refs_key = deleted._Refs_key)
108> begin
109>         rollback transaction
110>         raiserror 99999 "J# is referenced in GXD Index Record(s)"
111> 	return
112> end
113> 
114> if exists (select * from GXD_Antibody, deleted
115>          where GXD_Antibody._Refs_key = deleted._Refs_key)
116> begin
117>         rollback transaction
118>         raiserror 99999 "J# is referenced in GXD Antibody Record(s)"
119> 	return
120> end
121> 
122> if exists (select * from GXD_AntibodyAlias, deleted
123>          where GXD_AntibodyAlias._Refs_key = deleted._Refs_key)
124> begin
125>         rollback transaction
126>         raiserror 99999 "J# is referenced in GXD Antibody Alias Record(s)"
127> 	return
128> end
129> 
130> if exists (select * from GXD_Assay, deleted
131>          where GXD_Assay._Refs_key = deleted._Refs_key)
132> begin
133>         rollback transaction
134>         raiserror 99999 "J# is referenced in GXD Assay Record(s)"
135> 	return
136> end
137> 
138> if exists (select * from IMG_Image, deleted
139>          where IMG_Image._Refs_key = deleted._Refs_key)
140> begin
141>         rollback transaction
142>         raiserror 99999 "J# is referenced in GXD Image Record(s)"
143> 	return
144> end
145> 
146> if exists (select * from MRK_Reference, deleted
147>     where MRK_Reference._Refs_key = deleted._Refs_key)
148> begin
149>         rollback transaction
150>         raiserror 99999 "J# is referenced in Marker Reference Record(s)"
151> 	return
152> end
153> 
154> delete BIB_Books from BIB_Books, deleted
155> where BIB_Books._Refs_key = deleted._Refs_key
156> 
157> delete BIB_Notes from BIB_Notes, deleted
158> where BIB_Notes._Refs_key = deleted._Refs_key
159> 
160> delete ACC_Accession
161> from ACC_Accession a, ACC_MGIType m, deleted
162> where a._Object_key = deleted._Refs_key
163> and a._MGIType_key = m._MGIType_key
164> and m.name = "Reference"
165> 
Msg 207, Level 16, State 2:
Server 'MGD_DEV', Procedure 'BIB_Refs_Delete', Line 34:
Invalid column name '_Molecular_Refs_key'.
1> 
2> drop trigger BIB_ReviewStatus_Delete
1> 
2> create trigger BIB_ReviewStatus_Delete
3> on BIB_ReviewStatus
4> for delete
5> as
6> 
7> /* Before deleting a record, verify that the Status is not being */
8> /* referenced elsewhere in the database. */
9> 
10> if exists (select * from BIB_Refs, deleted
11>     where BIB_Refs._ReviewStatus_key = deleted._ReviewStatus_key)
12> begin
13>         rollback transaction
14>         raiserror 99999 "Review Status is referenced in Reference Record(s)"
15> 	return
16> end
17> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop trigger CRS_Cross_Delete
1> 
2> create trigger CRS_Cross_Delete
3> on CRS_Cross
4> for delete
5> as
6> 
7> /* Disallow removal of a record if the Cross is referenced in MLDP */
8> 
9> if (select count(*) from MLD_Matrix, deleted
10>     where MLD_Matrix._Cross_key = deleted._Cross_key) > 0
11> begin
12>         rollback transaction
13>         raiserror 99999 "Cross is referenced in MLDP Record(s)"
14> 	return
15> end
16> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop trigger GXD_Genotype_Delete
1> 
2> create trigger GXD_Genotype_Delete
3> on GXD_Genotype
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> /*if (select count(*) from GXD_GelLane, deleted */
10> /*    where GXD_GelLane._Genotype_key = deleted._Genotype_key) > 0 */
11> /*begin */
12> /*        rollback transaction */
13> /*        raiserror 99999 "Genotype is referenced in Gel Lane Record(s)" */
14> /*	return */
15> /*end */
16> 
17> /*if (select count(*) from GXD_Specimen, deleted */
18> /*    where GXD_Specimen._Genotype_key = deleted._Genotype_key) > 0 */
19> /*begin */
20> /*        rollback transaction */
21> /*        raiserror 99999 "Genotype is referenced in Specimen Record(s)" */
22> /*	return */
23> /*end */
24> 
25> /*if (select count(*) from GXD_Expression, deleted */
26> /*    where GXD_Expression._Genotype_key = deleted._Genotype_key) > 0 */
27> /*begin */
28> /*        rollback transaction */
29> /*        raiserror 99999 "Genotype is referenced in Expression Results (cache) Record(s)" */
30> /*	return */
31> /*end */
32> 
33> delete GXD_AllelePair from GXD_AllelePair, deleted
34> where GXD_AllelePair._Genotype_key = deleted._Genotype_key
35>  
1> 
2> drop trigger GXD_Antigen_Insert
1>  
2> create trigger GXD_Antigen_Insert
3> on GXD_Antigen
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Antigen */
8>  
9> declare @key integer
10> select @key = _Antigen_key from inserted
11> exec ACC_assignMGI @key, "Antigen"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18> 
1>  
2> drop trigger GXD_Antigen_Delete
1> 
2> create trigger GXD_Antigen_Delete
3> on GXD_Antigen
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Antibody, deleted
10>     where GXD_Antibody._Antigen_key = deleted._Antigen_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antigen is referenced in Antibody Record(s)"
14> 	return
15> end
16> 
17> /* If Probe Source Name is null, then Anonymous Source */
18> /* If Anonymous Source, delete upon deletion of Antigen */
19>  
20> if not exists (select * from GXD_Antigen, deleted
21>     where GXD_Antigen._Source_key = deleted._Source_key)
22> begin
23>         delete PRB_Source from PRB_Source, deleted
24>         where PRB_Source._Source_key = deleted._Source_key
25>               and PRB_Source.name is null
26> end
27>  
28> delete ACC_Accession 
29> from ACC_Accession a, ACC_MGIType m, deleted
30> where a._Object_key = deleted._Antigen_key
31> and a._MGIType_key = m._MGIType_key
32> and m.name = "Antigen"
33>   
1> 
2> drop trigger GXD_Antibody_Insert
1>  
2> create trigger GXD_Antibody_Insert
3> on GXD_Antibody
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Antibody */
8>  
9> declare @key integer
10> select @key = _Antibody_key from inserted
11> exec ACC_assignMGI @key, "Antibody"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1>  
2> drop trigger GXD_Antibody_Delete
1> 
2> create trigger GXD_Antibody_Delete
3> on GXD_Antibody
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_AntibodyPrep, deleted
10>     where GXD_AntibodyPrep._Antibody_key = deleted._Antibody_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody is referenced in Antibody Prep Record(s)"
14> 	return
15> end
16> 
17> delete GXD_AntibodyMarker from GXD_AntibodyMarker, deleted
18> where GXD_AntibodyMarker._Antibody_key = deleted._Antibody_key
19>  
20> delete ACC_Accession
21> from ACC_Accession a, ACC_MGIType m, deleted
22> where a._Object_key = deleted._Antibody_key
23> and a._MGIType_key = m._MGIType_key
24> and m.name = "Antibody"
25>  
1> 
2> /* GXD_Structure */
3> 
4> 
5> drop trigger GXD_Structure_Insert
1> 
2> create trigger GXD_Structure_Insert
3> on GXD_Structure
4> for insert
5> as
6> 
7> /* Ensure that _Parent_key of inserted exists as a _Structure_key and
8>    that parent has the same _Stage_key as inserted, if _Parent_key != NULL */
9> 
10> if (select _Parent_key from inserted) != NULL
11> begin
12>     if not exists (select *
13>         from GXD_Structure s, inserted
14>         where inserted._Parent_key = s._Structure_key
15>         and inserted._Stage_key = s._Stage_key)
16>     begin
17>        rollback transaction
18>        raiserror 99999 "GXD_Structure_Insert: Specified parent Structure does not exist"
19>        return
20>     end
21> end
22> 
23> declare @treeDepth integer
24> select @treeDepth = 1  /* assume that we are adding a child of a Stage node */
25> 
26> /* if the assumption doesn't hold, then the following query will set the
27>    current child's treeDepth */ 
28> 
29> 
30> /* find out the depth of the parent structure */
31> select @treeDepth = s.treeDepth + 1
32> from GXD_Structure s, inserted
33> where s._Structure_key = inserted._Parent_key 
34> 
35> /* update the inserted node */
36> update GXD_Structure
37> set treeDepth = @treeDepth
38> from GXD_Structure s, inserted
39> where s._Structure_key = inserted._Structure_key
40> 
41> if @@error != 0
42> begin
43>   rollback transaction
44>   raiserror 99999 "GXD_Structure_Insert: Update of treeDepth failed"
45>   return
46> end
47> 
48> /* incrementally modify the closure */
49> 
50> declare @inp integer  /* inserted node's parent */
51> select @inp = _Parent_key from inserted
52> 
53> /* _Parent_key will be null for an immediate child of a stage root,
54>    this node, by definition will not have any entries in the closure table,
55>    since it is a root node as far as the database is concerned */ 
56> 
57> if @inp != NULL
58> begin
59>    
60>    declare ancest_cursor cursor
61>    for select c._Structure_key
62>        from GXD_StructureClosure c
63>        where c._Descendent_key = @inp
64>    
65>    declare @sk integer
66>    declare @isk integer
67>    select @isk = _Structure_key from inserted  
68>    
69>    open ancest_cursor
70>    fetch ancest_cursor into @sk
71>    while (@@sqlstatus = 0)
72>    begin
73>       /* for each ancestor, insert ancestor's _Structure_key, inserted's 
74>          _Structure_key in GXD_StructureClosure */ 
75>       insert into GXD_StructureClosure (_Structure_key, _Descendent_key) 
76>              values (@sk, @isk)
77>       if @@error != 0
78>       begin
79>          rollback transaction
80>          raiserror 99999 "GXD_Structure_Insert: Incremental insert on closure table failed"
81>          close ancest_cursor
82>          return
83>       end
84>       fetch ancest_cursor into @sk
85>    end
86>    close ancest_cursor
87>    
88>    /* finally, insert the inserted node's _Parent_key and the inserted node's
89>       _Structure_key into the closure table */
90>    
91>    insert into GXD_StructureClosure (_Structure_key, _Descendent_key)
92>        values (@inp, @isk)
93>    if @@error != 0
94>    begin
95>       rollback transaction
96>       raiserror 99999 "GXD_Structure_Insert: Incremental insert on closure table failed"
97>       return
98>    end
99> end
100> 
101> /* Do not compute the printName for the inserted structure here!
102>    this will be taken care of by the GXD_StructureName triggers.
103>    The name records must be in place before a printName recomputation
104>    can be done. */ 
105> 
106> 
1> 
2> drop trigger GXD_Structure_Update
1> 
2> create trigger GXD_Structure_Update
3> on GXD_Structure
4> for update
5> as
6>    update GXD_Structure
7>    set s.modification_date = getdate()  
8>    from GXD_Structure s, inserted
9>    where s._Structure_key = inserted._Structure_key 
10> 
11>    /* make certain that printStop bits don't get cleared on Structures
12>       that are children of the Stage root nodes */
13> 
14>    if exists (select printStop 
15>               from inserted
16>               where printStop = 0 
17>               and _Parent_key = NULL)
18>    begin
19>         rollback transaction
20>         raiserror 99999 "GXD_Structure_Update: Cannot clear printStop on child of stage root"
21>         return
22>    end
23> 
24>    /* recalculate printnames on those structures where printStop has
25>       been changed */
26>  
27>    declare pstop_cursor cursor
28>    for select inserted._Structure_key
29>        from deleted, inserted
30>        where deleted.printStop != inserted.printStop
31>        and deleted._Structure_key = inserted._Structure_key
32>  
33>    declare @sk integer
34>    open pstop_cursor
35>    fetch pstop_cursor into @sk
36>    while (@@sqlstatus = 0)
37>    begin
38>        exec GXD_ComputePrintNamesFrom @sk
39>        if @@error != 0
40>        begin
41>            rollback transaction
42>            raiserror 99999 "GXD_Structure_Update: GXD_ComputePrintNamesFrom fail
43> ed"
44>            close pstop_cursor
45>            return
46>        end
47>        fetch pstop_cursor into @sk
48>    end
49>    close pstop_cursor
50> 
1> 
2> drop trigger GXD_Structure_Delete
1> 
2> create trigger GXD_Structure_Delete
3> on GXD_Structure
4> for delete
5> as
6> 
7> /* Disallow deletion if record is not an MGI-added record, but
8>    only if the user does not have the sa_role */
9> 
10> if exists (select * from deleted where edinburghkey != NULL)
11> begin
12> 	if (select proc_role("sa_role")) != 1
13>         begin
14>            rollback transaction
15>            raiserror 99999 "GXD_Structure_Delete: Structure is not an MGI-added record"
16> 	       return
17>         end
18> end
19> 
20> /* Disallow deletion if record is not a leaf node, i.e. it has descendents */
21> 
22> if exists (select * from GXD_StructureClosure, deleted
23>     where GXD_StructureClosure._Structure_key = deleted._Structure_key)
24> begin
25>         rollback transaction
26>         raiserror 99999 "GXD_Structure_Delete: Structure is not a leaf node; it has descendents"
27>         return
28> end
29> 
30> /* Disallow deletion if record is referenced elsewhere */
31> 
32> if exists (select * from GXD_ISResultStructure, deleted
33>     where GXD_ISResultStructure._Structure_key = deleted._Structure_key)
34> begin
35>         rollback transaction
36>         raiserror 99999 "GXD_Structure_Delete: Structure is referenced in InSitu Result Record(s)"
37>         return
38> end
39>  
40> if exists (select * from GXD_GelLaneStructure, deleted
41>     where GXD_GelLaneStructure._Structure_key = deleted._Structure_key)
42> begin
43>         rollback transaction
44>         raiserror 99999 "GXD_Structure_Delete: Structure is referenced in Gel Lane Structure Record(s)"
45>         return
46> end
47> 
48> if exists (select * from GXD_Expression, deleted
49>     where GXD_Expression._Structure_key = deleted._Structure_key)
50> begin
51>         rollback transaction
52>         raiserror 99999 "GXD_Structure_Delete: Structure is referenced in Expression Results (cache) Record(s)"
53> 	    return
54> end
55> 
56> /* incrementally modify the closure */
57> delete GXD_StructureClosure 
58> from GXD_StructureClosure sc, deleted
59> where sc._Descendent_key = deleted._Structure_key
60> 
61> if @@error != 0
62> begin
63>     rollback transaction
64>     raiserror 99999 "GXD_Structure_Delete: Delete of closure records failed"
65>     return
66> end
67> 
68> /* cascade deletes into the StructureName table */
69> delete GXD_StructureName
70> from GXD_StructureName sn, deleted
71> where sn._Structure_key = deleted._Structure_key
72> 
73> if @@error != 0
74> begin
75>     rollback transaction
76>     raiserror 99999 "GXD_Structure_Delete: Cascaded delete of StructureNames failed"
77>     return
78> end
79> 
1> 
2> /* GXD_StructureName */
3> 
4> drop trigger GXD_StructureName_Insert
1> 
2> create trigger GXD_StructureName_Insert
3> on GXD_StructureName
4> for insert
5> as
6> 
7> /* ensure that the structure specified exists */
8> if not exists(select * 
9>               from GXD_Structure s, inserted
10>               where s._Structure_key = inserted._Structure_key)
11> begin
12>     rollback transaction
13>     raiserror 99999 "GXD_StructureName_Insert: Inserted StructureName specifies a non-existent Structure"
14>     return
15> end
16> 
17> /* look for duplicate (structure key, structure) tuples */
18> 
19> if (select count(*) from 
20>    GXD_StructureName sn, inserted
21>    where sn._Structure_key = inserted._Structure_key
22>    and sn.structure = inserted.structure) >  1
23> begin
24>     rollback transaction
25>     raiserror 99999 "GXD_StructureName_Insert: Inserted StructureName has duplicate structure attribute"
26>     return
27> end
28> 
29> /* Prevent two children from having the same preferred name */
30> 
31> 
32> if (select count(*)
33>     from GXD_Structure s1, GXD_Structure s2, GXD_StructureName sn2, inserted
34>     where s1._Parent_key = s2._Parent_key
35>     and sn2._StructureName_key = s2._StructureName_key
36>     and inserted._StructureName_key = s1._StructureName_key 
37>     and inserted.structure = sn2.structure) > 1
38> begin
39>     rollback transaction
40>     raiserror 99999 "GXD_StructureName_Insert: Parent node cannot have two children with the same preferred name"
41>     return
42> end
43> 
44> /* call stored procedure that recalculates printNames, if a preferred
45>    structure name is changed.  Preferred StructureNames are those
46>    that are referred to by a record in GXD_Structure */
47> 
48> declare updatesk_cursor cursor
49> for select s._Structure_key 
50>     from GXD_Structure s, inserted
51>     where s._StructureName_key = inserted._StructureName_key
52> 
53> declare @isk integer
54> 
55> open updatesk_cursor
56> fetch updatesk_cursor into @isk
57> 
58> while (@@sqlstatus = 0)
59> begin
60>    exec GXD_ComputePrintNamesFrom @isk 
61>    if @@error != 0
62>    begin
63>         rollback transaction
64>         raiserror 99999 "GXD_StructureName_Insert: GXD_ComputePrintNamesFrom failed"
65>         close updatesk_cursor
66>         return
67>    end
68>    fetch updatesk_cursor into @isk
69> end
70> 
71> close updatesk_cursor
72> 
1> 
2> drop trigger GXD_StructureName_Update
1> 
2> create trigger GXD_StructureName_Update
3> on GXD_StructureName
4> for update
5> as
6> 
7> if (select count(*) from GXD_Structure s, inserted
8>     where s._Structure_key = inserted._Structure_key) !=
9>    (select count(*) from inserted)
10> begin
11>     rollback transaction
12>     raiserror 99999 "GXD_StructureName_Update: Non-existent Structure in StructureName record"
13>     return
14> end
15> 
16> 
17> if (select count(*) from 
18>     GXD_StructureName sn, inserted
19>     where sn._Structure_key = inserted._Structure_key
20>     and sn.structure = inserted.structure) > 
21>    (select count(*) from inserted)
22> begin
23>     rollback transaction
24>     raiserror 99999 "GXD_StructureName_Update: Inserted StructureName has duplicate structure attribute"
25>     return
26> end
27> 
28> update GXD_StructureName
29> set sn.modification_date = getdate()  
30> from GXD_StructureName sn, inserted
31> where sn._Structure_key = inserted._Structure_key 
32> 
33> /* call stored procedure that recalculates printNames, if a preferred
34>    structure name is changed.  Preferred StructureNames are those
35>    that are referred to by a record in GXD_Structure */
36> 
37> declare updatesk_cursor cursor
38> for select s._Structure_key 
39>     from GXD_Structure s, inserted
40>     where s._StructureName_key = inserted._StructureName_key
41> 
42> declare @isk integer
43> 
44> open updatesk_cursor
45> fetch updatesk_cursor into @isk
46> 
47> while (@@sqlstatus = 0)
48> begin
49>    exec GXD_ComputePrintNamesFrom @isk 
50>    if @@error != 0
51>    begin
52>         rollback transaction
53>         raiserror 99999 "GXD_StructureName_Update: GXD_ComputePrintNamesFrom failed"
54>         close updatesk_cursor
55>         return
56>    end
57>    fetch updatesk_cursor into @isk
58> end
59> 
60> close updatesk_cursor
61> 
1> 
2> drop trigger GXD_StructureName_Delete
1> 
2> create trigger GXD_StructureName_Delete
3> on GXD_StructureName
4> for delete
5> as
6> 
7> /* check to see if a Structure references the StructureNames being deleted */
8> 
9> if exists (select * from GXD_Structure, deleted
10>     where GXD_Structure._StructureName_key = deleted._StructureName_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "GXD_StructureName_Delete: Structure Name is referenced in Structure Record(s)"
14> 	return
15> end
16> 
1> 
2> /* GXD_StructureClosure */
3> 
4> drop trigger GXD_StructureClosure_Insert
1> 
2> create trigger GXD_StructureClosure_Insert
3> on GXD_StructureClosure
4> for insert
5> as
6> 
7> /* check to see if a Structure exists for the inserted structure keys */
8> if not exists(select * 
9>               from GXD_Structure s, inserted
10>               where s._Structure_key = inserted._Structure_key)
11> begin
12>     rollback transaction
13>     raiserror 99999 "GXD_StructureClosure_Insert: Non-existent Structure in StructureClosure record"
14>     return
15> end
1> 
2> drop trigger GXD_StructureClosure_Update
1> 
2> create trigger GXD_StructureClosure_Update
3> on GXD_StructureClosure
4> for update 
5> as
6> 
7> /* check to see if a Structure exists for the updated structure keys */
8> 
9> if (select count(*) 
10>     from GXD_Structure s, inserted 
11>     where s._Structure_key = inserted._Structure_key) !=
12>    (select count(*) from inserted)
13> begin
14>     rollback transaction
15>     raiserror 99999 "GXD_StructureClosure_Update: Non-existent Structure in StructureClosure record"
16>     return
17> end
1> drop trigger GXD_StructureClosure_Delete
1> 
2> create trigger GXD_StructureClosure_Delete
3> on GXD_StructureClosure
4> for delete
5> as
6> 
7> if exists (select * from GXD_Structure, deleted
8>     where GXD_Structure._Structure_key = deleted._Descendent_key)
9> begin
10>         rollback transaction
11>         raiserror 99999 "GXD_StructureClosure_Delete: Structure is referenced in GXD_Structure"
12>         return
13> end
14> 
1> 
2> /* GXD_TheilerStage */
3> 
4> drop trigger GXD_TheilerStage_Delete
1> 
2> create trigger GXD_TheilerStage_Delete
3> on GXD_TheilerStage
4> for delete
5> as
6> 
7> /* Totally disallow deletions of these records ??? */
8> 
9> rollback transaction
10> raiserror 99999 "Cannot delete Theiler Stage Record(s)"
11> return
12> 
13> if exists (select * from GXD_Structure, deleted
14>     where GXD_Structure._Stage_key = deleted._Stage_key)
15> begin
16>         rollback transaction
17>         raiserror 99999 "Theiler Stage is referenced in Structure Record(s)"
18>         return
19> end
20> 
1> 
2> drop trigger GXD_ProbePrep_Delete
1> 
2> create trigger GXD_ProbePrep_Delete
3> on GXD_ProbePrep
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Assay, deleted
10>     where GXD_Assay._ProbePrep_key = deleted._ProbePrep_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Probe Prep is referenced in Assay Record(s)"
14>         return
15> end
16> 
1> 
2> drop trigger GXD_AntibodyPrep_Delete
1> 
2> create trigger GXD_AntibodyPrep_Delete
3> on GXD_AntibodyPrep
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Assay, deleted
10>     where GXD_Assay._AntibodyPrep_key = deleted._AntibodyPrep_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody Prep is referenced in Assay Record(s)"
14>         return
15> end
16> 
1> 
2> drop trigger GXD_Assay_Insert
1>  
2> create trigger GXD_Assay_Insert
3> on GXD_Assay
4> for insert
5> as
6>  
7> declare @key integer
8> select @key = _Assay_key from inserted
9> 
10> /* Assign MGI Accession number for Assay */
11> exec ACC_assignMGI @key, "Assay"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
19> /* Insert entry in Reference bucket if it doesn't already exist */
20>  
21> if not exists (select * from MRK_Reference, inserted
22>     where MRK_Reference._Marker_key = inserted._Marker_key and
23>           MRK_Reference._Refs_key = inserted._Refs_key)
24> begin
25>   insert MRK_Reference (_Marker_key, _Refs_key, auto) 
26>   select _Marker_key, _Refs_key, 1 from inserted
27>   where _Refs_key is not null
28> end
29> 
1>  
2> drop trigger GXD_Assay_Update
1>  
2> create trigger GXD_Assay_Update
3> on GXD_Assay
4> for update
5> as
6>  
7> /* Insert entry in Reference bucket if it doesn't already exist */
8>  
9> if @@rowcount = 1
10>    and
11>    (update(_Refs_key) or update(_Marker_key))
12>    and
13>    not exists (select * from MRK_Reference, inserted
14>     where MRK_Reference._Marker_key = inserted._Marker_key and
15>           MRK_Reference._Refs_key = inserted._Refs_key)
16> begin
17>         insert MRK_Reference (_Marker_key, _Refs_key, auto) 
18>         select _Marker_key, _Refs_key, 1 from inserted
19>         where _Refs_key is not null
20> end
21>  
22> declare @key integer
23> select @key = _Assay_key from inserted
24> 
25> /* Update Expression Cache for Assay */
26> /* The update of a GXD_Assay record should be called AFTER any updates to GXD detail records */
27> 
28> exec GXD_loadCacheByAssay @key
29> 
1>  
2> drop trigger GXD_Assay_Delete
1> 
2> create trigger GXD_Assay_Delete
3> on GXD_Assay
4> for delete
5> as
6> 
7> delete GXD_Specimen from GXD_Specimen, deleted
8> where GXD_Specimen._Assay_key = deleted._Assay_key
9>  
10> delete GXD_GelLane from GXD_GelLane, deleted
11> where GXD_GelLane._Assay_key = deleted._Assay_key
12>  
13> delete GXD_GelRow from GXD_GelRow, deleted
14> where GXD_GelRow._Assay_key = deleted._Assay_key
15>  
16> delete GXD_AssayNote from GXD_AssayNote, deleted
17> where GXD_AssayNote._Assay_key = deleted._Assay_key
18>  
19> delete GXD_Expression from GXD_Expression, deleted
20> where GXD_Expression._Assay_key = deleted._Assay_key
21>  
22> delete GXD_ProbePrep from GXD_ProbePrep, deleted
23> where GXD_ProbePrep._ProbePrep_key = deleted._ProbePrep_key
24> 
25> delete GXD_AntibodyPrep from GXD_AntibodyPrep, deleted
26> where GXD_AntibodyPrep._AntibodyPrep_key = deleted._AntibodyPrep_key
27> 
28> delete ACC_Accession
29> from ACC_Accession a, ACC_MGIType m, deleted
30> where a._Object_key = deleted._Assay_key
31> and a._MGIType_key = m._MGIType_key
32> and m.name = "Assay"
33>  
1> 
2> drop trigger GXD_GelLane_Delete
1> 
2> create trigger GXD_GelLane_Delete
3> on GXD_GelLane
4> for delete
5> as
6> 
7> delete GXD_GelLaneStructure from GXD_GelLaneStructure, deleted
8> where GXD_GelLaneStructure._GelLane_key = deleted._GelLane_key
9>  
10> delete GXD_GelBand from GXD_GelBand, deleted
11> where GXD_GelBand._GelLane_key = deleted._GelLane_key
12> 
13> /* If Genotypes are specific to each specimen... */
14> 
15> if not exists (select * from GXD_GelLane, deleted
16> 	where GXD_GelLane._Genotype_key = deleted._Genotype_key)
17> begin
18> 	delete GXD_Genotype from GXD_Genotype, deleted
19> 	where GXD_Genotype._Genotype_key = deleted._Genotype_key
20> 	      and GXD_Genotype._Genotype_key >= 0
21> end
22> 
1> 
2> drop trigger GXD_GelRow_Insert
1> 
2> create trigger GXD_GelRow_Insert
3> on GXD_GelRow
4> for insert
5> as
6> 
7> if (select size from inserted) is not null and
8>    (select _GelUnits_key from inserted) < 0
9> begin
10>   rollback transaction
11>   raiserror 99999 "If Gel Row Size is entered, Gel Row Units must be specified."
12>   return
13> end
14> 
1> 
2> drop trigger GXD_GelRow_Update
1> 
2> create trigger GXD_GelRow_Update
3> on GXD_GelRow
4> for update
5> as
6> 
7> if (select size from inserted) is not null and
8>    (select _GelUnits_key from inserted) < 0
9> begin
10>   rollback transaction
11>   raiserror 99999 "If Gel Row Size is entered, Gel Row Units must be specified."
12>   return
13> end
14> 
1> 
2> drop trigger GXD_GelRow_Delete
1> 
2> create trigger GXD_GelRow_Delete
3> on GXD_GelRow
4> for delete
5> as
6> 
7> delete GXD_GelBand from GXD_GelBand, deleted
8> where GXD_GelBand._GelRow_key = deleted._GelRow_key
9> 
1> 
2> drop trigger GXD_Specimen_Delete
1> 
2> create trigger GXD_Specimen_Delete
3> on GXD_Specimen
4> for delete
5> as
6> 
7> /* If Genotypes are specific to each specimen... */
8> 
9> if not exists (select * from GXD_Specimen, deleted
10> 	where GXD_Specimen._Genotype_key = deleted._Genotype_key)
11> begin
12> 	delete GXD_Genotype from GXD_Genotype, deleted
13> 	where GXD_Genotype._Genotype_key = deleted._Genotype_key
14> 	      and GXD_Genotype._Genotype_key >= 0
15> end
16> 
17> delete GXD_InSituResult from GXD_InSituResult, deleted
18> where GXD_InSituResult._Specimen_key = deleted._Specimen_key
19> 
1> 
2> drop trigger GXD_InSituResult_Delete
1> 
2> create trigger GXD_InSituResult_Delete
3> on GXD_InSituResult
4> for delete
5> as
6> 
7> delete GXD_InSituResultImage from GXD_InSituResultImage, deleted
8> where GXD_InSituResultImage._Result_key = deleted._Result_key
9> 
10> delete GXD_ISResultStructure from GXD_ISResultStructure, deleted
11> where GXD_ISResultStructure._Result_key = deleted._Result_key
12> 
1> 
2> drop trigger GXD_Index_Delete
1> 
2> create trigger GXD_Index_Delete
3> on GXD_Index
4> for delete
5> as
6> 
7> delete GXD_Index_Stages from GXD_Index_Stages, deleted
8> where GXD_Index_Stages.index_id = deleted.index_id
9> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop trigger GXD_AntibodyClass_Delete
1> 
2> create trigger GXD_AntibodyClass_Delete
3> on GXD_AntibodyClass
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Antibody, deleted
10>     where GXD_Antibody._AntibodyClass_key = deleted._AntibodyClass_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody Class is referenced in Antibody Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger GXD_AntibodyType_Delete
1>  
2> create trigger GXD_AntibodyType_Delete
3> on GXD_AntibodyType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_Antibody, deleted
10>     where GXD_Antibody._AntibodyType_key = deleted._AntibodyType_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody Type is referenced in Antibody Record(s)"
14>         return
15> end
16>  
1> 
2> drop trigger GXD_AntibodySpecies_Delete
1>  
2> create trigger GXD_AntibodySpecies_Delete
3> on GXD_AntibodySpecies
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_Antibody, deleted
10>     where GXD_Antibody._AntibodySpecies_key = deleted._AntibodySpecies_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Antibody Species is referenced in Antibody Record(s)"
14>         return
15> end
16>  
1> 
2> drop trigger GXD_AssayType_Delete
1>  
2> create trigger GXD_AssayType_Delete
3> on GXD_AssayType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_Assay, deleted
10>     where GXD_Assay._AssayType_key = deleted._AssayType_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Assay Type is referenced in Assay Record(s)"
14>         return
15> end
16>  
17> if exists (select * from GXD_Expression, deleted
18>     where GXD_Expression._AssayType_key = deleted._AssayType_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Assay Type is referenced in Expression Results (cache) Record(s)"
22>         return
23> end
24>  
1>  
2> drop trigger GXD_EmbeddingMethod_Delete
1>  
2> create trigger GXD_EmbeddingMethod_Delete
3> on GXD_EmbeddingMethod
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_Specimen, deleted
10>     where GXD_Specimen._Embedding_key = deleted._Embedding_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Embedding Method is referenced in Specimen Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_FixationMethod_Delete
1>  
2> create trigger GXD_FixationMethod_Delete
3> on GXD_FixationMethod
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_Specimen, deleted
10>     where GXD_Specimen._Fixation_key = deleted._Fixation_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Fixation Method is referenced in Specimen Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_GelRNAType_Delete
1>  
2> create trigger GXD_GelRNAType_Delete
3> on GXD_GelRNAType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_GelLane, deleted
10>     where GXD_GelLane._GelRNAType_key = deleted._GelRNAType_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Gel RNA Type is referenced in Gel Lane Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_GelUnits_Delete
1>  
2> create trigger GXD_GelUnits_Delete
3> on GXD_GelUnits
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_GelRow, deleted
10>     where GXD_GelRow._GelUnits_key = deleted._GelUnits_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Gel Unit is referenced in Gel Row Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_GelControl_Delete
1>  
2> create trigger GXD_GelControl_Delete
3> on GXD_GelControl
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_GelLane, deleted
10>     where GXD_GelLane._GelControl_key = deleted._GelControl_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Gel Control is referenced in Gel Lane Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_LabelCoverage_Delete
1>  
2> create trigger GXD_LabelCoverage_Delete
3> on GXD_LabelCoverage
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_ProbePrep, deleted
10>     where GXD_ProbePrep._Coverage_key = deleted._Coverage_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Label Coverage is referenced in Probe Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Pattern_Delete
1>  
2> create trigger GXD_Pattern_Delete
3> on GXD_Pattern
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_InSituResult, deleted
10>     where GXD_InSituResult._Pattern_key = deleted._Pattern_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Expression Pattern is referenced in InSitu Result Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Label_Delete
1>  
2> create trigger GXD_Label_Delete
3> on GXD_Label
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_AntibodyPrep, deleted
10>     where GXD_AntibodyPrep._Label_key = deleted._Label_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Label is referenced in Antibody Prep Record(s)"
14> 	return
15> end
16> 
17> if exists (select * from GXD_ProbePrep, deleted
18>     where GXD_ProbePrep._Label_key = deleted._Label_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Label is referenced in Probe Prep Record(s)"
22>         return
23> end
24>  
1>  
2> drop trigger GXD_ProbeSense_Delete
1>  
2> create trigger GXD_ProbeSense_Delete
3> on GXD_ProbeSense
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_ProbePrep, deleted
10>     where GXD_ProbePrep._Sense_key = deleted._Sense_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Probe Sense is referenced in Probe Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Secondary_Delete
1>  
2> create trigger GXD_Secondary_Delete
3> on GXD_Secondary
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_AntibodyPrep, deleted
10>     where GXD_AntibodyPrep._Secondary_key = deleted._Secondary_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Secondary is referenced in Antibody Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_Strength_Delete
1>  
2> create trigger GXD_Strength_Delete
3> on GXD_Strength
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_InSituResult, deleted
10>     where GXD_InSituResult._Strength_key = deleted._Strength_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Strength is referenced in InSitu Result Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger GXD_VisualizationMethod_Delete
1>  
2> create trigger GXD_VisualizationMethod_Delete
3> on GXD_VisualizationMethod
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from GXD_ProbePrep, deleted
10>     where GXD_ProbePrep._Visualization_key = deleted._Visualization_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Visualization Method is referenced in Probe Prep Record(s)"
14>         return
15> end
16>  
1>  
2> drop trigger IMG_FieldType_Delete
1>  
2> create trigger IMG_FieldType_Delete
3> on IMG_FieldType
4> for delete
5> as
6>  
7> /* Disallow deletion if record is referenced elsewhere */
8>  
9> if exists (select * from IMG_ImagePane, deleted
10>     where IMG_ImagePane._FieldType_key = deleted._FieldType_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Image Field Type is referenced in Image Pane Record(s)"
14>         return
15> end
16>  
1>  
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop trigger HMD_Class_Delete
1> 
2> create trigger HMD_Class_Delete
3> on HMD_Class
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete HMD_Homology from HMD_Homology, deleted
10> where HMD_Homology._Class_key = deleted._Class_key
11> 
1> 
2> drop trigger HMD_Homology_Delete
1> 
2> create trigger HMD_Homology_Delete
3> on HMD_Homology
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete HMD_Homology_Marker from HMD_Homology_Marker, deleted
10> where HMD_Homology_Marker._Homology_key = deleted._Homology_key
11> 
12> delete HMD_Homology_Assay from HMD_Homology_Assay, deleted
13> where HMD_Homology_Assay._Homology_key = deleted._Homology_key
14> 
15> delete HMD_Notes from HMD_Notes, deleted
16> where HMD_Notes._Homology_key = deleted._Homology_key
17> 
1> 
2> /* TR 104 - moved logic to MRK_Marker_Insert */
3> 
4> /* drop trigger HMD_Homology_Marker_Insert */
5> 
6> drop trigger HMD_Assay_Delete
1> 
2> create trigger HMD_Assay_Delete
3> on HMD_Assay
4> for delete
5> as
6> 
7> /* Disallow removal of the homology assay if it is being referenced in homology */
8> 
9> if exists (select * from HMD_Homology_Assay, deleted
10>     where HMD_Homology_Assay._Assay_key = deleted._Assay_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Assay is referenced in Homology Record(s)"
14> 	return
15> end
16>  
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop trigger IMG_Image_Insert
1>  
2> create trigger IMG_Image_Insert
3> on IMG_Image
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Image */
8>  
9> declare @key integer
10> select @key = _Image_key from inserted
11> exec ACC_assignMGI @key, "Image"
12>  
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1>  
2> drop trigger IMG_Image_Delete
1> 
2> create trigger IMG_Image_Delete
3> on IMG_Image
4> for delete
5> as
6> 
7> delete IMG_ImageNote from IMG_ImageNote, deleted
8> where IMG_ImageNote._Image_key = deleted._Image_key
9>  
10> delete IMG_ImagePane from IMG_ImagePane, deleted
11> where IMG_ImagePane._Image_key = deleted._Image_key
12>  
13> delete ACC_Accession
14> from ACC_Accession a, ACC_MGIType m, deleted
15> where a._Object_key = deleted._Image_key
16> and a._MGIType_key = m._MGIType_key
17> and m.name = "Image"
18>  
1> 
2> drop trigger IMG_ImagePane_Delete
1> 
2> create trigger IMG_ImagePane_Delete
3> on IMG_ImagePane
4> for delete
5> as
6> 
7> /* Disallow deletion if record is referenced elsewhere */
8> 
9> if exists (select * from GXD_Assay, deleted
10>     where GXD_Assay._ImagePane_key = deleted._ImagePane_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Image Pane is referenced in Assay Record(s)"
14> 	return
15> end
16> 
17> if exists (select * from GXD_InSituResultImage, deleted
18>     where GXD_InSituResultImage._ImagePane_key = deleted._ImagePane_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Image Pane is referenced in InSitu Result Record(s)"
22> 	return
23> end
24> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop trigger MLD_Marker_Update
1> 
2> create trigger MLD_Marker_Update
3> on MLD_Marker
4> for update
5> as
6> 
7> /* If updating the Reference, propagate update to appropriate tables */
8> 
9> if update(_Refs_key)
10> begin
11> 	update MLD_Expts
12> 	  set _Refs_key = inserted._Refs_key
13> 	  from MLD_Expts, inserted, deleted
14> 	  where MLD_Expts._Refs_key = deleted._Refs_key
15> 
16> 	update MLD_Notes
17> 	  set _Refs_key = inserted._Refs_key
18> 	  from MLD_Notes, inserted, deleted
19> 	  where MLD_Notes._Refs_key = deleted._Refs_key
20> end
21> 
22> /* If the Marker in the Primary list is modified, then propagate */
23> /* the changes to the gene list of each experiment of the reference */
24> 
25> if update(_Marker_key)
26> begin
27> 	update MLD_Expt_Marker
28>           set _Marker_key = inserted._Marker_key
29> 	  from MLD_Expt_Marker, MLD_Expts, inserted, deleted
30> 	  where MLD_Expts._Refs_key = inserted._Refs_key and
31> 		MLD_Expts._Expt_key = MLD_Expt_Marker._Expt_key and
32> 		MLD_Expt_Marker._Marker_key = deleted._Marker_key
33> end
34> 
1> 
2> drop trigger MLD_Expts_Insert
1> 
2> create trigger MLD_Expts_Insert
3> on MLD_Expts
4> for insert
5> as
6> 
7> /* Assign MGI Accession number for each Experiment */
8> 
9> declare @key integer
10> select @key = _Expt_key from inserted
11> exec ACC_assignMGI @key, "Experiment"
12> 
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1> 
2> drop trigger MLD_Expts_Delete
1> 
2> create trigger MLD_Expts_Delete
3> on MLD_Expts
4> for delete
5> as
6> 
7> /* Re-order the tag numbers for experiments if one is deleted */
8> 
9> update MLD_Expts
10> set MLD_Expts.tag = MLD_Expts.tag - 1
11> from MLD_Expts, deleted
12> where MLD_Expts._Refs_key = deleted._Refs_key
13> and MLD_Expts.exptType = deleted.exptType
14> and MLD_Expts.tag > deleted.tag
15> 
16> /* Delete entries in all dependent experiment tables */
17> 
18> delete MLD_Expt_Marker from MLD_Expt_Marker, deleted
19> where MLD_Expt_Marker._Expt_key = deleted._Expt_key
20> 
21> delete MLD_Expt_Notes from MLD_Expt_Notes, deleted
22> where MLD_Expt_Notes._Expt_key = deleted._Expt_key
23> 
24> delete MLD_FISH from MLD_FISH, deleted
25> where MLD_FISH._Expt_key = deleted._Expt_key
26> 
27> delete MLD_FISH_Region from MLD_FISH_Region, deleted
28> where MLD_FISH_Region._Expt_key = deleted._Expt_key
29> 
30> delete MLD_Hybrid from MLD_Hybrid, deleted
31> where MLD_Hybrid._Expt_key = deleted._Expt_key
32> 
33> delete MLD_Concordance from MLD_Concordance, deleted
34> where MLD_Concordance._Expt_key = deleted._Expt_key
35> 
36> delete MLD_InSitu from MLD_InSitu, deleted
37> where MLD_InSitu._Expt_key = deleted._Expt_key
38> 
39> delete MLD_ISRegion from MLD_ISRegion, deleted
40> where MLD_ISRegion._Expt_key = deleted._Expt_key
41> 
42> delete MLD_Matrix from MLD_Matrix, deleted
43> where MLD_Matrix._Expt_key = deleted._Expt_key
44> 
45> delete MLD_MC2point from MLD_MC2point, deleted
46> where MLD_MC2point._Expt_key = deleted._Expt_key
47> 
48> delete MLD_MCDataList from MLD_MCDataList, deleted
49> where MLD_MCDataList._Expt_key = deleted._Expt_key
50> 
51> delete MLD_RI from MLD_RI, deleted
52> where MLD_RI._Expt_key = deleted._Expt_key
53> 
54> delete MLD_RIData from MLD_RIData, deleted
55> where MLD_RIData._Expt_key = deleted._Expt_key
56> 
57> delete MLD_RI2Point from MLD_RI2Point, deleted
58> where MLD_RI2Point._Expt_key = deleted._Expt_key
59> 
60> delete MLD_Hit from MLD_Hit, deleted
61> where MLD_Hit._Expt_key = deleted._Expt_key
62> 
63> delete MLD_Contig from MLD_Contig, deleted
64> where MLD_Contig._Expt_key = deleted._Expt_key
65> 
66> delete MLD_Statistics from MLD_Statistics, deleted
67> where MLD_Statistics._Expt_key = deleted._Expt_key
68> 
69> delete ACC_Accession
70> from ACC_Accession a, ACC_MGIType m, deleted
71> where a._Object_key = deleted._Expt_key
72> and a._MGIType_key = m._MGIType_key
73> and m.name = "Experiment"
74>  
1> 
2> drop trigger MLD_Expt_Marker_Insert
1>  
2> create trigger MLD_Expt_Marker_Insert
3> on MLD_Expt_Marker
4> for insert
5> as
6>  
7> /* If the chromosome in the Marker table is UN, then...  */
8>  
9> if exists (select * from MRK_Marker, MLD_Expts, inserted
10>     where MLD_Expts._Expt_key = inserted._Expt_key and
11>     MRK_Marker._Marker_key = inserted._Marker_key and
12>     MRK_Marker.chromosome = "UN")
13> begin
14>  
15>     /* Update the chromosome to the MLDP chromosome assignment */
16>  
17>     update MRK_Marker
18>     set chromosome = MLD_Expts.chromosome
19>     from MRK_Marker, MLD_Expts, inserted
20>     where MLD_Expts._Expt_key = inserted._Expt_key and
21>           MRK_Marker._Marker_key = inserted._Marker_key
22> end
23>  
1> 
2> drop trigger MLD_Expt_Marker_Update
1> 
2> create trigger MLD_Expt_Marker_Update
3> on MLD_Expt_Marker
4> for update
5> as
6> 
7> /* If modifying Assay type and this is the only instance of the */
8> /* Assay type in MGD, then remove it from the Assay table */
9> 
10> if update(_Assay_Type_key) and 
11>    not exists (select * from MLD_Expt_Marker, deleted
12>     where MLD_Expt_Marker._Assay_Type_key = deleted._Assay_Type_key)
13> begin
14>   delete MLD_Assay_Types from MLD_Assay_Types, deleted
15>   where MLD_Assay_Types._Assay_Type_key = deleted._Assay_Type_key
16> end
17> 
18> if update(_Marker_key)
19> begin
20> 	/* If the chromosome in the Marker table is UN, then...  */
21> 
22>   	if exists (select * from MRK_Marker, MLD_Expts, inserted
23>             where MLD_Expts._Expt_key = inserted._Expt_key and
24> 	    MRK_Marker._Marker_key = inserted._Marker_key and 
25> 	    MRK_Marker.chromosome = "UN")
26> 	begin
27> 
28> 	  /* Update the chromosome to the MLDP chromosome assignment */
29> 
30>   	  update MRK_Marker 
31>   	  set chromosome = MLD_Expts.chromosome
32>   	  from MRK_Marker, MLD_Expts, inserted
33>           where MLD_Expts._Expt_key = inserted._Expt_key and
34> 	        MRK_Marker._Marker_key = inserted._Marker_key
35> 	end
36> 
37> 	/* Propagate modification of Marker to experiment tables */
38> 
39> 	update MLD_Concordance 
40>           set _Marker_key = inserted._Marker_key
41> 	  from MLD_Concordance, inserted, deleted
42> 	  where MLD_Concordance._Expt_key = inserted._Expt_key and
43> 		MLD_Concordance._Marker_key = deleted._Marker_key
44> 
45> 	update MLD_MC2point 
46>           set _Marker_key_1 = inserted._Marker_key
47> 	  from MLD_MC2point, inserted, deleted
48> 	  where MLD_MC2point._Expt_key = inserted._Expt_key and
49> 		MLD_MC2point._Marker_key_1 = deleted._Marker_key
50> 
51> 	update MLD_MC2point 
52>           set _Marker_key_2 = inserted._Marker_key
53> 	  from MLD_MC2point, inserted, deleted
54> 	  where MLD_MC2point._Expt_key = inserted._Expt_key and
55> 		MLD_MC2point._Marker_key_2 = deleted._Marker_key
56> 
57> 	update MLD_RIData 
58>           set _Marker_key = inserted._Marker_key
59> 	  from MLD_RIData, inserted, deleted
60> 	  where MLD_RIData._Expt_key = inserted._Expt_key and
61> 		MLD_RIData._Marker_key = deleted._Marker_key
62> 
63> 	update MLD_RI2Point 
64>           set _Marker_key_1 = inserted._Marker_key
65> 	  from MLD_RI2Point, inserted, deleted
66> 	  where MLD_RI2Point._Expt_key = inserted._Expt_key and
67> 		MLD_RI2Point._Marker_key_1 = deleted._Marker_key
68> 
69> 	update MLD_RI2Point 
70>           set _Marker_key_2 = inserted._Marker_key
71> 	  from MLD_RI2Point, inserted, deleted
72> 	  where MLD_RI2Point._Expt_key = inserted._Expt_key and
73> 		MLD_RI2Point._Marker_key_2 = deleted._Marker_key
74> 
75>         update MLD_Statistics
76>           set _Marker_key_1 = inserted._Marker_key
77>           from MLD_Statistics, inserted, deleted
78>           where MLD_Statistics._Expt_key = inserted._Expt_key and
79>                 MLD_Statistics._Marker_key_1 = deleted._Marker_key
80> 
81>         update MLD_Statistics
82>           set _Marker_key_2 = inserted._Marker_key
83>           from MLD_Statistics, inserted, deleted
84>           where MLD_Statistics._Expt_key = inserted._Expt_key and
85>                 MLD_Statistics._Marker_key_2 = deleted._Marker_key
86> 
87>         update MLD_Distance
88>           set _Marker_key_1 = inserted._Marker_key
89>           from MLD_Distance, inserted, deleted
90>           where MLD_Distance._Expt_key = inserted._Expt_key and
91>                 MLD_Distance._Marker_key_1 = deleted._Marker_key
92> 
93>         update MLD_Distance
94>           set _Marker_key_2 = inserted._Marker_key
95>           from MLD_Distance, inserted, deleted
96>           where MLD_Distance._Expt_key = inserted._Expt_key and
97>                 MLD_Distance._Marker_key_2 = deleted._Marker_key
98> 
99> end
100> 
1> 
2> drop trigger MLD_Matrix_Delete
1> 
2> create trigger MLD_Matrix_Delete
3> on MLD_Matrix
4> for delete
5> as
6> 
7> /* Remove entries from Cross table upon deletion of Matrix */
8> /* record, if the cross is not a named (i.e. specific) Cross */
9> 
10> if exists (select * from CRS_Cross, deleted 
11>     where CRS_Cross._Cross_key = deleted._Cross_key and CRS_Cross.whoseCross is null)
12> begin
13> 	delete CRS_Cross from CRS_Cross, deleted
14> 	where CRS_Cross._Cross_key = deleted._Cross_key
15> end
16> 
1> 
2> drop trigger MLD_Contig_Delete
1> 
2> create trigger MLD_Contig_Delete
3> on MLD_Contig
4> for delete
5> as
6> 
7> /* Delete records in dependent tables */
8> 
9> delete MLD_ContigProbe from MLD_ContigProbe, deleted
10> where MLD_ContigProbe._Contig_key = deleted._Contig_key
11> 
1> 
2> drop trigger MLD_RI_Insert
1> 
2> create trigger MLD_RI_Insert
3> on MLD_RI
4> for insert
5> as
6> 
7> update MLD_RI
8> set designation = RI_RISet.designation,
9>     origin = RI_RISet.origin,
10>     abbrev1 = RI_RISet.abbrev1,
11>     abbrev2 = RI_RISet.abbrev2
12> from MLD_RI, RI_RISet, inserted
13> where MLD_RI._Expt_key = inserted._Expt_key and
14>       inserted._RISet_key = RI_RISet._RISet_key
1> 
2> drop trigger MLD_RI_Update
1> 
2> create trigger MLD_RI_Update
3> on MLD_RI
4> for update
5> as
6> 
7> /* If modifying RI key in MLDP table, then */
8> /* set appropriate column values in MLDP table */
9> /* as they appear in the RI table */
10> 
11> if update (_RISet_key)
12> begin
13>   update MLD_RI
14>   set designation = RI_RISet.designation,
15>       origin = RI_RISet.origin,
16>       abbrev1 = RI_RISet.abbrev1,
17>       abbrev2 = RI_RISet.abbrev2
18>   from MLD_RI, RI_RISet, inserted
19>   where MLD_RI._Expt_key = inserted._Expt_key and
20> 	inserted._RISet_key = RI_RISet._RISet_key
21> end
22> 
1> 
2> drop trigger MLD_Assay_Types_Delete
1> 
2> create trigger MLD_Assay_Types_Delete
3> on MLD_Assay_Types
4> for delete
5> as
6> 
7> /* Disallow removal of an Assay which is referenced in MLDP */
8> 
9> if exists (select * from MLD_Expt_Marker, deleted
10>     where MLD_Expt_Marker._Assay_Type_key = deleted._Assay_Type_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Assay is referenced in MLDP Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger MLD_InSitu_Insert
1> 
2> create trigger MLD_InSitu_Insert
3> on MLD_InSitu
4> for insert
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if (select MRK_Marker.cytogeneticOffset 
13>     from MRK_Marker, MLD_Expt_Marker, inserted
14>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key
15> 	  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
16> begin
17> 	update MRK_Marker
18> 	set cytogeneticOffset = inserted.band
19> 	from MRK_Marker, MLD_Expt_Marker, inserted
20>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
21> 	      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
22> end
23> 
1> 
2> drop trigger MLD_InSitu_Update
1> 
2> create trigger MLD_InSitu_Update
3> on MLD_InSitu
4> for update
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if update(band)
13> begin
14> 	if (select MRK_Marker.cytogeneticOffset 
15> 	    from MRK_Marker, MLD_Expt_Marker, inserted
16> 	    where inserted._Expt_key = MLD_Expt_Marker._Expt_key
17> 		  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
18> 	begin
19> 		update MRK_Marker
20> 		set cytogeneticOffset = inserted.band
21> 		from MRK_Marker, MLD_Expt_Marker, inserted
22> 	        where inserted._Expt_key = MLD_Expt_Marker._Expt_key
23> 		      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
24> 	end
25> end
26> 
1> 
2> drop trigger MLD_FISH_Insert
1> 
2> create trigger MLD_FISH_Insert
3> on MLD_FISH
4> for insert
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> /* If more than one Marker is defined in the experiment, then we can't */
13> /* assign any cytogenetic band information because we don't know which */
14> /* Marker is the relevant Marker */
15> 
16> if (select count(*) from MLD_Expt_Marker, inserted
17>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key) > 1
18> begin
19> 	return
20> end
21> 
22> if (select MRK_Marker.cytogeneticOffset 
23>     from MRK_Marker, MLD_Expt_Marker, inserted
24>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key
25> 	  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
26> begin
27> 	update MRK_Marker
28> 	set cytogeneticOffset = inserted.band
29> 	from MRK_Marker, MLD_Expt_Marker, inserted
30>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
31> 	      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
32> end
33> 
1> 
2> drop trigger MLD_FISH_Update
1> 
2> create trigger MLD_FISH_Update
3> on MLD_FISH
4> for update
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if update(band)
13> begin
14> 	/* If more than one Marker is defined in the experiment, then we can't */
15> 	/* assign any cytogenetic band information because we don't know which */
16> 	/* Marker is the relevant Marker */
17> 
18> 	if (select count(*) from MLD_Expt_Marker, inserted
19>     	    where inserted._Expt_key = MLD_Expt_Marker._Expt_key) > 1
20> 	begin
21> 		return
22> 	end
23> 
24> 	if (select MRK_Marker.cytogeneticOffset 
25> 	    from MRK_Marker, MLD_Expt_Marker, inserted
26> 	    where inserted._Expt_key = MLD_Expt_Marker._Expt_key
27> 		  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
28> 	begin
29> 		update MRK_Marker
30> 		set cytogeneticOffset = inserted.band
31> 		from MRK_Marker, MLD_Expt_Marker, inserted
32> 	        where inserted._Expt_key = MLD_Expt_Marker._Expt_key
33> 		      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
34> 	end
35> end
36> 
1> 
2> drop trigger MLD_Hybrid_Insert
1> 
2> create trigger MLD_Hybrid_Insert
3> on MLD_Hybrid
4> for insert
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if (select MRK_Marker.cytogeneticOffset 
13>     from MRK_Marker, MLD_Expt_Marker, inserted
14>     where inserted._Expt_key = MLD_Expt_Marker._Expt_key
15> 	  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
16> begin
17> 	update MRK_Marker
18> 	set cytogeneticOffset = inserted.band
19> 	from MRK_Marker, MLD_Expt_Marker, inserted
20>         where inserted._Expt_key = MLD_Expt_Marker._Expt_key
21> 	      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
22> end
23> 
1> 
2> drop trigger MLD_Hybrid_Update
1> 
2> create trigger MLD_Hybrid_Update
3> on MLD_Hybrid
4> for update
5> as
6> 
7> /* If the Marker's cytogenetic band is null, then */
8> /* assign the cytogenetic band for the Marker in the */
9> /* experiment using the band information reported in the */
10> /* experiment. */
11> 
12> if update(band)
13> begin
14> 	if (select MRK_Marker.cytogeneticOffset 
15> 	    from MRK_Marker, MLD_Expt_Marker, inserted
16> 	    where inserted._Expt_key = MLD_Expt_Marker._Expt_key
17> 		  and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key) is null
18> 	begin
19> 		update MRK_Marker
20> 		set cytogeneticOffset = inserted.band
21> 		from MRK_Marker, MLD_Expt_Marker, inserted
22> 	        where inserted._Expt_key = MLD_Expt_Marker._Expt_key
23> 		      and MLD_Expt_Marker._Marker_key = MRK_Marker._Marker_key
24> 	end
25> end
26> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop trigger MRK_Marker_Insert
1> 
2> create trigger MRK_Marker_Insert
3> on MRK_Marker
4> for insert
5> as
6> 
7> insert MRK_Label (_Marker_key, _Marker_Status_key, _Species_key, label, labelType) 
8> 	select _Marker_key, _Marker_Status_key, _Species_key, symbol, "S" from inserted
9> insert MRK_Label (_Marker_key, _Marker_Status_key, _Species_key, label, labelType) 
10> 	select _Marker_key, _Marker_Status_key, _Species_key, name, "N" from inserted
11> 
12> /* For Mouse Species, create Accession #, Current Symbol records */
13> 
14> if (select _Species_key from inserted) = 1
15> begin
16> 	insert MRK_Current (_Current_key, _Marker_key) 
17> 		select _Marker_key, _Marker_key from inserted
18> 
19> 	if (@@error != 0)
20> 	begin
21>   	  rollback transaction
22>   	  return
23> 	end
24> end
25> 
26> /* For non-mouse species, update MRK_Chromosome table */
27> 
28> if (select _Species_key from inserted) != 1
29> begin
30>         declare @speciesKey integer
31>         declare @chromosome varchar(8)
32>         select @speciesKey = _Species_key from inserted
33>         select @chromosome = chromosome from inserted
34>         exec MRK_addChromosome @speciesKey, @chromosome
35> end
36> 
1> 
2> drop trigger MRK_Marker_Update
1> 
2> create trigger MRK_Marker_Update
3> on MRK_Marker
4> for update
5> as
6> 
7> /* If not Mouse, disallow duplicate Species/Symbol records */
8> 
9> if (select _Species_key from inserted) != 1
10> begin
11> 	if update(symbol) and
12>            (select count(*) from MRK_Marker, inserted 
13> 	    where inserted._Species_key = MRK_Marker._Species_key and
14> 		  inserted.symbol = MRK_Marker.symbol) > 1
15> 	begin
16> 		rollback transaction
17> 		raiserror 99999 "Marker Symbol For This Species Already Exists.\nDelete Existing Row And Add A New Row For This Symbol."
18> 		return
19> 	end
20> end
21> 
22> /* If updating chromosome and changing from unknown to known, update offset to -1 */
23> 
24> if (select _Species_key from inserted) = 1 and update (chromosome)
25> begin
26>        if (select chromosome from deleted) = "UN" and
27>           (select chromosome from inserted) != "UN"
28> 	begin
29>         	update MRK_Offset set offset = -1
30>         	from inserted
31>         	where inserted._Marker_key = MRK_Offset._Marker_key and MRK_Offset.source = 0
32> 	end
33> end
34> 
35> /* For non-mouse species, update MRK_Chromosome table */
36> 
37> if (select _Species_key from inserted) != 1 and update(chromosome)
38> begin
39>         declare @speciesKey integer
40>         declare @chromosome varchar(8)
41>         select @speciesKey = _Species_key from inserted
42>         select @chromosome = chromosome from inserted
43>         exec MRK_addChromosome @speciesKey, @chromosome
44> end
45> 
1> 
2> drop trigger MRK_Marker_Delete
1> 
2> create trigger MRK_Marker_Delete
3> on MRK_Marker
4> for delete
5> as
6> 
7> /* Cannot delete records w/ reference of J:65060 (RIKEN) */
8> 
9> if exists (select * from deleted d, MRK_Reference_View r
10>     	   where d._Marker_key = r._Marker_key and r.jnum = 65060)
11> begin
12> 	rollback transaction
13>         raiserror 99999 "Marker record is referenced by J:65060.  Cannot delete this record."
14>         return
15> end
16> 
17> /* Disallow deletion if Marker is currently referenced elsewhere */
18> 
19> if exists (select * from MRK_Alias, deleted
20>     where MRK_Alias._Alias_key = deleted._Marker_key)
21> begin
22> 	rollback transaction
23> 	raiserror 99999 "Marker Symbol is referenced in Alias Record(s)"
24> 	return
25> end
26> 
27> /* Symbol is a Current Symbol of itself */
28> 
29> if exists (select * from MRK_Current, deleted
30>          where MRK_Current._Current_key = deleted._Marker_key)
31> begin
32> 	rollback transaction
33> 	raiserror 99999 "Marker Symbol is referenced in Current Symbol Record(s)"
34> 	return
35> end
36> 
37> if exists (select * from MRK_History, deleted
38>          where MRK_History._History_key = deleted._Marker_key and
39>                MRK_History._Marker_key != deleted._Marker_key)
40> begin
41> 	rollback transaction
42> 	raiserror 99999 "Marker Symbol is referenced in History Record(s)"
43> 	return
44> end
45> 
46> if exists (select * from PRB_Marker, deleted
47>          where PRB_Marker._Marker_key = deleted._Marker_key)
48> begin
49> 	rollback transaction
50> 	raiserror 99999 "Marker Symbol is referenced in Probe Marker Record(s)"
51> 	return
52> end
53> 
54> if exists (select * from PRB_RFLV, deleted
55>          where PRB_RFLV._Marker_key = deleted._Marker_key)
56> begin
57> 	rollback transaction
58> 	raiserror 99999 "Marker Symbol is referenced in Probe RFLV Record(s)"
59> 	return
60> end
61> 
62> if exists (select * from MLD_Marker, deleted
63>          where MLD_Marker._Marker_key = deleted._Marker_key)
64> begin
65> 	rollback transaction
66> 	raiserror 99999 "Marker Symbol is referenced in MLDP Marker Record(s)"
67> 	return
68> end
69> 
70> if exists (select * from MLD_Expt_Marker, deleted
71>          where MLD_Expt_Marker._Marker_key = deleted._Marker_key)
72> begin
73> 	rollback transaction
74> 	raiserror 99999 "Marker Symbol is referenced in MLDP Experiment Marker Record(s)"
75> 	return
76> end
77> 
78> if exists (select * from MLD_Concordance, deleted
79>          where MLD_Concordance._Marker_key = deleted._Marker_key)
80> begin
81> 	rollback transaction
82> 	raiserror 99999 "Marker Symbol is referenced in MLDP Hybrid Concordance Record(s)"
83> 	return
84> end
85> 
86> if exists (select * from MLD_MC2point, deleted
87>          where MLD_MC2point._Marker_key_1 = deleted._Marker_key)
88> begin
89> 	rollback transaction
90> 	raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
91> 	return
92> end
93> 
94> if exists (select * from MLD_MC2point, deleted
95>          where MLD_MC2point._Marker_key_2 = deleted._Marker_key)
96> begin
97> 	rollback transaction
98> 	raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
99> 	return
100> end
101> 
102> if exists (select * from MLD_RIData, deleted
103>          where MLD_RIData._Marker_key = deleted._Marker_key)
104> begin
105> 	rollback transaction
106> 	raiserror 99999 "Marker Symbol is referenced in MLDP RI Data Record(s)"
107> 	return
108> end
109> 
110> if exists (select * from MLD_RI2Point, deleted
111>          where MLD_RI2Point._Marker_key_1 = deleted._Marker_key)
112> begin
113> 	rollback transaction
114> 	raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
115> 	return
116> end
117> 
118> if exists (select * from MLD_RI2Point, deleted
119>          where MLD_RI2Point._Marker_key_2 = deleted._Marker_key)
120> begin
121> 	rollback transaction
122> 	raiserror 99999 "Marker Symbol is referenced in MLDP Cross 2 Point Record(s)"
123> 	return
124> end
125> 
126> if exists (select * from MLD_Distance, deleted
127>          where MLD_Distance._Marker_key_1 = deleted._Marker_key)
128> begin
129> 	rollback transaction
130> 	raiserror 99999 "Marker Symbol is referenced in Physical Mapping Record(s)"
131> 	return
132> end
133> 
134> if exists (select * from MLD_Distance, deleted
135>          where MLD_Distance._Marker_key_2 = deleted._Marker_key)
136> begin
137> 	rollback transaction
138> 	raiserror 99999 "Marker Symbol is referenced in Physical Mapping Record(s)"
139> 	return
140> end
141> 
142> if exists (select * from HMD_Homology_Marker, deleted
143>          where HMD_Homology_Marker._Marker_key = deleted._Marker_key)
144> begin
145> 	rollback transaction
146> 	raiserror 99999 "Marker Symbol is referenced in Homology Record(s)"
147> 	return
148> end
149> 
150> if exists (select * from MLC_Text_edit, deleted
151>          where MLC_Text_edit._Marker_key = deleted._Marker_key)
152> begin
153> 	rollback transaction
154> 	raiserror 99999 "Marker Symbol is referenced in MLC Edit Record(s)"
155> 	return
156> end
157> 
158> if exists (select * from MLC_Marker_edit, deleted
159>          where MLC_Marker_edit._Marker_key_2 = deleted._Marker_key)
160> begin
161> 	rollback transaction
162> 	raiserror 99999 "Marker Symbol is referenced in MLC Edit Record(s)"
163> 	return
164> end
165> 
166> if exists (select * from CRS_Matrix, deleted
167>          where CRS_Matrix._Marker_key = deleted._Marker_key)
168> begin
169> 	rollback transaction
170> 	raiserror 99999 "Marker Symbol is referenced in Cross Matrix Record(s)"
171> 	return
172> end
173> 
174> if exists (select * from GXD_Index, deleted
175>          where GXD_Index._Marker_key = deleted._Marker_key)
176> begin
177> 	rollback transaction
178> 	raiserror 99999 "Marker Symbol is referenced in GXD Index Record(s)"
179> 	return
180> end
181> 
182> if exists (select * from GXD_AllelePair, deleted
183>          where GXD_AllelePair._Marker_key = deleted._Marker_key)
184> begin
185> 	rollback transaction
186> 	raiserror 99999 "Marker Symbol is referenced in GXD Allele Pair Record(s)"
187> 	return
188> end
189> 
190> if exists (select * from GXD_AntibodyMarker, deleted
191>          where GXD_AntibodyMarker._Marker_key = deleted._Marker_key)
192> begin
193> 	rollback transaction
194> 	raiserror 99999 "Marker Symbol is referenced in GXD Antibody Marker Record(s)"
195> 	return
196> end
197> 
198> if exists (select * from GXD_Assay, deleted
199>          where GXD_Assay._Marker_key = deleted._Marker_key)
200> begin
201> 	rollback transaction
202> 	raiserror 99999 "Marker Symbol is referenced in GXD Assay Record(s)"
203> 	return
204> end
205> 
206> if exists (select * from PRB_Strain_Marker, deleted
207>     where PRB_Strain_Marker._Marker_key = deleted._Marker_key)
208> begin
209> 	rollback transaction
210> 	raiserror 99999 "Marker Symbol is referenced in Strain Record(s)"
211> 	return
212> end
213> 
214> if exists (select * from GO_MarkerGO, deleted
215>     where GO_MarkerGO._Marker_key = deleted._Marker_key)
216> begin
217> 	rollback transaction
218> 	raiserror 99999 "Marker Symbol is referenced in GO Marker Record(s)"
219> 	return
220> end
221> 
222> delete MRK_Alias from MRK_Alias, deleted
223> where MRK_Alias._Marker_key = deleted._Marker_key
224> 
225> delete ALL_Allele from ALL_Allele, deleted
226> where ALL_Allele._Marker_key = deleted._Marker_key
227> 
228> delete MRK_Classes from MRK_Classes, deleted
229> where MRK_Classes._Marker_key = deleted._Marker_key
230> 
231> delete MRK_Current from MRK_Current, deleted
232> where MRK_Current._Marker_key = deleted._Marker_key
233> 
234> delete MRK_History from MRK_History, deleted
235> where MRK_History._Marker_key = deleted._Marker_key
236> 
237> delete MRK_Notes from MRK_Notes, deleted
238> where MRK_Notes._Marker_key = deleted._Marker_key
239> 
240> delete MRK_Offset from MRK_Offset, deleted
241> where MRK_Offset._Marker_key = deleted._Marker_key
242> 
243> delete MRK_Other from MRK_Other, deleted
244> where MRK_Other._Marker_key = deleted._Marker_key
245> 
246> delete MRK_Reference from MRK_Reference, deleted
247> where MRK_Reference._Marker_key = deleted._Marker_key
248> 
249> delete MRK_Label from MRK_Label, deleted
250> where MRK_Label._Marker_key = deleted._Marker_key
251> 
252> delete ACC_Accession
253> from ACC_Accession a, ACC_MGIType m, deleted
254> where a._Object_key = deleted._Marker_key
255> and a._MGIType_key = m._MGIType_key
256> and m.name = "Marker"
257> 
1> 
2> drop trigger MRK_Alias_Insert
1> 
2> create trigger MRK_Alias_Insert
3> on MRK_Alias
4> for insert
5> as
6> 
7> if exists (select * from MRK_Marker, inserted
8>          where inserted._Marker_key = inserted._Alias_key)
9> begin
10>         rollback transaction
11>         raiserror 99999 "Symbol cannot use itself as an Alias"
12> 	return
13> end
14> 
1> 
2> drop trigger MRK_Class_Delete
1>  
2> create trigger MRK_Class_Delete
3> on MRK_Class
4> for delete
5> as
6> 
7> /* Disallow deletion if Class is referenced by a Marker */
8>  
9> if exists (select * from MRK_Classes, deleted
10>     where MRK_Classes._Class_key = deleted._Class_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Class is referenced in Marker Record(s)"
14> 	return
15> end
16>  
1>  
2> drop trigger MRK_Event_Delete
1> 
2> create trigger MRK_Event_Delete
3> on MRK_Event
4> for delete
5> as
6> 
7> /* Disallow deletion of event which is referenced in History table */
8> 
9> if exists (select * from MRK_History, deleted
10>          where MRK_History._Marker_Event_key = deleted._Marker_Event_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Event is referenced in History Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger MRK_EventReason_Delete
1> 
2> create trigger MRK_EventReason_Delete
3> on MRK_EventReason
4> for delete
5> as
6> 
7> /* Disallow deletion of event reason which is referenced in History table */
8> 
9> if exists (select * from MRK_History, deleted
10>          where MRK_History._Marker_EventReason_key = deleted._Marker_EventReason_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Event Reason is referenced in History Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger MRK_Species_Delete
1> 
2> create trigger MRK_Species_Delete
3> on MRK_Species
4> for delete
5> as
6> 
7> /* Disallow deletion of species which is referenced in MRK_Marker table */
8> 
9> if exists (select * from MRK_Marker, deleted
10>          where MRK_Marker._Species_key = deleted._Species_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Species is referenced in Marker Record(s)"
14> 	return
15> end
16> 
17> /* Delete records in dependent tables */
18> 
19> delete MRK_Chromosome from MRK_Chromosome, deleted
20> where MRK_Chromosome._Species_key = deleted._Species_key
21> 
1> 
2> drop trigger MRK_Status_Delete
1> 
2> create trigger MRK_Status_Delete
3> on MRK_Status
4> for delete
5> as
6> 
7> /* Disallow deletion of status which is referenced in Marker table */
8> 
9> if exists (select * from MRK_Marker, deleted
10>          where MRK_Marker._Marker_Status_key = deleted._Marker_Status_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Status is referenced in Marker Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger MRK_Types_Delete
1> 
2> create trigger MRK_Types_Delete
3> on MRK_Types
4> for delete
5> as
6> 
7> /* Disallow deletion of Type which is referenced in MRK_Marker table */
8> 
9> if exists (select * from MRK_Marker, deleted
10>          where MRK_Marker._Marker_Type_key = deleted._Marker_Type_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Marker Type is referenced in Marker Record(s)"
14> 	return
15> end
16> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop trigger PRB_Probe_Insert
1>  
2> create trigger PRB_Probe_Insert
3> on PRB_Probe
4> for insert
5> as
6>  
7> /* Assign MGI Accession number for each Molecular Segment */
8> 
9> declare @key integer
10> select @key = _Probe_key from inserted
11> exec ACC_assignMGI @key, "Segment"
12> 
13> if (@@error != 0)
14> begin
15>   rollback transaction
16>   return
17> end
18>  
1>  
2> drop trigger PRB_Probe_Update
1>  
2> create trigger PRB_Probe_Update
3> on PRB_Probe
4> for update
5> as
6>  
7> if update (_Source_key)
8> begin
9> 	/* Disallow edits to WashU data - TR 611 */
10> 
11>    	if exists (select * from PRB_Reference_View r, inserted i
12> 		where r._Probe_key = i._Probe_key and
13> 	      	      r.jnum = 57656)
14>    	    and
15>    	    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
16> 	begin
17>         	rollback transaction
18>         	raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot modify the Source information."
19> 		return
20> 	end
21> 
22> 	/* Delete orphan Anonymous _Source_keys */
23> 
24> 	if (select PRB_Source.name from PRB_Source, deleted
25> 	    where PRB_Source._Source_key = deleted._Source_key) is null
26> 	    and
27> 	   not exists (select * from PRB_Probe, deleted
28>             where PRB_Probe._Source_key = deleted._Source_key)
29> 	begin
30> 		delete PRB_Source from PRB_Source, deleted
31> 		where PRB_Source._Source_key = deleted._Source_key
32> 	end
33> 
34> 	/* Update _Source_key for all children of Parent */
35> 
36> 	update PRB_Probe set _Source_key = inserted._Source_key
37> 	from PRB_Probe, inserted
38> 	where PRB_Probe.derivedFrom = inserted._Probe_key
39> end
40> 
41> /* Disallow edits to WashU data - TR 611 */
42> 
43> if update (name)
44>    and
45>    exists (select * from PRB_Reference_View r, inserted i
46> 	where r._Probe_key = i._Probe_key and
47> 	      r.jnum = 57656)
48>    and
49>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
50> begin
51>         rollback transaction
52>         raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot modify the name."
53> 	return
54> end
55> 
1>  
2> drop trigger PRB_Probe_Delete
1> 
2> create trigger PRB_Probe_Delete
3> on PRB_Probe
4> for delete
5> as
6> 
7> /* Cannot delete records w/ reference of J:65060 (RIKEN) */
8> 
9> if exists (select * from deleted d, PRB_Reference_View r
10>            where d._Probe_key = r._Probe_key and r.jnum = 65060)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Molecular Segment record is referenced by J:65060.  Cannot delete this record."
14>         return
15> end
16> 
17> /* Disallow deletion if Molecular Segment is referenced elsewhere */
18> 
19> if exists (select * from PRB_Probe, deleted
20>     where PRB_Probe.derivedFrom = deleted._Probe_key)
21> begin
22>         rollback transaction
23>         raiserror 99999 "Molecular Segment is referenced as a Parent in Molecular Segment record(s)"
24> 	return
25> end
26>  
27> if exists (select * from MLD_Hit, deleted
28>          where MLD_Hit._Probe_key = deleted._Probe_key)
29> begin
30>         rollback transaction
31>         raiserror 99999 "Molecular Segment is referenced in MLDP Hit record(s)"
32> 	return
33> end
34>  
35> if exists (select * from MLD_Hit, deleted
36>          where MLD_Hit._Target_key = deleted._Probe_key)
37> begin
38>         rollback transaction
39>         raiserror 99999 "Molecular Segment is referenced as a Target in MLDP Hit record(s)"
40> 	return
41> end
42>  
43> if exists (select * from MLD_ContigProbe, deleted
44>          where MLD_ContigProbe._Probe_key = deleted._Probe_key)
45> begin
46>         rollback transaction
47>         raiserror 99999 "Molecular Segment is referenced in MLDP Contig/Probe record(s)"
48> 	return
49> end
50>  
51> if exists (select * from GXD_ProbePrep, deleted
52>          where GXD_ProbePrep._Probe_key = deleted._Probe_key)
53> begin
54>         rollback transaction
55>         raiserror 99999 "Molecular Segment is referenced in GXD Probe Prep record(s)"
56> 	return
57> end
58> 
59> /* Disallow edits to WashU data - TR 611 */
60> 
61> if exists (select * from PRB_Reference_View r, deleted d
62> 	where r._Probe_key = d._Probe_key and
63> 	      r.jnum = 57656)
64>    and
65>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
66> begin
67>         rollback transaction
68>         raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot delete record."
69> 	return
70> end
71> 
72> delete PRB_Marker from PRB_Marker, deleted
73> where PRB_Marker._Probe_key = deleted._Probe_key
74> 
75> delete PRB_Notes from PRB_Notes, deleted
76> where PRB_Notes._Probe_key = deleted._Probe_key
77> 
78> delete PRB_Reference from PRB_Reference, deleted
79> where PRB_Reference._Probe_key = deleted._Probe_key
80> 
81> /* If Probe Source Name is null, then Anonymous Source */
82> /* If Anonymous Source, delete upon deletion of Probe */
83> 
84> if exists (select * from PRB_Probe, deleted
85>     where PRB_Probe._Source_key = deleted._Source_key)
86> begin
87>   	delete PRB_Source from PRB_Source, deleted
88>   	where PRB_Source._Source_key = deleted._Source_key
89> 	      and PRB_Source.name is null
90> end
91> 
92> delete ACC_AccessionReference 
93> from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m, deleted
94> where a._Object_key = deleted._Probe_key
95> and a._MGIType_key = m._MGIType_key
96> and m.name = "Segment"
97> and a._Accession_key = ar._Accession_key
98>  
99> delete ACC_Accession 
100> from ACC_Accession a, ACC_MGIType m, deleted
101> where a._Object_key = deleted._Probe_key
102> and a._MGIType_key = m._MGIType_key
103> and m.name = "Segment"
104>  
1> 
2> drop trigger PRB_Allele_Delete
1> 
2> create trigger PRB_Allele_Delete
3> on PRB_Allele
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete PRB_Allele_Strain from PRB_Allele_Strain, deleted
10> where PRB_Allele_Strain._Allele_key = deleted._Allele_key
11> 
1> 
2> drop trigger PRB_Marker_Insert
1> 
2> create trigger PRB_Marker_Insert
3> on PRB_Marker
4> for insert
5> as
6> 
7> if @@rowcount = 1
8> begin
9> 	/* Relationship must be 'H' for Probes of non-mouse source */
10> 
11> 	if exists (select * from inserted i, PRB_Probe p, PRB_Source s
12>     		where i._Probe_key = p._Probe_key
13> 	  	and p.DNAtype != 'primer'
14> 	  	and p._Source_key = s._Source_key
15> 	  	and s.species not in ('mouse, laboratory')
16> 	  	and (i.relationship != 'H' or i.relationship is null))
17> 	begin
18>         	rollback transaction
19>         	raiserror 99999 "Relationship Must be 'H'"
20> 		return
21> 	end
22> 
23> 	/* Relationship 'P' can only be used during an EST bulk load */
24> 
25> 	if (select relationship from inserted) = 'P'
26> 	begin
27>         	rollback transaction
28>         	raiserror 99999 "Relationship 'P' can only be used during EST load"
29> 		return
30> 	end
31> 
32>   	/* If adding encoding Marker to a Molecular Segment and */
33> 	/* Molecular Segment contains a Seq ID and */
34> 	/* the Marker is not associated with the Seq ID */
35> 
36> 	if (select relationship from inserted) = 'E'
37> 	begin
38> 		if exists (select a1.accID
39> 		   from ACC_Accession a1, ACC_Accession a2, inserted i
40> 		   where a1._MGIType_key = 3 and 
41> 		         a1. _LogicalDB_key = 9 and 
42> 		         a1._Object_key = i._Probe_key)
43> 		   and
44> 		   not exists (select a1.accID
45> 		   from ACC_Accession a1, ACC_Accession a2, inserted i
46> 		   where a1._MGIType_key = 3 and 
47> 		         a1. _LogicalDB_key = 9 and 
48> 		         a1._Object_key = i._Probe_key and
49> 			 a1.accID = a2.accID and
50> 			 a2._MGIType_key = 2 and
51> 			 a2._LogicalDB_key = 9 and
52> 			 a2._Object_key = i._Marker_key)
53> 
54>   		begin
55>         		print "The Sequence ID(s) for this Molecular Segment should probably be added to the encoding, updated Marker."
56>   		end
57> 
58> 	end
59> end
60> 
1> 
2> drop trigger PRB_Marker_Update
1>  
2> create trigger PRB_Marker_Update
3> on PRB_Marker
4> for update
5> as
6>  
7> if @@rowcount = 1
8> begin
9> 
10> 	/* Relationship must be 'H' for Probes of non-mouse source */
11> 
12> 	if exists (select * from inserted i, PRB_Probe p, PRB_Source s
13>     		where i._Probe_key = p._Probe_key
14> 	  	and p.DNAtype != 'primer'
15> 	  	and p._Source_key = s._Source_key
16> 	  	and s.species not in ('mouse, laboratory')
17> 	  	and (i.relationship != 'H' or i.relationship is null))
18> 	begin
19>         	rollback transaction
20>         	raiserror 99999 "Relationship Must be 'H'"
21> 		return
22> 	end
23> 
24> 	/* Allow update of 'P' to other relationship */
25> 	/* Disallow update of other relationship to 'P' */
26> 	/* Only check on individual inserts */
27> 
28> 	if ((select relationship from inserted) = 'P'
29> 	    and (select _Marker_key from inserted) = (select _Marker_key from deleted))
30> 	   or
31> 	   ((select _Marker_key from inserted) != (select _Marker_key from deleted)
32> 	    and (select relationship from inserted) = 'P'
33> 	    and (select relationship from deleted) != 'P')
34> 	begin
35>         	rollback transaction
36>         	raiserror 99999 "Relationship 'P' can only be used during EST load"
37> 		return
38> 	end
39> 
40>         /* If updating to an encoding Marker for a Molecular Segment and */
41>         /* Molecular Segment contains a Seq ID and */
42>         /* the Marker is not associated with the Seq ID */
43>  
44>         if update(relationship) and (select relationship from inserted) = 'E'
45>         begin
46>                 if not exists (select a1.accID
47>                    from ACC_Accession a1, ACC_Accession a2, inserted i
48>                    where a1._MGIType_key = 3 and
49>                          a1. _LogicalDB_key = 9 and
50>                          a1._Object_key = i._Probe_key and
51>                          a1.accID = a2.accID and
52>                          a2._MGIType_key = 2 and
53>                          a2._LogicalDB_key = 9 and
54>                          a2._Object_key = i._Marker_key)
55>  
56>                 begin
57>                         print "The Sequence ID(s) for this Molecular Segment should probably be added to the encoding, updated Marker."
58>                 end
59> 	end 
60> 
61>         /* If updating to an non-encoding Marker for a Molecular Segment and */
62>         /* Molecular Segment contains a Seq ID and */
63>         /* the Marker is associated with the Seq ID */
64>  
65>         if update(relationship) and 
66> 	   (select relationship from deleted) = 'E' and
67>            (select relationship from inserted) != 'E'
68>         begin
69>                 if exists (select a1.accID
70>                    from ACC_Accession a1, ACC_Accession a2, inserted i
71>                    where a1._MGIType_key = 3 and
72>                          a1. _LogicalDB_key = 9 and
73>                          a1._Object_key = i._Probe_key and
74>                          a1.accID = a2.accID and
75>                          a2._MGIType_key = 2 and
76>                          a2._LogicalDB_key = 9 and
77>                          a2._Object_key = i._Marker_key)
78>  
79>                 begin
80>                         print "Please review the relationship(s) between the updated Marker and its Seq IDs.  These relationships may no longer be appropriate."
81>                 end
82> 	end 
83> end
84> 
85> if update(_Marker_key)
86> begin
87> 	update PRB_RFLV
88> 	set _Marker_key = inserted._Marker_key
89> 	from PRB_RFLV, PRB_Reference, inserted, deleted
90> 	where inserted._Probe_key = PRB_Reference._Probe_key
91> 	      and PRB_Reference._Reference_key = PRB_RFLV._Reference_key
92> 	      and PRB_RFLV._Marker_key = deleted._Marker_key
93> end
94> 
1> 
2> drop trigger PRB_Marker_Delete
1>  
2> create trigger PRB_Marker_Delete
3> on PRB_Marker
4> for delete
5> as
6> 
7> if @@rowcount = 1
8> begin
9>         /* If deleting an encoding Marker from a Molecular Segment and */
10>         /* Molecular Segment contains a Seq ID and */
11>         /* the Marker is associated with the Seq ID */
12>  
13>         if (select relationship from deleted) = 'E'
14>         begin
15>                 if exists (select a1.accID
16>                    from ACC_Accession a1, ACC_Accession a2, deleted d
17>                    where a1._MGIType_key = 3 and
18>                          a1. _LogicalDB_key = 9 and
19>                          a1._Object_key = d._Probe_key and
20>                          a1.accID = a2.accID and
21>                          a2._MGIType_key = 2 and
22>                          a2._LogicalDB_key = 9 and
23>                          a2._Object_key = d._Marker_key)
24>  
25>                 begin
26>                         print "Please review the relationship(s) between the deleted Marker and its Seq IDs.  These relationships may no longer be appropriate."
27>                 end
28> 	end 
29> 
30> end
31> 
1>  
2> drop trigger PRB_Reference_Update
1> 
2> create trigger PRB_Reference_Update
3> on PRB_Reference
4> for update
5> as
6> 
7> /* Disallow edits to WashU data - TR 611 */
8> 
9> if exists (select * from BIB_All_View b, inserted d
10> 	where d._Refs_key = b._Refs_key and
11> 	      b.jnum = 57656)
12>    and
13>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
14> begin
15>         rollback transaction
16>         raiserror 99999 "J:57656, WashU-HHMI Database Download.  Cannot update record."
17> 	return
18> end
19> 
1> 
2> drop trigger PRB_Reference_Delete
1> 
2> create trigger PRB_Reference_Delete
3> on PRB_Reference
4> for delete
5> as
6> 
7> /* Disallow edits to WashU data - TR 611 */
8> 
9> if exists (select * from BIB_All_View b, deleted d
10> 	where d._Refs_key = b._Refs_key and
11> 	      b.jnum = 57656)
12>    and
13>    (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
14> begin
15>         rollback transaction
16>         raiserror 99999 "J:57656, WashU-HHMI Database Download.  Cannot delete record."
17> 	return
18> end
19> 
20> /* Delete dependent records */
21> 
22> delete PRB_Alias from PRB_Alias, deleted
23> where PRB_Alias._Reference_key = deleted._Reference_key
24> 
25> delete PRB_Ref_Notes from PRB_Ref_Notes, deleted
26> where PRB_Ref_Notes._Reference_key = deleted._Reference_key
27> 
28> delete PRB_RFLV from PRB_RFLV, deleted
29> where PRB_RFLV._Reference_key = deleted._Reference_key
30> 
31> delete ACC_AccessionReference 
32> from ACC_Accession a, ACC_AccessionReference ar, ACC_MGIType m, deleted
33> where a._Object_key = deleted._Probe_key
34> and a._MGIType_key = m._MGIType_key
35> and m.name = "Segment"
36> and a._Accession_key = ar._Accession_key
37> and ar._Refs_key = deleted._Refs_key
38>  
1> 
2> drop trigger PRB_RFLV_Delete
1> 
2> create trigger PRB_RFLV_Delete
3> on PRB_RFLV
4> for delete
5> as
6> 
7> /* Delete dependent records */
8> 
9> delete PRB_Allele from PRB_Allele, deleted
10> where PRB_Allele._RFLV_key = deleted._RFLV_key
11> 
1> 
2> drop trigger PRB_Source_Insert
1> 
2> create trigger PRB_Source_Insert
3> on PRB_Source
4> for insert
5> as
6> 
7> /* The same exact logic to prevent invalid Age values must */
8> /* be used in the update trigger as well */
9> 
10> /* Ignore multi-row data */
11> 
12> if @@rowcount > 1
13> begin
14> 	return
15> end
16> 
17> /* Disallow edits to WashU data - TR 611 */
18> 
19> if exists (select * from PRB_Probe p, PRB_Reference_View r, inserted i
20> 	where i._Source_key = p._Source_key and
21> 	      p._Probe_key = r._Probe_key and
22>       	      r.jnum = 57656)
23>     and
24>     (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
25> begin
26>        	rollback transaction
27>        	raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot modify the Source information."
28> 	return
29> end
30> 
31> declare @age varchar(50)
32> select @age = inserted.age from inserted
33> 
34> /* If tissue = 'unfertilized egg', then age must be 'Not Applicable' */
35> 
36> if (select PRB_Tissue.tissue
37> 	from PRB_Tissue, inserted
38> 	where inserted._Tissue_key = PRB_Tissue._Tissue_key) = "unfertilized egg"
39>    and @age != "Not Applicable"
40> begin
41>         rollback transaction
42>         raiserror 99999 "Age for this tissue MUST be Not Applicable"
43> 	return
44> end
45> 
46> /* If age is 'Not Applicable', then tissue must be 'unfertilized egg' */
47> 
48> if @age = "Not Applicable"
49>    and
50>    (select PRB_Tissue.tissue
51> 	from PRB_Tissue, inserted
52> 	where inserted._Tissue_key = PRB_Tissue._Tissue_key) != "unfertilized egg"
53> begin
54>         rollback transaction
55>         raiserror 99999 "Age for this tissue CANNOT be Not Applicable"
56> 	return
57> end
58> 
59> /* Separate agePrefix from ageSuffix (numerics) */
60> 
61> declare @agePrefix varchar(50)
62> declare @ageSuffix varchar(50)
63> declare @idx integer
64> 
65> select @agePrefix = @age
66> select @idx = patindex("%[0-9]%", @age)
67> 
68> if @idx > 0
69> begin
70> 	select @agePrefix = substring(@age, 1, @idx - 1)
71> 	select @ageSuffix = substring(@age, @idx, char_length(@age))
72> end
73> 
74> /* If age is one of the following prefixes, then there can be no numeric values */
75> 
76> if @agePrefix in ('Not Specified', 'Not Applicable', 'embryonic', 'perinatal',
77> 	'postnatal', 'postnatal newborn', 'postnatal immature', 'postnatal adult')
78>    and @ageSuffix is not null
79> begin
80>         rollback transaction
81>         raiserror 99999 "The Age value specified CANNOT contain numeric values"
82> 	return
83> end
84> 
85> /* If age is one of the following prefixes, then there must be numeric values */
86> 
87> if @agePrefix in ('embryonic day', 'postnatal day', 'postnatal week',
88> 	'postnatal month', 'postnatal year')
89>    and @ageSuffix is null
90> begin
91>         rollback transaction
92>         raiserror 99999 "The Age value specified MUST contain numeric values"
93> 	return
94> end
95> 
1> 
2> drop trigger PRB_Source_Update
1> 
2> create trigger PRB_Source_Update
3> on PRB_Source
4> for update
5> as
6> 
7> /* The same exact logic to prevent invalid Age values must */
8> /* be used in the insert trigger as well */
9> 
10> /* Ignore multi-row data */
11> 
12> if @@rowcount > 1
13> begin
14> 	return
15> end
16> 
17> /* Disallow edits to WashU data - TR 611 */
18> 
19> if exists (select * from PRB_Probe p, PRB_Reference_View r, inserted i
20> 	where i._Source_key = p._Source_key and
21> 	      p._Probe_key = r._Probe_key and
22>       	      r.jnum = 57656)
23>     and
24>     (select user_name()) not in ("mgd_dbo", "dbo", "rpp")
25> begin
26>        	rollback transaction
27>        	raiserror 99999 "Molecular Segment is referenced by J:57656, WashU-HHMI Database Download.  Cannot modify the Source information."
28> 	return
29> end
30> 
31> declare @age varchar(50)
32> select @age = inserted.age from inserted
33> 
34> /* If tissue = 'unfertilized egg', then age must be 'Not Applicable' */
35> 
36> if (select PRB_Tissue.tissue
37> 	from PRB_Tissue, inserted
38> 	where inserted._Tissue_key = PRB_Tissue._Tissue_key) = "unfertilized egg"
39>    and @age != "Not Applicable"
40> begin
41>         rollback transaction
42>         raiserror 99999 "Age for this tissue MUST be Not Applicable"
43> 	return
44> end
45> 
46> /* If age is 'Not Applicable', then tissue must be 'unfertilized egg' */
47> 
48> if @age = "Not Applicable"
49>    and
50>    (select PRB_Tissue.tissue
51> 	from PRB_Tissue, inserted
52> 	where inserted._Tissue_key = PRB_Tissue._Tissue_key) != "unfertilized egg"
53> begin
54>         rollback transaction
55>         raiserror 99999 "Age for this tissue CANNOT be Not Applicable"
56> 	return
57> end
58> 
59> /* Separate agePrefix from ageSuffix (numerics) */
60> 
61> declare @agePrefix varchar(50)
62> declare @ageSuffix varchar(50)
63> declare @idx integer
64> 
65> select @agePrefix = @age
66> select @idx = patindex("%[0-9]%", @age)
67> 
68> if @idx > 0
69> begin
70> 	select @agePrefix = substring(@age, 1, @idx - 1)
71> 	select @ageSuffix = substring(@age, @idx, char_length(@age))
72> end
73> 
74> /* If age is one of the following prefixes, then there can be no numeric values */
75> 
76> if @agePrefix in ('Not Specified', 'Not Applicable', 'embryonic', 'perinatal',
77> 	'postnatal', 'postnatal newborn', 'postnatal immature', 'postnatal adult')
78>    and @ageSuffix is not null
79> begin
80>         rollback transaction
81>         raiserror 99999 "The Age value specified CANNOT contain numeric values"
82> 	return
83> end
84> 
85> /* If age is one of the following prefixes, then there must be numeric values */
86> 
87> if @agePrefix in ('embryonic day', 'postnatal day', 'postnatal week',
88> 	'postnatal month', 'postnatal year')
89>    and @ageSuffix is null
90> begin
91>         rollback transaction
92>         raiserror 99999 "The Age value specified MUST contain numeric values"
93> 	return
94> end
95> 
1> 
2> drop trigger PRB_Source_Delete
1> 
2> create trigger PRB_Source_Delete
3> on PRB_Source
4> for delete
5> as
6> 
7> /* Disallow deletion if Source is referenced elsewhere */
8> 
9> if exists (select * from PRB_Probe, deleted
10>          where PRB_Probe._Source_key = deleted._Source_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Molecular Segment Library is referenced in Probe Record(s)"
14> 	return
15> end
16>  
17> if exists (select * from GXD_Antigen, deleted
18>          where GXD_Antigen._Source_key = deleted._Source_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Molecular Segment Library is referenced in GXD Antigen Record(s)"
22> 	return
23> end
24>  
1> 
2> drop trigger PRB_Strain_Insert
1> 
2> create trigger PRB_Strain_Insert
3> on PRB_Strain
4> for insert
5> as
6> 
7> if (select count(*) from PRB_Strain, inserted
8>          where PRB_Strain.strain = inserted.strain) > 1
9> begin
10>         print "Potential Duplicate Strain Found"
11> end
12>  
1> 
2> drop trigger PRB_Strain_Update
1> 
2> create trigger PRB_Strain_Update
3> on PRB_Strain
4> for update
5> as
6> 
7> if (select count(*) from PRB_Strain, inserted
8>          where PRB_Strain.strain = inserted.strain) > 1
9> begin
10>         print "Potential Duplicate Strain Found"
11> end
12>  
13> update PRB_Strain 
14> set modification_date = getdate()
15> from PRB_Strain, inserted
16> where PRB_Strain._Strain_key = inserted._Strain_key
17> 
1> 
2> drop trigger PRB_Strain_Delete
1> 
2> create trigger PRB_Strain_Delete
3> on PRB_Strain
4> for delete
5> as
6> 
7> /* Disallow deletion if Strain is referenced elsewhere */
8> 
9> if exists (select * from PRB_Source, deleted
10>     where PRB_Source._Strain_key = deleted._Strain_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Strain is referenced in Molecular Segment Library Record(s)"
14> 	return
15> end
16> 
17> if exists (select * from PRB_Allele_Strain, deleted
18>          where PRB_Allele_Strain._Strain_key = deleted._Strain_key)
19> begin
20>         rollback transaction
21>         raiserror 99999 "Strain is referenced in RFLP Record(s)"
22> 	return
23> end
24> 
25> if exists (select * from MLD_FISH, deleted
26>          where MLD_FISH._Strain_key = deleted._Strain_key)
27> begin
28>         rollback transaction
29>         raiserror 99999 "Strain is referenced in FISH Record(s)"
30> 	return
31> end
32>  
33> if exists (select * from MLD_InSitu, deleted
34>          where MLD_InSitu._Strain_key = deleted._Strain_key)
35> begin
36>         rollback transaction
37>         raiserror 99999 "Strain is referenced in InSitu Record(s)"
38> 	return
39> end
40>  
41> if exists (select * from CRS_Cross, deleted
42>          where CRS_Cross._femaleStrain_key = deleted._Strain_key)
43> begin
44>         rollback transaction
45>         raiserror 99999 "Strain is referenced in Cross Record(s)"
46> 	return
47> end
48>  
49> if exists (select * from CRS_Cross, deleted
50>          where CRS_Cross._maleStrain_key = deleted._Strain_key)
51> begin
52>         rollback transaction
53>         raiserror 99999 "Strain is referenced in Cross Record(s)"
54> 	return
55> end
56>  
57> if exists (select * from CRS_Cross, deleted
58>          where CRS_Cross._StrainHO_key = deleted._Strain_key)
59> begin
60>         rollback transaction
61>         raiserror 99999 "Strain is referenced in Cross Record(s)"
62> 	return
63> end
64>  
65> if exists (select * from CRS_Cross, deleted
66>          where CRS_Cross._StrainHT_key = deleted._Strain_key)
67> begin
68>         rollback transaction
69>         raiserror 99999 "Strain is referenced in Cross Record(s)"
70> 	return
71> end
72>  
73> if exists (select * from GXD_Genotype, deleted
74>          where GXD_Genotype._Strain_key = deleted._Strain_key)
75> begin
76>         rollback transaction
77>         raiserror 99999 "Strain is referenced in GXD Genotype Record(s)"
78> 	return
79> end
80>  
81> if exists (select * from ALL_Allele, deleted
82>          where ALL_Allele._Strain_key = deleted._Strain_key)
83> begin
84>         rollback transaction
85>         raiserror 99999 "Strain is referenced in Allele Record(s)"
86> 	return
87> end
88>  
89> delete PRB_Strain_Marker from PRB_Strain_Marker, deleted
90> where PRB_Strain_Marker._Strain_key = deleted._Strain_key
91> 
1> 
2> drop trigger PRB_Tissue_Delete
1> 
2> create trigger PRB_Tissue_Delete
3> on PRB_Tissue
4> for delete
5> as
6> 
7> /* Disallow deletion if Tissue is referenced elsewhere */
8> 
9> if exists (select * from PRB_Source, deleted
10>     where PRB_Source._Tissue_key = deleted._Tissue_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Tissue is referenced in Molecular Segment Library Record(s)"
14> 	return
15> end
16>  
1> 
2> drop trigger PRB_Vector_Types_Delete
1> 
2> create trigger PRB_Vector_Types_Delete
3> on PRB_Vector_Types
4> for delete
5> as
6> 
7> /* Disallow deletion if Vector_Types is referenced elsewhere */
8> 
9> if exists (select * from PRB_Probe, deleted
10>     where PRB_Probe._Vector_key = deleted._Vector_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Vector Type is referenced in Molecular Segment Record(s)"
14> 	return
15> end
16>  
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop trigger RI_RISet_Update
1> 
2> create trigger RI_RISet_Update
3> on RI_RISet
4> for update
5> as
6> 
7> /* Update origin, designation, abbreviation values in individual */
8> /* experiment records whenever the "master" RI record is changed. */
9> /* The fields in the MLD_RI table are actually obsolete and should */
10> /* be removed from this table. */
11> 
12> update MLD_RI
13> set origin = inserted.origin, 
14>     designation = inserted.designation,
15>     abbrev1 = inserted.abbrev1,
16>     abbrev2 = inserted.abbrev2
17> from MLD_RI, inserted
18> where MLD_RI._RISet_key = inserted._RISet_key
19> 
1> 
2> drop trigger RI_RISet_Delete
1> 
2> create trigger RI_RISet_Delete
3> on RI_RISet
4> for delete
5> as
6> 
7> /* Disallow deletion if RI Set is referenced elsewhere */
8> 
9> if exists (select * from MLD_RI, deleted
10>     where MLD_RI._RISet_key = deleted._RISet_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "RI is referenced in MLDP Record(s)"
14> 	return
15> end
16> 
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view ACC_View
1> 
2> create view ACC_View
3> as
4> select a.*, MGIType = m.name,
5> LogicalDB = l.name, l.description, l._Species_key,
6> ActualDB = d.name, d.url, d.allowsMultiple, d.delimiter
7> from ACC_Accession a, ACC_MGIType m, ACC_LogicalDB l, ACC_ActualDB d
8> where a._MGIType_key = m._MGIType_key
9> and a._LogicalDB_Key = l._LogicalDB_key
10> and l._LogicalDB_key = d._LogicalDB_key
11> and d.active = 1
1> 
2> grant select on ACC_View to public
1>  
2> drop view ACC_LogicalDB_View
1> 
2> create view ACC_LogicalDB_View
3> as
4> select a.*, species = s.name
5> from ACC_LogicalDB a, MRK_Species s
6> where a._Species_key *= s._Species_key
1> 
2> grant select on ACC_LogicalDB_View to public
1>  
2> drop view ACC_Reference_View
1> 
2> create view ACC_Reference_View
3> as
4> select a.*, b._Refs_key, b.jnum, b.jnumID, b.short_citation
5> from ACC_View a, ACC_AccessionReference r, BIB_All_View b
6> where a._Accession_key = r._Accession_key
7> and r._Refs_key = b._Refs_key
1> 
2> grant select on ACC_Reference_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view ALL_Acc_View
1> 
2> create view ALL_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 11
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on ALL_Acc_View to public
1>  
2> drop view ALL_Allele_View
1>  
2> create view ALL_Allele_View
3> as
4> select a.*, markerSymbol = m.symbol, s.strain, im.mode, t.alleleType
5> from ALL_Allele a, MRK_Marker m, PRB_Strain s, ALL_Inheritance_mode im, ALL_Type t
6> where a._Marker_key = m._Marker_key
7> and a._Strain_key = s._Strain_key
8> and a._Mode_key = im._Mode_key
9> and a._Allele_Type_key = t._Allele_Type_key
1> 
2> grant select on ALL_Allele_View to public
1>  
2> drop view ALL_Allele_Refs_View
1> 
2> create view ALL_Allele_Refs_View
3> as
4> select a.*, b.jnum, b.short_citation
5> from ALL_Allele_View a, BIB_All_View b
6> where a._Refs_key = b._Refs_key
1> 
2> grant select on ALL_Allele_Refs_View to public
1>  
2> drop view ALL_Allele_MolRefs_View
1> 
2> create view ALL_Allele_MolRefs_View
3> as
4> select a.*, b.jnum, b.short_citation
5> from ALL_Allele_View a, BIB_All_View b
6> where a._Molecular_Refs_key = b._Refs_key
1> 
2> grant select on ALL_Allele_MolRefs_View to public
1>  
2> drop view ALL_Allele_Mutation_View
1> 
2> create view ALL_Allele_Mutation_View
3> as
4> select am.*, m.mutation
5> from ALL_Allele_Mutation am, ALL_Molecular_Mutation m
6> where am._Mutation_key = m._Mutation_key
1> 
2> grant select on ALL_Allele_Mutation_View to public
1> 
2> drop view ALL_Synonym_View
1> 
2> create view ALL_Synonym_View
3> as
4> select s.*, b.jnum, b.short_citation, a._Marker_key, m.symbol
5> from ALL_Synonym s, BIB_All_View b, ALL_Allele a, MRK_Marker m
6> where s._Refs_key = b._Refs_key
7> and s._Allele_key = a._Allele_key
8> and a._Marker_key = m._Marker_key
1> 
2> grant select on ALL_Synonym_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view BIB_Acc_View
1> 
2> create view BIB_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 1
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on BIB_Acc_View to public
1>  
2> /* BIB_All_View contains all BIB_Refs records, their J#s */
3> /* a long citation and a short citation */
4> 
5> drop view BIB_All_View
1>  
2> create view BIB_All_View
3> as
4> select r.*, 
5> reviewStatus = s.name,
6> jnumID = a.accID, jnum = a.numericPart,
7> citation = r.journal + " " + r.date + ";" + r.vol + "(" + r.issue + "):" + r.pgs,
8> short_citation = r._primary + ", " + r.journal + " " + r.date + ";" + 
9> r.vol + "(" + r.issue + "):" + r.pgs
10> from BIB_Refs r, BIB_ReviewStatus s, ACC_Accession a
11> where r._ReviewStatus_key = s._ReviewStatus_key
12> and r._Refs_key = a._Object_key
13> and a._MGIType_key = 1
14> and a.prefixPart =  "J:"
15> and a.preferred = 1
1>  
2> grant select on BIB_All_View to public
1>  
2> /* BIB_View contains all non-Submission BIB_Refs records, */
3> /* their J#s, a long citation and a short citation */
4> /* Submission references are not currently accessible on the Web */
5> 
6> drop view BIB_View
1> 
2> create view BIB_View
3> as
4> select r.*,
5> reviewStatus = s.name,
6> jnumID = a.accID, jnum = a.numericPart,
7> citation = r.journal + " " + r.date + ";" + r.vol + "(" + r.issue + "):" + r.pgs,
8> short_citation = r._primary + ", " + r.journal + " " + r.date + ";" + 
9> r.vol + "(" + r.issue + "):" + r.pgs
10> from BIB_Refs r, BIB_ReviewStatus s, ACC_Accession a
11> where r._ReviewStatus_key = s._ReviewStatus_key
12> and r._Refs_key = a._Object_key
13> and a._MGIType_key = 1
14> and a.prefixPart =  "J:"
15> and a.preferred = 1
16> and (journal != 'Submission' or journal is null)
1> 
2> grant select on BIB_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view CRS_Cross_View
1> 
2> create view CRS_Cross_View
3> as
4> select c.*, display = whoseCross + " [Type " + type + " (" + abbrevHO + "/" + abbrevHT + ")]",
5> femaleStrain = s1.strain, maleStrain = s2.strain,
6> strainHO = s3.strain, strainHT = s4.strain
7> from CRS_Cross c, PRB_Strain s1, PRB_Strain s2, PRB_Strain s3, PRB_Strain s4
8> where c._femaleStrain_key = s1._Strain_key
9> and c._maleStrain_key = s2._Strain_key
10> and c._StrainHO_key = s3._Strain_key
11> and c._StrainHT_key = s4._Strain_key
1> 
2> grant select on CRS_Cross_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view GO_Marker_View
1> 
2> create view GO_Marker_View
3> as
4> select gm._Marker_key, m.symbol, gt._Ontology_key, go.ontologyName, gm._Term_key, gt.goTerm, 
5> gd._Evidence_key, ge.evidence, gd._Refs_key, jnumID = a.accID
6> from GO_MarkerGO gm, MRK_Marker m, GO_Ontology go, GO_Term gt, GO_DataEvidence gd, GO_Evidence ge, ACC_Accession a
7> where gm._Marker_key = m._Marker_key
8> and gm._Term_key = gt._Term_key
9> and gt._Ontology_key = go._Ontology_key
10> and gm._MarkerGO_key = gd._MarkerGO_key
11> and gd._Evidence_key = ge._Evidence_key
12> and gd._Refs_key = a._Object_key
13> and a._MGIType_key = 1
14> and a.prefixPart = "J:"
1> 
2> grant select on GO_Marker_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view GXD_Antigen_Acc_View
1>  
2> create view GXD_Antigen_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 7
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on GXD_Antigen_Acc_View to public
1> 
2> drop view GXD_Antibody_Acc_View
1>  
2> create view GXD_Antibody_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 6
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on GXD_Antibody_Acc_View to public
1> 
2> drop view GXD_Assay_Acc_View
1>  
2> create view GXD_Assay_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 8
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on GXD_Assay_Acc_View to public
1> 
2> drop view GXD_Antigen_View
1> 
2> create view GXD_Antigen_View
3> as
4> select g.*, mgiID = a.accID, a.prefixPart, a.numericPart,
5> s.species, s.age, s.sex, s.cellLine, library = s.name,
6> s.description, s._Refs_key, s._Strain_key, s.strain, s._Tissue_key, s.tissue
7> from GXD_Antigen g, GXD_Antigen_Acc_View a, PRB_Source_View s
8> where g._Antigen_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and a.preferred = 1
11> and g._Source_key = s._Source_key
1> 
2> grant select on GXD_Antigen_View to public
1>  
2> drop view GXD_Antibody_View
1>  
2> create view GXD_Antibody_View
3> as
4> select ab.*, mgiID = a.accID, a.prefixPart, a.numericPart, 
5> ac.class, ap.antibodyType, ae.antibodySpecies, ag.antigenName
6> from GXD_Antibody ab, GXD_Antibody_Acc_View a, GXD_AntibodyClass ac, GXD_AntibodyType ap,
7> GXD_AntibodySpecies ae, GXD_Antigen ag
8> where ab._Antibody_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and a.preferred = 1
11> and ab._AntibodyClass_key = ac._AntibodyClass_key
12> and ab._AntibodyType_key = ap._AntibodyType_key
13> and ab._AntibodySpecies_key = ae._AntibodySpecies_key
14> and ab._Antigen_key *= ag._Antigen_key
1>  
2> grant select on GXD_Antibody_View to public
1>  
2> drop view GXD_AntibodyRef_View
1>  
2> create view GXD_AntibodyRef_View
3> as
4> select a._Antibody_key, a._Refs_key, c.jnumID, c.jnum, c.short_citation
5> from GXD_Antibody a, BIB_All_View c
6> where a._Refs_key = c._Refs_key
1>  
2> grant select on GXD_AntibodyRef_View to public
1>  
2> drop view GXD_AntibodyAntigen_View
1>  
2> create view GXD_AntibodyAntigen_View
3> as
4> select ab._Antibody_key, ab.antibodyName, ag.*
5> from GXD_Antibody ab, GXD_Antigen_View ag
6> where ab._Antigen_key = ag._Antigen_key
1>  
2> grant select on GXD_AntibodyAntigen_View to public
1>  
2> drop view GXD_AntibodyMarker_View
1>  
2> create view GXD_AntibodyMarker_View
3> as
4> select a._Antibody_key, a.antibodyName, am._Marker_key, m.symbol, m.chromosome
5> from GXD_Antibody a, GXD_AntibodyMarker am, MRK_Marker m
6> where a._Antibody_key = am._Antibody_key
7> and am._Marker_key = m._Marker_key
1>  
2> grant select on GXD_AntibodyMarker_View to public
1>  
2> drop view GXD_AntibodyAlias_View
1>  
2> create view GXD_AntibodyAlias_View
3> as
4> select a.antibodyName, aa.*
5> from GXD_Antibody a, GXD_AntibodyAlias aa
6> where a._Antibody_key = aa._Antibody_key
1>  
2> grant select on GXD_AntibodyAlias_View to public
1>  
2> drop view GXD_AntibodyAliasRef_View
1>  
2> create view GXD_AntibodyAliasRef_View
3> as
4> select a.antibodyName, aa.*, c.jnumID, c.jnum, c.short_citation
5> from GXD_Antibody a, GXD_AntibodyAlias aa, BIB_All_View c
6> where a._Antibody_key = aa._Antibody_key
7> and aa._Refs_key = c._Refs_key
1>  
2> grant select on GXD_AntibodyAliasRef_View to public
1>  
2> drop view GXD_Assay_View
1> 
2> create view GXD_Assay_View
3> as
4> select g.*, mgiID = ac.accID, ac.prefixPart, ac.numericPart,
5> aty.assayType, aty.isRNAAssay, aty.isGelAssay,
6> m.symbol, m.chromosome, m.name,
7> c.jnumID, c.jnum, c.short_citation
8> from GXD_Assay g, GXD_Assay_Acc_View ac, GXD_AssayType aty, MRK_Marker m, BIB_All_View c
9> where g._Assay_key = ac._Object_key
10> and ac.prefixPart = "MGI:"
11> and ac.preferred = 1
12> and g._AssayType_key = aty._AssayType_key
13> and g._Marker_key = m._Marker_key
14> and g._Refs_key = c._Refs_key
1> 
2> grant select on GXD_Assay_View to public
1> 
2> drop view GXD_AntibodyPrep_View
1> 
2> create view GXD_AntibodyPrep_View
3> as
4> select a._Assay_key, ap.*, s.secondary, l.label, ab.antibodyName, ac.accID
5> from GXD_Assay a, GXD_AntibodyPrep ap, GXD_Secondary s, GXD_Label l,
6> GXD_Antibody ab, ACC_Accession ac
7> where a._AntibodyPrep_key = ap._AntibodyPrep_key
8> and ap._Secondary_key = s._Secondary_key
9> and ap._Label_key = l._Label_key
10> and ap._Antibody_key = ab._Antibody_key
11> and ab._Antibody_key = ac._Object_key
12> and ac._MGIType_key = 6
13> and ac.prefixPart = "MGI:"
14> and ac.preferred = 1
1> 
2> grant select on GXD_AntibodyPrep_View to public
1> 
2> drop view GXD_ProbePrep_View
1>  
2> create view GXD_ProbePrep_View
3> as
4> select a._Assay_key, pp.*, s.sense, l.label, c.coverage, v.visualization, probeName = p.name, ac.accID
5> from GXD_Assay a, GXD_ProbePrep pp, GXD_ProbeSense s, GXD_Label l, GXD_LabelCoverage c, GXD_VisualizationMethod v,
6> PRB_Probe p, ACC_Accession ac
7> where a._ProbePrep_key = pp._ProbePrep_key
8> and pp._Sense_key = s._Sense_key
9> and pp._Label_key = l._Label_key
10> and pp._Coverage_key = c._Coverage_key
11> and pp._Visualization_key = v._Visualization_key
12> and pp._Probe_key = p._Probe_key
13> and p._Probe_key = ac._Object_key
14> and ac._MGIType_key = 3
15> and ac.prefixPart = "MGI:"
16> and ac.preferred = 1
1>  
2> grant select on GXD_ProbePrep_View to public
1>  
2> drop view GXD_Genotype_View
1>  
2> create view GXD_Genotype_View
3> as
4> select g.*, s.strain
5> from GXD_Genotype g, PRB_Strain s
6> where g._Strain_key = s._Strain_key
1>  
2> grant select on GXD_Genotype_View to public
1>  
2> drop view GXD_AllelePair_View
1> 
2> create view GXD_AllelePair_View
3> as
4> select a.*, m.symbol, allele1 = a1.symbol, allele2 = a2.symbol
5> from GXD_AllelePair a, MRK_Marker m, ALL_Allele a1, ALL_Allele a2
6> where a._Marker_key = m._Marker_key
7> and a._Allele_key_1 = a1._Allele_key
8> and a._Allele_key_2 *= a2._Allele_key
1> 
2> grant select on GXD_AllelePair_View to public
1> 
2> drop view GXD_Specimen_View
1> 
2> create view GXD_Specimen_View
3> as
4> select s.*, e.embeddingMethod, f.fixation, g.strain
5> from GXD_Specimen s, GXD_EmbeddingMethod e, GXD_FixationMethod f, GXD_Genotype_View g
6> where s._Embedding_key = e._Embedding_key
7> and s._Fixation_key = f._Fixation_key
8> and s._Genotype_key = g._Genotype_key
1> 
2> grant select on GXD_Specimen_View to public
1> 
2> drop view GXD_InSituResult_View
1> 
2> create view GXD_InSituResult_View
3> as
4> select r.*, s.strength, p.pattern
5> from GXD_InSituResult r, GXD_Strength s, GXD_Pattern p
6> where r._Strength_key = s._Strength_key
7> and r._Pattern_key = p._Pattern_key
1> 
2> grant select on GXD_InSituResult_View to public
1> 
2> drop view GXD_ISResultImage_View
1> 
2> create view GXD_ISResultImage_View
3> as
4> /* figurepaneLabel is the concatenation of figureLabel and paneLabel for display purposes */
5> select r._Specimen_key, r.sequenceNum, i.*, figurepaneLabel = m.figureLabel + convert(varchar(10), p.paneLabel), 
6> p._Image_key, p.paneLabel, m.figureLabel, m.xDim, m.yDim
7> from GXD_InSituResult r, GXD_InSituResultImage i, IMG_ImagePane p, IMG_Image m
8> where r._Result_key = i._Result_key
9> and i._ImagePane_key = p._ImagePane_key
10> and p._Image_key = m._Image_key
1> 
2> grant select on GXD_ISResultImage_View to public
1> 
2> drop view GXD_GelLane_View
1> 
2> create view GXD_GelLane_View
3> as
4> /* sampleAmount_str is a string version of sampleAmount without trailing zeroes for display purposes */
5> select l.*, t.rnaType, g.strain, c.gelLaneContent,
6> sampleAmount_str = ltrim(str(l.sampleAmount,10,2))
7> from GXD_GelLane l, GXD_GelRNAType t, GXD_Genotype_View g, GXD_GelControl c
8> where l._GelRNAType_key = t._GelRNAType_key
9> and l._Genotype_key = g._Genotype_key
10> and l._GelControl_key = c._GelControl_key
1> 
2> grant select on GXD_GelLane_View to public
1> 
2> drop view GXD_GelRow_View
1> 
2> create view GXD_GelRow_View
3> as
4> /* size_str is a string version of size without trailing zeroes for display purposes */
5> select l.*, size_str = ltrim(str(l.size,10,2)), u.units
6> from GXD_GelRow l, GXD_GelUnits u
7> where l._GelUnits_key = u._GelUnits_key
1> 
2> grant select on GXD_GelRow_View to public
1> 
2> drop view GXD_GelBand_View
1> 
2> create view GXD_GelBand_View
3> as
4> select b.*, s.strength, l._Assay_key, laneNum = l.sequenceNum, rowNum = r.sequenceNum
5> from GXD_GelBand b, GXD_Strength s, GXD_GelLane l, GXD_GelRow r
6> where b._Strength_key = s._Strength_key
7> and b._GelLane_key = l._GelLane_key
8> and b._GelRow_key = r._GelRow_key
1> 
2> grant select on GXD_GelBand_View to public
1> 
2> drop view GXD_GelLaneStructure_View
1> 
2> create view GXD_GelLaneStructure_View
3> as
4> select l._Assay_key, l.sequenceNum, g.*, s.printName, t.stage, t._Stage_key,
5> dbName = "[DB]:  Stage" + convert(varchar(5), t.stage) + ";" + s.printName
6> from GXD_GelLane l, GXD_GelLaneStructure g, GXD_Structure s, GXD_TheilerStage t
7> where l._GelLane_key = g._GelLane_key
8> and g._Structure_key = s._Structure_key
9> and s._Stage_key = t._Stage_key
1> 
2> grant select on GXD_GelLaneStructure_View to public
1> 
2> drop view GXD_ISResultStructure_View
1> 
2> create view GXD_ISResultStructure_View
3> as
4> select r._Specimen_key, r.sequenceNum, g.*, s.printName, t.stage, t._Stage_key,
5> dbName = "[DB]:  Stage" + convert(varchar(5), t.stage) + ";" + s.printName
6> from GXD_InSituResult r, GXD_ISResultStructure g, GXD_Structure s, GXD_TheilerStage t
7> where r._Result_key = g._Result_key
8> and g._Structure_key = s._Structure_key
9> and s._Stage_key = t._Stage_key
1> 
2> grant select on GXD_ISResultStructure_View to public
1> 
2> drop view GXD_Index_View
1> 
2> create view GXD_Index_View
3> as
4> select i.*, m.symbol, c.jnumID, c.jnum, c.short_citation
5> from GXD_Index i, MRK_Marker m, BIB_All_View c
6> where i._Marker_key = m._Marker_key
7> and i._Refs_key = c._Refs_key
1> 
2> grant select on GXD_Index_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view HMD_Homology_View
1> 
2> create view HMD_Homology_View
3> as
4> select r._Class_key, r._Refs_key, r.creation_date, r.modification_date,
5> classRef = convert(varchar(10), r._Class_key) + ':' + convert(varchar(10), r._Refs_key),
6> h._Homology_key, h._Marker_key,
7> m.symbol, m.name, m.chromosome, m.cytogeneticOffset,
8> m._Species_key, m.species, m.commonName, m.latinName,
9> b.jnumID, b.jnum, b.short_citation
10> from HMD_Homology r, HMD_Homology_Marker h, 
11> MRK_Marker_View m, BIB_View b
12> where r._Homology_key = h._Homology_key
13> and h._Marker_key = m._Marker_key
14> and r._Refs_key = b._Refs_key
1> 
2> grant select on HMD_Homology_View to public
1> 
2> drop view HMD_Homology_Assay_View
1> 
2> create view HMD_Homology_Assay_View
3> as
4> select h.*, a.assay
5> from HMD_Homology_Assay h, HMD_Assay a
6> where h._Assay_key = a._Assay_key
1> 
2> grant select on HMD_Homology_Assay_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view IMG_Image_Acc_View
1>  
2> create view IMG_Image_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 9
7> and a._LogicalDB_key = l._LogicalDB_key
1>   
2> grant select on IMG_Image_Acc_View to public
1> 
2> drop view IMG_Image_View
1> 
2> create view IMG_Image_View
3> as
4> select i.*, mgiID = a.accID, a.prefixPart, a.numericPart,
5> c.jnumID, c.jnum, c.short_citation
6> from IMG_Image i, IMG_Image_Acc_View a, BIB_All_View c
7> where i._Image_key = a._Object_key
8> and a.prefixPart = "MGI:"
9> and a.preferred = 1
10> and i._Refs_key = c._Refs_key
1> 
2> grant select on IMG_Image_View to public
1> 
2> drop view IMG_ImagePane_View
1> 
2> create view IMG_ImagePane_View
3> as
4> select i.*, f.fieldType
5> from IMG_ImagePane i, IMG_FieldType f
6> where i._FieldType_key = f._FieldType_key
1> 
2> grant select on IMG_ImagePane_View to public
1> 
2> drop view IMG_ImagePaneRef_View
1> 
2> create view IMG_ImagePaneRef_View
3> as
4> select r._Image_key, r._Refs_key, i._ImagePane_key, paneLabel = r.figureLabel + i.paneLabel,
5> c.jnumID, c.jnum, c.short_citation
6> from IMG_Image r, IMG_ImagePane i, BIB_All_View c
7> where r._Image_key = i._Image_key
8> and r._Refs_key = c._Refs_key
1> 
2> grant select on IMG_ImagePaneRef_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view MGI_Table_Column_View
1> 
2> create view MGI_Table_Column_View
3> as 
4> select _Table_id = t._Table_id, table_name = o.name, table_description = t.description,
5> column_name = c.name, _Column_id = cc._Column_id, column_description = cc.description,
6> example = cc.example, t.creation_date, t.modification_date
7> from sysobjects o, MGI_Tables t, MGI_Columns cc, syscolumns c
8> where o.type = 'U'
9> and o.id = t._Table_id 
10> and t._Table_id = cc._Table_id
11> and cc._Column_id = c.colid
12> and c.id = o.id
1> 
2> grant select on MGI_Table_Column_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view MLC_Marker_edit_View
1>  
2> create view MLC_Marker_edit_View
3> as
4> select m.*, m1.symbol, tagSymbol = m2.symbol 
5> from MLC_Marker_edit m, MRK_Marker m1, MRK_Marker m2
6> where m._Marker_key = m1._Marker_key
7> and m._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLC_Marker_edit_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view MLD_Acc_View
1>  
2> create view MLD_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 4
7> and a._LogicalDB_key = l._LogicalDB_key
1>  
2> grant select on MLD_Acc_View to public
1>  
2> drop view MLD_Marker_View
1> 
2> create view MLD_Marker_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, g.*, m.symbol, c._primary, c.authors
5> from BIB_View c, MLD_Marker g, MRK_Marker m
6> where g._Refs_key = c._Refs_key
7> and g._Marker_key = m._Marker_key
1> 
2> grant select on MLD_Marker_View to public
1> 
2> drop view MLD_Expt_View
1> 
2> create view MLD_Expt_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, x.*, c._primary, c.authors, 
5> mgiID = a.accID, a.prefixPart, a.numericPart
6> from BIB_View c, MLD_Expts x, MLD_Acc_View a
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and a.preferred = 1
1> 
2> grant select on MLD_Expt_View to public
1> 
2> drop view MLD_Expt_Marker_View
1> 
2> create view MLD_Expt_Marker_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, m.symbol, x.exptType, x.tag, e.*, 
5> allele = al.symbol, assay = a.description, c._primary, c.authors
6> from BIB_View c, MLD_Expts x, MLD_Expt_Marker e, ALL_Allele al, MLD_Assay_Types a, MRK_Marker m
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key = m._Marker_key
10> and e._Allele_key *= al._Allele_key
11> and e._Assay_Type_key = a._Assay_Type_key
1> 
2> grant select on MLD_Expt_Marker_View to public
1> 
2> drop view MLD_FISH_View
1> 
2> create view MLD_FISH_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, s.strain, c._primary, c.authors
5> from BIB_View c, MLD_Expts x, MLD_FISH e, PRB_Strain s
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Strain_key = s._Strain_key
1> 
2> grant select on MLD_FISH_View to public
1> 
2> drop view MLD_Hybrid_View
1> 
2> create view MLD_Hybrid_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, c._primary, c.authors 
5> from BIB_View c, MLD_Expts x, MLD_Hybrid e
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
1> 
2> grant select on MLD_Hybrid_View to public
1> 
2> drop view MLD_Concordance_View
1> 
2> create view MLD_Concordance_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, m.symbol, c._primary, c.authors 
5> from BIB_View c, MLD_Expts x, MLD_Concordance e, MRK_Marker m
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Marker_key *= m._Marker_key
1> 
2> grant select on MLD_Concordance_View to public
1> 
2> drop view MLD_InSitu_View
1> 
2> create view MLD_InSitu_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, s.strain, c._primary, c.authors
5> from BIB_View c, MLD_Expts x, MLD_InSitu e, PRB_Strain s
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Strain_key = s._Strain_key
1> 
2> grant select on MLD_InSitu_View to public
1> 
2> drop view MLD_Matrix_View
1> 
2> create view MLD_Matrix_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, x.tag,
5> e._Expt_key, e.female, e.female2, e.male, e.male2,
6> s.*,
7> femaleStrain = s1.strain, maleStrain = s2.strain,
8> strainHO = s3.strain, strainHT = s4.strain,
9> c._primary, c.authors
10> from BIB_View c, MLD_Expts x, MLD_Matrix e, CRS_Cross s,
11> PRB_Strain s1, PRB_Strain s2, PRB_Strain s3, PRB_Strain s4
12> where c._Refs_key = x._Refs_key
13> and x._Expt_key = e._Expt_key
14> and e._Cross_key = s._Cross_key
15> and s._femaleStrain_key = s1._Strain_key
16> and s._maleStrain_key = s2._Strain_key
17> and s._StrainHO_key = s3._Strain_key
18> and s._StrainHT_key = s4._Strain_key
1> 
2> grant select on MLD_Matrix_View to public
1> 
2> drop view MLD_MC2point_View
1> 
2> create view MLD_MC2point_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, c._primary, c.authors 
6> from BIB_View c, MLD_Expts x, MLD_MC2point e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_MC2point_View to public
1> 
2> drop view MLD_Statistics_View
1> 
2> create view MLD_Statistics_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, x.exptType, x.tag, c._primary, c.authors
6> from BIB_View c, MLD_Expts x, MLD_Statistics e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_Statistics_View to public
1> 
2> drop view MLD_Distance_View
1> 
2> create view MLD_Distance_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, c._primary, c.authors
6> from BIB_View c, MLD_Expts x, MLD_Distance e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_Distance_View to public
1> 
2> drop view MLD_RI_View
1> 
2> create view MLD_RI_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, x.tag, e._Expt_key, e.RI_IdList, 
5> s._RISet_key, s.origin, s.designation, abbrev1 = rtrim(s.abbrev1), abbrev2 = rtrim(s.abbrev2), 
6> c._primary, c.authors 
7> from BIB_View c, MLD_Expts x, MLD_RI e, RI_RISet s
8> where c._Refs_key = x._Refs_key
9> and x._Expt_key = e._Expt_key
10> and e._RISet_key *= s._RISet_key
1> 
2> grant select on MLD_RI_View to public
1> 
2> drop view MLD_RIData_View
1> 
2> create view MLD_RIData_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, m.symbol, c._primary, c.authors 
5> from BIB_View c, MLD_Expts x, MLD_RIData e, MRK_Marker m
6> where c._Refs_key = x._Refs_key
7> and x._Expt_key = e._Expt_key
8> and e._Marker_key = m._Marker_key
1> 
2> grant select on MLD_RIData_View to public
1> 
2> drop view MLD_RI2Point_View
1> 
2> create view MLD_RI2Point_View
3> as
4> select c.jnumID, c.jnum, c.short_citation, e.*, 
5> symbol1 = m1.symbol, symbol2 = m2.symbol, c._primary, c.authors 
6> from BIB_View c, MLD_Expts x, MLD_RI2Point e, MRK_Marker m1, MRK_Marker m2
7> where c._Refs_key = x._Refs_key
8> and x._Expt_key = e._Expt_key
9> and e._Marker_key_1 = m1._Marker_key
10> and e._Marker_key_2 = m2._Marker_key
1> 
2> grant select on MLD_RI2Point_View to public
1> 
2> drop view MLD_Hit_View
1>  
2> create view MLD_Hit_View
3> as
4> select x.*, probeKey = h._Probe_key, probe = p1.name, 
5> targetKey = h._Target_key, target = p2.name
6> from MLD_Expts x, MLD_Hit h, PRB_Probe p1, PRB_Probe p2
7> where x._Expt_key = h._Expt_key
8> and h._Probe_key = p1._Probe_key
9> and h._Target_key = p2._Probe_key
1>  
2> grant select on MLD_Hit_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view MRK_Acc_View
1> 
2> create view MRK_Acc_View
3> as
4> select a.*, LogicalDB = l.name, m._Species_key
5> from ACC_Accession a, ACC_LogicalDB l, MRK_Marker m
6> where a._MGIType_key = 2
7> and a._LogicalDB_key = l._LogicalDB_key
8> and a._Object_key = m._Marker_key
1> 
2> grant select on MRK_Acc_View to public
1>  
2> drop view MRK_Marker_View
1>  
2> create view MRK_Marker_View
3> as
4> select m.*, 
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> status = ms.status,
8> markerType = mt.name
9> from MRK_Marker m, MRK_Species s, MRK_Status ms, MRK_Types mt
10> where m._Species_key = s._Species_key
11> and m._Marker_Status_key = ms._Marker_Status_key
12> and m._Marker_Type_key = mt._Marker_Type_key
1> 
2> grant select on MRK_Marker_View to public
1>  
2> drop view MRK_Mouse_View
1>  
2> create view MRK_Mouse_View
3> as
4> select m.*, o.offset, offset_str = str(o.offset,10,2),
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> status = ms.status,
8> mgiID = a.accID, a.prefixPart, a.numericPart, a._Accession_key,
9> markerType = t.name
10> from MRK_Marker m, MRK_Offset o, MRK_Species s, MRK_Status ms, MRK_Acc_View a, MRK_Types t
11> where m._Species_key = 1
12> and m._Marker_key = o._Marker_key
13> and o.source = 0
14> and m._Species_key = s._Species_key
15> and m._Marker_Status_key = ms._Marker_Status_key
16> and m._Marker_key = a._Object_key
17> and a.prefixPart = "MGI:"
18> and a.preferred = 1
19> and m._Marker_Type_key = t._Marker_Type_key
1> 
2> grant select on MRK_Mouse_View to public
1>  
2> drop view MRK_NonMouse_View
1> 
2> create view MRK_NonMouse_View
3> as
4> select m.*,
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> a.accID, a._Accession_key
8> from MRK_Marker m, MRK_Species s, MRK_Acc_View a
9> where m._Species_key != 1
10> and m._Species_key = s._Species_key
11> and m._Marker_key = a._Object_key
12> and a._LogicalDB_key != 9
13> and a.private = 0
1> 
2> grant select on MRK_NonMouse_View to public
1> 
2> drop view MRK_Alias_View
1> 
2> create view MRK_Alias_View
3> as
4> select a.*, alias = m1.symbol, m2.symbol
5> from MRK_Alias a, MRK_Marker m1, MRK_Marker m2
6> where a._Marker_key = m2._Marker_key
7> and a._Alias_key = m1._Marker_key
1> 
2> grant select on MRK_Alias_View to public
1> 
2> drop view MRK_Classes_View
1> 
2> create view MRK_Classes_View
3> as
4> select c.*, m.symbol, l.name
5> from MRK_Classes c, MRK_Marker m, MRK_Class l
6> where c._Marker_key = m._Marker_key
7> and c._Class_key = l._Class_key
1> 
2> grant select on MRK_Classes_View to public
1> 
2> drop view MRK_History_View
1> 
2> create view MRK_History_View
3> as
4> select h.*, event_display = convert(char(10), h.event_date, 101), e.event, er.eventReason, history = m1.symbol, historyName = m1.name, m2.symbol, markerName = m2.name
5> from MRK_History h, MRK_Event e, MRK_EventReason er, MRK_Marker m1, MRK_Marker m2
6> where h._Marker_Event_key = e._Marker_Event_key
7> and h._Marker_EventReason_key = er._Marker_EventReason_key
8> and h._Marker_key = m2._Marker_key
9> and h._History_key = m1._Marker_key
1> 
2> grant select on MRK_History_View to public
1> 
2> drop view MRK_History_Ref_View
1>  
2> create view MRK_History_Ref_View
3> as
4> select h.*, event_display = convert(char(10), h.event_date, 101), e.event, er.eventReason,
5> history = m1.symbol, historyName = m1.name, m2.symbol,
6> b.jnumID, b.jnum, b.short_citation
7> from MRK_History h, MRK_Event e, MRK_EventReason er, MRK_Marker m1, MRK_Marker m2, BIB_View b
8> where h._Marker_Event_key = e._Marker_Event_key
9> and h._Marker_EventReason_key = er._Marker_EventReason_key
10> and h._Marker_key = m2._Marker_key
11> and h._History_key = m1._Marker_key
12> and h._Refs_key = b._Refs_key
1>  
2> grant select on MRK_History_Ref_View to public
1>  
2> drop view MRK_Current_View
1> 
2> create view MRK_Current_View
3> as
4> select c.*, current_symbol = m1.symbol, m2.symbol, m1.chromosome, m1._Marker_Type_key
5> from MRK_Current c, MRK_Marker m1, MRK_Marker m2
6> where c._Marker_key = m2._Marker_key
7> and c._Current_key = m1._Marker_key
1> 
2> grant select on MRK_Current_View to public
1> 
2> drop view MRK_Anchors_View
1> 
2> create view MRK_Anchors_View
3> as
4> select a.*, m.symbol
5> from MRK_Anchors a, MRK_Marker m
6> where a._Marker_key = m._Marker_key
1> 
2> grant select on MRK_Anchors_View to public
1> 
2> drop view MRK_Reference_View
1> 
2> create view MRK_Reference_View
3> as
4> select r.*, m.symbol, b.jnumID, b.jnum, b.short_citation, b.isReviewArticle
5> from MRK_Reference r, MRK_Marker m, BIB_View b
6> where r._Marker_key = m._Marker_key
7> and r._Refs_key = b._Refs_key
1> 
2> grant select on MRK_Reference_View to public
1> 
2> drop view MRK_AccRef_View
1>  
2> create view MRK_AccRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, ar._Refs_key, b.jnum, b.short_citation
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, BIB_All_View b
6> where a._MGIType_key = 2
7> and a._Accession_key = ar._Accession_key
8> and a._LogicalDB_key = l._LogicalDB_key
9> and a._MGIType_key = m._MGIType_key
10> and ar._Refs_key = b._Refs_key
1>  
2> grant select on MRK_AccRef_View to public
1> 
2> drop view MRK_AccNoRef_View
1>  
2> create view MRK_AccNoRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name,
5> subType = mt.name,
6> description = ma.symbol + ", " + ma.name + ", Chr " + ma.chromosome
7> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, MRK_Marker ma, MRK_Types mt
8> where a._MGIType_key = 2
9> and a._LogicalDB_key = l._LogicalDB_key
10> and a._MGIType_key = m._MGIType_key
11> and a._Object_key = ma._Marker_key
12> and ma._Marker_Type_key = mt._Marker_Type_key
13> and not exists (select r.* from ACC_AccessionReference r
14> where a._Accession_key = r._Accession_key)
1>  
2> grant select on MRK_AccNoRef_View to public
1>  
2> drop view MRK_Other_View
1>  
2> create view MRK_Other_View
3> as
4> select o.*, b.jnumID, b.jnum, b.short_citation, b.isReviewArticle
5> from MRK_Other o, BIB_View b
6> where o._Refs_key = b._Refs_key
1>  
2> grant select on MRK_Other_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view PRB_Acc_View
1> 
2> create view PRB_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 3
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on PRB_Acc_View to public
1> 
2> drop view PRB_AccNoRef_View
1> 
2> create view PRB_AccNoRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, description = p.name
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, PRB_Probe p
6> where a._MGIType_key = 3
7> and a._LogicalDB_key = l._LogicalDB_key
8> and a._MGIType_key = m._MGIType_key
9> and a._Object_key = p._Probe_key
10> and not exists (select r.* from ACC_AccessionReference r
11> where a._Accession_key = r._Accession_key)
1> 
2> grant select on PRB_AccNoRef_View to public
1> 
2> drop view PRB_AccRef_View
1> 
2> create view PRB_AccRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, r._Reference_key
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, PRB_Reference r
6> where a._Accession_key = ar._Accession_key
7> and a._LogicalDB_key = l._LogicalDB_key
8> and a._MGIType_key = m._MGIType_key
9> and a._Object_key = r._Probe_key
10> and ar._Refs_key = r._Refs_key
1> 
2> grant select on PRB_AccRef_View to public
1> 
2> drop view PRB_AccRefNoSeq_View
1> 
2> create view PRB_AccRefNoSeq_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, r._Reference_key
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, PRB_Reference r
6> where a._Accession_key = ar._Accession_key
7> and a._LogicalDB_Key != 9
8> and a._LogicalDB_key = l._LogicalDB_key
9> and a._MGIType_key = m._MGIType_key
10> and a._Object_key = r._Probe_key
11> and ar._Refs_key = r._Refs_key
1> 
2> grant select on PRB_AccRefNoSeq_View to public
1> 
2> drop view PRB_Strain_Acc_View
1> 
2> create view PRB_Strain_Acc_View
3> as
4> select a.*, LogicalDB = l.name
5> from ACC_Accession a, ACC_LogicalDB l
6> where a._MGIType_key = 10
7> and a._LogicalDB_key = l._LogicalDB_key
1> 
2> grant select on PRB_Strain_Acc_View to public
1>  
2> drop view PRB_Source_View
1>  
2> create view PRB_Source_View
3> as
4> select p.*, s.strain, sStandard = s.standard, t.tissue, tStandard = t.standard
5> from PRB_Source p, PRB_Strain s, PRB_Tissue t
6> where p._Strain_key = s._Strain_key 
7> and p._Tissue_key = t._Tissue_key 
1> 
2> grant select on PRB_Source_View to public
1>  
2> drop view PRB_View
1> 
2> create view PRB_View
3> as
4> select p.*, v.vectorType, mgiID = a.accID, a.prefixPart, a.numericPart,
5> s.species, s.age, s.sex, s.cellLine, library = s.name,
6> s.description, s._Refs_key, s._Strain_key, s.strain, s._Tissue_key, s.tissue
7> from PRB_Probe p, PRB_Acc_View a, PRB_Source_View s, PRB_Vector_Types v
8> where p._Probe_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and a.preferred = 1
11> and p._Vector_key = v._Vector_key
12> and p._Source_key = s._Source_key
1> 
2> grant select on PRB_View to public
1> 
2> drop view PRB_Primer_View
1>  
2> create view PRB_Primer_View
3> as
4> select p._Probe_key, p.name,
5> p.regionCovered,
6> p.regionCovered2,
7> p.DNAtype, p.primer1sequence, p.primer2sequence,
8> p.repeatUnit, p.productSize, p.moreProduct,
9> p.creation_date, p.modification_date,
10> mgiID = a.accID, a.prefixPart, a.numericPart
11> from PRB_Probe p, PRB_Acc_View a
12> where p.DNAtype = "primer"
13> and p._Probe_key = a._Object_key
14> and a.prefixPart = "MGI:"
1>   
2> grant select on PRB_Primer_View to public
1>     
2> drop view PRB_Probe_View
1>  
2> create view PRB_Probe_View
3> as
4> select p._Probe_key, p.name,
5> p.regionCovered,
6> p.regionCovered2,
7> p.insertSize, p.DNAtype,
8> p.derivedFrom, parentClone = p2.name,
9> p._Vector_key, v.vectorType, p.insertSite,
10> p.creation_date, p.modification_date,
11> s._Source_key, sourceName = s.name, s._Refs_key,
12> s.species, s.age, s.sex, s.cellLine, s._Strain_key, s.strain, s._Tissue_key, s.tissue,
13> mgiID = a.accID, a.prefixPart, a.numericPart
14> from PRB_Probe p, PRB_Acc_View a, PRB_Source_View s, PRB_Vector_Types v, PRB_Probe p2
15> where p.DNAtype != "primer"
16> and p._Probe_key = a._Object_key
17> and a.prefixPart = "MGI:"
18> and p._Source_key = s._Source_key
19> and p._Vector_key = v._Vector_key
20> and p.derivedFrom *= p2._Probe_key
1> 
2> grant select on PRB_Probe_View to public
1>  
2> drop view PRB_Parent_View
1> 
2> create view PRB_Parent_View
3> as
4> select p._Probe_key, p.name, a.accID, accPrefix = a.prefixPart, accNumeric = a.numericPart,
5> parentKey = p2._Probe_key, parentClone = p2.name,
6> parentID = a2.accID, parentPrefix = a2.prefixPart, parentNumeric = a2.numericPart
7> from PRB_Probe p, PRB_Acc_View a, PRB_Probe p2, PRB_Acc_View a2
8> where p._Probe_key = a._Object_key
9> and a.prefixPart = "MGI:"
10> and p.derivedFrom = p2._Probe_key
11> and p2._Probe_key = a2._Object_key
12> and a2.prefixPart = "MGI:"
1> 
2> grant select on PRB_Parent_View to public
1> 
2> drop view PRB_Marker_View
1> 
2> create view PRB_Marker_View
3> as
4> select g._Probe_key, p.name, g._Marker_key, m.symbol, m.chromosome, g.relationship
5> from PRB_Probe p, PRB_Marker g, MRK_Marker m
6> where p._Probe_key = g._Probe_key
7> and g._Marker_key = m._Marker_key
1> 
2> grant select on PRB_Marker_View to public
1> 
2> drop view PRB_Reference_View
1> 
2> create view PRB_Reference_View
3> as
4> select c.jnum, c.jnumID, c.short_citation, r.*
5> from PRB_Reference r, BIB_All_View c
6> where r._Refs_key = c._Refs_key
1> 
2> grant select on PRB_Reference_View to public
1> 
2> drop view PRB_RFLV_View
1> 
2> create view PRB_RFLV_View
3> as
4> select r.*, a._Allele_key, a.allele, a.fragments, s.strain, m.symbol, s._Strain_key, m.chromosome, m._Species_key
5> from PRB_RFLV r, PRB_Allele a, PRB_Allele_Strain p, PRB_Strain s, MRK_Marker m
6> where r._RFLV_key = a._RFLV_key
7> and a._Allele_key = p._Allele_key
8> and p._Strain_key = s._Strain_key
9> and r._Marker_key = m._Marker_key
1> 
2> grant select on PRB_RFLV_View to public
1> 
2> drop view PRB_SourceRef_View
1>  
2> create view PRB_SourceRef_View
3> as
4> select p.*, c.jnumID, c.jnum, c.short_citation
5> from PRB_Source_View p, BIB_All_View c
6> where p._Refs_key = c._Refs_key
1> 
2> grant select on PRB_SourceRef_View to public
1> 
2> drop view PRB_Strain_Marker_View
1> 
2> create view PRB_Strain_Marker_View
3> as
4> select s.*, m.symbol
5> from PRB_Strain_Marker s, MRK_Marker m
6> where s._Marker_key = m._Marker_key
1> 
2> grant select on PRB_Strain_Marker_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view BIB_Summary_All_View
1> 
2> create view BIB_Summary_All_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
8> from ACC_Accession a, ACC_Accession a2, BIB_Refs b
9> where a._MGIType_key = 1
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 1
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = b._Refs_key
1> 
2> grant select on BIB_Summary_All_View to public
1>  
2> drop view BIB_Summary_View
1> 
2> create view BIB_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
8> from ACC_Accession a, ACC_Accession a2, BIB_Refs b
9> where a._MGIType_key = 1
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 1
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = b._Refs_key
17> and (b.journal != 'Submission' or b.journal is null)
1> 
2> grant select on BIB_Summary_View to public
1>  
2> drop view MRK_Summary_View
1>  
2> create view MRK_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = mt.name,
7> description = m.symbol + ", " + m.name + ", Chr " + m.chromosome
8> from ACC_Accession a, ACC_Accession a2, MRK_Marker m, MRK_Types mt
9> where a._MGIType_key = 2
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 2
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = m._Marker_key
17> and m._Species_key = 1
18> and m._Marker_Type_key = mt._Marker_Type_key
1>  
2> grant select on MRK_Summary_View to public
1>  
2> drop view HMD_Summary_View
1>  
2> create view HMD_Summary_View
3> as
4> select a.*,
5> mgiID = null,
6> subType = mt.name,
7> description = m.symbol + ", " + m.name + ", Chr " + m.chromosome
8> from ACC_Accession a, MRK_Marker m, MRK_Types mt
9> where a._MGIType_key = 2
10> and a.private = 0
11> and a._Object_key = m._Marker_key
12> and m._Species_key != 1
13> and m._Marker_Type_key = mt._Marker_Type_key
1>  
2> grant select on HMD_Summary_View to public
1> 
2> drop view PRB_Summary_View
1>  
2> create view PRB_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = p.DNAtype,
7> description = p.name
8> from ACC_Accession a, ACC_Accession a2, PRB_Probe p
9> where a._MGIType_key = 3
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 3
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = p._Probe_key
1>  
2> grant select on PRB_Summary_View to public
1>  
2> drop view MLD_Summary_View
1>  
2> create view MLD_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = e.exptType,
7> description = b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
8> from ACC_Accession a, ACC_Accession a2, MLD_Expts e, BIB_Refs b
9> where a._MGIType_key = 4
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 4
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = e._Expt_key
17> and e._Refs_key = b._Refs_key
1>  
2> grant select on MLD_Summary_View to public
1>  
2> drop view GXD_Antibody_Summary_View
1>  
2> create view GXD_Antibody_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = t.antibodyType,
7> description = g.antibodyName
8> from ACC_Accession a, ACC_Accession a2, GXD_Antibody g, GXD_AntibodyType t
9> where a._MGIType_key = 6
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 6
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = g._Antibody_key
17> and g._AntibodyType_key = t._AntibodyType_key
1>  
2> grant select on GXD_Antibody_Summary_View to public
1>  
2> drop view GXD_Antigen_Summary_View
1>  
2> create view GXD_Antigen_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = g.antigenName
8> from ACC_Accession a, ACC_Accession a2, GXD_Antigen g
9> where a._MGIType_key = 7
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 7
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = g._Antigen_key
1>  
2> grant select on GXD_Antigen_Summary_View to public
1> 
2> drop view GXD_Assay_Summary_View
1>  
2> create view GXD_Assay_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = t.assayType,
7> description = m.symbol
8> from ACC_Accession a, ACC_Accession a2, GXD_Assay g, GXD_AssayType t, MRK_Marker m
9> where a._MGIType_key = 8
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 8
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = g._Assay_key
17> and g._AssayType_key = t._AssayType_key
18> and g._Marker_key = m._Marker_key
1>   
2> grant select on GXD_Assay_Summary_View to public
1> 
2> drop view IMG_Image_Summary_View
1>  
2> create view IMG_Image_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = null,
7> description = g.figureLabel + " " + 
8> b._primary + ", " + b.journal + " " + b.date + ";" + b.vol + "(" + b.issue + "):" + b.pgs
9> from ACC_Accession a, ACC_Accession a2, IMG_Image g, BIB_Refs b
10> where a._MGIType_key = 9
11> and a.private = 0
12> and a._Object_key = a2._Object_key
13> and a2._LogicalDB_key = 1
14> and a2._MGIType_key = 9
15> and a2.prefixPart = "MGI:"
16> and a2.preferred = 1
17> and a._Object_key = g._Image_key
18> and g._Refs_key = b._Refs_key
1>  
2> grant select on IMG_Image_Summary_View to public
1> 
2> drop view ALL_Summary_View
1>  
2> create view ALL_Summary_View
3> as
4> select a.*,
5> mgiID = a2.accID,
6> subType = t.alleleType,
7> description = al.symbol + ", " + al.name
8> from ACC_Accession a, ACC_Accession a2, ALL_Allele al, ALL_Type t
9> where a._MGIType_key = 11
10> and a.private = 0
11> and a._Object_key = a2._Object_key
12> and a2._LogicalDB_key = 1
13> and a2._MGIType_key = 11
14> and a2.prefixPart = "MGI:"
15> and a2.preferred = 1
16> and a._Object_key = al._Allele_key
17> and al._Allele_Type_key = t._Allele_Type_key
1>  
2> grant select on ALL_Summary_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view MRK_Acc_View
1> 
2> create view MRK_Acc_View
3> as
4> select a.*, LogicalDB = l.name, m._Species_key
5> from ACC_Accession a, ACC_LogicalDB l, MRK_Marker m
6> where a._MGIType_key = 2
7> and a._LogicalDB_key = l._LogicalDB_key
8> and a._Object_key = m._Marker_key
1> 
2> grant select on MRK_Acc_View to public
1>  
2> drop view MRK_Marker_View
1>  
2> create view MRK_Marker_View
3> as
4> select m.*, 
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> status = ms.status,
8> markerType = mt.name
9> from MRK_Marker m, MRK_Species s, MRK_Status ms, MRK_Types mt
10> where m._Species_key = s._Species_key
11> and m._Marker_Status_key = ms._Marker_Status_key
12> and m._Marker_Type_key = mt._Marker_Type_key
1> 
2> grant select on MRK_Marker_View to public
1>  
2> drop view MRK_Mouse_View
1>  
2> create view MRK_Mouse_View
3> as
4> select m.*, o.offset, offset_str = str(o.offset,10,2),
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> status = ms.status,
8> mgiID = a.accID, a.prefixPart, a.numericPart, a._Accession_key,
9> markerType = t.name
10> from MRK_Marker m, MRK_Offset o, MRK_Species s, MRK_Status ms, MRK_Acc_View a, MRK_Types t
11> where m._Species_key = 1
12> and m._Marker_key = o._Marker_key
13> and o.source = 0
14> and m._Species_key = s._Species_key
15> and m._Marker_Status_key = ms._Marker_Status_key
16> and m._Marker_key = a._Object_key
17> and a.prefixPart = "MGI:"
18> and a.preferred = 1
19> and m._Marker_Type_key = t._Marker_Type_key
1> 
2> grant select on MRK_Mouse_View to public
1>  
2> drop view MRK_NonMouse_View
1> 
2> create view MRK_NonMouse_View
3> as
4> select m.*,
5> species = s.name + " (" + s.species + ")", 
6> commonName = s.name, latinName = s.species,
7> a.accID, a._Accession_key
8> from MRK_Marker m, MRK_Species s, MRK_Acc_View a
9> where m._Species_key != 1
10> and m._Species_key = s._Species_key
11> and m._Marker_key = a._Object_key
12> and a._LogicalDB_key != 9
13> and a.private = 0
1> 
2> grant select on MRK_NonMouse_View to public
1> 
2> drop view MRK_Alias_View
1> 
2> create view MRK_Alias_View
3> as
4> select a.*, alias = m1.symbol, m2.symbol
5> from MRK_Alias a, MRK_Marker m1, MRK_Marker m2
6> where a._Marker_key = m2._Marker_key
7> and a._Alias_key = m1._Marker_key
1> 
2> grant select on MRK_Alias_View to public
1> 
2> drop view MRK_Classes_View
1> 
2> create view MRK_Classes_View
3> as
4> select c.*, m.symbol, l.name
5> from MRK_Classes c, MRK_Marker m, MRK_Class l
6> where c._Marker_key = m._Marker_key
7> and c._Class_key = l._Class_key
1> 
2> grant select on MRK_Classes_View to public
1> 
2> drop view MRK_History_View
1> 
2> create view MRK_History_View
3> as
4> select h.*, event_display = convert(char(10), h.event_date, 101), e.event, er.eventReason, history = m1.symbol, historyName = m1.name, m2.symbol, markerName = m2.name
5> from MRK_History h, MRK_Event e, MRK_EventReason er, MRK_Marker m1, MRK_Marker m2
6> where h._Marker_Event_key = e._Marker_Event_key
7> and h._Marker_EventReason_key = er._Marker_EventReason_key
8> and h._Marker_key = m2._Marker_key
9> and h._History_key = m1._Marker_key
1> 
2> grant select on MRK_History_View to public
1> 
2> drop view MRK_History_Ref_View
1>  
2> create view MRK_History_Ref_View
3> as
4> select h.*, event_display = convert(char(10), h.event_date, 101), e.event, er.eventReason,
5> history = m1.symbol, historyName = m1.name, m2.symbol,
6> b.jnumID, b.jnum, b.short_citation
7> from MRK_History h, MRK_Event e, MRK_EventReason er, MRK_Marker m1, MRK_Marker m2, BIB_View b
8> where h._Marker_Event_key = e._Marker_Event_key
9> and h._Marker_EventReason_key = er._Marker_EventReason_key
10> and h._Marker_key = m2._Marker_key
11> and h._History_key = m1._Marker_key
12> and h._Refs_key = b._Refs_key
1>  
2> grant select on MRK_History_Ref_View to public
1>  
2> drop view MRK_Current_View
1> 
2> create view MRK_Current_View
3> as
4> select c.*, current_symbol = m1.symbol, m2.symbol, m1.chromosome, m1._Marker_Type_key
5> from MRK_Current c, MRK_Marker m1, MRK_Marker m2
6> where c._Marker_key = m2._Marker_key
7> and c._Current_key = m1._Marker_key
1> 
2> grant select on MRK_Current_View to public
1> 
2> drop view MRK_Anchors_View
1> 
2> create view MRK_Anchors_View
3> as
4> select a.*, m.symbol
5> from MRK_Anchors a, MRK_Marker m
6> where a._Marker_key = m._Marker_key
1> 
2> grant select on MRK_Anchors_View to public
1> 
2> drop view MRK_Reference_View
1> 
2> create view MRK_Reference_View
3> as
4> select r.*, m.symbol, b.jnumID, b.jnum, b.short_citation, b.isReviewArticle
5> from MRK_Reference r, MRK_Marker m, BIB_View b
6> where r._Marker_key = m._Marker_key
7> and r._Refs_key = b._Refs_key
1> 
2> grant select on MRK_Reference_View to public
1> 
2> drop view MRK_AccRef_View
1>  
2> create view MRK_AccRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, ar._Refs_key, b.jnum, b.short_citation
5> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, BIB_All_View b
6> where a._MGIType_key = 2
7> and a._Accession_key = ar._Accession_key
8> and a._LogicalDB_key = l._LogicalDB_key
9> and a._MGIType_key = m._MGIType_key
10> and ar._Refs_key = b._Refs_key
1>  
2> grant select on MRK_AccRef_View to public
1> 
2> drop view MRK_AccNoRef_View
1>  
2> create view MRK_AccNoRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name,
5> subType = mt.name,
6> description = ma.symbol + ", " + ma.name + ", Chr " + ma.chromosome
7> from ACC_Accession a, ACC_LogicalDB l, ACC_MGIType m, MRK_Marker ma, MRK_Types mt
8> where a._MGIType_key = 2
9> and a._LogicalDB_key = l._LogicalDB_key
10> and a._MGIType_key = m._MGIType_key
11> and a._Object_key = ma._Marker_key
12> and ma._Marker_Type_key = mt._Marker_Type_key
13> and not exists (select r.* from ACC_AccessionReference r
14> where a._Accession_key = r._Accession_key)
1>  
2> grant select on MRK_AccNoRef_View to public
1>  
2> drop view MRK_Other_View
1>  
2> create view MRK_Other_View
3> as
4> select o.*, b.jnumID, b.jnum, b.short_citation, b.isReviewArticle
5> from MRK_Other o, BIB_View b
6> where o._Refs_key = b._Refs_key
1>  
2> grant select on MRK_Other_View to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop view HMD_Homology_View
1> 
2> create view HMD_Homology_View
3> as
4> select r._Class_key, r._Refs_key, r.creation_date, r.modification_date,
5> classRef = convert(varchar(10), r._Class_key) + ':' + convert(varchar(10), r._Refs_key),
6> h._Homology_key, h._Marker_key,
7> m.symbol, m.name, m.chromosome, m.cytogeneticOffset,
8> m._Species_key, m.species, m.commonName, m.latinName,
9> b.jnumID, b.jnum, b.short_citation
10> from HMD_Homology r, HMD_Homology_Marker h, 
11> MRK_Marker_View m, BIB_View b
12> where r._Homology_key = h._Homology_key
13> and h._Marker_key = m._Marker_key
14> and r._Refs_key = b._Refs_key
1> 
2> grant select on HMD_Homology_View to public
1> 
2> drop view HMD_Homology_Assay_View
1> 
2> create view HMD_Homology_Assay_View
3> as
4> select h.*, a.assay
5> from HMD_Homology_Assay h, HMD_Assay a
6> where h._Assay_key = a._Assay_key
1> 
2> grant select on HMD_Homology_Assay_View to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop procedure ACC_resetMax
1> 
2> create procedure ACC_resetMax
3>   @objectKey int,
4>   @mgiType varchar(80),
5>   @prefixPart varchar(20) = "MGI:"
6> as
7> 
8> /* If deleting object which is using the maxNumericPart 
9>    from ACC_AccessionMax, then reset the maxNumericPart
10>    so there aren't so many holes.  During withdrawals,
11>    new Marker symbols may not receive MGI accession numbers,
12>    but the MRK_Marker insert trigger will always insert one
13> */
14> 
15> declare @numericPart int
16> select @numericPart = a.numericPart 
17> from ACC_Accession a, ACC_MGIType m
18> where a._Object_key = @objectKey
19> and a.prefixPart = @prefixPart
20> and a._MGIType_key = m._MGIType_key
21> and m.name = @mgiType
22> 
23> if (select maxNumericPart from ACC_AccessionMax where prefixPart = @prefixPart) = @numericPart
24> begin
25> 	update ACC_AccessionMax
26> 	set maxNumericPart = maxNumericPart - 1
27> 	where prefixPart = @prefixPart
28> end
29> 
1> 
2> grant execute on ACC_resetMax to progs
1> 
2> grant execute on ACC_resetMax to editors
1> 
2> drop procedure ACC_findMax
1> 
2> create procedure ACC_findMax
3>   @prefixPart varchar(20) = "MGI:"
4> as
5> 
6> /* Return maxNumericPart for given prefixPart */
7> 
8> select maxNumericPart
9> from ACC_AccessionMax
10> where prefixPart = @prefixPart
1> 
2> grant execute on ACC_findMax to progs
1> 
2> grant execute on ACC_findMax to editors
1> 
2> grant execute on ACC_findMax to public
1> 
2> drop procedure ACC_setMax
1> 
2> create procedure ACC_setMax
3>   @increment integer,
4>   @prefixPart varchar(20) = "MGI:"
5> as
6> 
7> /* Increment the max MGI Accession Number by @increment */
8> 
9> update ACC_AccessionMax
10> set maxNumericPart = maxNumericPart + @increment
11> where prefixPart= @prefixPart
12> 
1> 
2> grant execute on ACC_setMax to progs
1> 
2> drop procedure ACC_reserveMGIBlock
1> 
2> create procedure ACC_reserveMGIBlock
3>   @blockOf integer
4> as
5> 
6> /* Reserve blocks of Accession IDs for IMAGE consortium, etc. */
7> 
8> select maxNumericPart + 1 "BEGIN BLOCK"
9> from ACC_AccessionMax
10> where prefixPart = "MGI:"
11> 
12> select @blockOf = @blockOf + 1
13> exec ACC_setMax @blockOf
14> 
15> select maxNumericPart "END BLOCK"
16> from ACC_AccessionMax
17> where prefixPart = "MGI:"
18> 
1> 
2> grant execute on ACC_reserveMGIBlock to progs
1> 
2> drop procedure ACC_assignMGI
1> 
2> create procedure ACC_assignMGI
3>   @objectKey int,
4>   @mgiType varchar(80),
5>   @prefixPart varchar(20) = "MGI:",
6>   @nextMGI int = -1,
7>   @preferred int = 1
8> as
9> 
10> /* Assign MGI or J accession number
11>    Allow override of J accession number
12>    Increment ACC_AccessionMax.maxNumericPart
13> */
14> 
15> declare @nextACC int
16> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
17> 
18> declare @mgiTypeKey int
19> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
20> 
21> if @nextMGI = -1
22> begin
23> 	select @nextMGI = maxNumericPart + 1 
24> 	from ACC_AccessionMax where prefixPart = @prefixPart
25> end
26> else if @prefixPart != "J:"
27> begin
28>     rollback transaction
29>     raiserror 99999 "Cannot override generation of MGI accession number"
30>     return
31> end
32> 
33> declare @accID varchar(30)
34> select @accID = @prefixPart + convert(varchar(20), @nextMGI)
35> 
36> insert into ACC_Accession 
37> (_Accession_key, accID, prefixPart, numericPart, 
38> _LogicalDB_key, _Object_key, _MGIType_key, preferred)
39> values(@nextACC, @accID, @prefixPart, @nextMGI, 1, @objectKey, @mgiTypeKey, @preferred)
40> 
41> if (select maxNumericPart from ACC_AccessionMax
42>     where prefixPart = @prefixPart) <= @nextMGI
43> begin
44> 	update ACC_AccessionMax 
45> 	set maxNumericPart = @nextMGI 
46> 	where prefixPart = @prefixPart
47> end
48> 
1> 
2> grant execute on ACC_assignMGI to progs
1> 
2> grant execute on ACC_assignMGI to editors
1> 
2> drop procedure ACC_assignJ
1> 
2> create procedure ACC_assignJ
3>   @objectKey int,
4>   @nextMGI int = -1
5> as
6> 
7> if @nextMGI != -1
8> begin
9> 	declare @exists int
10> 	select @exists = count(*) from BIB_Acc_View
11>                where prefixPart = "J:" and 
12> 	       numericPart = @nextMGI
13> 	if @exists > 0
14> 	begin
15>   		rollback transaction
16>   		raiserror 99999 "This J Number is already in use"
17>   		return
18> 	end
19> end
20> 
21> exec ACC_assignMGI @objectKey, "Reference", "J:", @nextMGI
22> 
1> 
2> grant execute on ACC_assignJ to progs
1> 
2> grant execute on ACC_assignJ to editors
1> 
2> drop procedure ACCRef_insert
1>  
2> create procedure ACCRef_insert
3>   @accKey int,
4>   @refsKey int
5> as
6>  
7> /* Insert record into ACC_AccessionReference table */
8> 
9> insert into ACC_AccessionReference
10> (_Accession_key, _Refs_key)
11> values(@accKey, @refsKey)
12> 
1>  
2> grant execute on ACCRef_insert to progs
1>  
2> grant execute on ACCRef_insert to editors
1>  
2> drop procedure ACC_insert
1>  
2> create procedure ACC_insert
3>   @objectKey int,
4>   @accID varchar(30),
5>   @logicalDB int,
6>   @mgiType varchar(80),
7>   @refsKey int = -1,
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* Insert record into master Accession table. */
13> /* If reference is given, insert record into Accession Reference table. */
14> 
15> if @accID is null
16> 	return
17> 
18> declare @nextACC int
19> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
20>  
21> declare @mgiTypeKey int
22> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
23>  
24> declare @prefixPart varchar(20)
25> declare @numericPart int
26> exec ACC_split @accID, @prefixPart out, @numericPart out
27> 						      
28> insert into ACC_Accession
29> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
30> values(@nextACC, @accID, @prefixPart, @numericPart, @logicalDB, @objectKey, @mgiTypeKey, @private, @preferred)
31> 
32> if @refsKey != -1
33> begin
34> 	exec ACCRef_insert @nextACC, @refsKey
35> end
36> 
1>  
2> grant execute on ACC_insert to progs
1>  
2> grant execute on ACC_insert to editors
1>  
2> drop procedure ACC_insert_bySpecies
1>  
2> create procedure ACC_insert_bySpecies
3>   @objectKey int,
4>   @accID varchar(30),
5>   @speciesKey int
6> as
7>  
8> /* Insert record into master Accession table for a given species */
9> 
10> if @accID is null
11> 	return
12> 
13> declare @logicalDBKey int
14> select @logicalDBKey = _LogicalDB_key from ACC_LogicalDB 
15> where _Species_key = @speciesKey
16>  
17> declare @private int
18> select @private = 0
19> 
20> exec ACC_insert @objectKey, @accID, @logicalDBKey, "Marker", -1, 1, @private
21>  
1>  
2> grant execute on ACC_insert_bySpecies to progs
1>  
2> grant execute on ACC_insert_bySpecies to editors
1>  
2> drop procedure ACCRef_process
1>  
2> create procedure ACCRef_process
3>   @objectKey int,
4>   @refsKey int,
5>   @accID varchar(30),
6>   @logicalDB int,
7>   @mgiType varchar(80),
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* Disallow edits to WashU data - TR 611 */
13> 
14> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
15> 	   and
16> 	  (select user_name()) not in ("mgd_dbo", "dbo")
17> begin
18> 	rollback transaction
19> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
20> 	return
21> end
22> 
23> /* Disallow edits to UniGene data - TR 983 */
24> 
25> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
26> 	   and
27> 	  (select user_name()) not in ("mgd_dbo", "dbo")
28> begin
29> 	rollback transaction
30> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
31> 	return
32> end
33> 
34> /* If the Object/Acc ID pair already exists, then use that _Accession_key */
35> /* and simply insert a new ACC_AccessionReference record (ACCRef_insert) */
36> /* Else, create a new ACC_Accession and ACC_AccessionReference record (ACC_insert) */
37> 
38> declare @accKey integer
39> select @accKey = a._Accession_key 
40> from ACC_Accession a, ACC_MGIType m
41> where accID = @accID
42> and a._Object_key = @objectKey
43> and a._MGIType_key = m._MGIType_key
44> and m.name = @mgiType
45> and a._LogicalDB_key = @logicalDB
46> 
47> begin tran
48> 
49> if @accKey is not null
50> 	exec ACCRef_insert @accKey, @refsKey
51> else
52> 	exec ACC_insert @objectKey, @accID, @logicalDB, @mgiType, @refsKey, @preferred, @private
53> 
54> /* TR 1270 - if adding a Sequence Acc ID to a Marker...
55>  *
56>  * try to update the IMAGE/Marker association
57> */
58> 
59> if @mgiType = "Marker" and @logicalDB = 9
60> begin
61> 	exec MRK_updateIMAGESeqAssoc @objectKey, @accID
62> 
63> 	if @@error != 0
64> 	begin
65> 		rollback transaction
66> 	end
67> end
68> 
69> commit tran
70> 
1>  
2> grant execute on ACCRef_process to progs
1>  
2> grant execute on ACCRef_process to editors
1>  
2> drop procedure ACC_update
1>  
2> create procedure ACC_update
3>   @accKey int,
4>   @accID varchar(30),
5>   @origRefsKey int = -1,
6>   @refsKey int = -1
7> as
8>  
9> /* Disallow edits to WashU data - TR 611 */
10> 
11> if @refsKey > 0
12>    and
13>    (
14>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
15>    or
16>    exists (select * from BIB_All_View where _Refs_key = @origRefsKey and jnum = 57656)
17>    )
18>    and
19>    (select user_name()) not in ("mgd_dbo", "dbo")
20> begin
21> 	rollback transaction
22> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
23> 	return
24> end
25> 
26> /* Disallow edits to UniGene data - TR 983 */
27> 
28> if @refsKey > 0
29>    and
30>    (
31>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
32>    or
33>    exists (select * from BIB_All_View where _Refs_key = @origRefsKey and jnum = 57747)
34>    )
35>    and
36>    (select user_name()) not in ("mgd_dbo", "dbo")
37> begin
38> 	rollback transaction
39> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
40> 	return
41> end
42> 
43> begin tran
44> 
45> declare @isMarkerSeq integer
46> select @isMarkerSeq = 0
47> 
48> if (select _MGIType_key from ACC_Accession 
49> 	where _Accession_key = @accKey) = 2
50>    and
51>    (select _LogicalDB_key from ACC_Accession 
52> 	where _Accession_key = @accKey) = 9
53> begin
54> 	select @isMarkerSeq = 1
55> end
56> 
57> declare @objectKey integer
58> declare @origAccID varchar(30)
59> 
60> select @objectKey = _Object_key from ACC_Accession where _Accession_key = @accKey
61> select @origAccID = accID from ACC_Accession where _Accession_key = @accKey
62> 
63> /* Update the Accession record for a given Accession key */
64> 
65> if @accID is null
66> begin
67> 	exec ACC_delete_byAccKey @accKey
68> end
69> else
70> begin
71> 	declare @prefixPart varchar(20)
72> 	declare @numericPart int
73> 	exec ACC_split @accID, @prefixPart out, @numericPart out
74> 						      
75> 	if (@prefixPart = "J:" or substring(@prefixPart,1,4) = "MGD-")
76> 	begin
77> 		if (select count(*) from ACC_Accession
78> 	    	    where numericPart = @numericPart and
79> 			  prefixPart = @prefixPart) >= 1
80> 		begin
81> 			rollback transaction
82> 			raiserror 99999 "Duplicate MGI Accession Number"
83> 			return
84> 		end
85> 	end
86> 
87> 	update ACC_Accession
88>   	set accID = @accID, 
89>       	prefixPart = @prefixPart, 
90>       	numericPart = @numericPart,
91>       	modification_date = getdate()
92>   	where _Accession_key = @accKey
93> 
94> 	if @refsKey > 0
95> 	begin
96> 		update ACC_AccessionReference
97> 		set _Refs_key = @refsKey
98>   		where _Accession_key = @accKey and
99> 		      _Refs_key = @origRefsKey
100> 	end
101> end
102> 
103> /* TR 1270 - if updating a Sequence Acc ID of a Marker...
104>  *
105>  * delete the old IMAGE/Marker encodes relationship
106>  *
107> */
108> 
109> if @origAccID != @accID and @isMarkerSeq = 1
110> begin
111> 	exec MRK_deleteIMAGESeqAssoc @objectKey, @origAccID
112> 
113> 	if @@error != 0
114> 	begin
115> 		rollback transaction
116> 	end
117> end
118> 
119> /* TR 1270 - if updating a Sequence Acc ID of a Marker...
120>  *
121>  * update the IMAGE/Marker association
122> */
123> 
124> if @isMarkerSeq = 1
125> begin
126> 	exec MRK_updateIMAGESeqAssoc @objectKey, @accID
127> 
128> 	if @@error != 0
129> 	begin
130> 		rollback transaction
131> 	end
132> end
133> 
134> commit tran
135> 
1>  
2> grant execute on ACC_update to progs
1>  
2> grant execute on ACC_update to editors
1>  
2> drop procedure ACC_delete_byObject
1> 
2> create procedure ACC_delete_byObject
3>   @objectKey int,
4>   @mgiType varchar(80)
5> as
6> 
7> /* Delete all accession records for a given Object */
8> 
9> delete ACC_Accession 
10> from ACC_Accession a, ACC_MGIType m
11> where a._Object_key = @objectKey 
12> and a._MGIType_key = m._MGIType_key
13> and m.name = @mgiType
14> 
15> /* May have to reset the MGI or J: Max part */
16> 
17> exec ACC_resetMax @objectKey, @mgiType
18> exec ACC_resetMax @objectKey, @mgiType, "J:"
19> 
1>  
2> grant execute on ACC_delete_byObject to progs
1>  
2> grant execute on ACC_delete_byObject to editors
1>  
2> drop procedure ACC_delete_byAccKey
1> 
2> create procedure ACC_delete_byAccKey
3>   @accKey int,
4>   @refsKey int = -1
5> as
6> 
7> /* Disallow edits to WashU data - TR 611 */
8> 
9> if @refsKey > 0
10>    and
11>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
12>    and
13>    (select user_name()) not in ("mgd_dbo", "dbo")
14> begin
15> 	rollback transaction
16> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
17> 	return
18> end
19> 
20> /* Disallow edits to UniGene data - TR 983 */
21> 
22> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
23> 	   and
24> 	  (select user_name()) not in ("mgd_dbo", "dbo")
25> begin
26> 	rollback transaction
27> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
28> 	return
29> end
30> 
31> begin tran
32> 
33> declare @isMarkerSeq integer
34> select @isMarkerSeq = 0
35> 
36> declare @deleteIMAGESeqAssoc integer
37> select @deleteIMAGESeqAssoc = 0
38> 
39> if (select _MGIType_key from ACC_Accession 
40> 	where _Accession_key = @accKey) = 2
41>    and
42>    (select _LogicalDB_key from ACC_Accession 
43> 	where _Accession_key = @accKey) = 9
44> begin
45> 	select @isMarkerSeq = 1
46> end
47> 
48> declare @objectKey integer
49> declare @accID varchar(30)
50> 
51> select @objectKey = _Object_key from ACC_Accession where _Accession_key = @accKey
52> select @accID = accID from ACC_Accession where _Accession_key = @accKey
53> 
54> if @refsKey = -1
55> begin
56> 	delete ACC_Accession where _Accession_key = @accKey
57> 	select @deleteIMAGESeqAssoc = 1
58> end
59> else
60> begin
61> 	delete ACC_AccessionReference 
62> 	where _Accession_key = @accKey
63> 	and _Refs_key = @refsKey
64> 
65> 	/* If the deletion of the detail would leave the master all alone...
66>    	   then delete the master too.
67> 	*/
68> 
69> 	if not exists (select * from ACC_AccessionReference
70>     		where _Accession_key = @accKey)
71> 	begin
72> 	    delete ACC_Accession where _Accession_key = @accKey
73> 	    select @deleteIMAGESeqAssoc = 1
74> 	end
75> end
76> 
77> /* TR 1270 - if deleting a Sequence Acc ID of a Marker...
78> *
79> * delete the old IMAGE/Marker encodes relationship
80> *
81> */
82> 
83> if @isMarkerSeq = 1 and @deleteIMAGESeqAssoc = 1
84> begin
85> 	exec MRK_deleteIMAGESeqAssoc @objectKey, @accID
86> 
87> 	if @@error != 0
88> 	begin
89> 		rollback transaction
90> 	end
91> end
92> 
93> commit tran
94> 
1>  
2> grant execute on ACC_delete_byAccKey to progs
1>  
2> grant execute on ACC_delete_byAccKey to editors
1>  
2> /* 1> declare @prefixPart varchar(20) */
3> /* 2> declare @numericPart int */
4> /* 3> exec ACC_split "MGI:12345", @prefixPart out, @numericPart out */
5> /* 4> go */
6> /* (return status = 0) */
7> /* Return parameters: */
8> /* ---- -----------  */
9> /* MGI:       12345  */
10> 
11> drop procedure ACC_split
1> 
2> create procedure ACC_split
3>   @accID varchar(20),
4>   @prefixPart varchar(20) out,
5>   @numericPart integer out
6> as
7> 
8> declare @temp varchar(20) 
9> declare @suffix varchar(20)
10> declare @acclen integer
11> declare @idx integer
12> 
13> /* Remove trailing blanks */
14> select @accID = rtrim(@accID)
15> select @acclen = char_length(@accID)
16> select @temp = reverse(@accID)
17> select @idx  = patindex("%[^0-9]%",@temp)
18> 
19> /* If @idx = 0, then no prefix */
20> 
21> if @idx = 0
22> begin
23>   select @numericPart = convert(integer, @accID)
24>   select @prefixPart = NULL
25> end
26> 
27> else
28> 
29> begin
30>   select @prefixPart = reverse(substring(@temp,@idx,@acclen-@idx+1))
31>   select @suffix = substring(@accID,
32>                              char_length(@prefixPart)+1,
33>                              @acclen - char_length(@prefixPart))
34> 
35>   if @suffix is not NULL
36>      select @numericPart = convert(integer, @suffix)
37>   else
38>      select @numericPart = NULL
39> end
40> 
1> 
2> grant execute on ACC_split to progs
1>  
2> grant execute on ACC_split to editors
1>  
2> grant execute on ACC_split to public
1>  
2> drop procedure ACC_fetch_byLogical
1>  
2> create procedure ACC_fetch_byLogical
3>   @objectKey integer,
4>   @mgiType varchar(80),
5>   @logicalDB varchar(80) = "MGI"
6> as
7>  
8> select a.accID, a.prefixPart, a.numericPart
9> from ACC_Accession a, ACC_MGIType m, ACC_LogicalDB l
10> where a._Object_key = @objectKey
11> and a._MGIType_key = m._MGIType_key
12> and m.name = @mgiType
13> and a._LogicalDB_key = l._LogicalDB_key
14> and l.name = @logicalDB
15> 
1>  
2> grant execute on ACC_fetch_byLogical to progs
1>  
2> grant execute on ACC_fetch_byLogical to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop procedure ALL_convertAllele
1>  
2> create procedure ALL_convertAllele
3>   @markerKey integer,
4>   @oldSymbol varchar(25),
5>   @newSymbol varchar(25),
6>   @alleleOf integer = 0
7> as
8>  
9> begin transaction
10> 
11> declare @userID varchar(30)
12> select @userID = user_name()
13> 
14> /* Convert allele symbols of @markerKey using @oldSymbol and @newSymbol values */
15> 
16> /* If old Symbol is NOT allele of new Symbol... */
17> /* Convert new alleles:  */
18> /*	oldallele<+> --> newsymbol<+> */
19> /*	oldallele<allele> --> newsymbol<allele> */
20> /*      oldallele         --> newsymbol         */
21> 
22> if @alleleOf = 0
23> begin
24> 	/*	oldallele<+> --> newsymbol<+> */
25> 	/*	oldallele<allele> --> newsymbol<allele> */
26> 
27> 	update ALL_Allele
28> 	set symbol = @newSymbol + "<" + 
29> 		substring(symbol, charindex("<", symbol) + 1, char_length(symbol)),
30> 		reviewed = 0, userID = @userID, modification_date = getdate()
31> 	where _Marker_key = @markerKey and symbol like '%<%'
32> 
33> 	/*      oldallele         --> newsymbol         */
34> 
35> 	update ALL_Allele set symbol = @newSymbol, 
36> 		reviewed = 0, userID = @userID, modification_date = getdate()
37> 	where _Marker_key = @markerKey and symbol = @oldSymbol
38> end
39> else
40> begin
41> 	/* If old Symbol is an Allele of new Symbol... */
42> 	/* Convert new alleles:  */
43> 	/*	oldallele<+> --> newsymbol<+> */
44> 	/*	oldallele<allele> --> newsymbol<oldallele-allele> */
45> 	/*      oldallele         --> newsymbol<oldallele>        */
46> 
47> 	/* Non Wild Type */
48> 	/*	oldallele<allele> --> newsymbol<oldallele-allele> */
49> 
50> 	update ALL_Allele
51> 	set symbol = @newSymbol + "<" + substring(symbol, 1, charindex("<", symbol) - 1) + "-" + 
52> 	     	substring(symbol, charindex("<", symbol) + 1, char_length(symbol)),
53> 		reviewed = 0, userID = @userID, modification_date = getdate()
54> 	where _Marker_key = @markerKey and symbol like '%<%' and symbol not like '%<+>'
55> 
56> 	/*      oldallele         --> newsymbol<oldallele>        */
57> 
58> 	update ALL_Allele
59> 	set symbol = @newSymbol + "<" + symbol + ">", 
60> 		reviewed = 0, userID = @userID, modification_date = getdate()
61> 	where _Marker_key = @markerKey and symbol not like '%<%' and symbol not like '%<+>'
62> 
63> 	/* Wild Type Allele */
64> 	/*	oldsymbol<+>	  --> newsymbol<+>        */
65> 
66> 	update ALL_Allele
67> 	set symbol = @newSymbol + "<+>",
68> 		reviewed = 0, userID = @userID, modification_date = getdate()
69> 	where _Marker_key = @markerKey and symbol like '%<+>'
70> end
71> 
72> commit transaction
73> 
1> 
2> grant execute on ALL_convertAllele to cml, djr, ljm, rmb
1>  
2> grant execute on ALL_convertAllele to progs
1>  
2> drop procedure ALL_insertAllele
1>  
2> create procedure ALL_insertAllele
3>   @markerKey integer,
4>   @refsKey integer,
5>   @symbol varchar(50),
6>   @name varchar(255),
7>   @userID varchar(30) = null,
8>   @molRefsKey integer = null,
9>   @strainKey integer = -1,
10>   @modeKey integer = -1,
11>   @typeKey integer = -1,
12>   @reviewed bit = 0,
13>   @oldSymbol varchar(50) = null
14> as
15> 
16> declare @alleleKey integer
17> select @alleleKey = max(_Allele_key) + 1 from ALL_Allele
18> 
19> if @userID is null
20> 	select @userID = user_name()
21> 
22> /* Insert New Allele into ALL_Allele */
23> 
24> insert ALL_Allele 
25> (_Allele_key, _Refs_key, _Molecular_Refs_key, _Marker_key, _Strain_key, _Mode_key, _Allele_Type_key, reviewed, userID, symbol, name)
26> values(@alleleKey, @refsKey, @molRefsKey, @markerKey, @strainKey, @modeKey, @typeKey, @reviewed, @userID, @symbol, @name)
27> 
28> if @oldSymbol is not null
29> begin
30> 	update MLD_Expt_Marker set _Allele_key = @alleleKey
31> 	where _Marker_key = @markerKey and gene = @oldSymbol
32> end
33> 
1> 
2> grant execute on ALL_insertAllele to cml, djr, ljm, rmb
1>  
2> grant execute on ALL_insertAllele to progs
1>  
2> drop procedure ALL_mergeAllele
1>  
2> create procedure ALL_mergeAllele
3>   @oldAlleleKey int,
4>   @newAlleleKey int
5> as
6> 
7> /*
8>  * Update old Allele key to new Allele key
9>  * in all relevant tables which contain an Allele key.
10>  * When finished, remove the Allele record for the old
11>  * Allele key.
12> */
13> 
14> update GXD_AllelePair
15> set _Allele_key_1 = @newAlleleKey
16> where _Allele_key_1 = @oldAlleleKey
17> 
18> update GXD_AllelePair
19> set _Allele_key_2 = @newAlleleKey
20> where _Allele_key_2 = @oldAlleleKey
21> 
22> update MLD_Expt_Marker
23> set _Allele_key = @newAlleleKey
24> where _Allele_key = @oldAlleleKey
25> 
26> delete from ALL_Allele
27> where _Allele_key = @oldAlleleKey
28> 
1> 
2> grant execute on ALL_mergeAllele to editors
1>  
2> grant execute on ALL_mergeAllele to progs
1>  
2> drop procedure ALL_mergeWildTypes
Msg 3701, Level 11, State 1:
Server 'MGD_DEV', Line 2:
Cannot drop the procedure 'ALL_mergeWildTypes', because it doesn't exist in the
system catalogs.
1> 
2> create procedure ALL_mergeWildTypes
3> 	@oldKey int,
4> 	@newKey int,
5> 	@oldSymbol varchar(25),
6> 	@newSymbol varchar(25)
7> as
8> 
9> declare @oldAlleleKey int
10> declare @newAlleleKey int
11> 
12> select @oldAlleleKey = _Allele_key from ALL_Allele where _Marker_key = @oldKey and
13> 	symbol = @oldSymbol + '<+>'
14> 
15> select @newAlleleKey = _Allele_key from ALL_Allele where _Marker_key = @newKey and
16> 	symbol = @newSymbol + '<+>'
17> 
18> if @oldAlleleKey is not null and @newAlleleKey is not null
19> begin
20> 	exec ALL_mergeAllele @oldAlleleKey, @newAlleleKey
21> end
22> 
1> 
2> grant execute on ALL_mergeWildTypes to editors
1> 
2> grant execute on ALL_mergeWildTypes to progs
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop procedure BIB_byJnum
1> 
2> create procedure BIB_byJnum
3>   @jnum	integer
4> as
5> 
6> /* Selects _Refs_key and short citation for given */
7> /* numeric J: (ex. BIB_byJnum 12345) */
8> 
9> select b._Refs_key, b.short_citation, b.isReviewArticle 
10> from BIB_View b, BIB_Acc_View ba
11> where ba.numericPart = @jnum
12> and ba.prefixPart = "J:"
13> and ba._Object_key = b._Refs_key
1> 
2> grant execute on BIB_byJnum to progs
1> 
2> grant execute on BIB_byJnum to public
1> 
2> drop procedure BIB_HMD_Exists
1> 
2> create procedure BIB_HMD_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of Homology records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from HMD_Homology where _Refs_key = @key
10> 
1> 
2> grant execute on BIB_HMD_Exists to public
1> 
2> drop procedure BIB_MLC_Exists
1> 
2> create procedure BIB_MLC_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of MLC records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from MLC_Reference where _Refs_key = @key
10> union
11> select count(*) from MLC_Reference_edit where _Refs_key = @key
12> 
1> 
2> grant execute on BIB_MLC_Exists to public
1> 
2> drop procedure BIB_MLD_Exists
1> 
2> create procedure BIB_MLD_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of Mapping records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from MLD_Marker where _Refs_key = @key
10> 
1> 
2> grant execute on BIB_MLD_Exists to public
1> 
2> drop procedure BIB_PRB_Exists
1> 
2> create procedure BIB_PRB_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of Molecular Segment records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from PRB_Reference where _Refs_key = @key
10> 
1> 
2> grant execute on BIB_PRB_Exists to public
1> 
2> drop procedure BIB_GXD_Exists
1> 
2> create procedure BIB_GXD_Exists
3>   @key integer
4> as
5> 
6> /* Returns count of GXD index records cross referencing */
7> /* given Reference key (_Refs_key) */
8> 
9> select count(*) from GXD_Index where _Refs_key = @key
10> union
11> select count(*) from GXD_Assay where _Refs_key = @key
12> 
1> 
2> grant execute on BIB_GXD_Exists to public
1> 
2> drop procedure BIB_getYear
1> 
2> create procedure BIB_getYear
3>   @dateStr varchar(30)
4> as
5> 
6> /* Given input string of a date, split out the 4-digit year */
7> 
8> declare @year integer
9> declare @idx integer
10>  
11> select @idx = patindex("%[0-9][0-9][0-9][0-9]%", @dateStr)
12>  
13> if @idx = 0
14> begin
15>         select @year = NULL
16> end
17> else
18> begin
19>         select @year = convert(int, substring(@dateStr, @idx, 4))
20> end
21>  
22> select @year
23> 
1> 
2> grant execute on BIB_getYear to progs
1>  
2> grant execute on BIB_getYear to editors
1>  
2> grant execute on BIB_getYear to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop procedure GXD_loadCacheByAssay
1> 
2> create procedure GXD_loadCacheByAssay
3>   @assayKey int
4> as
5> 
6> /*
7>  * Load the GXD_Expression (cache) table for the given Assay
8>  * Should be called after any modification to any table within
9>  * the GXD_Assay hierarchy.
10>  */
11> 
12> /* Delete any pre-existing cache results for given assay */
13> 
14> delete from GXD_Expression where _Assay_key = @assayKey
15> 
16> /* Retrieve values from GXD_Assay Table for given Assay */
17> 
18> declare @assayTypeKey int	/* Assay Type Key */
19> declare @markerKey int		/* Marker Key */
20> declare @isGelAssay int		/* Is Assay Type a Gel Assay? */
21> 
22> select @assayTypeKey = a._AssayType_key,
23>        @markerKey = a._Marker_key,
24>        @isGelAssay = t.isGelAssay
25> from GXD_Assay a, GXD_AssayType t
26> where a._Assay_key = @assayKey
27> and a._AssayType_key = t._AssayType_key
28> 
29> /* Variables to hold values needed for cache table from Gel/InSitu Results */
30> 
31> declare @laneKey int
32> declare @specimenKey int
33> declare @resultKey int
34> declare @structureKey int
35> declare @genotypeKey int
36> declare @controlKey int
37> declare @age varchar(50)
38> declare @ageMin float
39> declare @ageMax float
40> 
41> declare @isExpressed int	/* was any expression detected? */
42> 
43> /*
44>  * If Assay is a Gel:
45>  *   For each Gel Lane:
46>  *     If Gel Lane is not a Control:
47>  *       If any Gel Bands in the Gel Lane have strength != "Absent":
48>  *         expressed = yes
49>  *       Else:
50>  *         expressed = no
51>  *       For each Structure associated with Gel Lane:
52>  *	   Insert into cache table
53>  * Else If Assay is InSitu:
54>  *   For each Specimen:
55>  *     For each Specimen Result:
56>  *       For each Structure associated with Result:
57>  *         If any Result has strength != "Absent" and != "Not Applicable":
58>  *           expressed = yes
59>  *         Else:
60>  *           expressed = no
61>  *	   Insert into cache table
62>  */
63> 
64> /* If Assay is a Gel */
65> 
66> if (@isGelAssay = 1)
67> begin
68> 
69>   declare lane_cursor cursor for
70>   select _GelLane_key, _Genotype_key, _GelControl_key, age, ageMin, ageMax
71>   from GXD_GelLane
72>   where _Assay_key = @assayKey
73>   for read only
74>  
75>   open lane_cursor
76>   fetch lane_cursor into @laneKey, @genotypeKey, @controlKey, @age, @ageMin, @ageMax
77>  
78>   /* For each Gel Lane */
79> 
80>   while (@@sqlstatus = 0)
81>   begin
82> 
83>     /* If Gel Lane is not a Control (control = No) */
84> 
85>     if (@controlKey = 1)
86>     begin
87> 
88>       /* If any Gel Bands in the Gel Lane have strength != "Absent":
89>        *   expressed = yes
90>        * Else:
91>        *   expressed = no
92>       */
93> 
94>       if (select count(b._GelBand_key) 
95> 	  from GXD_GelBand b, GXD_GelLane l, GXD_Strength s
96> 	  where l._Assay_key = @assayKey
97> 	  and l._GelLane_key = @laneKey
98> 	  and l._GelLane_key = b._GelLane_key
99> 	  and b._Strength_key = s._Strength_key
100> 	  and s.strength != "Absent") > 0
101>       begin
102> 	select @isExpressed = 1
103>       end
104>       else
105>       begin
106> 	select @isExpressed = 0
107>       end
108> 
109>       declare structure_cursor cursor for
110>       select _Structure_key from GXD_GelLaneStructure where _GelLane_key = @laneKey
111>       for read only
112> 
113>       open structure_cursor
114>       fetch structure_cursor into @structureKey
115> 
116>       /* For each Structure associated with Gel Lane */
117> 
118>       while (@@sqlstatus = 0)
119>       begin
120> 
121>         /* Insert into cache table */
122> 
123> 	insert GXD_Expression 
124>         select max(_Expression_key) + 1, 
125> 	       @assayKey, @assayTypeKey, @genotypeKey, @markerKey, @structureKey,
126> 	       @isExpressed, @age, @ageMin, @ageMax, getdate(), getdate()
127> 	from GXD_Expression
128> 
129>         fetch structure_cursor into @structureKey
130>       end
131>       close structure_cursor
132>       deallocate cursor structure_cursor
133>     end
134>     fetch lane_cursor into @laneKey, @genotypeKey, @controlKey, @age, @ageMin, @ageMax
135>   end
136>  
137>   close lane_cursor
138>   deallocate cursor lane_cursor
139> end
140> 
141> /* If Assay is a InSitu */
142> 
143> else
144> begin
145>   declare specimen_cursor cursor for
146>   select _Specimen_key, _Genotype_key, age, ageMin, ageMax
147>   from GXD_Specimen
148>   where _Assay_key = @assayKey
149>   for read only
150> 
151>   open specimen_cursor
152>   fetch specimen_cursor into @specimenKey, @genotypeKey, @age, @ageMin, @ageMax
153> 
154>   /* For each Specimen */
155> 
156>   while (@@sqlstatus = 0)
157>   begin
158>     declare result_cursor cursor for
159>     select _Result_key
160>     from GXD_InSituResult
161>     where _Specimen_key = @specimenKey
162>     for read only
163> 
164>     open result_cursor
165>     fetch result_cursor into @resultKey
166> 
167>     /* For each Specimen Result */
168> 
169>     while (@@sqlstatus = 0)
170>     begin
171> 
172>       /* If Result has strength != "Absent" and != "Not Applicable":
173>        *   expressed = yes
174>        * Else:
175>        *   expressed = no
176>       */
177> 
178>       if (select count(r._Strength_key)
179> 	  from GXD_InSituResult r, GXD_Strength s
180> 	  where r._Result_key = @resultKey
181> 	  and r._Strength_key = s._Strength_key
182> 	  and s.strength != "Absent"
183> 	  and s.strength != "Not Applicable") = 1
184>       begin
185> 	select @isExpressed = 1
186>       end
187>       else
188>       begin
189> 	select @isExpressed = 0
190>       end
191> 
192>       declare structure_cursor cursor for
193>       select _Structure_key
194>       from GXD_ISResultStructure
195>       where _Result_key = @resultKey
196>       for read only
197> 
198>       open structure_cursor
199>       fetch structure_cursor into @structureKey
200> 
201>       /* For each Structure associated with a Result */
202> 
203>       while (@@sqlstatus = 0)
204>       begin
205> 
206>         /* Insert into cache table */
207> 
208> 	insert GXD_Expression 
209>         select max(_Expression_key) + 1, 
210> 	       @assayKey, @assayTypeKey, @genotypeKey, @markerKey, @structureKey,
211> 	       @isExpressed, @age, @ageMin, @ageMax, getdate(), getdate()
212> 	from GXD_Expression
213> 
214>         fetch structure_cursor into @structureKey
215>       end
216>       close structure_cursor
217>       deallocate cursor structure_cursor
218> 
219>       /* Retrieve next Result */
220> 
221>       fetch result_cursor into @resultKey
222>     end
223> 
224>     close result_cursor
225>     deallocate cursor result_cursor
226> 
227>     /* Retrieve next Specimen */
228> 
229>     fetch specimen_cursor into @specimenKey, @genotypeKey, @age, @ageMin, @ageMax
230>   end
231> 
232>   close specimen_cursor
233>   deallocate cursor specimen_cursor
234> end
235>  
1> 
2> grant execute on GXD_loadCacheByAssay to progs
1> 
2> grant execute on GXD_loadCacheByAssay to editors
1> 
2> drop procedure GXD_loadCacheAll
1> 
2> create procedure GXD_loadCacheAll
3> as
4> 
5> /*
6>  * Load the GXD_Expression (cache) table for all Assays
7>  */
8> 
9> declare @assaykey int
10> 
11> declare assay_cursor cursor for
12> select _Assay_key from GXD_Assay
13> for read only
14>  
15> open assay_cursor
16> fetch assay_cursor into @assaykey
17> 
18> while (@@sqlstatus = 0)
19> begin
20>   exec GXD_loadCacheByAssay @assaykey
21>   fetch assay_cursor into @assaykey
22> end
23> 
24> close assay_cursor
25> deallocate cursor assay_cursor
26> 
1> 
2> grant execute on GXD_loadCacheAll to progs
1> 
2> grant execute on GXD_loadCacheAll to editors
1> 
2> 
3> drop procedure IMG_setPDO
1> 
2> create procedure IMG_setPDO (
3> 	@pixID int = NULL, 
4> 	@xDim int, 
5> 	@yDim int, 
6> 	@image_key int
7> ) as 
8> /* If image_key is valid and a PIX foreign accession number
9>    doesnot already exist for the _Image_key and the PIX: accession
10>    ID doesnot already exist, the new ID is added to ACC_Accession
11>    and the x,y dim update the image record.
12>    ASSUMES:
13>    - _LogicalDB_key for "MGI Image Archive" is 19,
14>    - _MGIType_key for mgi Image objects is 9
15>    REQUIRES:
16>    - four integer inputs
17>    - _Image_key exists
18>    - _Image_key is not referenced by an existing PIX:#
19>    - PIX:# does not exist (referencing another _Image_key)
20> */
21> 
22> declare @accID varchar(80), @prefix varchar(4), @imageLDB int, @imageType int
23> 
24> select @prefix = 'PIX:', 
25> 	   @imageLDB = 19,
26> 	   @imageType = 9
27> 
28> if @pixID is NULL or @image_key is NULL or @xDim is NULL or @yDim is NULL
29>   BEGIN
30> 	rollback transaction
31> 	raiserror 99999 "All four arguments must be non-NULL."
32> 	return
33>   END
34> else
35> 	select @accID = @prefix + convert(varchar(10), @pixID)
36> 
37> /* ck for missing image rec */
38> if not exists (select 1 from IMG_Image where _Image_key = @image_key)
39>   BEGIN
40> 	rollback transaction
41> 	raiserror 99999 "%1! _Image_key does not exist.", @image_key
42> 	return
43>   END
44> 
45> /* check that this PIX:# does not already exist */
46> if exists (select 1 from ACC_Accession 
47>    where accID = @accID and _MGIType_key = @imageType
48>    and _LogicalDB_key = @imageLDB 
49>    )
50>   BEGIN
51> 	rollback transaction
52> 	raiserror 99999 "%1! accession already exists.", @accID
53> 	return
54>   END
55> 
56> /* check that image record is not referenced by another PIX:# */
57> if exists (select 1 from ACC_Accession
58>    where _Object_key = @image_key and prefixPart = @prefix
59>    and _LogicalDB_key = @imageLDB and _MGIType_key = @imageType
60>    )
61>   BEGIN
62> 	rollback transaction
63> 	raiserror 99999 "A PIX: accession already exists for _Image_key %1!.", @image_key
64> 	return
65>   END
66> 
67> 
68> /* insert the new PIX: accession record */
69> exec ACC_insert @image_key, 
70> 				@accID, 
71> 				@imageLDB, 
72> 				"Image", 
73> 				-1, 
74> 				1, 
75> 				1
76> 
77> if @@error != 0
78>   BEGIN
79> 	rollback transaction
80> 	raiserror 99999 "ACC_insert failed."
81> 	return	
82>   END
83> 
84> /* set the image dimensions */
85> update IMG_Image set xDim = @xDim, yDim = @yDim
86> where _Image_key = @image_key
87> 
88> if @@error != 0
89>   BEGIN
90> 	rollback transaction
91> 	raiserror 99999, "Update x,y Dimensions failed."
92> 	return
93>   END
94> 
1> 
2> grant execute on IMG_setPDO to progs
1> 
2> grant execute on IMG_setPDO to editors
1> 
2> 
3> /* Structure table stored procs.
4>    Note that these must be executed from within 
5>    a transaction block for rollbacks to work correctly */
6> 
7> drop procedure GXD_SetStructDescPrintName 
1> 
2> create procedure 
3>     GXD_SetStructDescPrintName @structure_key int, @path VARCHAR(255)
4> as
5>        /* Sets the printName of a Structure and all of the descendents 
6>         * that depend on this Structure's printStop status (those descendents
7>         * that do not have printStop set to 1).
8>         *
9>         * definition <current_structure> : 
10>         *          Structure w/_Structure_key = @structure_key  
11>         *
12>         * @structure_key : Structure key of the <current_structure> (the 
13>         *                  structure that might need printName updated)
14>         * @path          : The inclusive path from an ancestor of 
15>         *                  <current_structure> with printStop set to 1. 
16>         *                  This path does not include the <current_structure>'s 
17>         *                  preferred name.
18>         */
19> 
20>        declare @current_prefname VARCHAR(255)
21> 
22>        /* get the preferred name of the current structure */ 
23>        select @current_prefname = sn.structure
24>        from GXD_Structure s, GXD_StructureName sn
25>        where s._Structure_key = @structure_key
26>        and sn._StructureName_key = s._StructureName_key
27> 
28>        /* grow the path using the prefname */
29>        declare @pathlength int
30>        select @pathlength = char_length(@path) + 1 +   /* +1 for ; */
31>                             char_length(@current_prefname)
32>        if @pathlength > 255 
33>        begin
34>             /* truncate the path with an ellipsis. Look for one */
35>             declare @ellipsis int 
36>             declare @numchars_to_remove int
37> 
38>             /* number of characters to remove from @path so we have room
39>                for the ellipsis, ';', and current_prefname */
40>             select @numchars_to_remove = @pathlength - 255 + 3
41> 
42>             select @ellipsis = charindex("...", @path)
43>             if @ellipsis = 0  /* then no ellipsis yet, add one */
44>               begin
45>                  select @path = substring(@path,1,255-@numchars_to_remove)
46>                                 + "..."
47>               end
48>             else
49>               begin
50>                  /* find the ellipsis, and remove text to the right of it */
51>                  select @path = substring(@path,@ellipsis + 3,255) 
52>               end
53>        end
54> 
55>        if char_length(rtrim(@path)) > 0
56>            select @path = rtrim(@path) + ";" + @current_prefname
57>        else
58>            select @path = @current_prefname
59> 
60>        /* update the current node's printName */
61> 
62>        update GXD_Structure
63>        set printName = @path
64>        where _Structure_key = @structure_key 
65> 
66>        if @@error != 0  /* then update failed */ 
67>        begin
68>             raiserror 99999 "GXD_SetStructDescPrintName: Update of printName failed"
69>             rollback transaction
70>             return
71>        end
72>     
73>        /* Now fixup immediate descendent's printNames */
74> 
75>        declare @dek int
76> 
77>        declare desc_cursor cursor 
78>        for select s._Structure_key
79>            from GXD_Structure s
80>            where s._Parent_key = @structure_key 
81>              and s.printStop = 0     /* if printStop is 1, we can ignore it */
82>       
83> 
84>       open desc_cursor
85>       fetch desc_cursor into @dek
86> 
87>       while (@@sqlstatus = 0)
88>       begin 
89>          exec GXD_SetStructDescPrintName @dek, @path
90>          if @@error != 0  /* transaction failed for some reason */
91>          begin
92>             rollback transaction  /* rollback and return */
93>             raiserror 99999 "GXD_SetStructDescPrintName: Recursive call failed"
94>             close desc_cursor
95>             return
96>          end
97>          fetch desc_cursor into @dek 
98>       end
99> 
100>       close desc_cursor
1> 
2> 
3> grant execute on GXD_SetStructDescPrintName to progs
1> 
2> grant execute on GXD_SetStructDescPrintName to editors
1> 
2> 
3> drop procedure GXD_ComputePrintNamesFrom
1> 
2> 
3> create procedure
4>     GXD_ComputePrintNamesFrom  @structure_key int = null
5> as
6>    /* Changes printName for node with _Structure_key = @structure_key,
7>     * and all of its descendents, as appropriate.
8>     *
9>     * uses GXD_SetStructDescPrintName to set descendent's printNames.
10>     */
11> 
12>    if @structure_key is null
13>    begin
14>           rollback transaction
15>           raiserror 99999 "GXD_ComputePrintNamesFrom: Structure key not provided"
16>           return
17>    end
18>    else
19>    begin
20>        declare @printStop bit
21>        declare @path VARCHAR(255)
22>        
23>        /* get the printStop of the specified structure */
24> 
25>        select @printStop = s.printStop
26>               from GXD_Structure s
27>               where s._Structure_key = @structure_key
28> 
29>        /* path to the current node */ 
30>        select @path = ""
31> 
32>        if @printStop = 0 
33>        begin
34>             /* we must determine the path by moving up the tree until
35>                we find an ancestor with a printStop set, accumulating
36>                the path.
37>              */
38>             declare @ansk int  /* ancestor structure key */
39>             declare @aprintStop bit
40>             declare @aprefname VARCHAR(255)
41> 
42>             declare ancest_cursor cursor
43>             for select c._Structure_key
44>                 from GXD_Structure s, GXD_StructureClosure c
45>                 where c._Descendent_key = @structure_key
46>                 and c._Structure_key = s._Structure_key
47>                 order by s.treeDepth desc 
48> 
49>             open ancest_cursor
50>             fetch ancest_cursor into @ansk
51> 
52>             while (@@sqlstatus = 0)
53>             begin
54>                /* we have an ancestor, find out its printStop status */
55>                select @aprintStop = s.printStop, @aprefname = sn.structure
56>                from GXD_Structure s, GXD_StructureName sn
57>                where s._Structure_key = @ansk 
58>                and s._StructureName_key = sn._StructureName_key
59>                   
60>                select @path = ltrim(rtrim(@aprefname)) + @path 
61> 
62>                if @aprintStop = 1   /* found a printStop set */
63>                   break
64>                else                 /* we need to go higher */ 
65>                   select @path = ";" + @path
66> 
67>                fetch ancest_cursor into @ansk  /* get another key */
68>             end
69> 
70>             close ancest_cursor
71>        end
72> 
73>        /* @path is now set appropriately, downto the current node,
74>           but not inclusive of it. Now, fixup all the descendents */ 
75>           
76>        begin transaction
77> 
78>        exec GXD_SetStructDescPrintName @structure_key, @path
79>        if @@error != 0
80>        begin
81>           rollback transaction
82>           raiserror 99999 "GXD_ComputePrintNamesFrom: call to GXD_SetStructDescPrintName failed"
83>           return
84>        end
85>        else
86>           commit transaction
87>    end
1>        
2> grant execute on GXD_ComputePrintNamesFrom to progs
1> 
2> grant execute on GXD_ComputePrintNamesFrom to editors
1> 
2> 
3> drop procedure GXD_SetPreferredName
1> 
2> create procedure GXD_SetPreferredName 
3>      @structure_key int = null, @name varchar(255) = null
4> as
5>    /* 
6>     * Sets the preferred name of the structure whose _Structure_key = 
7>     * @structure_key.  Deletes the StructureName that *was* the preferred
8>     * name iff the current preferred name is different from the one being
9>     * set. Modifies the GXD_Structure and GXD_StructureName
10>     * tables.  Fails if node is not MGI-added (edinburghkey != NULL).
11>     *
12>     * If a StructureName doesn't exist where _Structure_key = @structure_key
13>     * and @name = structure, then a new StructureName record 
14>     * is created with _Structure_key = @structure_key, and structure = @name. 
15>     *
16>     * The _StructureName_key attribute of the structure with _Structure_key = 
17>     * @structure_key is set to point to either the existing or newly-created
18>     * StructureName record.  
19>     *
20>     * Always sets modification_date to getdate(), even if a new structurename
21>     * isn't created.  The ADI relies on this behavior.
22>     *
23>     */
24>    
25>    if @structure_key is null
26>    begin
27>        rollback transaction
28>        raiserror 99999 "GXD_SetPreferredName: Structure key not provided"
29>        return
30>    end
31>     
32>    if @name is null
33>    begin
34>        rollback transaction
35>        raiserror 99999 "GXD_SetPreferredName: Name not provided"
36>        return
37>    end
38> 
39>    if (select edinburghkey 
40>        from GXD_Structure s
41>        where s._Structure_key = @structure_key) != NULL
42>    begin
43>        rollback transaction
44>        raiserror 99999 "GXD_SetPreferredName: Cannot set preferred name for non MGI-added structures"
45>        return
46>    end
47>   
48>    /* determine the current preferred name key */
49>    declare @cpnk integer       /* current structure name key */
50> 
51>    select @cpnk = sn._StructureName_key
52>    from GXD_Structure s, GXD_StructureName sn
53>    where s._Structure_key = @structure_key
54>    and s._Structure_key = sn._Structure_key
55>    and s._StructureName_key = sn._StructureName_key
56> 
57>    declare @ctsn integer 
58>    declare @different integer  /* set to true if our set name !=
59>                                   current preferred name */ 
60>    select @different = 0       /* assume we are changing the 
61>                                   preferred name to the *same* name */
62>  
63>    /* find out how many StructureName entries match our desired preferred
64>       name */
65>    select @ctsn = count(*) 
66>                   from GXD_StructureName
67>                   where _Structure_key = @structure_key
68>                   and structure = @name
69> 
70>    if @ctsn = 0  /* if none, then we must create the StructureName */ 
71>    begin         /* and delete the old one */
72>        select @different = 1  /* set delete flag for current pref. name */
73> 
74>        declare @snk integer
75> 
76>        /* insert the new StructureName */
77>        select @snk = max(_StructureName_key) + 1 from GXD_StructureName
78>        insert into GXD_StructureName (_StructureName_key, _Structure_key,
79>                                       structure, mgiAdded) 
80>        values(@snk, @structure_key, @name, 1)
81> 
82>        if @@error != 0  /* then insert failed */ 
83>        begin
84>             rollback transaction
85> 	        raiserror 99999 "Insert into GXD_StructureName failed"
86>             return
87>        end
88>       
89>        /* set ctsn to 1, as if the StructureName had been there all along */
90>        select @ctsn = 1
91>    end
92> 
93>    if @ctsn = 1 /* then update GXD_Structure to reference this name */
94>    begin
95>         update GXD_Structure 
96>                   set _StructureName_key = (
97>                       select _StructureName_key 
98>                       from GXD_StructureName
99>                       where _Structure_key = @structure_key
100>                       and structure = @name )
101>                   where _Structure_key = @structure_key
102> 
103>        if @@error != 0  /* then insert failed */ 
104>        begin
105>           rollback transaction
106> 	      raiserror 99999 "GXD_SetPreferredName: Update of _StructureName_key in GXD_Structure failed"
107>           return
108>        end
109>       
110>        /* we update the structurename's modification date, regardless */ 
111> 
112>        update GXD_StructureName
113>               set modification_date = getdate()
114>               where _StructureName_key = @cpnk
115> 
116>        if @@error != 0  /* then update failed */ 
117>        begin
118>           rollback transaction
119> 	      raiserror 99999 "GXD_SetPreferredName: Update of modification_date in GXD_Structure failed"
120>           return
121>        end
122> 
123>        /* delete the current structureName, referenced by the structure's
124>           _StructureName_key, if we have a new structureName to point to */
125> 
126>        if @different = 1
127>        begin
128>            delete from GXD_StructureName
129>            where _Structure_key = @structure_key 
130>            and _StructureName_key = @cpnk
131>        
132>            if @@error != 0  /* then insert failed */ 
133>            begin
134>               rollback transaction
135> 	          raiserror 99999 "GXD_SetPreferredName: Could not delete previous preferred name"
136>               return
137>            end
138>        end
139> 
140>        /* recompute printNames, since the Update trigger cannot without
141>           causing infinite recursive calls */
142> 
143>        exec GXD_ComputePrintNamesFrom @structure_key
144>        if @@error != 0  /* then insert failed */ 
145>        begin
146>           rollback transaction
147> 	      raiserror 99999 "GXD_SetPreferredName: Call to GXD_ComputePrintNamesFrom failed"
148>           return
149>        end
150>    end
151>    else  /* then greater than 1, an error */
152>    begin
153> 	  rollback transaction
154> 	  raiserror 99999 "GXD_SetPreferredName: Duplicate names for structure in GXD_StructureName"
155> 	  return	
156>    end
157>              
158> 
1> 
2> grant execute on GXD_SetPreferredName to progs
1> 
2> grant execute on GXD_SetPreferredName to editors
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop procedure HMD_getChromosomes
1> 
2> create procedure HMD_getChromosomes
3>                 @_Species_key int = NULL
4> as
5> /*
6>  * 	Procedure takes a species key and returns the ordered
7>  *	list of chromosomes.
8>  *
9>  *	DOW Jan 17, 1996
10>  */
11> select chromosome 
12> from MRK_Chromosome 
13> where _Species_key = @_Species_key 
14> order by sequenceNum
1> 
2> grant execute on HMD_getChromosomes to public
1> 
2> drop procedure HMD_getOxfordGrid
1> 
2> create procedure HMD_getOxfordGrid
3>                 @Species1 int = NULL,
4>                 @Species2 int = NULL
5> as
6> 
7> /* Return all Chromosome Pairs/Homology Classes involving Species 1 & Species 2 */
8> /* Include Chromosome UN. To exclude, add the following where clauses */
9> /*	    m1.chromosome != 'UN' and	*/
10> /*	    m2.chromosome != 'UN'	*/
11> 
12> select distinct c1 = m1.chromosome, c2 = m2.chromosome, h1._Class_key
13>                 from    MRK_Marker m1,
14>                         MRK_Marker m2,
15>                         HMD_Homology h1,
16>                         HMD_Homology h2,
17>                         HMD_Homology_Marker hm1,
18>                         HMD_Homology_Marker hm2
19>                 where   m1._Species_key = @Species1 and
20>                         m1._Marker_key = hm1._Marker_key and
21> 			hm1._Homology_key = h1._Homology_key and
22>                         h1._Class_key = h2._Class_key and
23> 			h2._Homology_key = hm2._Homology_key and
24>                         hm2._Marker_key = m2._Marker_key and
25>                         m2._Species_key = @Species2 
26> order by c1, c2
27>  
1> 
2> grant execute on HMD_getOxfordGrid to public
1>  
2> drop procedure HMD_hasHomology
1> 
2> create procedure HMD_hasHomology
3>                 @_Marker_key int = NULL,
4>                 @_Refs_key int = NULL
5> as
6> /*
7>  * 	Procedure takes either a Marker key or a Ref key,
8>  *	and determines whether not a homology will exists.
9>  *	For a homology to be returned, for a _Class_key,
10>  *	there must be more than one marker.
11>  *
12>  *	DOW Jan 10, 1996
13>  */
14> declare @count int
15> declare @has_Homology int
16> create table #classes
17>         (_Class_key int)
18> 
19> /*
20>  *	has_Homology is the value to be returned.
21>  *	Default is "no homology" 
22>  */	
23> select @has_Homology = 0
24> 
25> /*	Do with a query using a _Marker_key...	*/
26> if (@_Marker_key != NULL and @_Refs_key = NULL)
27>         insert #classes
28>         select h._Class_key
29>         from HMD_Homology h, HMD_Homology_Marker m
30>         where m._Marker_key = @_Marker_key and
31> 	      m._Homology_key = h._Homology_key
32> /*	...or a _Refs_key...	*/
33> else if (@_Refs_key != NULL and @_Marker_key = NULL)
34>         insert #classes
35>         select _Class_key
36>         from HMD_Homology
37>         where _Refs_key = @_Refs_key
38> /*	...but not both!!	*/
39> else
40> begin
41> 	print 'Cannot process with both _Refs_key AND _Marker_key!'
42> 	select @has_Homology
43> 	return 
44> end
45> 
46> /*
47>  *	Cursor simply does a count of distinct markers(species) in a class
48>  */
49> declare classCount cursor for
50> select count(distinct m._Marker_key)
51> from HMD_Homology h, HMD_Homology_Marker m, #classes c
52> where h._Class_key = c._Class_key
53>       and h._Homology_key = m._Homology_key
54> group by h._Class_key
55> for read only
56> 
57> open classCount
58> 
59> /*	Pull out classes, one by one...	*/
60> fetch classCount
61>         into @count
62> 
63> /*	Nothing here... bail out!	*/
64> if (@@sqlstatus = 2)
65> begin
66> 	print 'Nothing found'
67> 	select @has_Homology
68>         return 
69> end
70> /*
71>  * 	If cursor result is not empty, then process
72>  * 	each row to determine if class has a homology
73>  * 	including more than one species (marker).
74>  */
75> while (@@sqlstatus = 0)
76> begin
77>         if (@count > 1)
78> /*	There is a valid homology within this class.	*/
79>                 select @has_Homology = 1
80> 
81> /*	Fetch next row.	*/
82>         fetch classCount
83>                 into @count
84> end
85> /*	This select will return the value of @has_Homology as a row of data */
86> select @has_Homology
87> 
88> close classCount
89> 
90> deallocate cursor classCount
1> 
2> grant execute on HMD_hasHomology to public
1>  
2> checkpoint
1> 
2> drop procedure HMD_updateClass
1> 
2> create procedure HMD_updateClass
3>   @_Class_key integer,
4>   @_Refs_key integer,
5>   @isNewClass integer = 1
6> as
7> 
8> /* Merge classes of Homologies which, due to a new Homology record */
9> /* should really be one class (due to transitivity nature of Homology) */
10> 
11> /* For each Class which exists which contains Markers from New Class... */
12> 
13> select _Class_key = @_Class_key
14> into #classes
15> union
16> select distinct h2._Class_key 
17> from HMD_Homology h1, HMD_Homology_Marker hm1, 
18>      HMD_Homology h2, HMD_Homology_Marker hm2
19> where h1._Class_key = @_Class_key and
20>       h1._Homology_key = hm1._Homology_key and
21>       hm1._Marker_key = hm2._Marker_key and
22>       hm2._Homology_key = h2._Homology_key and
23>       h2._Class_key != @_Class_key
24> 
25> /* Select all Species/Symbol pairs from the New Class */
26> 
27> select distinct hm._Marker_key, m._Species_key
28> into #markers
29> from #classes c, HMD_Homology h, HMD_Homology_Marker hm, MRK_Marker m
30> where c._Class_key = h._Class_key and
31>       h._Homology_key = hm._Homology_key and
32>       hm._Marker_key = m._Marker_key
33> 
34> declare @speciesKey integer
35> declare @dupspeciesKey integer
36> declare @do_update integer
37> select @do_update = 1
38> 
39> /* Fetch counts for Species/Symbol pairs */
40> 
41> declare classCount cursor for select _Species_key from #markers group by _Species_key having count(*) > 1
42> open classCount
43> fetch classCount into @speciesKey
44> 
45> while (@@sqlstatus = 0)
46> begin
47> 	select @do_update = 0
48> 	select @dupspeciesKey = @speciesKey
49> 	fetch classCount into @speciesKey
50> end
51> 
52> close classCount
53> deallocate cursor classCount
54> 
55> if (@do_update = 1) /* Merge Classes */
56> begin
57>         update HMD_Homology
58> 	set _Class_key = @_Class_key
59> 	from #classes c, HMD_Homology h
60> 	where c._Class_key = h._Class_key
61> 
62> 	/* Return the @_Class_key:@_Refs_key */
63> 	select convert(varchar(10), @_Class_key) + ':' + convert(varchar(10), @_Refs_key)
64> end
65> else
66> begin
67> 	declare @species varchar(255)
68> 	select @species = name from MRK_Species where _Species_key = @dupspeciesKey
69> 
70> 	/* Return the @_Class_key:@_Refs_key */
71> 	select convert(varchar(10), @_Class_key) + ':' + convert(varchar(10), @_Refs_key)
72> 
73> 	/* If this is a new class record, then delete it if there is a conflict */
74> 	if (@isNewClass = 1)
75> 	begin
76> 		delete from HMD_Class where _Class_key = @_Class_key
77> 	end
78> 
79> 	raiserror 99999 "Another Homology has been detected which conflicts with Species:  %1!", @species
80> 
81> end
82> 
1> 
2> grant execute on HMD_updateClass to progs
1> 
2> grant execute on HMD_updateClass to editors
1> 
2> checkpoint
1> 
2> drop procedure HMD_Cleanup
1> 
2> create procedure HMD_Cleanup
3>   @_Class_key integer,
4>   @_Homology_key integer
5> as
6> 
7> /* Clean up any orphan HMD_Class or HMD_Homology records after deletions */
8> 
9> if (select count(*) from HMD_Homology_Marker where _Homology_key = @_Homology_key) = 0
10> begin
11> 	delete HMD_Homology where _Homology_key = @_Homology_key
12> end
13> 
14> if (select count(*) from HMD_Homology where _Class_key = @_Class_key) = 0
15> begin
16> 	delete HMD_Class where _Class_key = @_Class_key
17> end
18> 
19> /* Delete all non-mouse, non-human Markers no longer referenced in Homology */
20> 
21> delete MRK_Marker from MRK_Marker m
22> where m._Species_key != 1 and m._Species_key != 2
23>       and not exists 
24>       (select h.* from HMD_Homology_Marker h where m._Marker_key = h._Marker_key)
25> 
1> 
2> grant execute on HMD_Cleanup to progs
1> 
2> grant execute on HMD_Cleanup to editors
1> 
2> drop procedure HMD_nomenUpdate
1> 
2> create procedure HMD_nomenUpdate
3> 	@oldMarkerKey int,
4> 	@newMarkerKey int
5> as
6> 
7> begin transaction
8> 
9> /* set the _Class_key of the old Marker's homology class */
10> /* to the _Class_key of the *new Marker's homology class */
11> 
12> update HMD_Homology 
13> set _Class_key = (select distinct h._Class_key 
14> 	from HMD_Homology h, HMD_Homology_Marker m 
15> 	where m._Marker_key = @newMarkerKey and 
16> 	      m._Homology_key = h._Homology_key) 
17> from HMD_Homology h, HMD_Homology_Marker m 
18> where m._Marker_key = @oldMarkerKey and 
19>       m._Homology_key = h._Homology_key
20> 
21> /* update the appropriate homology/marker records */
22> 
23> update HMD_Homology_Marker 
24> set _Marker_key = @newMarkerKey
25> where _Marker_key = @oldMarkerKey
26> 
27> /* remove the old marker */
28> 
29> delete from MRK_Marker 
30> where _Marker_key = @oldMarkerKey
31> 
32> /* remove the old class record */
33> 
34> delete HMD_Class 
35> from HMD_Homology h, HMD_Homology_Marker m 
36> where m._Marker_key = @oldMarkerKey and 
37>       m._Homology_key = h._Homology_key
38> 
39> commit transaction
40> 
1> 
2> grant execute on HMD_nomenUpdate to progs
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop procedure MGI_Table_Column_Cleanup
1> 
2> create procedure MGI_Table_Column_Cleanup
3> as
4> 
5> /*
6> This procedure synchronizes MGI_Tables and MGI_Columns with
7> sysobjects and syscolumns.
8> 
9> After a schema change, this procedure needs to be run so the obsolete
10> tables and columns are removed from MGI_Tables and MGI_Columns
11> */
12> 
13> /* Add new tables ids to MGI_Tables */
14> 
15> insert into MGI_Tables
16> select s.id, null, getdate(), getdate()
17> from sysobjects s
18> where s.type = "U"
19> and not exists (select 1 from MGI_Tables t where s.id = t._Table_id)
20> 
21> /* Add new column ids to MGI_Columns */
22> 
23> insert into MGI_Columns
24> select c.id, c.colid, null, null, getdate(), getdate()
25> from syscolumns c, MGI_Tables t
26> where c.id = t._Table_id
27> and not exists (select 1 from MGI_Columns l
28> where t._Table_id = l._Table_id
29> and l._Column_id = c.colid)
30> 
31> /* Delete old table ids from MGI_Tables */
32> 
33> delete MGI_Tables
34> from MGI_Tables t
35> where not exists (select 1 from sysobjects s where s.id = t._Table_id)
36> 
37> /* Delete old column ids from MGI_Columns */
38> 
39> delete MGI_Columns
40> from MGI_Columns c
41> where not exists (select 1 from MGI_Tables t where t._Table_id = c._Table_id)
42> 
1> 
2> grant execute on MGI_Table_Column_Cleanup to progs
1> 
2> drop procedure MGI_resetSequenceNum
1> 
2> create procedure MGI_resetSequenceNum
3>   @table varchar(255),		/* Table Name */
4>   @key int			/* Primary key */
5> as
6> 
7> /* Re-order the sequenceNum field so that they are 
8>    continuous and there are no gaps.
9> 
10>    ex. 1,2,5,6,7 would be reordered to 1,2,3,4,5
11> */
12> 
13> declare @pkey int	/* primary key of records to update */
14> declare @oldSeq int	/* current sequence number */
15> declare @newSeq int	/* new sequence number */
16> select @newSeq = 1
17>  
18> if (@table = "GXD_GelLane")
19> begin
20>   declare seq_cursor cursor for
21>   select _GelLane_key, sequenceNum
22>   from GXD_GelLane
23>   where _Assay_key = @key
24>   order by sequenceNum
25>   for read only
26> end
27> else if (@table = "GXD_GelRow")
28> begin
29>   declare seq_cursor cursor for
30>   select _GelRow_key, sequenceNum
31>   from GXD_GelRow
32>   where _Assay_key = @key
33>   order by sequenceNum
34>   for read only
35> end
36> else if (@table = "GXD_Specimen")
37> begin
38>   declare seq_cursor cursor for
39>   select _Specimen_key, sequenceNum
40>   from GXD_Specimen
41>   where _Assay_key = @key 
42>   order by sequenceNum 
43>   for read only
44> end
45> else if (@table = "GXD_InSituResult")
46> begin
47>   declare seq_cursor cursor for
48>   select _Result_key, sequenceNum
49>   from GXD_InSituResult
50>   where _Specimen_key = @key
51>   order by sequenceNum
52>   for read only
53> end
54> else if (@table = "MRK_History")
55> begin
56>   declare seq_cursor cursor for
57>   select _Marker_key, sequenceNum
58>   from MRK_History
59>   where _Marker_key = @key
60>   order by sequenceNum
61>   for read only
62> end
63> else if (@table = "MLD_Marker")
64> begin
65>   declare seq_cursor cursor for
66>   select _Refs_key, sequenceNum
67>   from MLD_Marker
68>   where _Refs_key = @key
69>   order by sequenceNum
70>   for read only
71> end
72> else if (@table = "MLD_Expt_Marker")
73> begin
74>   declare seq_cursor cursor for
75>   select _Expt_key, sequenceNum
76>   from MLD_Expt_Marker
77>   where _Expt_key = @key
78>   order by sequenceNum
79>   for read only
80> end
81> else if (@table = "MLD_MCDataList")
82> begin
83>   declare seq_cursor cursor for
84>   select _Expt_key, sequenceNum
85>   from MLD_MCDataList
86>   where _Expt_key = @key
87>   order by sequenceNum
88>   for read only
89> end
90> else if (@table = "MLD_MC2point")
91> begin
92>   declare seq_cursor cursor for
93>   select _Expt_key, sequenceNum
94>   from MLD_MC2point
95>   where _Expt_key = @key
96>   order by sequenceNum
97>   for read only
98> end
99> else if (@table = "MLD_RIData")
100> begin
101>   declare seq_cursor cursor for
102>   select _Expt_key, sequenceNum
103>   from MLD_RIData
104>   where _Expt_key = @key
105>   order by sequenceNum
106>   for read only
107> end
108> else if (@table = "MLD_RI2Point")
109> begin
110>   declare seq_cursor cursor for
111>   select _Expt_key, sequenceNum
112>   from MLD_RI2Point
113>   where _Expt_key = @key
114>   order by sequenceNum
115>   for read only
116> end
117> else if (@table = "MLD_FISH_Region")
118> begin
119>   declare seq_cursor cursor for
120>   select _Expt_key, sequenceNum
121>   from MLD_FISH_Region
122>   where _Expt_key = @key
123>   order by sequenceNum
124>   for read only
125> end
126> else if (@table = "MRK_Chromosome")
127> begin
128>   declare seq_cursor cursor for
129>   select _Species_key, sequenceNum
130>   from MRK_Chromosome
131>   where _Species_key = @key
132>   order by sequenceNum
133>   for read only
134> end
135> else if (@table = "MLD_Statistics")
136> begin
137>   declare seq_cursor cursor for
138>   select _Expt_key, sequenceNum
139>   from MLD_Statistics
140>   where _Expt_key = @key
141>   order by sequenceNum
142>   for read only
143> end
144> else
145> begin
146>   return
147> end
148> 
149> open seq_cursor
150> fetch seq_cursor into @pkey, @oldSeq
151>  
152> while (@@sqlstatus = 0)
153> begin
154>   if (@table = "GXD_GelLane")
155>   begin
156>     update GXD_GelLane set sequenceNum = @newSeq
157>       where _GelLane_key = @pkey
158>   end
159>   else if (@table = "GXD_GelRow")
160>   begin
161>     update GXD_GelRow set sequenceNum = @newSeq
162>       where _GelRow_key = @pkey
163>   end
164>   else if (@table = "GXD_Specimen")
165>   begin
166>     update GXD_Specimen set sequenceNum = @newSeq
167>       where _Specimen_key = @pkey
168>   end
169>   else if (@table = "GXD_InSituResult")
170>   begin
171>     update GXD_InSituResult set sequenceNum = @newSeq
172>       where _Result_key = @pkey
173>   end
174>   else if (@table = "MRK_History")
175>   begin
176>     update MRK_History set sequenceNum = @newSeq
177>       where _Marker_key = @pkey and sequenceNum = @oldSeq
178>   end
179>   else if (@table = "MLD_Marker")
180>   begin
181>     update MLD_Marker set sequenceNum = @newSeq
182>       where _Refs_key = @pkey and sequenceNum = @oldSeq
183>   end
184>   else if (@table = "MLD_Expt_Marker")
185>   begin
186>     update MLD_Expt_Marker set sequenceNum = @newSeq
187>       where _Expt_key = @pkey and sequenceNum = @oldSeq
188>   end
189>   else if (@table = "MLD_MCDataList")
190>   begin
191>     update MLD_MCDataList set sequenceNum = @newSeq
192>       where _Expt_key = @pkey and sequenceNum = @oldSeq
193>   end
194>   else if (@table = "MLD_MC2point")
195>   begin
196>     update MLD_MC2point set sequenceNum = @newSeq
197>       where _Expt_key = @pkey and sequenceNum = @oldSeq
198>   end
199>   else if (@table = "MLD_RIData")
200>   begin
201>     update MLD_RIData set sequenceNum = @newSeq
202>       where _Expt_key = @pkey and sequenceNum = @oldSeq
203>   end
204>   else if (@table = "MLD_RI2Point")
205>   begin
206>     update MLD_RI2Point set sequenceNum = @newSeq
207>       where _Expt_key = @pkey and sequenceNum = @oldSeq
208>   end
209>   else if (@table = "MLD_FISH_Region")
210>   begin
211>     update MLD_FISH_Region set sequenceNum = @newSeq
212>       where _Expt_key = @pkey and sequenceNum = @oldSeq
213>   end
214>   else if (@table = "MRK_Chromosome")
215>   begin
216>     update MRK_Chromosome set sequenceNum = @newSeq
217>       where _Species_key = @pkey and sequenceNum = @oldSeq
218>   end
219>   else if (@table = "MLD_Statistics")
220>   begin
221>     update MLD_Statistics set sequenceNum = @newSeq
222>       where _Expt_key = @pkey and sequenceNum = @oldSeq
223>   end
224>   select @newSeq = @newSeq + 1
225>   fetch seq_cursor into @pkey, @oldSeq
226> end
227>  
228> close seq_cursor
229> deallocate cursor seq_cursor
230>  
1> 
2> grant execute on MGI_resetSequenceNum to progs
1> 
2> grant execute on MGI_resetSequenceNum to editors
1> 
2> drop procedure GEN_rowcount
1>  
2> create procedure GEN_rowcount
3>   @table varchar(30)
4> as
5> 
6> select convert(char(10),rowcnt(MAX(doampg)))
7> from sysobjects o, sysindexes i
8> where o.name = @table
9> and o.id = i.id
1> 
2> grant execute on GEN_rowcount to public
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> /* Obsolete */
3> 
4> drop procedure Current_Symbol
1> 
2> /* End Obsolete */
3> 
4> drop procedure MLC_transfer
1> 
2> create procedure MLC_transfer
3>     @_Marker_key int
4> as
5> /* This proc transfers rows with primary_key = @_Marker_key from the MLC 
6>  * edit tables to the Production MLC tables.  If the MLC_Text_edit table
7>  * does not contain a row with _Marker_key = @_Marker_key, then this is
8>  * a delete that will be propagated to the Production MLC tables.
9>  */
10> 
11> begin transaction
12> 
13> declare @doinsert bit
14> select @doinsert = 1  /* assume we are copying, not deleting */
15> 
16> 
17> /* determine if this is a copy or delete */
18> 
19> if (select count(*) 
20>     from MLC_Text_edit
21>     where _Marker_key = @_Marker_key) = 0
22> begin  /* then we must propagate a delete */
23>     select @doinsert = 0
24> end
25> 
26> 
27> /* make sure to set the textsize to avoid truncation during selects
28>    when copying data between MLC_Text_edit and MLC_Text */
29> 
30> set textsize 500000
31> 
32> /* MLC_Text */
33> 
34> /* delete the rows from the Production table that will be replaced
35>    with rows from the corresponding _edit table */ 
36> 
37> delete from MLC_Text where _Marker_key = @_Marker_key
38> if @@error != 0
39> begin
40>    rollback transaction
41>    raiserror 99999 "Delete from MLC_Text failed, mk = %1!", @_Marker_key
42>    return
43> end
44> 
45> if @doinsert = 1
46> begin
47>    /* insert the updated rows into production tables */ 
48>    insert MLC_Text 
49>    select * from MLC_Text_edit where _Marker_key = @_Marker_key
50> 
51>    if @@error != 0
52>    begin
53>       rollback transaction
54>       raiserror 99999 "Insert into MLC_Text failed, mk = %1!", @_Marker_key
55>       return
56>    end
57> end
58> 
59> /* MLC_Marker */
60> 
61> /* delete the rows from the Production table that will be replaced
62>    with rows from the corresponding _edit table */ 
63> 
64> delete from MLC_Marker where _Marker_key = @_Marker_key
65> if @@error != 0
66> begin
67>    rollback transaction
68>    raiserror 99999 "Delete from MLC_Marker failed, mk = %1!", @_Marker_key
69>    return
70> end
71> 
72> if @doinsert = 1
73> begin
74>    /* insert the updated rows into production tables */ 
75>    insert MLC_Marker 
76>    select * from MLC_Marker_edit where _Marker_key = @_Marker_key
77> 
78>    if @@error != 0
79>    begin
80>       rollback transaction
81>       raiserror 99999 "Insert into MLC_Marker failed, mk = %1!", @_Marker_key
82>       return
83>    end
84> end
85> 
86> 
87> /* MLC_Reference */
88> 
89> /* delete the rows from the Production table that will be replaced
90>    with rows from the corresponding _edit table */ 
91> 
92> delete from MLC_Reference where _Marker_key = @_Marker_key
93> if @@error != 0
94> begin
95>    rollback transaction
96>    raiserror 99999 "Delete from MLC_Reference failed, mk = %1!", @_Marker_key
97>    return
98> end
99> 
100> if @doinsert = 1
101> begin
102>    /* insert the updated rows into production tables */ 
103>    insert MLC_Reference 
104>    select * from MLC_Reference_edit where _Marker_key = @_Marker_key
105> 
106>    if @@error != 0
107>    begin
108>       rollback transaction
109>       raiserror 99999 "Insert into MLC_Reference failed, mk = %1!", @_Marker_key
110>       return
111>    end
112> end
113> 
114> commit transaction
1> 
2> grant execute on MLC_transfer to progs
1> 
2> grant execute on MLC_transfer to cml, csmith, dbradt, dph, hjd, jblake, lmm, rmb, sr, tc, wjb
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop procedure MRK_insertHistory
1>  
2> create procedure MRK_insertHistory
3>   @markerKey integer,
4>   @historyKey integer,
5>   @refKey integer,
6>   @eventKey integer,
7>   @eventReasonKey integer,
8>   @name varchar(255) = null,
9>   @event_date datetime = null
10> as
11>  
12> /* Insert new History record into MRK_History */
13>  
14> declare @maxSeq int
15> select @maxSeq = max(sequenceNum) from MRK_History where _Marker_key = @markerKey
16> 
17> if @maxSeq is null
18> begin
19> 	select @maxSeq = 0
20> end
21> 
22> if @event_date is null
23> begin
24> 	select @event_date = getdate()
25> end
26>  
27> insert MRK_History 
28> (_Marker_key, _History_key, _Refs_key, _Marker_Event_key, _Marker_EventReason_key, sequenceNum, name, event_date)
29> values(@markerKey, @historyKey, @refKey, @eventKey, @eventReasonKey, @maxSeq + 1, @name, @event_date)
30> 
1>  
2> grant execute on MRK_insertHistory to cml, djr, ljm, rmb
1>  
2> grant execute on MRK_insertHistory to progs
1>  
2> drop procedure MRK_MaxOffset
1> 
2> create procedure MRK_MaxOffset
3> 	@chromosome varchar(2),
4> 	@source int 
5> as
6> 
7> select maxOffset = max(o.offset)
8> from MRK_Offset o, MRK_Marker m
9> where o._Marker_key = m._Marker_key
10> and o.source = @source 
11> and m.chromosome = @chromosome 
12> and m._Species_key = 1
13> 
1> 
2> grant execute on MRK_MaxOffset to public
1> 
2> drop procedure MRK_MiniMapMarkers
1> 
2> create procedure MRK_MiniMapMarkers
3> 	@_Marker_key int,
4> 	@source int 
5> as
6> 
7> /* retrieve data for all anchor markers on the chromosome */
8> 
9> select distinct m._Marker_key, m.symbol, m.name, m.chromosome, o.offset, m.cytogeneticOffset
10> from MRK_Marker m, MRK_Offset o, MRK_Anchors a
11> where m._Marker_key = a._Marker_key
12> 	and o.source = @source
13> 	and o._Marker_key = m._Marker_key
14> 	and o.offset > -1.0
15> 	and a.chromosome = (select m.chromosome 
16> 	from MRK_Marker m
17> 	where m._Marker_key = @_Marker_key)
18> 
19> union
20> 
21> /* get the data for the marker itself */
22> 
23> select distinct m._Marker_key, m.symbol, m.name, m.chromosome, o.offset, m.cytogeneticOffset
24> from MRK_Marker m, MRK_Offset o
25> where m._Marker_key = @_Marker_key
26> 	and o.source = @source
27> 	and o._Marker_key = m._Marker_key
28> 	and o.offset > -1.0
1> 
2> grant execute on MRK_MiniMapMarkers to public
1> 
2> drop procedure MRK_isAnchor
1>  
2> create procedure MRK_isAnchor
3>   @key int
4> as
5> 
6> /* Determine if Marker key exists in MRK_Anchors table */
7> 
8> declare @found int
9> select @found = count(*) from MRK_Anchors where _Marker_key = @key
10> select @found
11> 
1> 
2> grant execute on MRK_isAnchor to public
1>  
2> drop procedure MRK_breakpointSplit
1> 
2> create procedure MRK_breakpointSplit
3>   @markerKey integer,
4>   @distalCytoBand varchar(20) = null
5> as
6> 
7> /* See TR#120; procedure to split cytogenetic marker into 2 distinct markers */
8> 
9> declare @band varchar(20)
10> declare @symbol varchar(25)
11> declare @name varchar(255)
12> declare @markerType integer
13> declare @idx integer
14> 
15> select @symbol = symbol, @band = cytogeneticOffset, @name = name, @markerType = _Marker_Type_key
16> from MRK_Marker where _Marker_key = @markerKey
17> 
18> if @markerType != 3
19> begin
20> 	rollback transaction
21> 	raiserror 99999 "Invalid Marker for Breakpoint Split: %1!", @symbol
22> 	return
23> end
24> 
25> select @idx = charindex(" & ", @band)
26> 
27> declare @proximalBand varchar(20)
28> declare @distalBand varchar(20)
29> 
30> declare @proximalSymbol varchar(25)
31> declare @distalSymbol varchar(25)
32> 
33> declare @proximalName varchar(255)
34> declare @distalName varchar(255)
35> 
36> declare @proximalKey integer
37> declare @distalKey integer
38> 
39> /* If symbol band is not in the format 'X & Y', then distal band remains NULL */
40> 
41> if @idx = 0
42> begin
43> 	select @proximalBand = @band
44> 	/* distal band is null */
45> end
46> else
47> begin
48> 	select @proximalBand = substring(@band, 1, @idx - 1)
49> 	select @distalBand = substring(@band, @idx + 3, char_length(@band))
50> end
51> 
52> /* If caller supplies a distal band, use it */
53> 
54> if @distalCytoBand is not null
55> begin
56> 	select @distalBand = @distalCytoBand
57> end
58> 
59> select @proximalSymbol = @symbol + "-p"
60> select @proximalName = @name + ", proximal"
61> select @proximalKey = @markerKey
62> 
63> select @distalSymbol = @symbol + "-d"
64> select @distalName = @name + ", distal"
65> select @distalKey = max(_Marker_key) + 1 from MRK_Marker
66> 
67> /* Update the symbol, name and cytogenetic offset for the current Marker to the proximal symbol */
68> 
69> update MRK_Marker
70> set symbol = @proximalSymbol,
71>     name = @proximalName,
72>     cytogeneticOffset = @proximalBand
73> where _Marker_key = @proximalKey
74> 
75> update MRK_History
76> set name = @proximalName
77> where _Marker_key = @proximalKey
78> and name = @name
79> 
80> /* Copy proximal symbol info to a new distal symbol */
81> 
82> insert into MRK_Marker 
83> (_Marker_key, _Species_key, _Marker_Status_key, _Marker_Type_key, symbol, name, chromosome, cytogeneticOffset)
84> select @distalKey, _Species_key, _Marker_Status_key, _Marker_Type_key, 
85> @distalSymbol, @distalName, chromosome, @distalBand
86> from MRK_Marker where _Marker_key = @proximalKey
87> 
88> exec ACC_assignMGI @distalKey, "Marker"
89> 
90> /* Notes */
91> insert into MRK_Notes
92> (_Marker_key, sequenceNum, note)
93> select @distalKey, sequenceNum, note
94> from MRK_Notes where _Marker_key = @proximalKey
95> 
96> /* Offset */
97> insert into MRK_Offset
98> (_Marker_key, source, offset)
99> select @distalKey, source, offset
100> from MRK_Offset where _Marker_key = @proximalKey
101> 
102> /* References */
103> insert into MRK_Reference
104> (_Marker_key, _Refs_key, auto)
105> select @distalKey, _Refs_key, auto
106> from MRK_Reference where _Marker_key = @proximalKey
107> 
108> /* History */
109> insert into MRK_History
110> (_Marker_key, _Marker_Event_key, _Marker_EventReason_key, _History_key, _Refs_key, sequenceNum, name, event_date)
111> select @distalKey, _Marker_Event_key, _Marker_EventReason_key, _History_key, _Refs_key, sequenceNum, name, event_date
112> from MRK_History where _Marker_key = @proximalKey and _History_key != @proximalKey
113> 
114> insert into MRK_History
115> (_Marker_key, _Marker_Event_key, _Marker_EventReason_key, _History_key, _Refs_key, sequenceNum, name, event_date)
116> select @distalKey, _Marker_Event_key, _Marker_EventReason_key, @distalKey, _Refs_key, sequenceNum, @distalName, event_date
117> from MRK_History where _Marker_key = @proximalKey and _History_key = @proximalKey
118> 
119> /* Other Names */
120> select seq = identity(5), name, _Refs_key
121> into #otherTmp
122> from MRK_Other where _Marker_key = @proximalKey
123> 
124> declare @maxOther int
125> select @maxOther = max(_Other_key) from MRK_Other
126> 
127> insert into MRK_Other
128> (_Other_key, _Marker_key, _Refs_key, name)
129> select @maxOther + seq, @distalKey, _Refs_key, name
130> from #otherTmp
131>  
132> /* Accession Numbers */
133> /* Copy all nonMGI preferred Accession numbers of proximal symbol to distal symbol */
134> 
135> select seq = identity(5), a.*
136> into #accTmp
137> from ACC_Accession a where a._Object_key = @proximalKey
138> and a._MGIType_key = 2
139> 
140> declare @maxAcc int
141> select @maxAcc = max(_Accession_key) from ACC_Accession
142> 
143> insert into ACC_Accession
144> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
145> select @maxAcc + seq, accID, prefixPart, numericPart, _LogicalDB_key, @distalKey, _MGIType_key,
146> private, preferred
147> from #accTmp
148> where prefixPart != "MGI:" and preferred != 1
149>  
150> /* Insert Other Name entries for both proximal and distal symbols */
151> 
152> declare @otherKey int
153> select @otherKey = max(_Other_key) + 1 from MRK_Other
154> insert into MRK_Other values(@otherKey, @proximalKey, NULL, @symbol, getdate(), getdate())
155> insert into MRK_Other values(@otherKey + 1, @distalKey, NULL, @symbol, getdate(), getdate())
156> 
157> select @proximalKey, @proximalSymbol
158> select @distalKey, @distalSymbol
159> 
1> 
2> grant execute on MRK_breakpointSplit to djr, ljm, rmb
1> 
2> grant execute on MRK_breakpointSplit to progs
1> 
2> drop procedure MRK_addChromosome
1> 
2> create procedure MRK_addChromosome
3>   @speciesKey integer,
4>   @chromosome varchar(8)
5> as
6> 
7> /* If Chromosome for given Species does not exist in MRK_Chromosome, */
8> /* then insert the chromosome into MRK_Chromosome. */
9> /* MRK_Chromosome is used to sequentially order the Chromosome values within */
10> /* a given Species for sorting in Homology, reports, Oxford Grids, etc. */
11> 
12> if (select count(*) from MRK_Chromosome
13>     where _Species_key = @speciesKey and chromosome = @chromosome) = 0
14> begin
15>         /* Get next available sequence number */
16>         declare @nextseq integer
17> 
18>         select @nextseq = max(sequenceNum) + 1 
19>         	from MRK_Chromosome
20>         	where _Species_key = @speciesKey
21> 
22>         if @nextseq is NULL or @nextseq = 0
23>         begin
24>         	select @nextseq = 1
25>         end
26> 
27>         insert into MRK_Chromosome (_Species_key, chromosome, sequenceNum)
28> 	values(@speciesKey, @chromosome, @nextseq)
29> 
30> end
1> 
2> grant execute on MRK_addChromosome to editors
1> 
2> grant execute on MRK_addChromosome to progs
1> 
2> drop procedure MRK_updateIMAGESeqAssoc
1>  
2> create procedure MRK_updateIMAGESeqAssoc
3>   @markerKey integer,
4>   @accID varchar(30)
5> as
6>  
7> /* TR 1270
8>  *
9>  * update/add marker/clone/E association
10>  * if accID exists for IMAGE clone
11>  *
12>  * see TR for more specific details
13> */
14> 
15> declare @cloneKey integer
16> 
17> select @cloneKey = p._Probe_key
18> from PRB_Probe p, PRB_Acc_View a
19> where p.name = 'I.M.A.G.E. clone'
20> and p._Probe_key = a._Object_key
21> and a._LogicalDB_key = 9
22> and a.accID = @accID
23> 
24> /* @accID is not attached to an IMAGE clone. do nothing. */
25> if @cloneKey is null
26> begin
27> 	return
28> end
29> 
30> /* if another "E" marker exists for the clone, print message and return */
31> 
32> if exists (select 1 from PRB_Marker 
33> 	where _Probe_key = @cloneKey
34> 	and _Marker_key != @markerKey
35> 	and relationship = 'E')
36> begin
37> 	print "The Clone/Sequence Accession number %1! has an encodes relationship with another Marker.", @accID
38> 	return
39> end
40> 
41> /* 
42>  * if clone/marker relationship exists, update to 'E'
43>  * else insert clone/marker/E relationship record
44> */
45> 
46> if exists (select 1 from PRB_Marker 
47> 	where _Probe_key = @cloneKey
48> 	and _Marker_key = @markerKey)
49> begin
50> 	update PRB_Marker set relationship = 'E', modification_date = getdate()
51> 	where _Probe_key = @cloneKey
52> 	and _Marker_key = @markerKey
53> end
54> else
55> begin
56> 	insert into PRB_Marker values(@cloneKey, @markerKey, 'E', getdate(), getdate())
57> end
58> 
59> /* delete all putative associations for clone */
60> 
61> delete from PRB_Marker where _Probe_key = @cloneKey and relationship = 'P'
62> 
1> 
2> grant execute on MRK_updateIMAGESeqAssoc to editors
1>  
2> grant execute on MRK_updateIMAGESeqAssoc to progs
1>  
2> drop procedure MRK_deleteIMAGESeqAssoc
1>  
2> create procedure MRK_deleteIMAGESeqAssoc
3>   @markerKey integer,
4>   @accID varchar(30)
5> as
6> 
7> /* TR 1270
8>  *
9>  * delete marker/clone/E association
10>  * if accID exists for IMAGE clone
11>  *
12>  * see TR for more specific details
13> */
14> 
15> declare @cloneKey integer
16> 
17> select @cloneKey = p._Probe_key
18> from PRB_Probe p, PRB_Acc_View a
19> where p.name = 'I.M.A.G.E. clone'
20> and p._Probe_key = a._Object_key
21> and a._LogicalDB_key = 9
22> and a.accID = @accID
23> 
24> /* @accID is not attached to an IMAGE clone. do nothing. */
25> if @cloneKey is null
26> begin
27> 	return
28> end
29> 
30> /* if @accid is still attached to the marker, do nothing. */
31> 
32> if exists (select 1 from MRK_Acc_View 
33> where _Object_key = @markerKey
34> and accID = @accID)
35> begin
36> 	return
37> end
38> 
39> delete from PRB_Marker 
40> where _Probe_key = @cloneKey
41> and _Marker_key = @markerKey
42> and relationship = "E"
43> 
1> 
2> grant execute on MRK_deleteIMAGESeqAssoc to editors
1>  
2> grant execute on MRK_deleteIMAGESeqAssoc to progs
1>  
2> drop procedure MRK_reloadLabel
1> 
2> create procedure MRK_reloadLabel
3> 	@markerKey integer
4> as
5> 
6> /* Delete all MRK_Label records for a Marker and regenerate */
7> 
8> delete from MRK_Label where _Marker_key = @markerKey
9> 
10> declare marker_cursor cursor for
11> select _Marker_Status_key, _Species_key, symbol, labelType = "S"
12> from MRK_Marker
13> where _Marker_key = @markerKey
14> union
15> select _Marker_Status_key, _Species_key, name, labelType = "N"
16> from MRK_Marker
17> where _Marker_key = @markerKey
18> union
19> select distinct m2._Marker_Status_key, m2._Species_key, m2.symbol, labelType = "S" 
20> from MRK_History h, MRK_Marker m, MRK_Marker m2 
21> where h._Marker_key = @markerKey
22> and h._Marker_key = m._Marker_key 
23> and h._History_key = m2._Marker_key 
24> union
25> select distinct m2._Marker_Status_key, m2._Species_key, h.name, labelType = "N" 
26> from MRK_History h, MRK_Marker m, MRK_Marker m2 
27> where h._Marker_key = @markerKey
28> and h.name is not null 
29> and h._Marker_key = m._Marker_key 
30> and h._History_key = m2._Marker_key 
31> union
32> select distinct -2, 1, o.name, labelType = "Y" 
33> from MRK_Other o
34> where o._Marker_key = @markerKey
35> for read only
36> 
37> open marker_cursor
38> 
39> declare @statusKey integer
40> declare @speciesKey integer
41> declare @label varchar(255)
42> declare @labelType char(1)
43> 
44> fetch marker_cursor into @statusKey, @speciesKey, @label, @labelType
45> 
46> while (@@sqlstatus = 0)
47> begin
48> 	insert into MRK_Label (_Marker_key, _Marker_Status_key, _Species_key, label, labelType)
49> 	values (@markerKey, @statusKey, @speciesKey, @label, @labelType)
50> 
51> 	if @@error != 0
52> 	begin
53> 		rollback transaction
54> 		raiserror 99999 "Could Re-load Marker Label"
55> 		return
56> 	end
57> 
58> 	fetch marker_cursor into @statusKey, @speciesKey, @label, @labelType
59> end
60> 
61> close marker_cursor
62> deallocate cursor marker_cursor
63> 
1> 
2> grant execute on MRK_reloadLabel to editors
1> 
2> grant execute on MRK_reloadLabel to progs
1> 
2> drop procedure MRK_reloadReference
1> 
2> create procedure MRK_reloadReference
3> 	@markerKey integer
4> as
5> 
6> /* Select all unique Marker/Reference pairs */
7> 
8> declare marker_cursor cursor for
9> select distinct r._Refs_key, auto = 1 
10> from PRB_Marker m, PRB_Reference r 
11> where m._Marker_key = @markerKey
12> and m._Probe_key = r._Probe_key 
13> union 
14> select distinct h._Refs_key, auto = 1 
15> from HMD_Homology_Marker hm, HMD_Homology h 
16> where hm._Marker_key = @markerKey
17> and hm._Homology_key = h._Homology_key 
18> union 
19> select distinct _Refs_key, auto = 1 
20> from MRK_History
21> where _Marker_key = @markerKey
22> and _Refs_key is not null 
23> union 
24> select distinct _Refs_key, auto = 1 
25> from MLD_Marker 
26> where _Marker_key = @markerKey
27> union 
28> select distinct _Refs_key, auto = 1 
29> from GXD_Index 
30> where _Marker_key = @markerKey
31> union 
32> select distinct _Refs_key, auto = 1 
33> from GXD_Assay 
34> where _Marker_key = @markerKey
35> union 
36> select distinct _Refs_key, auto = 1 
37> from MRK_Other 
38> where _Marker_key = @markerKey
39> and _Refs_key is not null 
40> union 
41> select distinct ar._Refs_key, auto = 1 
42> from ACC_Accession a, ACC_AccessionReference ar 
43> where a._Object_key = @markerKey
44> and a._MGIType_key = 2 
45> and a.private = 0
46> and a._Accession_key = ar._Accession_key 
47> union 
48> select distinct _Refs_key, auto = 0 
49> from MRK_Reference
50> where _Marker_key = @markerKey and auto = 0
51> for read only
52> 
53> open marker_cursor
54> 
55> delete from MRK_Reference where _Marker_key = @markerKey
56> 
57> declare @refKey integer
58> declare @auto bit
59> 
60> fetch marker_cursor into @refKey, @auto
61> 
62> while (@@sqlstatus = 0)
63> begin
64> 	if not exists (select * from MRK_Reference where _Marker_key = @markerKey
65> 		and _Refs_key = @refKey)
66> 	begin
67> 		insert into MRK_Reference (_Marker_key, _Refs_key, auto)
68> 		values (@markerKey, @refKey, @auto)
69> 
70> 		if @@error != 0
71> 		begin
72> 			rollback transaction
73> 			raiserror 99999 "Could Re-load Marker Reference"
74> 			return
75> 		end
76> 	end
77> 
78> 	fetch marker_cursor into @refKey, @auto
79> end
80> 
81> close marker_cursor
82> deallocate cursor marker_cursor
83> 
1> 
2> grant execute on MRK_reloadReference to editors
1> 
2> grant execute on MRK_reloadReference to progs
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop procedure MRKXfer_count_MLD
1>  
2> create procedure MRKXfer_count_MLD
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Markers in MLDP for marker/reference pair */
8> 
9> select count(*) from MLD_Marker
10> where _Marker_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_MLD to public
1>  
2> drop procedure MRKXfer_MLD
1>  
2> create procedure MRKXfer_MLD
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return MGI Experiment Accession numbers for marker/reference pair */
8> 
9> select distinct e._Expt_key 
10> into #expts
11> from MLD_Marker m, MLD_Expts e
12> where m._Marker_key = @markerKey and
13>       m._Refs_key = @refKey and
14>       m._Refs_key = e._Refs_key
15> 
16> select distinct a.mgiID
17> from #expts t, MLD_Summary_View a
18> where t._Expt_key = a._Object_key
19> 
1> 
2> grant execute on MRKXfer_MLD to public
1>  
2> drop procedure MRKXfer_count_HMD
1>  
2> create procedure MRKXfer_count_HMD
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Homology records for marker/reference pair */
8> 
9> select count(r._Refs_key) from HMD_Homology_Marker m, HMD_Homology r
10> where m._Marker_key = @markerKey and
11>       m._Homology_Key = r._Homology_key and
12>       r._Refs_key = @refKey
13> 
1> 
2> grant execute on MRKXfer_count_HMD to public
1>  
2> drop procedure MRKXfer_count_GXDIndex
1>  
2> create procedure MRKXfer_count_GXDIndex
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Index records for marker/reference pair */
8> 
9> select count(_Refs_key) from GXD_Index
10> where _Marker_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_GXDIndex to public
1>  
2> drop procedure MRKXfer_count_GXDAntibody
1>  
2> create procedure MRKXfer_count_GXDAntibody
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Antibody records for marker/reference pair */
8> 
9> select a._Refs_key
10> into #count
11> from GXD_Antibody a, GXD_AntibodyMarker am
12> where a._Refs_key = @refKey and 
13>       a._Antibody_key = am._Antibody_key and
14>       am._Marker_key = @markerKey
15> union
16> select a._Refs_key
17> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
18> where a._Antibody_key = am._Antibody_key and 
19>       am._Marker_key = @markerKey and 
20>       a._Antibody_key = aa._Antibody_key and 
21>       aa._Refs_key = @refKey
22> 
23> select count(*) from #count
24> 
1> 
2> grant execute on MRKXfer_count_GXDAntibody to public
1>  
2> drop procedure MRKXfer_count_GXDAntibodyAssay
1>  
2> create procedure MRKXfer_count_GXDAntibodyAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Assay records which use the Antibody for marker/reference pair
8>    to detect the Marker.
9> */
10>  
11> select a._Antibody_key 
12> into #antibody
13> from GXD_Antibody a, GXD_AntibodyMarker am
14> where a._Refs_key = @refKey and
15>       a._Antibody_key = am._Antibody_key and
16>       am._Marker_key = @markerKey
17> union
18> select a._Antibody_key
19> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
20> where a._Antibody_key = am._Antibody_key and
21>       am._Marker_key = @markerKey and
22>       a._Antibody_key = aa._Antibody_key and
23>       aa._Refs_key = @refKey
24>  
25> select count(a._Assay_key)
26> from #antibody p, GXD_AntibodyPrep xa, GXD_Assay a
27> where p._Antibody_key = xa._Antibody_key and
28>       xa._AntibodyPrep_key = a._AntibodyPrep_key and
29>       a._Marker_key = @markerKey
30> 
1>  
2> grant execute on MRKXfer_count_GXDAntibodyAssay to public
1>  
2> drop procedure MRKXfer_GXDAntibodyAssay
1>  
2> create procedure MRKXfer_GXDAntibodyAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Assay records which use the Antibody for marker/reference pair
8>    to detect the Marker.
9> */
10>  
11> select a._Antibody_key
12> into #antibody
13> from GXD_Antibody a, GXD_AntibodyMarker am
14> where a._Refs_key = @refKey and
15>       a._Antibody_key = am._Antibody_key and
16>       am._Marker_key = @markerKey
17> union
18> select a._Antibody_key
19> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
20> where a._Antibody_key = am._Antibody_key and
21>       am._Marker_key = @markerKey and
22>       a._Antibody_key = aa._Antibody_key and
23>       aa._Refs_key = @refKey
24>  
25> select a._Assay_key
26> into #assay
27> from #antibody p, GXD_AntibodyPrep xa, GXD_Assay a
28> where p._Antibody_key = xa._Antibody_key and
29>       xa._AntibodyPrep_key = a._AntibodyPrep_key and
30>       a._Marker_key = @markerKey
31>  
32> select a.mgiID
33> from #assay t, GXD_Assay_Summary_View a
34> where t._Assay_key = a._Object_key
35> 
1>  
2> grant execute on MRKXfer_GXDAntibodyAssay to public
1>  
2> drop procedure MRKXfer_GXDAntibody
1>  
2> create procedure MRKXfer_GXDAntibody
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return MGI Antibody Accession numbers for marker/reference pair */
8> 
9> select a._Antibody_key 
10> into #antibody
11> from GXD_Antibody a, GXD_AntibodyMarker am
12> where a._Refs_key = @refKey and
13>       a._Antibody_key = am._Antibody_key and
14>       am._Marker_key = @markerKey
15> union
16> select a._Antibody_key
17> from GXD_Antibody a, GXD_AntibodyMarker am, GXD_AntibodyAlias aa
18> where a._Antibody_key = am._Antibody_key and
19>       am._Marker_key = @markerKey and
20>       a._Antibody_key = aa._Antibody_key and
21>       aa._Refs_key = @refKey
22>  
23> select a.mgiID
24> from #antibody t, GXD_Antibody_Summary_View a
25> where t._Antibody_key = a._Object_key
26> 
1>  
2> grant execute on MRKXfer_GXDAntibody to public
1>  
2> drop procedure MRKXfer_count_GXDAssay
1>  
2> create procedure MRKXfer_count_GXDAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of GXD Assay records for marker/reference pair */
8> 
9> select count(_Refs_key) from GXD_Assay
10> where _Marker_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_GXDAssay to public
1>  
2> drop procedure MRKXfer_GXDAssay
1>  
2> create procedure MRKXfer_GXDAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return MGI Assay Accession numbers for marker/reference pair */
8> 
9> select _Assay_key
10> into #assay
11> from GXD_Assay
12> where _Marker_key = @markerKey and
13>       _Refs_key = @refKey
14> 
15> select a.mgiID
16> from #assay t, GXD_Assay_Summary_View a
17> where t._Assay_key = a._Object_key
18> 
1>  
2> grant execute on MRKXfer_GXDAssay to public
1>  
2> drop procedure MRKXfer_count_MLC
1>  
2> create procedure MRKXfer_count_MLC
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of MLC Text records for marker/reference pair */
8> 
9> select count(m._Marker_key) 
10> from MLC_Text_edit m, MLC_Reference_edit r
11> where m._Marker_key = @markerKey
12> and m._Marker_key = r._Marker_key
13> and r._Refs_key = @refKey
14> 
1> 
2> grant execute on MRKXfer_count_MLC to public
1>  
2> drop procedure MRKXfer_count_PRB
1>  
2> create procedure MRKXfer_count_PRB
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Probe records for marker/reference pair */
8> 
9> select count(distinct p.name) from PRB_Probe p, PRB_Marker m, PRB_Reference r
10> where m._Marker_key = @markerKey and
11>       m._Probe_key = r._Probe_key and
12>       r._Refs_key = @refKey and
13>       m._Probe_key = p._Probe_key
14> 
1> 
2> grant execute on MRKXfer_count_PRB to public
1>  
2> drop procedure MRKXfer_PRB
1>  
2> create procedure MRKXfer_PRB
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for marker/reference pair */
8> 
9> select distinct p.name, p._Probe_key
10> from PRB_Probe p, PRB_Marker m, PRB_Reference r
11> where m._Marker_key = @markerKey and
12>       m._Probe_key = r._Probe_key and
13>       r._Refs_key = @refKey and
14>       m._Probe_key = p._Probe_key
15>  
1>  
2> grant execute on MRKXfer_PRB to public
1> 
2> drop procedure MRKXfer_count_PRBAssay
1>  
2> create procedure MRKXfer_count_PRBAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for Assays which use Probe to detect Marker */
8> 
9> select distinct p.name, p._Probe_key
10> into #probe
11> from PRB_Probe p, PRB_Marker m, PRB_Reference r
12> where m._Marker_key = @markerKey and
13>       m._Probe_key = r._Probe_key and
14>       r._Refs_key = @refKey and
15>       m._Probe_key = p._Probe_key
16>  
17> select count(a._Assay_key)
18> from #probe p, GXD_ProbePrep xp, GXD_Assay a
19> where p._Probe_key = xp._Probe_key and
20>       xp._ProbePrep_key = a._ProbePrep_key and
21>       a._Marker_key = @markerKey
22> 
1> 
2> grant execute on MRKXfer_count_PRBAssay to public
1> 
2> drop procedure MRKXfer_PRBAssay
1>  
2> create procedure MRKXfer_PRBAssay
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for Assays which use Probe to detect Marker */
8> 
9> select distinct p.name, p._Probe_key
10> into #probe
11> from PRB_Probe p, PRB_Marker m, PRB_Reference r
12> where m._Marker_key = @markerKey and
13>       m._Probe_key = r._Probe_key and
14>       r._Refs_key = @refKey and
15>       m._Probe_key = p._Probe_key
16>  
17> select a._Assay_key
18> into #assay
19> from #probe p, GXD_ProbePrep xp, GXD_Assay a
20> where p._Probe_key = xp._Probe_key and
21>       xp._ProbePrep_key = a._ProbePrep_key and
22>       a._Marker_key = @markerKey
23> 
24> select a.mgiID
25> from #assay t, GXD_Assay_Summary_View a
26> where t._Assay_key = a._Object_key
27> 
1> 
2> grant execute on MRKXfer_PRBAssay to public
1> 
2> drop procedure MRKXfer_count_PRBReference
1>  
2> create procedure MRKXfer_count_PRBReference
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Probes for marker/reference pair */
8> /* which contain more than one reference */
9>  
10> select distinct p._Probe_key, p.name
11> into #probe
12> from PRB_Probe p, PRB_Marker m, PRB_Reference r
13> where m._Marker_key = @markerKey and
14>       m._Probe_key = r._Probe_key and
15>       r._Refs_key = @refKey and
16>       m._Probe_key = p._Probe_key
17>  
18> select distinct t._Probe_key
19> into #count
20> from #probe t, PRB_Reference r
21> where t._Probe_key = r._Probe_key
22> group by t._Probe_key
23> having count(*) > 1
24>  
25> select count(*) from #count
26> 
1>  
2> grant execute on MRKXfer_count_PRBReference to public
1>  
2> drop procedure MRKXfer_PRBReference
1>  
2> create procedure MRKXfer_PRBReference
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Probe Names for marker/reference pair */
8> /* which contain more than one reference */
9> 
10> 
11> select distinct p._Probe_key, p.name
12> into #probe
13> from PRB_Probe p, PRB_Marker m, PRB_Reference r
14> where m._Marker_key = @markerKey and
15>       m._Probe_key = r._Probe_key and
16>       r._Refs_key = @refKey and
17>       m._Probe_key = p._Probe_key
18>  
19> select t.name, t._Probe_key
20> from #probe t, PRB_Reference r
21> where t._Probe_key = r._Probe_key
22> group by t._Probe_key
23> having count(*) > 1
24> 
1>  
2> grant execute on MRKXfer_PRBReference to public
1> 
2> drop procedure MRKXfer_count_PRBNote
1>  
2> create procedure MRKXfer_count_PRBNote
3>   @probeKey integer,
4>   @marker varchar(25)
5> as
6>  
7> /* Return number of Probe Notes for probe/marker pair */
8> 
9> select count(_Probe_key) 
10> from PRB_Notes
11> where _Probe_key = @probeKey and
12>       note like "%" + @marker + "%"
13> 
1>  
2> grant execute on MRKXfer_count_PRBNote to public
1> 
2> drop procedure MRKXfer_count_MRKAccession
1>  
2> create procedure MRKXfer_count_MRKAccession
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return number of Markers with accession/reference pair */
8> 
9> select count(*) from MRK_AccRef_View
10> where _Object_key = @markerKey and
11>       _Refs_key = @refKey
12> 
1> 
2> grant execute on MRKXfer_count_MRKAccession to public
1>  
2> drop procedure MRKXfer_MRKAccession
1>  
2> create procedure MRKXfer_MRKAccession
3>   @markerKey integer,
4>   @refKey integer
5> as
6>  
7> /* Return Accession numbers for marker/reference pair */
8>  
9> select distinct accID
10> from MRK_AccRef_View
11> where _Object_key = @markerKey and
12>       _Refs_key = @refKey
13>  
1>  
2> grant execute on MRKXfer_MRKAccession to public
1>  
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop procedure MRK_copyHistory
1>  
2> create procedure MRK_copyHistory
3>   @oldKey integer,
4>   @newKey integer
5> as
6>  
7> begin transaction
8> 
9> /* Copy History of @oldKey to @newKey */
10>  
11> declare history_cursor cursor for
12> select _History_key, _Refs_key, _Marker_Event_key, _Marker_EventReason_key, name, event_date
13> from MRK_History
14> where _Marker_key = @oldKey
15> order by sequenceNum
16> for read only
17> 
18> open history_cursor
19> 
20> declare @historyKey integer
21> declare @refKey integer
22> declare @name varchar(255)
23> declare @eventKey integer
24> declare @eventReasonKey integer
25> declare @event_date datetime
26> 
27> fetch history_cursor into @historykey, @refKey, @eventKey, @eventReasonKey, @name, @event_date
28> 
29> while (@@sqlstatus = 0)
30> begin
31> 	exec MRK_insertHistory @newKey, @historyKey, @refKey, @eventKey, @eventReasonKey, @name, @event_date
32> 	fetch history_cursor into @historykey, @refKey, @eventKey, @eventReasonKey, @name, @event_date
33> end
34> 
35> close history_cursor
36> deallocate cursor history_cursor
37> 
38> commit transaction
39> 
1>  
2> grant execute on MRK_copyHistory to cml, ljm, lmm
1>  
2> grant execute on MRK_copyHistory to progs
1>  
2> drop procedure MRK_updateKeys
1> 
2> create procedure MRK_updateKeys
3>   @oldKey integer,
4>   @newKey integer
5> as
6> 
7> begin transaction
8> 
9> /* Executed during merge withdrawal process */
10> 
11> /*
12>    Set the preferred bit to 0 for all MGI Acc# brought over from old symbol if
13>    the new symbol already contains a preferred MGI Acc#.
14>    Associate all Accession numbers w/ new symbol.
15> */
16> 
17> if (select count(*) 
18>     from ACC_Accession 
19>     where _MGIType_key = 2 and 
20> 	  prefixPart = "MGI:" and
21> 	  _Object_key = @newKey and
22> 	  preferred = 1) > 0
23> begin
24> 	update ACC_Accession 
25> 	set _Object_key = @newKey, preferred = 0
26> 	where _LogicalDB_key = 1 and _MGIType_key = 2 and _Object_key = @oldKey
27> end
28> 
29> update ACC_Accession 
30> set _Object_key = @newKey
31> where _MGIType_key = 2 and _Object_key = @oldKey
32> 
33> /* Associate aliases, classes, other names, references w/ new symbol */
34> 
35> /* Remove reflexive Alias records, if they exist */
36> 
37> delete from MRK_Alias where _Marker_key = @oldKey and _Alias_key = @newKey
38> delete from MRK_Alias where _Alias_key = @oldKey and _Marker_key = @newKey
39> 
40> update MRK_Alias set _Marker_key = @newKey where _Marker_key = @oldKey
41> update MRK_Alias set _Alias_key = @newKey where _Alias_key = @oldKey
42> update ALL_Allele set _Marker_key = @newKey where _Marker_key = @oldKey
43> update MRK_Anchors set _Marker_key = @newKey where _Marker_key = @oldKey
44> update MRK_Other set _Marker_key = @newKey where _Marker_key = @oldKey
45> 
46> /* MRK_Classes may contain potential duplicates */
47> 
48> insert into MRK_Classes
49> select @newKey, m._Class_key, m.creation_date, m.modification_date
50> from MRK_Classes m
51> where m._Marker_key = @oldKey
52> and not exists (select m2.* from MRK_Classes m2
53> where m2._Marker_key = @newKey
54> and m2._Class_key = m._Class_key)
55> 
56> delete from MRK_Classes where _Marker_key = @oldKey
57> 
58> /* Update all auxiliary references to old symbol w/ new symbol */
59> 
60> update CRS_Matrix set _Marker_key = @newKey where _Marker_key = @oldKey
61> update CRS_References set _Marker_key = @newKey where _Marker_key = @oldKey
62> update HMD_Homology_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
63> update GXD_AllelePair set _Marker_key = @newKey where _Marker_key = @oldKey
64> update GXD_AntibodyMarker set _Marker_key = @newKey where _Marker_key = @oldKey
65> update GXD_Assay set _Marker_key = @newKey where _Marker_key = @oldKey
66> update GXD_Expression set _Marker_key = @newKey where _Marker_key = @oldKey
67> update GXD_Index set _Marker_key = @newKey where _Marker_key = @oldKey
68> 
69> /* Include MLD_Marker and MLD_Expt_Marker because sometimes Markers are */
70> /* mentioned in one table and not the other */
71> 
72> update MLD_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
73> update MLD_Expt_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
74> update MLD_Concordance set _Marker_key = @newKey where _Marker_key = @oldKey
75> update MLD_Distance set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
76> update MLD_Distance set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
77> update MLD_MC2point set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
78> update MLD_MC2point set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
79> update MLD_RI2Point set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
80> update MLD_RI2Point set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
81> update MLD_RIData set _Marker_key = @newKey where _Marker_key = @oldKey
82> update MLD_Statistics set _Marker_key_1 = @newKey where _Marker_key_1 = @oldKey
83> update MLD_Statistics set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
84> update GO_MarkerGO set _Marker_key = @newKey where _Marker_key = @oldKey
85> 
86> update PRB_Strain 
87> set s.needsReview = 1
88> from PRB_Strain s, PRB_Strain_Marker m
89> where m._Marker_key = @oldKey
90> and m._Strain_key = s._Strain_key
91>  
92> update PRB_Strain_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
93> 
94> /* PRB_Marker may contain potential duplicates */
95> 
96> insert into PRB_Marker
97> select m._Probe_key, @newKey, m.relationship, m.creation_date, m.modification_date
98> from PRB_Marker m
99> where m._Marker_key = @oldKey
100> and not exists (select m2.* from PRB_Marker m2
101> where m2._Marker_key = @newKey
102> and m2._Probe_key = m._Probe_key)
103>   
104> delete from PRB_Marker where _Marker_key = @oldKey
105> update PRB_RFLV set _Marker_key = @newKey where _Marker_key = @oldKey
106> 
107> /* Update MLC tables iff New Symbol entry doesn't exist in MLC */
108> /* Nomenclature updates are propagated to the non-edit tables immediately */
109> 
110> if not exists (select * from MLC_Marker_edit where _Marker_key = @newKey)
111> begin
112>   update MLC_Marker_edit set _Marker_key = @newKey where _Marker_key = @oldKey
113>   update MLC_Marker_edit set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
114>   update MLC_Reference_edit set _Marker_key = @newKey where _Marker_key = @oldKey
115>   update MLC_Text_edit set _Marker_key = @newKey where _Marker_key = @oldKey
116>   update MLC_Marker set _Marker_key = @newKey where _Marker_key = @oldKey
117>   update MLC_Marker set _Marker_key_2 = @newKey where _Marker_key_2 = @oldKey
118>   update MLC_Reference set _Marker_key = @newKey where _Marker_key = @oldKey
119>   update MLC_Text set _Marker_key = @newKey where _Marker_key = @oldKey
120> end
121> 
122> /* Insert non-auto Marker References to the new symbol */
123> /* MRK_Reference may contain potential duplicates */
124> 
125> insert into MRK_Reference
126> select @newKey, m._Refs_key, m.auto, m.creation_date, m.modification_date
127> from MRK_Reference m
128> where m._Marker_key = @oldKey and m.auto = 0
129> and not exists (select m2.* from MRK_Reference m2
130> where m2._Marker_key = @newKey
131> and m2._Refs_key = m._Refs_key)
132> 
133> delete from MRK_Reference where _Marker_key = @oldKey
134> 
135> /* Reload MRK_Label and MRK_Reference for both old and new symbols */
136> 
137> exec MRK_reloadLabel @oldKey
138> exec MRK_reloadLabel @newKey
139> exec MRK_reloadReference @oldKey
140> exec MRK_reloadReference @newKey
141> 
142> commit transaction
143> 
1> 
2> grant execute on MRK_updateKeys to cml, ljm, lmm
1> 
2> grant execute on MRK_updateKeys to progs
1> 
2> drop procedure MRK_updateOffset
1> 
2> create procedure MRK_updateOffset
3>   @oldKey integer,
4>   @newKey integer
5> as
6> 
7> /* Update cytogenetic and centimorgan offsets for @newKey 
8>  * using @oldKey values.
9>  */
10> 
11> begin transaction
12> 
13> declare @oldCyto varchar(20)
14> declare @newCyto varchar(20)
15> 
16> declare @oldMGD float
17> declare @newMGD float
18> 
19> declare @oldCC float
20> declare @newCC float
21> 
22> declare @oldMIT float
23> declare @newMIT float
24> 
25> select @oldCyto = cytogeneticOffset from MRK_Marker where _Marker_key = @oldKey
26> select @newCyto = cytogeneticOffset from MRK_Marker where _Marker_key = @newKey
27> 
28> select @oldMGD = offset from MRK_Offset where _Marker_key = @oldKey and source = 0
29> select @oldCC = offset from MRK_Offset where _Marker_key = @oldKey and source = 1
30> select @oldMIT = offset from MRK_Offset where _Marker_key = @oldKey and source = 2
31> 
32> select @newMGD = offset from MRK_Offset where _Marker_key = @newKey and source = 0
33> select @newCC = offset from MRK_Offset where _Marker_key = @newKey and source = 1
34> select @newMIT = offset from MRK_Offset where _Marker_key = @newKey and source = 2
35> 
36> -- If the new symbol lacks an Cytogenetic offset, then use the old symbols' offset
37> 
38> if @newCyto is null
39> begin
40>   update MRK_Marker set cytogeneticOffset = @oldCyto where _Marker_key = @newKey
41> end
42> 
43> -- If the new symbol lacks an MGD offset, then use the old symbols' offset
44> 
45> if @newMGD < 0
46> begin
47>   update MRK_Offset set offset = @oldMGD where _Marker_key = @newKey and source = 0
48> end
49> 
50> -- If the new symbol lacks a CC offset, then use the old symbol's CC offset
51> 
52> if @newCC < 0 and @oldCC > 0
53> begin
54>   update MRK_Offset set offset = @oldCC where _Marker_key = @newKey and source = 1
55> end
56> else if @newCC is null and @oldCC is not null
57> begin
58>   insert MRK_Offset (_Marker_key, source, offset) values(@newKey, 1, @oldCC)
59> end
60> 
61> -- If the new symbol lacks an MIT offset, then use the old symbol's MIT offset
62> 
63> if @newMIT < 0 and @oldMIT > 0
64> begin
65>   update MRK_Offset set offset = @oldMIT where _Marker_key = @newKey and source = 2
66> end
67> else if @newMIT is null and @oldMIT is not null
68> begin
69>   insert MRK_Offset (_Marker_key, source, offset) values(@newKey, 2, @oldMIT)
70> end
71> 
72> commit transaction
73> 
1> 
2> grant execute on MRK_updateOffset to cml, ljm, lmm
1> 
2> grant execute on MRK_updateOffset to progs
1> 
2> drop procedure MRK_simpleWithdrawal
1> 
2> create procedure MRK_simpleWithdrawal
3> 	@oldKey integer,
4> 	@refKey integer,
5> 	@eventReasonKey integer,
6> 	@newSymbol varchar(25),
7> 	@newName varchar(255)
8> as
9> 
10> /*
11>  * This procedure will process a simple marker withdrawal.
12>  * A simple marker withdrawal requires:
13>  *	a) the "old" marker key
14>  *	b) the reference key
15>  *	c) the event reason key
16>  *	c) the "new" marker symbol which does not already exist
17>  *	d) the "new" marker name
18>  *
19>  * Since the server is not case-sensitive, the caller is
20>  * responsible for making sure the new symbol is unique and correct.
21>  *
22> */
23> 
24> begin transaction
25> 
26> declare @oldSymbol varchar(25)
27> declare @oldName varchar(255)
28> select @oldSymbol = symbol,
29>        @oldName = name 
30> from MRK_Marker where _Marker_key = @oldKey 
31>      and _Species_key = 1
32>      and _Marker_Status_key = 1
33> 
34> if @oldSymbol is null
35> begin
36> 	raiserror 99999 "Invalid Old Symbol Key %1!", @oldKey
37> 	rollback transaction
38> 	return
39> end
40> 
41> declare @withdrawnName varchar(255)
42> select @withdrawnName = "withdrawn, = " + @newSymbol
43> 
44> /* Create a new marker record using the old marker record as the template */
45> 
46> declare @newKey integer
47> select @newKey = max(_Marker_key) + 1 from MRK_Marker
48> 
49> insert into MRK_Marker 
50> (_Marker_key, _Species_key, _Marker_Type_key, _Marker_Status_key, symbol, name, chromosome)
51> select @newKey, _Species_key, _Marker_Type_key, 2, symbol, @withdrawnName, chromosome
52> from MRK_Marker
53> where _Marker_key = @oldKey
54> 
55> if @@error != 0
56> begin
57> 	raiserror 99999 "Could not add marker in MRK_simpleWithdrawal"
58> 	rollback transaction
59> 	return
60> end
61> 
62> /* Create Offset for new marker */
63> insert into MRK_Offset values(@newKey, 0, -999.0, getdate(), getdate())
64> 
65> if @@error != 0
66> begin
67> 	raiserror 99999 "Could not add offset in MRK_simpleWithdrawal"
68> 	rollback transaction
69> 	return
70> end
71> 
72> /* Update the Current marker of the new marker */
73> update MRK_Current set _Current_key = @oldKey where _Marker_key = @newKey
74> 
75> if @@error != 0
76> begin
77> 	raiserror 99999 "Could not update current in MRK_simpleWithdrawal"
78> 	rollback transaction
79> 	return
80> end
81> 
82> /* Update old marker record with new symbol and name values */
83> update MRK_Marker 
84> set symbol = @newSymbol, name = @newName
85> where _Marker_key = @oldKey
86> 
87> if @@error != 0
88> begin
89> 	raiserror 99999 "Could not update marker in MRK_simpleWithdrawal"
90> 	rollback transaction
91> 	return
92> end
93> 
94> /* Update history lines */
95> update MRK_History set _History_key = @newKey where _Marker_key = @oldKey
96> and _History_key = @oldKey
97> 
98> if @@error != 0
99> begin
100> 	raiserror 99999 "Could not update history in MRK_simpleWithdrawal"
101> 	rollback transaction
102> 	return
103> end
104> 
105> /* Add History line for withdrawal */
106> exec MRK_insertHistory @oldKey, @newKey, @refKey, 2, @eventReasonKey, @oldName
107> 
108> if @@error != 0
109> begin
110> 	raiserror 99999 "Could not add history in MRK_simpleWithdrawal"
111> 	rollback transaction
112> 	return
113> end
114> 
115> /* Add History line for assignment */
116> exec MRK_insertHistory @oldKey, @oldKey, @refKey, 1, @eventReasonKey, @newName
117> 
118> if @@error != 0
119> begin
120> 	raiserror 99999 "Could not add history in MRK_simpleWithdrawal"
121> 	rollback transaction
122> 	return
123> end
124> 
125> /* Convert alleles */
126> exec ALL_convertAllele @oldKey, @oldSymbol, @newSymbol
127> 
128> if @@error != 0
129> begin
130> 	raiserror 99999 "Could not convert alleles in MRK_simpleWithdrawal"
131> 	rollback transaction
132> 	return
133> end
134> 
135> /* Re-load labels */
136> 
137> exec MRK_reloadLabel @oldKey
138> 
139> if @@error != 0
140> begin
141> 	raiserror 99999 "Could not reload Labels."
142> 	rollback transaction
143> 	return
144> end
145> 
146> /* Re-load labels */
147> 
148> exec MRK_reloadReference @oldKey
149> 
150> if @@error != 0
151> begin
152> 	raiserror 99999 "Could not reload References."
153> 	rollback transaction
154> 	return
155> end
156> 
157> commit transaction
158> 
1> 
2> grant execute on MRK_simpleWithdrawal to cml, ljm, lmm
1> 
2> grant execute on MRK_simpleWithdrawal to progs
1> 
2> drop procedure MRK_mergeWithdrawal
1> 
2> create procedure MRK_mergeWithdrawal
3> 	@oldKey integer,
4> 	@newKey integer,
5> 	@refKey integer,
6> 	@eventKey integer,
7> 	@eventReasonKey integer
8> as
9> 
10> /*
11>  * This procedure will process a merge marker withdrawal.
12>  * A merge withdrawal is a withdrawal where both the "old" and "new"
13>  * markers already exist in the database.
14>  *
15>  * A merge marker withdrawal requires:
16>  *	a) the "old" marker key
17>  *	b) the "new" marker key
18>  *	c) the reference key
19>  *	d) the event key
20>  *	e) the event reason key
21>  *
22>  * Caller must still run symbolchg.py for MLC updates.
23> */
24> 
25> begin transaction
26> 
27> declare @oldSymbol varchar(25)
28> declare @oldName varchar(255)
29> select @oldSymbol = symbol,
30>        @oldName = name 
31> from MRK_Marker where _Marker_key = @oldKey
32>      and _Species_key = 1
33>      and _Marker_Status_key = 1
34> 
35> if @oldSymbol is null
36> begin
37> 	raiserror 99999 "Invalid Old Symbol Key %1!", @oldKey
38> 	rollback transaction
39> 	return
40> end
41> 
42> declare @newSymbol varchar(25)
43> select @newSymbol = symbol
44> from MRK_Marker where _Marker_key = @newKey
45>      and _Species_key = 1
46>      and _Marker_Status_key = 1
47> 
48> if @newSymbol is null
49> begin
50> 	raiserror 99999 "Invalid New Symbol Key %1!", @newKey
51> 	rollback transaction
52> 	return
53> end
54> 
55> declare @withdrawnName varchar(255)
56> declare @alleleOf integer
57> 
58> if @eventKey = 4
59> begin
60> 	select @withdrawnName = "withdrawn, allele of " + @newSymbol
61> 	select @alleleOf = 1
62> end
63> else
64> begin
65> 	select @withdrawnName = "withdrawn, = " + @newSymbol
66> 	select @alleleOf = 0
67> end
68> 
69> /* If new symbol has a chromosome of UN, update the new symbol's chromosome value */
70> /* with the old symbol chromosome value */
71> 
72> if (select chromosome from MRK_Marker where _Marker_key = @newKey) = "UN"
73> begin
74> 	declare @newChr char(8)
75> 	select @newChr = chromosome from MRK_Marker where _Marker_key = @oldKey
76> 	update MRK_Marker set chromosome = @newChr where _Marker_key = @newKey
77> 
78> 	if @@error != 0
79> 	begin
80> 		raiserror 99999 "Could not update new symbol's chromosome in MRK_mergeWithdrawal"
81> 		rollback transaction
82> 		return
83> 	end
84> end
85> 
86> /* Update offset values of new symbol */
87> 
88> exec MRK_updateOffset @oldKey, @newKey
89> 
90> if @@error != 0
91> begin
92> 	raiserror 99999 "Could not update offset values in MRK_mergeWithdrawal"
93> 	rollback transaction
94> 	return
95> end
96> 
97> /* Update MGD offset of old symbol */
98> 
99> update MRK_Offset set offset = -999.0 where _Marker_key = @oldKey and source = 0
100> 
101> if @@error != 0
102> begin
103> 	raiserror 99999 "Could not update offset of old symbol in MRK_mergeWithdrawal"
104> 	rollback transaction
105> 	return
106> end
107> 
108> /* Delete remaining offsets of old symbol */
109> 
110> delete MRK_Offset where _Marker_key = @oldKey and source > 0
111> 
112> if @@error != 0
113> begin
114> 	raiserror 99999 "Could not delete offsets of old symbol in MRK_mergeWithdrawal"
115> 	rollback transaction
116> 	return
117> end
118> 
119> /* Update name/cytogenetic offset of old symbol */
120> 
121> update MRK_Marker 
122> set name = @withdrawnName, cytogeneticOffset = null, _Marker_Status_key = 2
123> where _Marker_key = @oldKey
124> 
125> if @@error != 0
126> begin
127> 	raiserror 99999 "Could not update name of old symbol in MRK_mergeWithdrawal"
128> 	rollback transaction
129> 	return
130> end
131> 
132> /* Merge potential duplicate wild type alleles of old and new symbols */
133> /* before converting oldsymbol alleles */
134> 
135> exec ALL_mergeWildTypes @oldKey, @newKey, @oldSymbol, @newSymbol
136> 
137> if @@error != 0
138> begin
139> 	raiserror 99999 "Could not merge wild type alleles in MRK_mergeWithdrawal"
140> 	rollback transaction
141> 	return
142> end
143> 
144> /* Convert Remaining Alleles */
145> 
146> exec ALL_convertAllele @oldKey, @oldSymbol, @newSymbol, @alleleOf
147> 
148> if @@error != 0
149> begin
150> 	raiserror 99999 "Could not convert alleles in MRK_mergeWithdrawal"
151> 	rollback transaction
152> 	return
153> end
154> 
155> if @alleleOf = 1
156> begin
157> 	/* If no alleles exist for the old symbol, create a newSymbol<oldSymbol> allele */
158> 
159> 	if not exists (select 1 from ALL_Allele where _Marker_key = @oldKey)
160> 	begin
161> 		declare @alleleSymbol varchar(50)
162> 		select @alleleSymbol = @newSymbol + "<" + @oldSymbol + ">"
163> 
164> 		exec ALL_insertAllele @newKey,@refKey,@alleleSymbol,@oldName,null,null,-1,-1,-1,0,@oldSymbol
165> 
166> 		if @@error != 0
167> 		begin
168> 			raiserror 99999 "Could not insert allele in MRK_mergeWithdrawal"
169> 			rollback transaction
170> 			return
171> 		end
172> 	end
173> end
174> 
175> /* Update current symbols */
176> 
177> update MRK_Current set _Current_key = @newKey where _Current_key = @oldKey
178> 
179> if @@error != 0
180> begin
181> 	raiserror 99999 "Could not update current symbols in MRK_mergeWithdrawal"
182> 	rollback transaction
183> 	return
184> end
185> 
186> /* Copy History records from old symbol to new symbol */
187> 
188> exec MRK_copyHistory @oldKey, @newKey
189> 
190> if @@error != 0
191> begin
192> 	raiserror 99999 "Could not copy history records in MRK_mergeWithdrawal"
193> 	rollback transaction
194> 	return
195> end
196> 
197> /* Insert history record for withdrawal */
198> 
199> exec MRK_insertHistory @newKey, @oldKey, @refKey, @eventKey, @eventReasonKey, @oldName
200> 
201> if @@error != 0
202> begin
203> 	raiserror 99999 "Could not create history record in MRK_mergeWithdrawal"
204> 	rollback transaction
205> 	return
206> end
207> 
208> /* Remove history records from old symbol */
209> 
210> delete from MRK_History where _Marker_key = @oldKey
211> 
212> if @@error != 0
213> begin
214> 	raiserror 99999 "Could not delete obsolete history records in MRK_mergeWithdrawal"
215> 	rollback transaction
216> 	return
217> end
218> 
219> /* Update keys from old key to new key */
220> 
221> exec MRK_updateKeys @oldKey, @newKey
222> 
223> if @@error != 0
224> begin
225> 	raiserror 99999 "Could not update keys in MRK_mergeWithdrawal"
226> 	rollback transaction
227> 	return
228> end
229> 
230> commit transaction
231> 
1> 
2> grant execute on MRK_mergeWithdrawal to cml, ljm, lmm
1> 
2> grant execute on MRK_mergeWithdrawal to progs
1> 
2> drop procedure MRK_alleleWithdrawal
1> 
2> create procedure MRK_alleleWithdrawal
3> 	@oldKey integer,
4> 	@newKey integer,
5> 	@refKey integer,
6> 	@eventReasonKey integer
7> as
8> 
9> /*
10>  * This procedure will process an allele marker withdrawal.
11>  *
12>  * An allele marker withdrawal requires:
13>  *	a) the "old" marker key
14>  *	b) the "new" marker key
15>  *	c) the reference key
16>  *	d) the event reason key
17>  *
18> */
19> 
20> begin transaction
21> 
22> declare @oldSymbol varchar(25)
23> declare @oldName varchar(255)
24> select @oldSymbol = symbol,
25>        @oldName = name 
26> from MRK_Marker where _Marker_key = @oldKey
27>      and _Species_key = 1
28>      and _Marker_Status_key = 1
29> 
30> if @oldSymbol is null
31> begin
32> 	raiserror 99999 "Invalid Old Symbol Key %1!", @oldKey
33> 	rollback transaction
34> 	return
35> end
36> 
37> declare @newSymbol varchar(25)
38> select @newSymbol = symbol
39> from MRK_Marker where _Marker_key = @newKey
40>      and _Species_key = 1
41>      and _Marker_Status_key = 1
42> 
43> if @newSymbol is null
44> begin
45> 	raiserror 99999 "Invalid New Symbol Key %1!", @newKey
46> 	rollback transaction
47> 	return
48> end
49> 
50> exec MRK_mergeWithdrawal @oldKey, @newKey, @refKey, 4, @eventReasonKey
51> 
52> if @@error != 0
53> begin
54> 	raiserror 99999 "Could not execute allele withdrawal call to merge withdrawal"
55> 	rollback transaction
56> 	return
57> end
58> 
59> commit transaction
60> 
1> 
2> grant execute on MRK_alleleWithdrawal to cml, ljm, lmm
1> 
2> grant execute on MRK_alleleWithdrawal to progs
1> 
2> drop procedure MRK_splitWithdrawal
1> 
2> create procedure MRK_splitWithdrawal
3>         @oldKey integer,
4>         @refKey integer,
5> 	@eventReasonKey integer,
6>         @newSymbols varchar(255) /* list of new symbols separated by commas */
7> as
8> 
9> /* In a split, none of the new symbols are expected to exist in the database */
10> /*
11>  * This procedure will process a split marker withdrawal.
12>  * A split withdrawal is a withdrawal where there are more than
13>  * one "new" markers and none of the new markers exist in the database.
14>  *
15>  * A split marker withdrawal requires:
16>  *	a) the "old" marker key
17>  *	b) a list of comma-separated new symbols (ex. "new-1,new-2,new-3")
18>  *	c) the reference key
19>  *
20>  * Other data (mapping, homology, etc.) associated with the "split" marker
21>  * remains with the split marker and must be manually moved to one of the
22>  * new markers.
23>  *
24>  * MLC changes must also be done manually.
25>  *
26> */
27> 
28> 
29> begin transaction
30> 
31> declare @oldName varchar(255)
32> select @oldName = name 
33> from MRK_Marker where _Marker_key = @oldKey
34>      and _Species_key = 1
35>      and _Marker_Status_key = 1
36> 
37> if @oldName is null
38> begin
39> 	raiserror 99999 "Invalid Old Symbol Key %1!", @oldKey
40> 	rollback transaction
41> 	return
42> end
43> 
44> declare @withdrawnName varchar(255)
45> select @withdrawnName = "withdrawn, = " + substring(@newSymbols, 1, char_length(@newSymbols) - 1)
46> 
47> /* Remove all current markers for old key;  these will be replaced by the new symbols */
48> 
49> delete from MRK_Current where _Marker_key = @oldKey
50> 
51> if @@error != 0
52> begin
53> 	raiserror 99999 "Could not delete current symbols in MRK_splitWithdrawal"
54> 	rollback transaction
55> 	return
56> end
57> 
58> /* For each new marker:
59>  *
60>  *	a.  add the new marker record
61>  *	a.  transfer the offset values of the old marker to the new marker
62>  *	b.  set the new key as one of the current keys of the old symbol
63>  *	c.  copy the old symbol's history to the new marker
64>  *	d.  insert the assignment history line for the new marker
65> */
66> 
67> declare @newKey integer
68> declare @newSymbol varchar(25)
69> declare @idx integer
70> 
71> while (@newSymbols != null)
72> begin
73> 	select @idx = charindex(",", @newSymbols)
74> 
75> 	if @idx > 0
76> 	begin
77> 		select @newSymbol = substring(@newSymbols, 1, @idx - 1)
78> 		select @newSymbols = substring(@newSymbols, @idx + 1, char_length(@newSymbols))
79> 	end
80> 	else
81> 	begin
82> 		/* at end of list of @newSymbols */
83> 		select @newSymbol = @newSymbols
84> 		select @newSymbols = ""
85> 	end
86> 
87> 	if @newSymbol != null
88> 	begin
89> 		select @newKey = max(_Marker_key) + 1 from MRK_Marker
90> 
91> 		/* during a split, each new marker is created and gets a new MGI accession number */
92> 		/* the original MGI accession number stays associated with the split marker */
93> 
94> 		insert into MRK_Marker 
95> 		(_Marker_key, _Species_key, _Marker_Type_key, _Marker_Status_key, symbol, name, chromosome)
96> 		select @newKey, _Species_key, _Marker_Type_key, 1, @newSymbol, name, chromosome
97> 		from MRK_Marker
98> 		where _Marker_key = @oldKey
99> 
100> 		if @@error != 0
101> 		begin
102> 			raiserror 99999 "Could not add marker %1! in MRK_splitWithdrawal", @newSymbol
103> 			rollback transaction
104> 			return
105> 		end
106> 
107> 		exec ACC_assignMGI @newKey, "Marker"
108> 
109> 		if @@error != 0
110> 		begin
111> 			raiserror 99999 "Could not create marker accession ID %1! in MRK_splitWithdrawal", @newSymbol
112> 			rollback transaction
113> 			return
114> 		end
115> 
116> 		/* create MGD offset record for new Marker.  */
117> 
118> 		insert into MRK_Offset
119> 		(_Marker_key, source, offset)
120> 		select @newKey, source, offset
121> 		from MRK_Offset
122> 		where _Marker_key = @oldKey
123> 		and source = 0
124> 
125> 		if @@error != 0
126> 		begin
127> 			raiserror 99999 "Could not add marker offset in MRK_splitWithdrawal"
128> 			rollback transaction
129> 			return
130> 		end
131> 
132> 		/* update Marker offsets of new symbol */
133> 
134> 		exec MRK_updateOffset @oldKey, @newKey
135> 
136> 		if @@error != 0
137> 		begin
138> 			raiserror 99999 "Could not update marker offsets in MRK_splitWithdrawal"
139> 			rollback transaction
140> 			return
141> 		end
142> 
143> 		insert MRK_Current (_Current_key, _Marker_key) values (@newKey, @oldKey)
144> 
145> 		if @@error != 0
146> 		begin
147> 			raiserror 99999 "Could not add current marker in MRK_splitWithdrawal"
148> 			rollback transaction
149> 			return
150> 		end
151> 
152> 		exec MRK_copyHistory @oldKey, @newKey
153> 
154> 		if @@error != 0
155> 		begin
156> 			raiserror 99999 "Could not copy history in MRK_splitWithdrawal"
157> 			rollback transaction
158> 			return
159> 		end
160> 
161> 		exec MRK_insertHistory @newKey, @oldKey, @refKey, 5, @eventReasonKey, @oldName
162> 
163> 		if @@error != 0
164> 		begin
165> 			raiserror 99999 "Could not insert history in MRK_splitWithdrawal"
166> 			rollback transaction
167> 			return
168> 		end
169> 
170> 		/* Add History line for assignment */
171> 		exec MRK_insertHistory @newKey, @newKey, @refKey, 1, @eventReasonKey, @oldName
172> 
173> 		if @@error != 0
174> 		begin
175> 			raiserror 99999 "Could not insert history in MRK_splitWithdrawal"
176> 			rollback transaction
177> 			return
178> 		end
179> 	end
180> end
181> 
182> /* Now make the final necessary modifications to the old symbol */
183> 
184> update MRK_Offset set offset = -999.0 where _Marker_key = @oldKey and source = 0
185> 
186> if @@error != 0
187> begin
188> 	raiserror 99999 "Could not update marker offset in MRK_splitWithdrawal"
189> 	rollback transaction
190> 	return
191> end
192> 
193> delete from MRK_Offset where _Marker_key = @oldKey and source > 0
194> 
195> if @@error != 0
196> begin
197> 	raiserror 99999 "Could not delete marker offsets in MRK_splitWithdrawal"
198> 	rollback transaction
199> 	return
200> end
201> 
202> update MRK_Marker
203> set name = @withdrawnName, cytogeneticOffset = null, _Marker_Status_key = 2
204> where _Marker_key = @oldKey
205> 
206> if @@error != 0
207> begin
208> 	raiserror 99999 "Could not update marker in MRK_splitWithdrawal"
209> 	rollback transaction
210> 	return
211> end
212> 
213> delete from MRK_History where _Marker_key = @oldKey
214> 
215> if @@error != 0
216> begin
217> 	raiserror 99999 "Could not delete obsolete history in MRK_splitWithdrawal"
218> 	rollback transaction
219> 	return
220> end
221> 
222> /* Re-load labels */
223> 
224> exec MRK_reloadLabel @oldKey
225> 
226> if @@error != 0
227> begin
228> 	raiserror 99999 "Could not reload Labels."
229> 	rollback transaction
230> 	return
231> end
232> 
233> /* Re-load labels */
234> 
235> exec MRK_reloadReference @oldKey
236> 
237> if @@error != 0
238> begin
239> 	raiserror 99999 "Could not reload References."
240> 	rollback transaction
241> 	return
242> end
243> 
244> commit transaction
245> 
1> 
2> grant execute on MRK_splitWithdrawal to cml, ljm, lmm
1> 
2> grant execute on MRK_splitWithdrawal to progs
1> 
2> drop procedure MRK_deleteWithdrawal
1> 
2> create procedure MRK_deleteWithdrawal
3> 	@oldKey integer,
4> 	@refKey integer,
5> 	@eventReasonKey integer
6> as
7> 
8> /*
9>  * This procedure will process a delete withdrawal.
10>  * A delete marker withdrawal requires:
11>  *	a) the "old" marker key
12>  *	b) a reference key
13>  *
14> */
15> 
16> declare @oldSymbol varchar(25)
17> declare @oldName varchar(255)
18> select @oldSymbol = symbol,
19>        @oldName = name 
20> from MRK_Marker where _Marker_key = @oldKey 
21>      and _Species_key = 1
22>      and _Marker_Status_key = 1
23> 
24> if @oldSymbol is null
25> begin
26> 	raiserror 99999 "Invalid Old Symbol Key %1!", @oldKey
27> 	rollback transaction
28> 	return
29> end
30> 
31> /* Update MGD offset of old symbol */
32> 
33> update MRK_Offset set offset = -999.0 where _Marker_key = @oldKey and source = 0
34> 
35> if @@error != 0
36> begin
37> 	raiserror 99999 "Could not update offset of old symbol in MRK_deleteWithdrawal"
38> 	rollback transaction
39> 	return
40> end
41> 
42> /* Update Marker info */
43> 
44> update MRK_Marker
45> set name = "withdrawn", _Marker_Status_key = 2
46> where _Marker_key = @oldKey
47> 
48> if @@error != 0
49> begin
50> 	raiserror 99999 "Could not update marker in MRK_deleteWithdrawal"
51> 	rollback transaction
52> 	return
53> end
54> 
55> /* Add History line for withdrawal */
56> exec MRK_insertHistory @oldKey, @oldKey, @refKey, 6, @eventReasonKey, @oldName
57> 
58> if @@error != 0
59> begin
60> 	raiserror 99999 "Could not add history in MRK_deleteWithdrawal"
61> 	rollback transaction
62> 	return
63> end
64> 
1> 
2> grant execute on MRK_deleteWithdrawal to cml, ljm, lmm
1> 
2> grant execute on MRK_deleteWithdrawal to progs
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop procedure PRB_getStrainReferences
1>  
2> create procedure PRB_getStrainReferences
3>   @strainKey int,
4>   @countOnly int = 0
5> as
6> 
7> /* Select all References and Data Sets for given Strain */
8>  
9> select distinct e._Refs_key, dataSet = 'Mapping'
10> into #references
11> from MLD_Expts e, MLD_InSitu m
12> where e._Expt_key = m._Expt_key
13> and m._Strain_key = @strainKey
14> union
15> select distinct e._Refs_key, dataSet = 'Mapping'
16> from MLD_Expts e, MLD_FISH m
17> where e._Expt_key = m._Expt_key
18> and m._Strain_key = @strainKey
19> union
20> select distinct e._Refs_key, dataSet = 'Mapping'
21> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
22> where e._Expt_key = m._Expt_key
23> and m._Cross_key = c._Cross_key
24> and c._femaleStrain_key = @strainKey
25> union
26> select distinct e._Refs_key, dataSet = 'Mapping'
27> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
28> where e._Expt_key = m._Expt_key
29> and m._Cross_key = c._Cross_key
30> and c._maleStrain_key = @strainKey
31> union
32> select distinct e._Refs_key, dataSet = 'Mapping'
33> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
34> where e._Expt_key = m._Expt_key
35> and m._Cross_key = c._Cross_key
36> and c._StrainHO_key = @strainKey
37> union
38> select distinct e._Refs_key, dataSet = 'Mapping'
39> from MLD_Expts e, MLD_Matrix m, CRS_Cross c
40> where e._Expt_key = m._Expt_key
41> and m._Cross_key = c._Cross_key
42> and c._StrainHT_key = @strainKey
43> union
44> select distinct a._Refs_key, dataSet = 'Expression'
45> from GXD_Genotype s, GXD_Expression x, GXD_Assay a
46> where s._Strain_key = @strainKey
47> and s._Genotype_key = x._Genotype_key
48> and x._Assay_key = a._Assay_key
49> union
50> select distinct r._Refs_key, dataSet = 'RFLP'
51> from PRB_Reference r, PRB_RFLV v, PRB_Allele a, PRB_Allele_Strain s
52> where r._Reference_key = v._Reference_key
53> and v._RFLV_key = a._RFLV_key
54> and a._Allele_key = s._Allele_key
55> and s._Strain_key = @strainKey
56> union
57> select distinct _Refs_key, dataSet = 'Allele'
58> from ALL_Allele
59> where _Strain_key = @strainKey
60>  
61> if @countOnly = 1
62> begin
63> 	select count(*) from #references
64> end
65> else
66> begin
67> 	select a.jnumID, r.dataSet
68> 	from #references r, BIB_View a
69> 	where r._Refs_key = a._Refs_key
70> 	order by a.jnum
71> end
72> 
1> 
2> grant execute on PRB_getStrainReferences to public
1>  
2> drop procedure PRB_getStrainDataSets
1>  
2> create procedure PRB_getStrainDataSets
3>   @strainKey int,
4>   @countOnly int = 0
5> as
6> 
7> /* Select all Probes and Data Sets for given Strain */
8>  
9> select _Source_key, _Strain_key
10> into #source from PRB_Source
11> where _Strain_key = @strainKey
12> order by _Source_key
13> 
14> if (select count(*) from #source) = 0
15> begin
16> 	return
17> end
18> 
19> create unique clustered index index_Source_key on #source(_Source_key) with sorted_data
20> 
21> select p._Probe_key, dataSet = 'Molecular Segment'
22> into #probes
23> from PRB_Probe p, #source s
24> where p._Source_key = s._Source_key
25> union
26> select a._Antigen_key, dataSet = 'Antigen'
27> from GXD_Antigen a, #source s
28> where a._Source_key = s._Source_key
29> union
30> select a._Allele_key, dataSet = 'Allele'
31> from ALL_Allele a, #source s
32> where a._Strain_key = s._Strain_key
33> 
34> 
35> if @countOnly = 1
36> begin
37> 	select count(*) from #probes
38> end
39> else
40> begin
41> 	select a.accID, p.dataSet
42> 	from #probes p, PRB_Acc_View a
43> 	where p.dataSet = 'Molecular Segment'
44> 	and p._Probe_key = a._Object_key
45> 	and a.prefixPart = 'MGI:'
46> 	and a.preferred = 1
47> 	union
48> 	select a.accID, p.dataSet
49> 	from #probes p, GXD_Antigen_Acc_View a
50> 	where p.dataSet = 'Antigen'
51> 	and p._Probe_key = a._Object_key
52> 	and a.prefixPart = 'MGI:'
53> 	and a.preferred = 1
54> 	union
55> 	select a.accID, p.dataset
56> 	from #probes p, ALL_Acc_View a
57> 	where p.dataSet = 'Allele'
58> 	and a.prefixPart = 'MGI:'
59> 	and a.preferred = 1
60> 	order by a.accID
61> end
62> 
1> 
2> grant execute on PRB_getStrainDataSets to public
1>  
2> drop procedure PRB_mergeTissue
1>  
2> create procedure PRB_mergeTissue
3>   @oldTissueKey int,
4>   @newTissueKey int
5> as
6> 
7> /*
8>  * Update old Tissue key to new Tissue key
9>  * in all relevant tables which contain a Tissue key.
10>  * When finished, remove the Tissue record for the old
11>  * Tissue key.
12> */
13> 
14> update PRB_Source
15> set _Tissue_key = @newTissueKey
16> where _Tissue_key = @oldTissueKey
17> 
18> delete from PRB_Tissue
19> where _Tissue_key = @oldTissueKey
20> 
1> 
2> grant execute on PRB_mergeTissue to editors
1>  
2> grant execute on PRB_mergeTissue to progs
1>  
2> drop procedure PRB_mergeStandardTissue
1>  
2> create procedure PRB_mergeStandardTissue
3>   @tissue varchar(255),
4>   @fromStandard int = 0,
5>   @toStandard int = 1
6> as
7>  
8> /* Given a Tissue, merge all of the records into one Tissue.
9>  *
10>  * Merge all Non-Standard Tissues into the Standard Tissue (default)
11>  * (exec PRB_mergeStandardTissue "Tissue")
12>  *
13>  * OR
14>  *
15>  * Merge all Standard Tissues into the Non-Standard Tissue
16>  * (exec PRB_mergeStandardTissue "Tissue", 1, 0)
17>  *
18> */
19> 
20> declare @newTissueKey integer
21> declare @oldTissueKey integer
22> 
23> if (select count(_Tissue_key) from PRB_Tissue
24>     where tissue = @tissue and standard = @toStandard) > 1
25> begin
26> 	rollback transaction
27> 	raiserror 99999 "More than one designation exists for Tissue: %1!", @tissue
28> 	return
29> end
30> 
31> if (select count(_Tissue_key) from PRB_Tissue
32>     where tissue = @tissue and standard = @toStandard) = 0
33> begin
34> 	rollback transaction
35> 	raiserror 99999 "No correct designation exists for Tissue: %1!", @tissue
36> 	return
37> end
38> 
39> select @newTissueKey = _Tissue_key from PRB_Tissue
40> where tissue = @tissue and standard = @toStandard
41> 
42> declare tissue_cursor cursor for
43> select _Tissue_key
44> from PRB_Tissue
45> where tissue = @tissue and standard = @fromStandard
46> for read only
47>  
48> open tissue_cursor
49>  
50> fetch tissue_cursor into @oldTissueKey
51>  
52> while (@@sqlstatus = 0)
53> begin
54> 	exec PRB_mergeTissue @oldTissueKey, @newTissueKey
55>         fetch tissue_cursor into @oldTissueKey
56> end
57>  
58> close tissue_cursor
59>  
60> deallocate cursor tissue_cursor
61>  
1> 
2> grant execute on PRB_mergeStandardTissue to editors
1>  
2> grant execute on PRB_mergeStandardTissue to progs
1>  
2> drop procedure PRB_getTissueDataSets
1>  
2> create procedure PRB_getTissueDataSets
3>   @tissueKey int,
4>   @countOnly int = 0
5> as
6> 
7> /* Select all Data Sets for given Tissue */
8>  
9> select _Source_key into #source from PRB_Source
10> where _Tissue_key = @tissueKey
11> order by _Source_key
12> 
13> if (select count(*) from #source) = 0
14> begin
15> 	return
16> end
17> 
18> create unique clustered index index_Source_key on #source(_Source_key) with sorted_data
19> 
20> select dataKey = p._Probe_key, dataSet = 'Molecular Segment'
21> into #datasets
22> from PRB_Probe p, #source s
23> where p._Source_key = s._Source_key
24> union
25> select dataKey = a._Antigen_key, dataSet = 'Antigen'
26> from GXD_Antigen a, #source s
27> where a._Source_key = s._Source_key
28> 
29> if @countOnly = 1
30> begin
31> 	select count(*) from #datasets
32> end
33> else
34> begin
35> 	select a.accID, d.dataSet, a.numericPart
36> 	from #datasets d, PRB_Acc_View a
37> 	where d.datakey = a._Object_key
38> 	and a.prefixPart = 'MGI:'
39> 	and a.preferred = 1
40> 	union
41> 	select a.accID, d.dataSet, a.numericPart
42> 	from #datasets d, GXD_Antigen_Acc_View a
43> 	where d.datakey = a._Object_key
44> 	and a.prefixPart = 'MGI:'
45> 	and a.preferred = 1
46> 	order by a.numericPart
47> end
48> 
1> 
2> grant execute on PRB_getTissueDataSets to public
1>  
2> checkpoint
1> 
2> drop procedure PRB_insertReference
1> 
2> create procedure PRB_insertReference
3> 	@refKey integer,
4> 	@probeKey integer,
5> 	@holder varchar(40)
6> as
7> 
8> /* Insert record into PRB_Reference if _Refs_key/_Probe_key pair does not already exist */
9> 
10> if (select count(*) from PRB_Reference 
11> 	where _Refs_key = @refKey and _Probe_key = @probeKey) > 0
12> begin
13> 	return
14> end
15> 
16> declare @maxReferenceKey integer
17> select @maxReferenceKey = max(_Reference_key) + 1 from PRB_Reference
18> 
19> insert into PRB_Reference
20> values (@maxReferenceKey, @probeKey, @refKey, @holder, 0, 0, getdate(), getdate())
21> 
1> 
2> grant execute on PRB_insertReference to editors
1> 
2> grant execute on PRB_insertReference to progs
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop procedure MRK_insertHistory
1>  
2> create procedure MRK_insertHistory
3>   @markerKey integer,
4>   @historyKey integer,
5>   @refKey integer,
6>   @eventKey integer,
7>   @eventReasonKey integer,
8>   @name varchar(255) = null,
9>   @event_date datetime = null
10> as
11>  
12> /* Insert new History record into MRK_History */
13>  
14> declare @maxSeq int
15> select @maxSeq = max(sequenceNum) from MRK_History where _Marker_key = @markerKey
16> 
17> if @maxSeq is null
18> begin
19> 	select @maxSeq = 0
20> end
21> 
22> if @event_date is null
23> begin
24> 	select @event_date = getdate()
25> end
26>  
27> insert MRK_History 
28> (_Marker_key, _History_key, _Refs_key, _Marker_Event_key, _Marker_EventReason_key, sequenceNum, name, event_date)
29> values(@markerKey, @historyKey, @refKey, @eventKey, @eventReasonKey, @maxSeq + 1, @name, @event_date)
30> 
1>  
2> grant execute on MRK_insertHistory to cml, djr, ljm, rmb
1>  
2> grant execute on MRK_insertHistory to progs
1>  
2> drop procedure MRK_MaxOffset
1> 
2> create procedure MRK_MaxOffset
3> 	@chromosome varchar(2),
4> 	@source int 
5> as
6> 
7> select maxOffset = max(o.offset)
8> from MRK_Offset o, MRK_Marker m
9> where o._Marker_key = m._Marker_key
10> and o.source = @source 
11> and m.chromosome = @chromosome 
12> and m._Species_key = 1
13> 
1> 
2> grant execute on MRK_MaxOffset to public
1> 
2> drop procedure MRK_MiniMapMarkers
1> 
2> create procedure MRK_MiniMapMarkers
3> 	@_Marker_key int,
4> 	@source int 
5> as
6> 
7> /* retrieve data for all anchor markers on the chromosome */
8> 
9> select distinct m._Marker_key, m.symbol, m.name, m.chromosome, o.offset, m.cytogeneticOffset
10> from MRK_Marker m, MRK_Offset o, MRK_Anchors a
11> where m._Marker_key = a._Marker_key
12> 	and o.source = @source
13> 	and o._Marker_key = m._Marker_key
14> 	and o.offset > -1.0
15> 	and a.chromosome = (select m.chromosome 
16> 	from MRK_Marker m
17> 	where m._Marker_key = @_Marker_key)
18> 
19> union
20> 
21> /* get the data for the marker itself */
22> 
23> select distinct m._Marker_key, m.symbol, m.name, m.chromosome, o.offset, m.cytogeneticOffset
24> from MRK_Marker m, MRK_Offset o
25> where m._Marker_key = @_Marker_key
26> 	and o.source = @source
27> 	and o._Marker_key = m._Marker_key
28> 	and o.offset > -1.0
1> 
2> grant execute on MRK_MiniMapMarkers to public
1> 
2> drop procedure MRK_isAnchor
1>  
2> create procedure MRK_isAnchor
3>   @key int
4> as
5> 
6> /* Determine if Marker key exists in MRK_Anchors table */
7> 
8> declare @found int
9> select @found = count(*) from MRK_Anchors where _Marker_key = @key
10> select @found
11> 
1> 
2> grant execute on MRK_isAnchor to public
1>  
2> drop procedure MRK_breakpointSplit
1> 
2> create procedure MRK_breakpointSplit
3>   @markerKey integer,
4>   @distalCytoBand varchar(20) = null
5> as
6> 
7> /* See TR#120; procedure to split cytogenetic marker into 2 distinct markers */
8> 
9> declare @band varchar(20)
10> declare @symbol varchar(25)
11> declare @name varchar(255)
12> declare @markerType integer
13> declare @idx integer
14> 
15> select @symbol = symbol, @band = cytogeneticOffset, @name = name, @markerType = _Marker_Type_key
16> from MRK_Marker where _Marker_key = @markerKey
17> 
18> if @markerType != 3
19> begin
20> 	rollback transaction
21> 	raiserror 99999 "Invalid Marker for Breakpoint Split: %1!", @symbol
22> 	return
23> end
24> 
25> select @idx = charindex(" & ", @band)
26> 
27> declare @proximalBand varchar(20)
28> declare @distalBand varchar(20)
29> 
30> declare @proximalSymbol varchar(25)
31> declare @distalSymbol varchar(25)
32> 
33> declare @proximalName varchar(255)
34> declare @distalName varchar(255)
35> 
36> declare @proximalKey integer
37> declare @distalKey integer
38> 
39> /* If symbol band is not in the format 'X & Y', then distal band remains NULL */
40> 
41> if @idx = 0
42> begin
43> 	select @proximalBand = @band
44> 	/* distal band is null */
45> end
46> else
47> begin
48> 	select @proximalBand = substring(@band, 1, @idx - 1)
49> 	select @distalBand = substring(@band, @idx + 3, char_length(@band))
50> end
51> 
52> /* If caller supplies a distal band, use it */
53> 
54> if @distalCytoBand is not null
55> begin
56> 	select @distalBand = @distalCytoBand
57> end
58> 
59> select @proximalSymbol = @symbol + "-p"
60> select @proximalName = @name + ", proximal"
61> select @proximalKey = @markerKey
62> 
63> select @distalSymbol = @symbol + "-d"
64> select @distalName = @name + ", distal"
65> select @distalKey = max(_Marker_key) + 1 from MRK_Marker
66> 
67> /* Update the symbol, name and cytogenetic offset for the current Marker to the proximal symbol */
68> 
69> update MRK_Marker
70> set symbol = @proximalSymbol,
71>     name = @proximalName,
72>     cytogeneticOffset = @proximalBand
73> where _Marker_key = @proximalKey
74> 
75> update MRK_History
76> set name = @proximalName
77> where _Marker_key = @proximalKey
78> and name = @name
79> 
80> /* Copy proximal symbol info to a new distal symbol */
81> 
82> insert into MRK_Marker 
83> (_Marker_key, _Species_key, _Marker_Status_key, _Marker_Type_key, symbol, name, chromosome, cytogeneticOffset)
84> select @distalKey, _Species_key, _Marker_Status_key, _Marker_Type_key, 
85> @distalSymbol, @distalName, chromosome, @distalBand
86> from MRK_Marker where _Marker_key = @proximalKey
87> 
88> exec ACC_assignMGI @distalKey, "Marker"
89> 
90> /* Notes */
91> insert into MRK_Notes
92> (_Marker_key, sequenceNum, note)
93> select @distalKey, sequenceNum, note
94> from MRK_Notes where _Marker_key = @proximalKey
95> 
96> /* Offset */
97> insert into MRK_Offset
98> (_Marker_key, source, offset)
99> select @distalKey, source, offset
100> from MRK_Offset where _Marker_key = @proximalKey
101> 
102> /* References */
103> insert into MRK_Reference
104> (_Marker_key, _Refs_key, auto)
105> select @distalKey, _Refs_key, auto
106> from MRK_Reference where _Marker_key = @proximalKey
107> 
108> /* History */
109> insert into MRK_History
110> (_Marker_key, _Marker_Event_key, _Marker_EventReason_key, _History_key, _Refs_key, sequenceNum, name, event_date)
111> select @distalKey, _Marker_Event_key, _Marker_EventReason_key, _History_key, _Refs_key, sequenceNum, name, event_date
112> from MRK_History where _Marker_key = @proximalKey and _History_key != @proximalKey
113> 
114> insert into MRK_History
115> (_Marker_key, _Marker_Event_key, _Marker_EventReason_key, _History_key, _Refs_key, sequenceNum, name, event_date)
116> select @distalKey, _Marker_Event_key, _Marker_EventReason_key, @distalKey, _Refs_key, sequenceNum, @distalName, event_date
117> from MRK_History where _Marker_key = @proximalKey and _History_key = @proximalKey
118> 
119> /* Other Names */
120> select seq = identity(5), name, _Refs_key
121> into #otherTmp
122> from MRK_Other where _Marker_key = @proximalKey
123> 
124> declare @maxOther int
125> select @maxOther = max(_Other_key) from MRK_Other
126> 
127> insert into MRK_Other
128> (_Other_key, _Marker_key, _Refs_key, name)
129> select @maxOther + seq, @distalKey, _Refs_key, name
130> from #otherTmp
131>  
132> /* Accession Numbers */
133> /* Copy all nonMGI preferred Accession numbers of proximal symbol to distal symbol */
134> 
135> select seq = identity(5), a.*
136> into #accTmp
137> from ACC_Accession a where a._Object_key = @proximalKey
138> and a._MGIType_key = 2
139> 
140> declare @maxAcc int
141> select @maxAcc = max(_Accession_key) from ACC_Accession
142> 
143> insert into ACC_Accession
144> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
145> select @maxAcc + seq, accID, prefixPart, numericPart, _LogicalDB_key, @distalKey, _MGIType_key,
146> private, preferred
147> from #accTmp
148> where prefixPart != "MGI:" and preferred != 1
149>  
150> /* Insert Other Name entries for both proximal and distal symbols */
151> 
152> declare @otherKey int
153> select @otherKey = max(_Other_key) + 1 from MRK_Other
154> insert into MRK_Other values(@otherKey, @proximalKey, NULL, @symbol, getdate(), getdate())
155> insert into MRK_Other values(@otherKey + 1, @distalKey, NULL, @symbol, getdate(), getdate())
156> 
157> select @proximalKey, @proximalSymbol
158> select @distalKey, @distalSymbol
159> 
1> 
2> grant execute on MRK_breakpointSplit to djr, ljm, rmb
1> 
2> grant execute on MRK_breakpointSplit to progs
1> 
2> drop procedure MRK_addChromosome
1> 
2> create procedure MRK_addChromosome
3>   @speciesKey integer,
4>   @chromosome varchar(8)
5> as
6> 
7> /* If Chromosome for given Species does not exist in MRK_Chromosome, */
8> /* then insert the chromosome into MRK_Chromosome. */
9> /* MRK_Chromosome is used to sequentially order the Chromosome values within */
10> /* a given Species for sorting in Homology, reports, Oxford Grids, etc. */
11> 
12> if (select count(*) from MRK_Chromosome
13>     where _Species_key = @speciesKey and chromosome = @chromosome) = 0
14> begin
15>         /* Get next available sequence number */
16>         declare @nextseq integer
17> 
18>         select @nextseq = max(sequenceNum) + 1 
19>         	from MRK_Chromosome
20>         	where _Species_key = @speciesKey
21> 
22>         if @nextseq is NULL or @nextseq = 0
23>         begin
24>         	select @nextseq = 1
25>         end
26> 
27>         insert into MRK_Chromosome (_Species_key, chromosome, sequenceNum)
28> 	values(@speciesKey, @chromosome, @nextseq)
29> 
30> end
1> 
2> grant execute on MRK_addChromosome to editors
1> 
2> grant execute on MRK_addChromosome to progs
1> 
2> drop procedure MRK_updateIMAGESeqAssoc
1>  
2> create procedure MRK_updateIMAGESeqAssoc
3>   @markerKey integer,
4>   @accID varchar(30)
5> as
6>  
7> /* TR 1270
8>  *
9>  * update/add marker/clone/E association
10>  * if accID exists for IMAGE clone
11>  *
12>  * see TR for more specific details
13> */
14> 
15> declare @cloneKey integer
16> 
17> select @cloneKey = p._Probe_key
18> from PRB_Probe p, PRB_Acc_View a
19> where p.name = 'I.M.A.G.E. clone'
20> and p._Probe_key = a._Object_key
21> and a._LogicalDB_key = 9
22> and a.accID = @accID
23> 
24> /* @accID is not attached to an IMAGE clone. do nothing. */
25> if @cloneKey is null
26> begin
27> 	return
28> end
29> 
30> /* if another "E" marker exists for the clone, print message and return */
31> 
32> if exists (select 1 from PRB_Marker 
33> 	where _Probe_key = @cloneKey
34> 	and _Marker_key != @markerKey
35> 	and relationship = 'E')
36> begin
37> 	print "The Clone/Sequence Accession number %1! has an encodes relationship with another Marker.", @accID
38> 	return
39> end
40> 
41> /* 
42>  * if clone/marker relationship exists, update to 'E'
43>  * else insert clone/marker/E relationship record
44> */
45> 
46> if exists (select 1 from PRB_Marker 
47> 	where _Probe_key = @cloneKey
48> 	and _Marker_key = @markerKey)
49> begin
50> 	update PRB_Marker set relationship = 'E', modification_date = getdate()
51> 	where _Probe_key = @cloneKey
52> 	and _Marker_key = @markerKey
53> end
54> else
55> begin
56> 	insert into PRB_Marker values(@cloneKey, @markerKey, 'E', getdate(), getdate())
57> end
58> 
59> /* delete all putative associations for clone */
60> 
61> delete from PRB_Marker where _Probe_key = @cloneKey and relationship = 'P'
62> 
1> 
2> grant execute on MRK_updateIMAGESeqAssoc to editors
1>  
2> grant execute on MRK_updateIMAGESeqAssoc to progs
1>  
2> drop procedure MRK_deleteIMAGESeqAssoc
1>  
2> create procedure MRK_deleteIMAGESeqAssoc
3>   @markerKey integer,
4>   @accID varchar(30)
5> as
6> 
7> /* TR 1270
8>  *
9>  * delete marker/clone/E association
10>  * if accID exists for IMAGE clone
11>  *
12>  * see TR for more specific details
13> */
14> 
15> declare @cloneKey integer
16> 
17> select @cloneKey = p._Probe_key
18> from PRB_Probe p, PRB_Acc_View a
19> where p.name = 'I.M.A.G.E. clone'
20> and p._Probe_key = a._Object_key
21> and a._LogicalDB_key = 9
22> and a.accID = @accID
23> 
24> /* @accID is not attached to an IMAGE clone. do nothing. */
25> if @cloneKey is null
26> begin
27> 	return
28> end
29> 
30> /* if @accid is still attached to the marker, do nothing. */
31> 
32> if exists (select 1 from MRK_Acc_View 
33> where _Object_key = @markerKey
34> and accID = @accID)
35> begin
36> 	return
37> end
38> 
39> delete from PRB_Marker 
40> where _Probe_key = @cloneKey
41> and _Marker_key = @markerKey
42> and relationship = "E"
43> 
1> 
2> grant execute on MRK_deleteIMAGESeqAssoc to editors
1>  
2> grant execute on MRK_deleteIMAGESeqAssoc to progs
1>  
2> drop procedure MRK_reloadLabel
1> 
2> create procedure MRK_reloadLabel
3> 	@markerKey integer
4> as
5> 
6> /* Delete all MRK_Label records for a Marker and regenerate */
7> 
8> delete from MRK_Label where _Marker_key = @markerKey
9> 
10> declare marker_cursor cursor for
11> select _Marker_Status_key, _Species_key, symbol, labelType = "S"
12> from MRK_Marker
13> where _Marker_key = @markerKey
14> union
15> select _Marker_Status_key, _Species_key, name, labelType = "N"
16> from MRK_Marker
17> where _Marker_key = @markerKey
18> union
19> select distinct m2._Marker_Status_key, m2._Species_key, m2.symbol, labelType = "S" 
20> from MRK_History h, MRK_Marker m, MRK_Marker m2 
21> where h._Marker_key = @markerKey
22> and h._Marker_key = m._Marker_key 
23> and h._History_key = m2._Marker_key 
24> union
25> select distinct m2._Marker_Status_key, m2._Species_key, h.name, labelType = "N" 
26> from MRK_History h, MRK_Marker m, MRK_Marker m2 
27> where h._Marker_key = @markerKey
28> and h.name is not null 
29> and h._Marker_key = m._Marker_key 
30> and h._History_key = m2._Marker_key 
31> union
32> select distinct -2, 1, o.name, labelType = "Y" 
33> from MRK_Other o
34> where o._Marker_key = @markerKey
35> for read only
36> 
37> open marker_cursor
38> 
39> declare @statusKey integer
40> declare @speciesKey integer
41> declare @label varchar(255)
42> declare @labelType char(1)
43> 
44> fetch marker_cursor into @statusKey, @speciesKey, @label, @labelType
45> 
46> while (@@sqlstatus = 0)
47> begin
48> 	insert into MRK_Label (_Marker_key, _Marker_Status_key, _Species_key, label, labelType)
49> 	values (@markerKey, @statusKey, @speciesKey, @label, @labelType)
50> 
51> 	if @@error != 0
52> 	begin
53> 		rollback transaction
54> 		raiserror 99999 "Could Re-load Marker Label"
55> 		return
56> 	end
57> 
58> 	fetch marker_cursor into @statusKey, @speciesKey, @label, @labelType
59> end
60> 
61> close marker_cursor
62> deallocate cursor marker_cursor
63> 
1> 
2> grant execute on MRK_reloadLabel to editors
1> 
2> grant execute on MRK_reloadLabel to progs
1> 
2> drop procedure MRK_reloadReference
1> 
2> create procedure MRK_reloadReference
3> 	@markerKey integer
4> as
5> 
6> /* Select all unique Marker/Reference pairs */
7> 
8> declare marker_cursor cursor for
9> select distinct r._Refs_key, auto = 1 
10> from PRB_Marker m, PRB_Reference r 
11> where m._Marker_key = @markerKey
12> and m._Probe_key = r._Probe_key 
13> union 
14> select distinct h._Refs_key, auto = 1 
15> from HMD_Homology_Marker hm, HMD_Homology h 
16> where hm._Marker_key = @markerKey
17> and hm._Homology_key = h._Homology_key 
18> union 
19> select distinct _Refs_key, auto = 1 
20> from MRK_History
21> where _Marker_key = @markerKey
22> and _Refs_key is not null 
23> union 
24> select distinct _Refs_key, auto = 1 
25> from MLD_Marker 
26> where _Marker_key = @markerKey
27> union 
28> select distinct _Refs_key, auto = 1 
29> from GXD_Index 
30> where _Marker_key = @markerKey
31> union 
32> select distinct _Refs_key, auto = 1 
33> from GXD_Assay 
34> where _Marker_key = @markerKey
35> union 
36> select distinct _Refs_key, auto = 1 
37> from MRK_Other 
38> where _Marker_key = @markerKey
39> and _Refs_key is not null 
40> union 
41> select distinct ar._Refs_key, auto = 1 
42> from ACC_Accession a, ACC_AccessionReference ar 
43> where a._Object_key = @markerKey
44> and a._MGIType_key = 2 
45> and a.private = 0
46> and a._Accession_key = ar._Accession_key 
47> union 
48> select distinct _Refs_key, auto = 0 
49> from MRK_Reference
50> where _Marker_key = @markerKey and auto = 0
51> for read only
52> 
53> open marker_cursor
54> 
55> delete from MRK_Reference where _Marker_key = @markerKey
56> 
57> declare @refKey integer
58> declare @auto bit
59> 
60> fetch marker_cursor into @refKey, @auto
61> 
62> while (@@sqlstatus = 0)
63> begin
64> 	if not exists (select * from MRK_Reference where _Marker_key = @markerKey
65> 		and _Refs_key = @refKey)
66> 	begin
67> 		insert into MRK_Reference (_Marker_key, _Refs_key, auto)
68> 		values (@markerKey, @refKey, @auto)
69> 
70> 		if @@error != 0
71> 		begin
72> 			rollback transaction
73> 			raiserror 99999 "Could Re-load Marker Reference"
74> 			return
75> 		end
76> 	end
77> 
78> 	fetch marker_cursor into @refKey, @auto
79> end
80> 
81> close marker_cursor
82> deallocate cursor marker_cursor
83> 
1> 
2> grant execute on MRK_reloadReference to editors
1> 
2> grant execute on MRK_reloadReference to progs
1> 
2> checkpoint
Password: 
1> 
2> use mgd_release
1> 
2> checkpoint
1> 
2> drop procedure ACC_resetMax
1> 
2> create procedure ACC_resetMax
3>   @objectKey int,
4>   @mgiType varchar(80),
5>   @prefixPart varchar(20) = "MGI:"
6> as
7> 
8> /* If deleting object which is using the maxNumericPart 
9>    from ACC_AccessionMax, then reset the maxNumericPart
10>    so there aren't so many holes.  During withdrawals,
11>    new Marker symbols may not receive MGI accession numbers,
12>    but the MRK_Marker insert trigger will always insert one
13> */
14> 
15> declare @numericPart int
16> select @numericPart = a.numericPart 
17> from ACC_Accession a, ACC_MGIType m
18> where a._Object_key = @objectKey
19> and a.prefixPart = @prefixPart
20> and a._MGIType_key = m._MGIType_key
21> and m.name = @mgiType
22> 
23> if (select maxNumericPart from ACC_AccessionMax where prefixPart = @prefixPart) = @numericPart
24> begin
25> 	update ACC_AccessionMax
26> 	set maxNumericPart = maxNumericPart - 1
27> 	where prefixPart = @prefixPart
28> end
29> 
1> 
2> grant execute on ACC_resetMax to progs
1> 
2> grant execute on ACC_resetMax to editors
1> 
2> drop procedure ACC_findMax
1> 
2> create procedure ACC_findMax
3>   @prefixPart varchar(20) = "MGI:"
4> as
5> 
6> /* Return maxNumericPart for given prefixPart */
7> 
8> select maxNumericPart
9> from ACC_AccessionMax
10> where prefixPart = @prefixPart
1> 
2> grant execute on ACC_findMax to progs
1> 
2> grant execute on ACC_findMax to editors
1> 
2> grant execute on ACC_findMax to public
1> 
2> drop procedure ACC_setMax
1> 
2> create procedure ACC_setMax
3>   @increment integer,
4>   @prefixPart varchar(20) = "MGI:"
5> as
6> 
7> /* Increment the max MGI Accession Number by @increment */
8> 
9> update ACC_AccessionMax
10> set maxNumericPart = maxNumericPart + @increment
11> where prefixPart= @prefixPart
12> 
1> 
2> grant execute on ACC_setMax to progs
1> 
2> drop procedure ACC_reserveMGIBlock
1> 
2> create procedure ACC_reserveMGIBlock
3>   @blockOf integer
4> as
5> 
6> /* Reserve blocks of Accession IDs for IMAGE consortium, etc. */
7> 
8> select maxNumericPart + 1 "BEGIN BLOCK"
9> from ACC_AccessionMax
10> where prefixPart = "MGI:"
11> 
12> select @blockOf = @blockOf + 1
13> exec ACC_setMax @blockOf
14> 
15> select maxNumericPart "END BLOCK"
16> from ACC_AccessionMax
17> where prefixPart = "MGI:"
18> 
1> 
2> grant execute on ACC_reserveMGIBlock to progs
1> 
2> drop procedure ACC_assignMGI
1> 
2> create procedure ACC_assignMGI
3>   @objectKey int,
4>   @mgiType varchar(80),
5>   @prefixPart varchar(20) = "MGI:",
6>   @nextMGI int = -1,
7>   @preferred int = 1
8> as
9> 
10> /* Assign MGI or J accession number
11>    Allow override of J accession number
12>    Increment ACC_AccessionMax.maxNumericPart
13> */
14> 
15> declare @nextACC int
16> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
17> 
18> declare @mgiTypeKey int
19> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
20> 
21> if @nextMGI = -1
22> begin
23> 	select @nextMGI = maxNumericPart + 1 
24> 	from ACC_AccessionMax where prefixPart = @prefixPart
25> end
26> else if @prefixPart != "J:"
27> begin
28>     rollback transaction
29>     raiserror 99999 "Cannot override generation of MGI accession number"
30>     return
31> end
32> 
33> declare @accID varchar(30)
34> select @accID = @prefixPart + convert(varchar(20), @nextMGI)
35> 
36> insert into ACC_Accession 
37> (_Accession_key, accID, prefixPart, numericPart, 
38> _LogicalDB_key, _Object_key, _MGIType_key, preferred)
39> values(@nextACC, @accID, @prefixPart, @nextMGI, 1, @objectKey, @mgiTypeKey, @preferred)
40> 
41> if (select maxNumericPart from ACC_AccessionMax
42>     where prefixPart = @prefixPart) <= @nextMGI
43> begin
44> 	update ACC_AccessionMax 
45> 	set maxNumericPart = @nextMGI 
46> 	where prefixPart = @prefixPart
47> end
48> 
1> 
2> grant execute on ACC_assignMGI to progs
1> 
2> grant execute on ACC_assignMGI to editors
1> 
2> drop procedure ACC_assignJ
1> 
2> create procedure ACC_assignJ
3>   @objectKey int,
4>   @nextMGI int = -1
5> as
6> 
7> if @nextMGI != -1
8> begin
9> 	declare @exists int
10> 	select @exists = count(*) from BIB_Acc_View
11>                where prefixPart = "J:" and 
12> 	       numericPart = @nextMGI
13> 	if @exists > 0
14> 	begin
15>   		rollback transaction
16>   		raiserror 99999 "This J Number is already in use"
17>   		return
18> 	end
19> end
20> 
21> exec ACC_assignMGI @objectKey, "Reference", "J:", @nextMGI
22> 
1> 
2> grant execute on ACC_assignJ to progs
1> 
2> grant execute on ACC_assignJ to editors
1> 
2> drop procedure ACCRef_insert
1>  
2> create procedure ACCRef_insert
3>   @accKey int,
4>   @refsKey int
5> as
6>  
7> /* Insert record into ACC_AccessionReference table */
8> 
9> insert into ACC_AccessionReference
10> (_Accession_key, _Refs_key)
11> values(@accKey, @refsKey)
12> 
1>  
2> grant execute on ACCRef_insert to progs
1>  
2> grant execute on ACCRef_insert to editors
1>  
2> drop procedure ACC_insert
1>  
2> create procedure ACC_insert
3>   @objectKey int,
4>   @accID varchar(30),
5>   @logicalDB int,
6>   @mgiType varchar(80),
7>   @refsKey int = -1,
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* Insert record into master Accession table. */
13> /* If reference is given, insert record into Accession Reference table. */
14> 
15> if @accID is null
16> 	return
17> 
18> declare @nextACC int
19> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
20>  
21> declare @mgiTypeKey int
22> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
23>  
24> declare @prefixPart varchar(20)
25> declare @numericPart int
26> exec ACC_split @accID, @prefixPart out, @numericPart out
27> 						      
28> insert into ACC_Accession
29> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
30> values(@nextACC, @accID, @prefixPart, @numericPart, @logicalDB, @objectKey, @mgiTypeKey, @private, @preferred)
31> 
32> if @refsKey != -1
33> begin
34> 	exec ACCRef_insert @nextACC, @refsKey
35> end
36> 
1>  
2> grant execute on ACC_insert to progs
1>  
2> grant execute on ACC_insert to editors
1>  
2> drop procedure ACC_insert_bySpecies
1>  
2> create procedure ACC_insert_bySpecies
3>   @objectKey int,
4>   @accID varchar(30),
5>   @speciesKey int
6> as
7>  
8> /* Insert record into master Accession table for a given species */
9> 
10> if @accID is null
11> 	return
12> 
13> declare @logicalDBKey int
14> select @logicalDBKey = _LogicalDB_key from ACC_LogicalDB 
15> where _Species_key = @speciesKey
16>  
17> declare @private int
18> select @private = 0
19> 
20> exec ACC_insert @objectKey, @accID, @logicalDBKey, "Marker", -1, 1, @private
21>  
1>  
2> grant execute on ACC_insert_bySpecies to progs
1>  
2> grant execute on ACC_insert_bySpecies to editors
1>  
2> drop procedure ACCRef_process
1>  
2> create procedure ACCRef_process
3>   @objectKey int,
4>   @refsKey int,
5>   @accID varchar(30),
6>   @logicalDB int,
7>   @mgiType varchar(80),
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* Disallow edits to WashU data - TR 611 */
13> 
14> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
15> 	   and
16> 	  (select user_name()) not in ("mgd_dbo", "dbo")
17> begin
18> 	rollback transaction
19> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
20> 	return
21> end
22> 
23> /* Disallow edits to UniGene data - TR 983 */
24> 
25> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
26> 	   and
27> 	  (select user_name()) not in ("mgd_dbo", "dbo")
28> begin
29> 	rollback transaction
30> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
31> 	return
32> end
33> 
34> /* If the Object/Acc ID pair already exists, then use that _Accession_key */
35> /* and simply insert a new ACC_AccessionReference record (ACCRef_insert) */
36> /* Else, create a new ACC_Accession and ACC_AccessionReference record (ACC_insert) */
37> 
38> declare @accKey integer
39> select @accKey = a._Accession_key 
40> from ACC_Accession a, ACC_MGIType m
41> where accID = @accID
42> and a._Object_key = @objectKey
43> and a._MGIType_key = m._MGIType_key
44> and m.name = @mgiType
45> and a._LogicalDB_key = @logicalDB
46> 
47> begin tran
48> 
49> if @accKey is not null
50> 	exec ACCRef_insert @accKey, @refsKey
51> else
52> 	exec ACC_insert @objectKey, @accID, @logicalDB, @mgiType, @refsKey, @preferred, @private
53> 
54> /* TR 1270 - if adding a Sequence Acc ID to a Marker...
55>  *
56>  * try to update the IMAGE/Marker association
57> */
58> 
59> if @mgiType = "Marker" and @logicalDB = 9
60> begin
61> 	exec MRK_updateIMAGESeqAssoc @objectKey, @accID
62> 
63> 	if @@error != 0
64> 	begin
65> 		rollback transaction
66> 	end
67> end
68> 
69> commit tran
70> 
1>  
2> grant execute on ACCRef_process to progs
1>  
2> grant execute on ACCRef_process to editors
1>  
2> drop procedure ACC_update
1>  
2> create procedure ACC_update
3>   @accKey int,
4>   @accID varchar(30),
5>   @origRefsKey int = -1,
6>   @refsKey int = -1
7> as
8>  
9> /* Disallow edits to WashU data - TR 611 */
10> 
11> if @refsKey > 0
12>    and
13>    (
14>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
15>    or
16>    exists (select * from BIB_All_View where _Refs_key = @origRefsKey and jnum = 57656)
17>    )
18>    and
19>    (select user_name()) not in ("mgd_dbo", "dbo")
20> begin
21> 	rollback transaction
22> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
23> 	return
24> end
25> 
26> /* Disallow edits to UniGene data - TR 983 */
27> 
28> if @refsKey > 0
29>    and
30>    (
31>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
32>    or
33>    exists (select * from BIB_All_View where _Refs_key = @origRefsKey and jnum = 57747)
34>    )
35>    and
36>    (select user_name()) not in ("mgd_dbo", "dbo")
37> begin
38> 	rollback transaction
39> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
40> 	return
41> end
42> 
43> begin tran
44> 
45> declare @isMarkerSeq integer
46> select @isMarkerSeq = 0
47> 
48> if (select _MGIType_key from ACC_Accession 
49> 	where _Accession_key = @accKey) = 2
50>    and
51>    (select _LogicalDB_key from ACC_Accession 
52> 	where _Accession_key = @accKey) = 9
53> begin
54> 	select @isMarkerSeq = 1
55> end
56> 
57> declare @objectKey integer
58> declare @origAccID varchar(30)
59> 
60> select @objectKey = _Object_key from ACC_Accession where _Accession_key = @accKey
61> select @origAccID = accID from ACC_Accession where _Accession_key = @accKey
62> 
63> /* Update the Accession record for a given Accession key */
64> 
65> if @accID is null
66> begin
67> 	exec ACC_delete_byAccKey @accKey
68> end
69> else
70> begin
71> 	declare @prefixPart varchar(20)
72> 	declare @numericPart int
73> 	exec ACC_split @accID, @prefixPart out, @numericPart out
74> 						      
75> 	if (@prefixPart = "J:" or substring(@prefixPart,1,4) = "MGD-")
76> 	begin
77> 		if (select count(*) from ACC_Accession
78> 	    	    where numericPart = @numericPart and
79> 			  prefixPart = @prefixPart) >= 1
80> 		begin
81> 			rollback transaction
82> 			raiserror 99999 "Duplicate MGI Accession Number"
83> 			return
84> 		end
85> 	end
86> 
87> 	update ACC_Accession
88>   	set accID = @accID, 
89>       	prefixPart = @prefixPart, 
90>       	numericPart = @numericPart,
91>       	modification_date = getdate()
92>   	where _Accession_key = @accKey
93> 
94> 	if @refsKey > 0
95> 	begin
96> 		update ACC_AccessionReference
97> 		set _Refs_key = @refsKey
98>   		where _Accession_key = @accKey and
99> 		      _Refs_key = @origRefsKey
100> 	end
101> end
102> 
103> /* TR 1270 - if updating a Sequence Acc ID of a Marker...
104>  *
105>  * delete the old IMAGE/Marker encodes relationship
106>  *
107> */
108> 
109> if @origAccID != @accID and @isMarkerSeq = 1
110> begin
111> 	exec MRK_deleteIMAGESeqAssoc @objectKey, @origAccID
112> 
113> 	if @@error != 0
114> 	begin
115> 		rollback transaction
116> 	end
117> end
118> 
119> /* TR 1270 - if updating a Sequence Acc ID of a Marker...
120>  *
121>  * update the IMAGE/Marker association
122> */
123> 
124> if @isMarkerSeq = 1
125> begin
126> 	exec MRK_updateIMAGESeqAssoc @objectKey, @accID
127> 
128> 	if @@error != 0
129> 	begin
130> 		rollback transaction
131> 	end
132> end
133> 
134> commit tran
135> 
1>  
2> grant execute on ACC_update to progs
1>  
2> grant execute on ACC_update to editors
1>  
2> drop procedure ACC_delete_byObject
1> 
2> create procedure ACC_delete_byObject
3>   @objectKey int,
4>   @mgiType varchar(80)
5> as
6> 
7> /* Delete all accession records for a given Object */
8> 
9> delete ACC_Accession 
10> from ACC_Accession a, ACC_MGIType m
11> where a._Object_key = @objectKey 
12> and a._MGIType_key = m._MGIType_key
13> and m.name = @mgiType
14> 
15> /* May have to reset the MGI or J: Max part */
16> 
17> exec ACC_resetMax @objectKey, @mgiType
18> exec ACC_resetMax @objectKey, @mgiType, "J:"
19> 
1>  
2> grant execute on ACC_delete_byObject to progs
1>  
2> grant execute on ACC_delete_byObject to editors
1>  
2> drop procedure ACC_delete_byAccKey
1> 
2> create procedure ACC_delete_byAccKey
3>   @accKey int,
4>   @refsKey int = -1
5> as
6> 
7> /* Disallow edits to WashU data - TR 611 */
8> 
9> if @refsKey > 0
10>    and
11>    exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57656)
12>    and
13>    (select user_name()) not in ("mgd_dbo", "dbo")
14> begin
15> 	rollback transaction
16> 	raiserror 99999 "Accession ID is referenced by J:57656, WashU-HHMI Database Download.  Cannot edit."
17> 	return
18> end
19> 
20> /* Disallow edits to UniGene data - TR 983 */
21> 
22> if exists (select * from BIB_All_View where _Refs_key = @refsKey and jnum = 57747)
23> 	   and
24> 	  (select user_name()) not in ("mgd_dbo", "dbo")
25> begin
26> 	rollback transaction
27> 	raiserror 99999 "Accession ID is referenced by J:57747, UniGene Database Download.  Cannot edit."
28> 	return
29> end
30> 
31> begin tran
32> 
33> declare @isMarkerSeq integer
34> select @isMarkerSeq = 0
35> 
36> declare @deleteIMAGESeqAssoc integer
37> select @deleteIMAGESeqAssoc = 0
38> 
39> if (select _MGIType_key from ACC_Accession 
40> 	where _Accession_key = @accKey) = 2
41>    and
42>    (select _LogicalDB_key from ACC_Accession 
43> 	where _Accession_key = @accKey) = 9
44> begin
45> 	select @isMarkerSeq = 1
46> end
47> 
48> declare @objectKey integer
49> declare @accID varchar(30)
50> 
51> select @objectKey = _Object_key from ACC_Accession where _Accession_key = @accKey
52> select @accID = accID from ACC_Accession where _Accession_key = @accKey
53> 
54> if @refsKey = -1
55> begin
56> 	delete ACC_Accession where _Accession_key = @accKey
57> 	select @deleteIMAGESeqAssoc = 1
58> end
59> else
60> begin
61> 	delete ACC_AccessionReference 
62> 	where _Accession_key = @accKey
63> 	and _Refs_key = @refsKey
64> 
65> 	/* If the deletion of the detail would leave the master all alone...
66>    	   then delete the master too.
67> 	*/
68> 
69> 	if not exists (select * from ACC_AccessionReference
70>     		where _Accession_key = @accKey)
71> 	begin
72> 	    delete ACC_Accession where _Accession_key = @accKey
73> 	    select @deleteIMAGESeqAssoc = 1
74> 	end
75> end
76> 
77> /* TR 1270 - if deleting a Sequence Acc ID of a Marker...
78> *
79> * delete the old IMAGE/Marker encodes relationship
80> *
81> */
82> 
83> if @isMarkerSeq = 1 and @deleteIMAGESeqAssoc = 1
84> begin
85> 	exec MRK_deleteIMAGESeqAssoc @objectKey, @accID
86> 
87> 	if @@error != 0
88> 	begin
89> 		rollback transaction
90> 	end
91> end
92> 
93> commit tran
94> 
1>  
2> grant execute on ACC_delete_byAccKey to progs
1>  
2> grant execute on ACC_delete_byAccKey to editors
1>  
2> /* 1> declare @prefixPart varchar(20) */
3> /* 2> declare @numericPart int */
4> /* 3> exec ACC_split "MGI:12345", @prefixPart out, @numericPart out */
5> /* 4> go */
6> /* (return status = 0) */
7> /* Return parameters: */
8> /* ---- -----------  */
9> /* MGI:       12345  */
10> 
11> drop procedure ACC_split
1> 
2> create procedure ACC_split
3>   @accID varchar(20),
4>   @prefixPart varchar(20) out,
5>   @numericPart integer out
6> as
7> 
8> declare @temp varchar(20) 
9> declare @suffix varchar(20)
10> declare @acclen integer
11> declare @idx integer
12> 
13> /* Remove trailing blanks */
14> select @accID = rtrim(@accID)
15> select @acclen = char_length(@accID)
16> select @temp = reverse(@accID)
17> select @idx  = patindex("%[^0-9]%",@temp)
18> 
19> /* If @idx = 0, then no prefix */
20> 
21> if @idx = 0
22> begin
23>   select @numericPart = convert(integer, @accID)
24>   select @prefixPart = NULL
25> end
26> 
27> else
28> 
29> begin
30>   select @prefixPart = reverse(substring(@temp,@idx,@acclen-@idx+1))
31>   select @suffix = substring(@accID,
32>                              char_length(@prefixPart)+1,
33>                              @acclen - char_length(@prefixPart))
34> 
35>   if @suffix is not NULL
36>      select @numericPart = convert(integer, @suffix)
37>   else
38>      select @numericPart = NULL
39> end
40> 
1> 
2> grant execute on ACC_split to progs
1>  
2> grant execute on ACC_split to editors
1>  
2> grant execute on ACC_split to public
1>  
2> drop procedure ACC_fetch_byLogical
1>  
2> create procedure ACC_fetch_byLogical
3>   @objectKey integer,
4>   @mgiType varchar(80),
5>   @logicalDB varchar(80) = "MGI"
6> as
7>  
8> select a.accID, a.prefixPart, a.numericPart
9> from ACC_Accession a, ACC_MGIType m, ACC_LogicalDB l
10> where a._Object_key = @objectKey
11> and a._MGIType_key = m._MGIType_key
12> and m.name = @mgiType
13> and a._LogicalDB_key = l._LogicalDB_key
14> and l.name = @logicalDB
15> 
1>  
2> grant execute on ACC_fetch_byLogical to progs
1>  
2> grant execute on ACC_fetch_byLogical to public
1>  
2> checkpoint
Password: 
1> 
2> use nomen_release
1> 
2> checkpoint
1> 
2> drop trigger ACC_Accession_Insert
1> 
2> create trigger ACC_Accession_Insert
3> on ACC_Accession
4> for insert
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   declare @accID varchar(30)
10>   select @accID = accID from inserted
11> 
12>   /* For Nucleotide Sequences, check that it is valid */
13> 
14>   if (select _LogicalDB_key from inserted) = 9 and
15>      (select @accID) not like '[A-Z][0-9][0-9][0-9][0-9][0-9]' and
16>      (select @accID) not like '[A-Z][A-Z][0-9][0-9][0-9][0-9][0-9][0-9]'
17>   begin
18> 	rollback transaction
19> 	raiserror 99999 "Invalid Nucleotide Sequence Accession Number '%1!'.  Number must be single uppercase letter + 5 numbers OR 2 uppercase letters + 6 numbers.", @accID
20> 	return
21>   end
22> 
23>   /* If inserting the Sequence ID for a Marker */
24>   /* and the same ID exists for another Marker...*/
25> 
26>   if (select _LogicalDB_key from inserted) in (9) and
27>       (select _MGIType_key from inserted) = 1 and
28>       exists (select a._Accession_key
29>               from ACC_Accession a, inserted i
30>               where i.accID = a.accID and
31> 		    i._Object_key != a._Object_key and
32> 	            a._MGIType_key = 1)
33>   begin
34> 	print "The Accession ID '%1!' is associated with another Symbol.", @accID
35>   end
36> 
37>   /* For LocusLink, only allow specific users to edit Accession numbers */
38> 
39>   if (select _LogicalDB_key from inserted) in (24) and
40>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "cml", "djr", "ljm", "lmm", "sr")
41>   begin
42>         rollback transaction
43>         raiserror 99999 "You do not have permission to edit LocusLink Accession numbers."
44>         return
45>   end
46> 
47> end
48> 
49> /* If Tier3 user */
50> 
51> if (select user_name()) in ('cml', 'dbradt', 'djr', 'dph', 'hjd', 'rmb', 'sr', 'tc', 'tier3')
52> begin
53> 	/* If Status is not Pending or Reserved, cannot edit */
54> 
55> 	if (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
56> 		where i._Object_key = n._Nomen_key) != 1 and
57> 	   (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
58> 		where i._Object_key = n._Nomen_key) != 3
59> 	begin
60> 		rollback transaction
61> 		raiserror 99999 "You do not have permission to edit this record."
62> 		return
63> 	end
64> 
65> 	/* If Status is "Pending" */
66> 	/* Then User modifying record must = user who submitted record */
67> 
68> 	if (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
69> 		where i._Object_key = n._Nomen_key) = 1 and
70> 	   (select n.submittedBy from inserted i, MRK_Nomen n
71> 		where i._Object_key = n._Nomen_key) != user_name()
72> 	begin
73> 		rollback transaction
74> 		raiserror 99999 "You do not have permission to edit this record."
75> 		return
76> 	end
77> 
78> 	/* If Status is "Reserved", then any Tier 3 user can modify the record */
79> end
80> 
81> /* If Tier2 user */
82> 
83> if (select user_name()) in ('lhg', 'tier2')
84> begin
85> 	/* Status must = "Pending" */
86> 
87> 	if (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
88> 		where i._Object_key = n._Nomen_key) != 1
89> 	begin
90> 		rollback transaction
91> 		raiserror 99999 "You do not have permission to edit this record."
92> 		return
93> 	end
94> 
95> 	/* User modifying record must = user who submitted record */
96> 
97> 	if (select n.submittedBy from inserted i, MRK_Nomen n
98> 		where i._Object_key = n._Nomen_key) != user_name()
99> 	begin
100> 		rollback transaction
101> 		raiserror 99999 "You do not have permission to edit this record."
102> 		return
103> 	end
104> end
105> 
1> 
2> drop trigger ACC_Accession_Update
1> 
2> create trigger ACC_Accession_Update
3> on ACC_Accession
4> for update
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   declare @accID varchar(30)
10>   select @accID = accID from inserted
11> 
12>   /* For Nucleotide Sequences, check that it is valid */
13> 
14>   if (select _LogicalDB_key from inserted) = 9 and
15>      (select @accID) not like '[A-Z][0-9][0-9][0-9][0-9][0-9]' and
16>      (select @accID) not like '[A-Z][A-Z][0-9][0-9][0-9][0-9][0-9][0-9]'
17>   begin
18> 	rollback transaction
19> 	raiserror 99999 "Invalid Nucleotide Sequence Accession Number '%1!'.  Number must be single uppercase letter + 5 numbers OR 2 uppercase letters + 6 numbers.", @accID
20> 	return
21>   end
22> 
23>   /* If updating the Sequence ID for a Marker */
24>   /* and the same ID exists for another Marker...*/
25> 
26>   if (select _LogicalDB_key from inserted) in (9) and
27>       (select _MGIType_key from inserted) = 1 and
28>       exists (select a._Accession_key
29>               from ACC_Accession a, inserted i
30>               where i.accID = a.accID and
31> 		    i._Object_key != a._Object_key and
32> 	            a._MGIType_key = 1)
33>   begin
34> 	print "The Accession ID '%1!' is associated with another Symbol.", @accID
35>   end
36> 
37>   /* For LocusLink, only allow specific users to edit Accession numbers */
38> 
39>   if (select _LogicalDB_key from inserted) in (24) and
40>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "cml", "djr", "ljm", "lmm", "sr")
41>   begin
42>         rollback transaction
43>         raiserror 99999 "You do not have permission to edit LocusLink Accession numbers."
44>         return
45>   end
46> 
47> end
48> 
49> /* If Tier3 user */
50> 
51> if (select user_name()) in ('cml', 'dbradt', 'djr', 'dph', 'hjd', 'rmb', 'sr', 'tc', 'tier3')
52> begin
53> 	/* If Status is not Pending or Reserved, cannot edit */
54> 
55> 	if (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
56> 		where i._Object_key = n._Nomen_key) != 1 and
57> 	   (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
58> 		where i._Object_key = n._Nomen_key) != 3
59> 	begin
60> 		rollback transaction
61> 		raiserror 99999 "You do not have permission to edit this record."
62> 		return
63> 	end
64> 
65> 	/* If Status is "Pending" */
66> 	/* Then User modifying record must = user who submitted record */
67> 
68> 	if (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
69> 		where i._Object_key = n._Nomen_key) = 1 and
70> 	   (select n.submittedBy from inserted i, MRK_Nomen n
71> 		where i._Object_key = n._Nomen_key) != user_name()
72> 	begin
73> 		rollback transaction
74> 		raiserror 99999 "You do not have permission to edit this record."
75> 		return
76> 	end
77> 
78> 	/* If Status is "Reserved", then any Tier 3 user can modify the record */
79> end
80> 
81> /* If Tier2 user */
82> 
83> if (select user_name()) in ('lhg', 'tier2')
84> begin
85> 	/* Status must = "Pending" */
86> 
87> 	if (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
88> 		where i._Object_key = n._Nomen_key) != 1
89> 	begin
90> 		rollback transaction
91> 		raiserror 99999 "You do not have permission to edit this record."
92> 		return
93> 	end
94> 
95> 	/* User modifying record must = user who submitted record */
96> 
97> 	if (select n.submittedBy from inserted i, MRK_Nomen n
98> 		where i._Object_key = n._Nomen_key) != user_name()
99> 	begin
100> 		rollback transaction
101> 		raiserror 99999 "You do not have permission to edit this record."
102> 		return
103> 	end
104> end
105> 
1> 
2> drop trigger ACC_Accession_Delete
1> 
2> create trigger ACC_Accession_Delete
3> on ACC_Accession
4> for delete
5> as
6> 
7> if @@rowcount = 1
8> begin
9>   /* For LocusLink, only allow specific users to edit Accession numbers */
10> 
11>   if (select _LogicalDB_key from deleted) in (24) and
12>      (select user_name()) not in ("mgd_dbo", "dbo", "pm", "lec", "cml", "djr", "ljm", "lmm", "sr")
13>   begin
14>         rollback transaction
15>         raiserror 99999 "You do not have permission to edit LocusLink Accession numbers."
16>         return
17>   end
18> 
19> end
20> 
21> /* If Tier3 user */
22> 
23> if (select user_name()) in ('cml', 'dbradt', 'djr', 'dph', 'hjd', 'rmb', 'sr', 'tc', 'tier3')
24> begin
25> 	/* If Status is not Pending or Reserved, cannot edit */
26> 
27> 	if (select distinct n._Marker_Status_key from deleted d, MRK_Nomen n
28> 		where d._Object_key = n._Nomen_key) != 1 and
29> 	   (select distinct n._Marker_Status_key from deleted d, MRK_Nomen n
30> 		where d._Object_key = n._Nomen_key) != 3
31> 	begin
32> 		rollback transaction
33> 		raiserror 99999 "You do not have permission to edit this record."
34> 		return
35> 	end
36> 
37> 	/* If Status is "Pending" */
38> 	/* Then User modifying record must = user who submitted record */
39> 
40> 	if (select distinct n._Marker_Status_key from deleted d, MRK_Nomen n
41> 		where d._Object_key = n._Nomen_key) = 1 and
42> 	   (select n.submittedBy from deleted d, MRK_Nomen n
43> 		where d._Object_key = n._Nomen_key) != user_name()
44> 	begin
45> 		rollback transaction
46> 		raiserror 99999 "You do not have permission to edit this record."
47> 		return
48> 	end
49> 
50> 	/* If Status is "Reserved", then any Tier 3 user can modify the record */
51> end
52> 
53> /* If Tier2 user */
54> 
55> if (select user_name()) in ('lhg', 'tier2')
56> begin
57> 	/* Status must = "Pending" */
58> 
59> 	if (select distinct n._Marker_Status_key from deleted d, MRK_Nomen n
60> 		where d._Object_key = n._Nomen_key) != 1
61> 	begin
62> 		rollback transaction
63> 		raiserror 99999 "You do not have permission to edit this record."
64> 		return
65> 	end
66> 
67> 	/* User modifying record must = user who submitted record */
68> 
69> 	if (select n.submittedBy from deleted d, MRK_Nomen n
70> 		where d._Object_key = n._Nomen_key) != user_name()
71> 	begin
72> 		rollback transaction
73> 		raiserror 99999 "You do not have permission to edit this record."
74> 		return
75> 	end
76> end
77> 
78> delete ACC_AccessionReference
79> from ACC_AccessionReference a, deleted d
80> where a._Accession_key = d._Accession_key
81> 
1> 
2> drop trigger ACC_AccessionReference_Delete
1> 
2> create trigger ACC_AccessionReference_Delete
3> on ACC_AccessionReference
4> for delete
5> as
6> 
7> /* If Tier3 user */
8> 
9> if (select user_name()) in ('cml', 'dbradt', 'djr', 'dph', 'hjd', 'rmb', 'sr', 'tc', 'tier3')
10> begin
11> 	/* If Status is not Pending or Reserved, cannot edit */
12> 
13> 	if (select distinct n._Marker_Status_key from deleted d, ACC_Accession a, MRK_Nomen n
14>                 where d._Accession_key = a._Accession_key and
15> 		a._Object_key = n._Nomen_key) != 1 and
16> 	   (select distinct n._Marker_Status_key from deleted d, ACC_Accession a, MRK_Nomen n
17>                 where d._Accession_key = a._Accession_key and
18> 		a._Object_key = n._Nomen_key) != 3
19> 	begin
20> 		rollback transaction
21> 		raiserror 99999 "You do not have permission to edit this record."
22> 		return
23> 	end
24> 
25> 	/* If Status is "Pending" */
26> 	/* Then User modifying record must = user who submitted record */
27> 
28> 	if (select distinct n._Marker_Status_key from deleted d, ACC_Accession a, MRK_Nomen n
29>                 where d._Accession_key = a._Accession_key and
30> 		a._Object_key = n._Nomen_key) = 1 and
31> 	   (select n.submittedBy from deleted d, ACC_Accession a, MRK_Nomen n
32>                 where d._Accession_key = a._Accession_key and
33> 		a._Object_key = n._Nomen_key) != user_name()
34> 	begin
35> 		rollback transaction
36> 		raiserror 99999 "You do not have permission to edit this record."
37> 		return
38> 	end
39> 
40> 	/* If Status is "Reserved", then any Tier 3 user can modify the record */
41> end
42> 
43> /* If Tier2 user */
44> 
45> if (select user_name()) in ('lhg', 'tier2')
46> begin
47> 	/* Status must = "Pending" */
48> 
49> 	if (select distinct n._Marker_Status_key from deleted d, ACC_Accession a, MRK_Nomen n
50>                 where d._Accession_key = a._Accession_key and
51> 		a._Object_key = n._Nomen_key) != 1
52> 	begin
53> 		rollback transaction
54> 		raiserror 99999 "You do not have permission to edit this record."
55> 		return
56> 	end
57> 
58> 	/* User modifying record must = user who submitted record */
59> 
60> 	if (select n.submittedBy from deleted d, ACC_Accession a, MRK_Nomen n
61>                 where d._Accession_key = a._Accession_key and
62> 		a._Object_key = n._Nomen_key) != user_name()
63> 	begin
64> 		rollback transaction
65> 		raiserror 99999 "You do not have permission to edit this record."
66> 		return
67> 	end
68> end
69> 
1> 
2> checkpoint
Password: 
1> 
2> use nomen_release
1> 
2> checkpoint
1> 
2> /* Obsolete Triggers */
3> 
4> /* End Obsolete Triggers */
5> 
6> drop trigger MRK_Nomen_Insert
1> 
2> create trigger MRK_Nomen_Insert
3> on MRK_Nomen
4> for insert
5> as
6> 
7> if (select user_name()) not in ('mgd_dbo', 'dbo', 'ljm', 'lmm', 'tier4')
8> begin
9> 	if (select _Marker_Status_key from inserted) != 1
10> 	begin
11> 		rollback transaction
12> 		raiserror 99999 "You do not have permission to set the Status field to any value other than Pending."
13> 		return
14> 	end
15> end
16> 
17> if (select user_name()) not in ('mgd_dbo', 'dbo')
18> begin
19> 	if (select _Marker_Event_key from inserted) != 1
20> 	begin
21> 		rollback transaction
22> 		raiserror 99999 "You do not have permission to set the Event field to any value other than Assigned."
23> 		return
24> 	end
25> end
26> 
27> declare @key integer
28> select @key = _Nomen_key from inserted
29> exec ACC_assignMGI @key, "Nomenclature"
30> 
1> 
2> drop trigger MRK_Nomen_Update
1> 
2> create trigger MRK_Nomen_Update
3> on MRK_Nomen
4> for update
5> as
6> 
7> /* Any user (except dbo) */
8> 
9> if (select user_name()) not in ('mgd_dbo', 'dbo')
10> begin
11> 	if (select _Marker_Status_key from deleted) = 5 and
12>            (select _Marker_Status_key from inserted) != 5
13> 	begin
14> 		rollback transaction
15> 		raiserror 99999 "You cannot modify status from Broadcast."
16> 		return
17> 	end
18> 
19> 	if update(_Marker_Event_key)
20> 	begin
21> 		rollback transaction
22> 		raiserror 99999 "You do not have permission to modify the Event field."
23> 		return
24> 	end
25> 
26> 	if update(submittedBy)
27> 	begin
28> 		rollback transaction
29> 		raiserror 99999 "You do not have permission to modify the Submitted By field."
30> 		return
31> 	end
32> end
33> 
34> /* If Tier3 user */
35> 
36> if (select user_name()) in ('cml', 'dbradt', 'djr', 'dph', 'hjd', 'rmb', 'sr', 'tc', 'tier3')
37> begin
38> 	/* User modifying record must = user who submitted record */
39> 	/* unless the marker is reserved */
40> 
41> 	if (select submittedBy from deleted) != user_name() and
42> 	   (select _Marker_Status_key from deleted) != 3
43> 	begin
44> 		rollback transaction
45> 		raiserror 99999 "You do not have permission to edit this record."
46> 		return
47> 	end
48> end
49> 
50> /* If Tier2 user */
51> 
52> if (select user_name()) in ('lhg', 'tier2')
53> begin
54> 	/* User modifying record must = user who submitted record */
55> 	/* unless the marker is reserved */
56> 
57> 	if (select submittedBy from deleted) != user_name()
58> 	begin
59> 		rollback transaction
60> 		raiserror 99999 "You do not have permission to edit this record."
61> 		return
62> 	end
63> end
64> 
1> 
2> drop trigger MRK_Nomen_Delete
1> 
2> create trigger MRK_Nomen_Delete
3> on MRK_Nomen
4> for delete
5> as
6> 
7> /* Cannot delete records w/ primary reference of J:65060 (RIKEN) */
8> 
9> if exists (select 1 from deleted d, MRK_Nomen_Reference_View r
10>            where d._Nomen_key = r._Nomen_key and r.isPrimary = 1 and r.jnum = 65060)
11> begin
12> 	rollback transaction
13> 	raiserror 99999 "Nomen record is referenced by J:65060.  Cannot delete this record."
14> 	return
15> end
16> 
17> /* If Tier3 user */
18> 
19> if (select user_name()) in ('cml', 'dbradt', 'djr', 'dph', 'hjd', 'rmb', 'sr', 'tc', 'tier3')
20> begin
21> 	/* User modifying record must = user who submitted record */
22> 
23> 	if (select submittedBy from deleted) != user_name() and
24> 	   (select _Marker_Status_key from deleted) != 3
25> 	begin
26> 		rollback transaction
27> 		raiserror 99999 "You do not have permission to edit this record."
28> 		return
29> 	end
30> end
31> 
32> /* If Tier2 user */
33> 
34> if (select user_name()) in ('lhg', 'tier2')
35> begin
36> 	/* User modifying record must = user who submitted record */
37> 
38> 	if (select submittedBy from deleted) != user_name()
39> 	begin
40> 		rollback transaction
41> 		raiserror 99999 "You do not have permission to edit this record."
42> 		return
43> 	end
44> end
45> 
46> delete MRK_Nomen_GeneFamily from MRK_Nomen_GeneFamily, deleted
47> where MRK_Nomen_GeneFamily._Nomen_key = deleted._Nomen_key
48>  
49> delete MRK_Nomen_Notes from MRK_Nomen_Notes, deleted
50> where MRK_Nomen_Notes._Nomen_key = deleted._Nomen_key
51>  
52> delete MRK_Nomen_Other from MRK_Nomen_Other, deleted
53> where MRK_Nomen_Other._Nomen_key = deleted._Nomen_key
54>  
55> delete MRK_Nomen_Reference from MRK_Nomen_Reference, deleted
56> where MRK_Nomen_Reference._Nomen_key = deleted._Nomen_key
57>  
58> delete ACC_Accession
59> from ACC_Accession a, ACC_MGIType m, deleted
60> where a._Object_key = deleted._Nomen_key
61> and a._MGIType_key = m._MGIType_key
62> and m.name = "Nomenclature"
63> 
1> 
2> drop trigger MRK_Nomen_GeneFamily_IUD
1> 
2> create trigger MRK_Nomen_GeneFamily_IUD
3> on MRK_Nomen_GeneFamily
4> for insert, update, delete
5> as
6> 
7> /* If Tier3 user */
8> 
9> if (select user_name()) in ('cml', 'dbradt', 'djr', 'dph', 'hjd', 'rmb', 'sr', 'tc', 'tier3')
10> begin
11> 	if (select distinct n.submittedBy from inserted i, MRK_Nomen n
12> 		where i._Nomen_key = n._Nomen_key) != user_name() and
13>            (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
14>                 where i._Nomen_key = n._Nomen_key) != 3
15> 	begin
16> 		rollback transaction
17> 		raiserror 99999 "You do not have permission to edit this record."
18> 		return
19> 	end
20> 
21> 	if (select distinct n.submittedBy from deleted d, MRK_Nomen n
22> 		where d._Nomen_key = n._Nomen_key) != user_name() and
23>            (select distinct n._Marker_Status_key from deleted d, MRK_Nomen n
24>                 where d._Nomen_key = n._Nomen_key) != 3
25> 	begin
26> 		rollback transaction
27> 		raiserror 99999 "You do not have permission to edit this record."
28> 		return
29> 	end
30> end
31> 
32> /* If Tier2 user */
33> 
34> if (select user_name()) in ('lhg', 'tier2')
35> begin
36> 	if (select distinct n.submittedBy from inserted i, MRK_Nomen n
37> 		where i._Nomen_key = n._Nomen_key) != user_name()
38> 	begin
39> 		rollback transaction
40> 		raiserror 99999 "You do not have permission to edit this record."
41> 		return
42> 	end
43> 
44> 	if (select distinct n.submittedBy from deleted d, MRK_Nomen n
45> 		where d._Nomen_key = n._Nomen_key) != user_name()
46> 	begin
47> 		rollback transaction
48> 		raiserror 99999 "You do not have permission to edit this record."
49> 		return
50> 	end
51> end
52> 
1> 
2> drop trigger MRK_Nomen_Other_IUD
1> 
2> create trigger MRK_Nomen_Other_IUD
3> on MRK_Nomen_Other
4> for insert, update, delete
5> as
6> 
7> /* If Tier3 user */
8> 
9> if (select user_name()) in ('cml', 'dbradt', 'djr', 'dph', 'hjd', 'rmb', 'sr', 'tc', 'tier3')
10> begin
11> 	if (select distinct n.submittedBy from inserted i, MRK_Nomen n
12> 		where i._Nomen_key = n._Nomen_key) != user_name() and
13>            (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
14>                 where i._Nomen_key = n._Nomen_key) != 3
15> 	begin
16> 		rollback transaction
17> 		raiserror 99999 "You do not have permission to edit this record."
18> 		return
19> 	end
20> 
21> 	if (select distinct n.submittedBy from deleted d, MRK_Nomen n
22> 		where d._Nomen_key = n._Nomen_key) != user_name() and
23>            (select distinct n._Marker_Status_key from deleted d, MRK_Nomen n
24>                 where d._Nomen_key = n._Nomen_key) != 3
25> 	begin
26> 		rollback transaction
27> 		raiserror 99999 "You do not have permission to edit this record."
28> 		return
29> 	end
30> end
31> 
32> /* If Tier2 user */
33> 
34> if (select user_name()) in ('lhg', 'tier2')
35> begin
36> 	if (select distinct n.submittedBy from inserted i, MRK_Nomen n
37> 		where i._Nomen_key = n._Nomen_key) != user_name()
38> 	begin
39> 		rollback transaction
40> 		raiserror 99999 "You do not have permission to edit this record."
41> 		return
42> 	end
43> 
44> 	if (select distinct n.submittedBy from deleted d, MRK_Nomen n
45> 		where d._Nomen_key = n._Nomen_key) != user_name()
46> 	begin
47> 		rollback transaction
48> 		raiserror 99999 "You do not have permission to edit this record."
49> 		return
50> 	end
51> end
52> 
1> 
2> drop trigger MRK_Nomen_Reference_Insert
1> 
2> create trigger MRK_Nomen_Reference_Insert
3> on MRK_Nomen_Reference
4> for insert, update
5> as
6> 
7> /* If Tier3 user */
8> 
9> if (select user_name()) in ('cml', 'dbradt', 'djr', 'dph', 'hjd', 'rmb', 'sr', 'tc', 'tier3')
10> begin
11> 	if (select distinct n.submittedBy from inserted i, MRK_Nomen n
12> 		where i._Nomen_key = n._Nomen_key) != user_name() and
13>            (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
14>                 where i._Nomen_key = n._Nomen_key) != 3
15> 	begin
16> 		rollback transaction
17> 		raiserror 99999 "You do not have permission to edit this record."
18> 		return
19> 	end
20> 
21> 	if (select distinct n.submittedBy from deleted d, MRK_Nomen n
22> 		where d._Nomen_key = n._Nomen_key) != user_name() and
23>            (select distinct n._Marker_Status_key from deleted d, MRK_Nomen n
24>                 where d._Nomen_key = n._Nomen_key) != 3
25> 	begin
26> 		rollback transaction
27> 		raiserror 99999 "You do not have permission to edit this record."
28> 		return
29> 	end
30> end
31> 
32> /* If Tier2 user */
33> 
34> if (select user_name()) in ('lhg', 'tier2')
35> begin
36> 	if (select distinct n.submittedBy from inserted i, MRK_Nomen n
37> 		where i._Nomen_key = n._Nomen_key) != user_name()
38> 	begin
39> 		rollback transaction
40> 		raiserror 99999 "You do not have permission to edit this record."
41> 		return
42> 	end
43> 
44> 	if (select distinct n.submittedBy from deleted d, MRK_Nomen n
45> 		where d._Nomen_key = n._Nomen_key) != user_name()
46> 	begin
47> 		rollback transaction
48> 		raiserror 99999 "You do not have permission to edit this record."
49> 		return
50> 	end
51> end
52> 
53> if @@rowcount > 1
54> begin
55> 	return
56> end
57> 
58> /* Whenever a Reference is added to Nomen, make sure the Nomen database */
59> /* is selected in the BIB_Refs table */
60> 
61> declare @dbs varchar(60)
62> 
63> select @dbs = b.dbs
64> from mgd_release..BIB_Refs b, inserted i
65> where i._Refs_key = b._Refs_key
66> 
67> if (charindex("Nomen", @dbs) = 0)
68> begin
69> 	if substring(@dbs, char_length(@dbs), char_length(@dbs)) = "/"
70> 	begin
71> 		select @dbs = @dbs + "Nomen/"
72> 	end
73> 	else
74> 	begin
75> 		select @dbs = @dbs + "/Nomen/"
76> 	end
77> 
78> 	update mgd_release..BIB_Refs
79> 	set b.dbs = @dbs
80> 	from mgd_release..BIB_Refs b, inserted i
81> 	where b._Refs_key = i._Refs_key
82> end
83> 
1> 
2> drop trigger MRK_Nomen_Reference_Delete
1> 
2> create trigger MRK_Nomen_Reference_Delete
3> on MRK_Nomen_Reference
4> for delete
5> as
6> 
7> /* If Tier3 user */
8> 
9> if (select user_name()) in ('cml', 'dbradt', 'djr', 'dph', 'hjd', 'rmb', 'sr', 'tc', 'tier3')
10> begin
11> 	if (select distinct n.submittedBy from inserted i, MRK_Nomen n
12> 		where i._Nomen_key = n._Nomen_key) != user_name() and
13>            (select distinct n._Marker_Status_key from inserted i, MRK_Nomen n
14>                 where i._Nomen_key = n._Nomen_key) != 3
15> 	begin
16> 		rollback transaction
17> 		raiserror 99999 "You do not have permission to edit this record."
18> 		return
19> 	end
20> 
21> 	if (select distinct n.submittedBy from deleted d, MRK_Nomen n
22> 		where d._Nomen_key = n._Nomen_key) != user_name() and
23>            (select distinct n._Marker_Status_key from deleted d, MRK_Nomen n
24>                 where d._Nomen_key = n._Nomen_key) != 3
25> 	begin
26> 		rollback transaction
27> 		raiserror 99999 "You do not have permission to edit this record."
28> 		return
29> 	end
30> end
31> 
32> /* If Tier2 user */
33> 
34> if (select user_name()) in ('lhg', 'tier2')
35> begin
36> 	if (select distinct n.submittedBy from inserted i, MRK_Nomen n
37> 		where i._Nomen_key = n._Nomen_key) != user_name()
38> 	begin
39> 		rollback transaction
40> 		raiserror 99999 "You do not have permission to edit this record."
41> 		return
42> 	end
43> 
44> 	if (select distinct n.submittedBy from deleted d, MRK_Nomen n
45> 		where d._Nomen_key = n._Nomen_key) != user_name()
46> 	begin
47> 		rollback transaction
48> 		raiserror 99999 "You do not have permission to edit this record."
49> 		return
50> 	end
51> end
52> 
1> 
2> drop trigger MRK_Status_Delete
1> 
2> create trigger MRK_Status_Delete
3> on MRK_Status
4> for delete
5> as
6> 
7> /* Disallow deletion if Status is currently referenced elsewhere */
8> 
9> if exists (select 1 from MRK_Nomen, deleted
10>     where MRK_Nomen._Marker_Status_key = deleted._Marker_Status_key)
11> begin
12> 	rollback transaction
13> 	raiserror 99999 "Marker Status is referenced in Nomen Record(s)"
14> 	return
15> end
16> 
1> 
2> drop trigger MRK_GeneFamily_Delete
1> 
2> create trigger MRK_GeneFamily_Delete
3> on MRK_GeneFamily
4> for delete
5> as
6> 
7> /* Disallow deletion if Gene Family is currently referenced elsewhere */
8> 
9> if exists (select 1 from MRK_Nomen_GeneFamily, deleted
10>     where MRK_Nomen_GeneFamily._Marker_Family_key = deleted._Marker_Family_key)
11> begin
12> 	rollback transaction
13> 	raiserror 99999 "Gene Family is referenced in Nomen Record(s)"
14> 	return
15> end
16> 
1> 
2> checkpoint
Password: 
1> 
2> use nomen_release
1> 
2> checkpoint
1> 
2> drop view MGI_Table_Column_View
1> 
2> create view MGI_Table_Column_View
3> as 
4> select _Table_id = t._Table_id, table_name = o.name, table_description = t.description,
5> column_name = c.name, _Column_id = cc._Column_id, column_description = cc.description,
6> example = cc.example, t.creation_date, t.modification_date
7> from sysobjects o, MGI_Tables t, MGI_Columns cc, syscolumns c
8> where o.type = 'U'
9> and o.id = t._Table_id 
10> and t._Table_id = cc._Table_id
11> and cc._Column_id = c.colid
12> and c.id = o.id
1> 
2> grant select on MGI_Table_Column_View to public
1>  
2> checkpoint
Password: 
1> 
2> use nomen_release
1> 
2> checkpoint
1> 
2> /* Obsolete views */
3> 
4> /* end Obsolete views (remove during next release) */
5> 
6> drop view MRK_Nomen_View
1> 
2> create view MRK_Nomen_View
3> as
4> select n.*, s.status, e.event, r.eventReason, markerType = t.name
5> from MRK_Nomen n, MRK_Status s, mgd_release..MRK_Event e, mgd_release..MRK_EventReason r, mgd_release..MRK_Types t
6> where n._Marker_Status_key = s._Marker_Status_key
7> and n._Marker_Event_key = e._Marker_Event_key
8> and n._Marker_EventReason_key = r._Marker_EventReason_key
9> and n._Marker_Type_key = t._Marker_Type_key
1> 
2> grant select on MRK_Nomen_View to public
1> 
2> drop view MRK_Nomen_Other_View
1> 
2> create view MRK_Nomen_Other_View
3> as
4> select r.*, b.jnumID, b.jnum, b.short_citation, firstAuthor = b._primary
5> from MRK_Nomen_Other r, mgd_release..BIB_All_View b
6> where r._Refs_key = b._Refs_key
1> 
2> grant select on MRK_Nomen_Other_View to public
1>  
2> drop view MRK_Nomen_Reference_View
1> 
2> create view MRK_Nomen_Reference_View
3> as
4> select r.*, b.jnumID, b.jnum, b.short_citation, firstAuthor = b._primary, b.isReviewArticle
5> from MRK_Nomen_Reference r, mgd_release..BIB_All_View b
6> where r._Refs_key = b._Refs_key
1> 
2> grant select on MRK_Nomen_Reference_View to public
1>  
2> drop view MRK_Nomen_GeneFamily_View
1> 
2> create view MRK_Nomen_GeneFamily_View
3> as
4> select n.*, g.name
5> from MRK_Nomen_GeneFamily n, MRK_GeneFamily g
6> where n._Marker_Family_key = g._Marker_Family_key
1> 
2> grant select on MRK_Nomen_GeneFamily_View to public
1>  
2> drop view MRK_Nomen_CoordNotes_View
1> 
2> create view MRK_Nomen_CoordNotes_View
3> as
4> select * from MRK_Nomen_Notes where noteType = 'C'
1> 
2> grant all on MRK_Nomen_CoordNotes_View to ljm, lmm, tier4
1> 
2> grant all on MRK_Nomen_CoordNotes_View to progs
1> 
2> grant select on MRK_Nomen_CoordNotes_View to public
1> 
2> drop view MRK_Nomen_EditorNotes_View
1> 
2> create view MRK_Nomen_EditorNotes_View
3> as
4> select * from MRK_Nomen_Notes where noteType = 'E'
1> 
2> grant all on MRK_Nomen_EditorNotes_View to cml, dbradt, djr, dph, hjd, rmb, sr, tc, tier2, tier3, tier4
1> 
2> grant all on MRK_Nomen_EditorNotes_View to progs
1> 
2> grant select on MRK_Nomen_EditorNotes_View to public
1> 
2> drop view MRK_Nomen_AccRef_View
1>  
2> create view MRK_Nomen_AccRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name, ar._Refs_key, b.jnumID, b.jnum, b.short_citation
5> from ACC_Accession a, mgd_release..ACC_LogicalDB l, ACC_MGIType m, ACC_AccessionReference ar, mgd_release..BIB_All_View b
6> where a._MGIType_key = 1
7> and a._Accession_key = ar._Accession_key
8> and a._LogicalDB_key = l._LogicalDB_key
9> and a._MGIType_key = m._MGIType_key
10> and ar._Refs_key = b._Refs_key
1>  
2> grant select on MRK_Nomen_AccRef_View to public
1> 
2> drop view MRK_Nomen_AccNoRef_View
1>  
2> create view MRK_Nomen_AccNoRef_View
3> as
4> select a.*, LogicalDB = l.name, MGIType = m.name,
5> subType = mt.name,
6> description = ma.symbol + ", " + ma.name
7> from ACC_Accession a, mgd_release..ACC_LogicalDB l, ACC_MGIType m, MRK_Nomen ma, mgd_release..MRK_Types mt
8> where a._MGIType_key = 1
9> and a._LogicalDB_key = l._LogicalDB_key
10> and a._MGIType_key = m._MGIType_key
11> and a._Object_key = ma._Nomen_key
12> and ma._Marker_Type_key = mt._Marker_Type_key
13> and not exists (select r.* from ACC_AccessionReference r
14> where a._Accession_key = r._Accession_key)
1>  
2> grant select on MRK_Nomen_AccNoRef_View to public
1>  
2> checkpoint
Password: 
1> 
2> use nomen_release
1> 
2> checkpoint
1> 
2> drop procedure ACC_assignMGI
1> 
2> create procedure ACC_assignMGI
3>   @objectKey int,
4>   @mgiType varchar(80),
5>   @prefixPart varchar(20) = "MGI:",
6>   @nextMGI int = -1,
7>   @preferred int = 1
8> as
9> 
10> /* Assign MGI or J accession number
11>    Allow override of J accession number
12>    Increment mgd_release..ACC_AccessionMax.maxNumericPart
13> */
14> 
15> declare @nextACC int
16> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
17> 
18> declare @mgiTypeKey int
19> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
20> 
21> if @nextMGI = -1
22> begin
23> 	select @nextMGI = maxNumericPart + 1 
24> 	from mgd_release..ACC_AccessionMax where prefixPart = @prefixPart
25> end
26> else if @prefixPart != "J:"
27> begin
28>     rollback transaction
29>     raiserror 99999 "Cannot override generation of MGI accession number"
30>     return
31> end
32> 
33> declare @accID varchar(30)
34> select @accID = @prefixPart + convert(varchar(20), @nextMGI)
35> 
36> insert into ACC_Accession 
37> (_Accession_key, accID, prefixPart, numericPart, 
38> _LogicalDB_key, _Object_key, _MGIType_key, preferred)
39> values(@nextACC, @accID, @prefixPart, @nextMGI, 1, @objectKey, @mgiTypeKey, @preferred)
40> 
41> if (select maxNumericPart from mgd_release..ACC_AccessionMax
42>     where prefixPart = @prefixPart) <= @nextMGI
43> begin
44> 	update mgd_release..ACC_AccessionMax 
45> 	set maxNumericPart = @nextMGI 
46> 	where prefixPart = @prefixPart
47> end
48> 
1> 
2> grant execute on ACC_assignMGI to progs
1> 
2> grant execute on ACC_assignMGI to editors
1> 
2> /* 1> declare @prefixPart varchar(20) */
3> /* 2> declare @numericPart int */
4> /* 3> exec ACC_split "MGI:12345", @prefixPart out, @numericPart out */
5> /* 4> go */
6> /* (return status = 0) */
7> /* Return parameters: */
8> /* ---- -----------  */
9> /* MGI:       12345  */
10> 
11> drop procedure ACC_split
1> 
2> create procedure ACC_split
3>   @accID varchar(20),
4>   @prefixPart varchar(20) out,
5>   @numericPart integer out
6> as
7> 
8> declare @temp varchar(20) 
9> declare @suffix varchar(20)
10> declare @acclen integer
11> declare @idx integer
12> 
13> /* Remove trailing blanks */
14> select @accID = rtrim(@accID)
15> select @acclen = char_length(@accID)
16> select @temp = reverse(@accID)
17> select @idx  = patindex("%[^0-9]%",@temp)
18> 
19> /* If @idx = 0, then no prefix */
20> 
21> if @idx = 0
22> begin
23>   select @numericPart = convert(integer, @accID)
24>   select @prefixPart = NULL
25> end
26> 
27> else
28> 
29> begin
30>   select @prefixPart = reverse(substring(@temp,@idx,@acclen-@idx+1))
31>   select @suffix = substring(@accID,
32>                              char_length(@prefixPart)+1,
33>                              @acclen - char_length(@prefixPart))
34> 
35>   if @suffix is not NULL
36>      select @numericPart = convert(integer, @suffix)
37>   else
38>      select @numericPart = NULL
39> end
40> 
1> 
2> grant execute on ACC_split to progs
1>  
2> grant execute on ACC_split to editors
1>  
2> grant execute on ACC_split to public
1>  
2> drop procedure ACCRef_insert
1>  
2> create procedure ACCRef_insert
3>   @accKey int,
4>   @refsKey int
5> as
6>  
7> /* Insert record into ACC_AccessionReference table */
8> 
9> insert into ACC_AccessionReference
10> (_Accession_key, _Refs_key)
11> values(@accKey, @refsKey)
12> 
1>  
2> grant execute on ACCRef_insert to progs
1>  
2> grant execute on ACCRef_insert to editors
1>  
2> drop procedure ACC_insert
1>  
2> create procedure ACC_insert
3>   @objectKey int,
4>   @accID varchar(30),
5>   @logicalDB int,
6>   @mgiType varchar(80),
7>   @refsKey int = -1,
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* Insert record into master Accession table. */
13> /* If reference is given, insert record into Accession Reference table. */
14> 
15> if @accID is null
16> 	return
17> 
18> declare @nextACC int
19> select @nextACC = max(_Accession_key) + 1 from ACC_Accession
20> 
21> if @nextACC is null
22> begin
23> 	select @nextACC = 1
24> end
25> 
26> declare @mgiTypeKey int
27> select @mgiTypeKey = _MGIType_key from ACC_MGIType where name = @mgiType
28>  
29> declare @prefixPart varchar(20)
30> declare @numericPart int
31> exec ACC_split @accID, @prefixPart out, @numericPart out
32> 						      
33> insert into ACC_Accession
34> (_Accession_key, accID, prefixPart, numericPart, _LogicalDB_key, _Object_key, _MGIType_key, private, preferred)
35> values(@nextACC, @accID, @prefixPart, @numericPart, @logicalDB, @objectKey, @mgiTypeKey, @private, @preferred)
36> 
37> if @refsKey != -1
38> begin
39> 	exec ACCRef_insert @nextACC, @refsKey
40> end
41> 
1>  
2> grant execute on ACC_insert to progs
1>  
2> grant execute on ACC_insert to editors
1>  
2> drop procedure ACCRef_process
1>  
2> create procedure ACCRef_process
3>   @objectKey int,
4>   @refsKey int,
5>   @accID varchar(30),
6>   @logicalDB int,
7>   @mgiType varchar(80),
8>   @preferred int = 1,
9>   @private int = 0
10> as
11>  
12> /* If the Object/Acc ID pair already exists, then use that _Accession_key */
13> /* and simply insert a new ACC_AccessionReference record (ACCRef_insert) */
14> /* Else, create a new ACC_Accession and ACC_AccessionReference record (ACC_insert) */
15> 
16> declare @accKey integer
17> select @accKey = a._Accession_key 
18> from ACC_Accession a, ACC_MGIType m
19> where accID = @accID
20> and a._Object_key = @objectKey
21> and a._MGIType_key = m._MGIType_key
22> and m.name = @mgiType
23> and a._LogicalDB_key = @logicalDB
24> 
25> begin tran
26> 
27> if @accKey is not null
28> 	exec ACCRef_insert @accKey, @refsKey
29> else
30> 	exec ACC_insert @objectKey, @accID, @logicalDB, @mgiType, @refsKey, @preferred, @private
31> 
32> commit tran
33> 
1>  
2> grant execute on ACCRef_process to progs
1>  
2> grant execute on ACCRef_process to editors
1>  
2> drop procedure ACC_delete_byAccKey
1> 
2> create procedure ACC_delete_byAccKey
3>   @accKey int,
4>   @refsKey int = -1
5> as
6> 
7> /* Delete ACC_Accession/ACC_AccessonReference records for a given _Accession_key */
8> 
9> if @refsKey = -1
10> begin
11> 	delete ACC_Accession where _Accession_key = @accKey
12> end
13> else
14> begin
15> 
16> 	delete ACC_AccessionReference 
17> 	where _Accession_key = @accKey
18> 	and _Refs_key = @refsKey
19> 
20>         /* If the deletion of the detail would leave the master all alone...
21>            then delete the master too.
22>         */
23> 
24>         if not exists (select * from ACC_AccessionReference
25>                 where _Accession_key = @accKey)
26>         begin
27>             delete ACC_Accession where _Accession_key = @accKey
28>         end
29> end
30> 
1>  
2> grant execute on ACC_delete_byAccKey to progs
1>  
2> grant execute on ACC_delete_byAccKey to editors
1>  
2> drop procedure ACC_update
1>  
2> create procedure ACC_update
3>   @accKey int,
4>   @accID varchar(30),
5>   @origRefsKey int = -1,
6>   @refsKey int = -1
7> as
8>  
9> /* Update the Accession record for a given Accession key */
10> 
11> if @accID is null
12> begin
13> 	exec ACC_delete_byAccKey @accKey
14> end
15> else
16> begin
17> 	declare @prefixPart varchar(20)
18> 	declare @numericPart int
19> 	exec ACC_split @accID, @prefixPart out, @numericPart out
20> 						      
21> 	if (@prefixPart = "J:" or substring(@prefixPart,1,4) = "MGD-")
22> 	begin
23> 		if (select count(*) from ACC_Accession
24> 	    	    where numericPart = @numericPart and
25> 			  prefixPart = @prefixPart) >= 1
26> 		begin
27> 			rollback transaction
28> 			raiserror 99999 "Duplicate MGI Accession Number"
29> 			return
30> 		end
31> 	end
32> 
33> 	update ACC_Accession
34>   	set accID = @accID, 
35>       	prefixPart = @prefixPart, 
36>       	numericPart = @numericPart,
37>       	modification_date = getdate()
38>   	where _Accession_key = @accKey
39> 
40> 	if @refsKey > 0
41> 	begin
42> 		update ACC_AccessionReference
43> 		set _Refs_key = @refsKey
44>   		where _Accession_key = @accKey and
45> 		      _Refs_key = @origRefsKey
46> 	end
47> end
48> 
1>  
2> grant execute on ACC_update to progs
1>  
2> grant execute on ACC_update to editors
1>  
2> drop procedure ACC_delete_byObject
1> 
2> create procedure ACC_delete_byObject
3>   @objectKey int,
4>   @mgiType varchar(80)
5> as
6> 
7> /* Delete all accession records for a given Object */
8> 
9> delete ACC_Accession
10> from ACC_Accession a, ACC_MGIType m
11> where a._Object_key = @objectKey
12> and a._MGIType_key = m._MGIType_key
13> and m.name = @mgiType
14> 
1>  
2> grant execute on ACC_delete_byObject to progs
1>  
2> grant execute on ACC_delete_byObject to editors
1>  
2> checkpoint
Password: 
1> 
2> use nomen_release
1> 
2> checkpoint
1> 
2> drop procedure MGI_Table_Column_Cleanup
1> 
2> create procedure MGI_Table_Column_Cleanup
3> as
4> 
5> /*
6> This procedure synchronizes MGI_Tables and MGI_Columns with
7> sysobjects and syscolumns.
8> 
9> After a schema change, this procedure needs to be run so the obsolete
10> tables and columns are removed from MGI_Tables and MGI_Columns
11> */
12> 
13> /* Add new tables ids to MGI_Tables */
14> 
15> insert into MGI_Tables
16> select s.id, null, getdate(), getdate()
17> from sysobjects s
18> where s.type = "U"
19> and not exists (select 1 from MGI_Tables t where s.id = t._Table_id)
20> 
21> /* Add new column ids to MGI_Columns */
22> 
23> insert into MGI_Columns
24> select c.id, c.colid, null, null, getdate(), getdate()
25> from syscolumns c, MGI_Tables t
26> where c.id = t._Table_id
27> and not exists (select 1 from MGI_Columns l 
28> where t._Table_id = l._Table_id
29> and l._Column_id = c.colid)
30> 
31> /* Delete old table ids from MGI_Tables */
32> 
33> delete MGI_Tables
34> from MGI_Tables t
35> where not exists (select 1 from sysobjects s where s.id = t._Table_id)
36> 
37> /* Delete old column ids from MGI_Columns */
38> 
39> delete MGI_Columns
40> from MGI_Columns c
41> where not exists (select 1 from MGI_Tables t where t._Table_id = c._Table_id)
42> 
1> 
2> grant execute on MGI_Table_Column_Cleanup to progs
1> 
2> drop procedure GEN_rowcount
1>  
2> create procedure GEN_rowcount
3>   @table varchar(30)
4> as
5> 
6> select convert(char(10),rowcnt(MAX(doampg)))
7> from sysobjects o, sysindexes i
8> where o.name = @table
9> and o.id = i.id
1> 
2> grant execute on GEN_rowcount to public
1> 
2> checkpoint
Password: 
1> 
2> use nomen_release
1> 
2> checkpoint
1> 
2> drop procedure NOMEN_verifyMarker
1> 
2> create procedure NOMEN_verifyMarker
3>   @symbol varchar(25)
4> as
5> 
6> /* Verify if marker symbol exists in Nomen or MGD master Marker list */
7> 
8> declare @status varchar(255)
9> 
10> if exists (select 1 from mgd_release..MRK_Marker m where m.symbol = @symbol and m._Species_key = 1)
11> begin
12> 	select @status = "Symbol '" + @symbol + "' exists in MGD\n"
13> end
14> 
15> if exists (select 1 from mgd_release..MRK_Marker m where m.symbol = @symbol + "-pending" and m._Species_key = 1)
16> begin
17> 	select @status = @status + "Symbol '" + @symbol + "-pending' exists in MGD\n"
18> end
19> 
20> if exists (select 1 from MRK_Nomen where symbol = @symbol)
21> begin
22> 	select @status = @status + "Symbol '" + @symbol + "' exists in Nomen\n"
23> end
24> 
25> if @status is not null
26> begin
27> 	raiserror 99999 @status
28> end
29> 
1> 
2> grant execute on NOMEN_verifyMarker to public
1> 
2> checkpoint
Password: 
1> 
2> use nomen_release
1> 
2> checkpoint
1> 
2> drop procedure Nomen_transferToMGD
1> 
2> create procedure Nomen_transferToMGD
3> 	@nomenKey integer
4> as
5> 
6> /* Transfer one marker to MGD */
7> 
8> begin transaction
9> 
10> if (select @nomenKey) is null
11> begin
12> 	raiserror 99999 "Must supply a key for Nomen_transferToMGD."
13> 	rollback transaction
14> 	return
15> end
16> 
17> declare @symbol varchar(25)
18> select @symbol = symbol from MRK_Nomen where _Nomen_key = @nomenKey
19> 
20> /* Tier 3 users can broadcast Pending & Reserved Symbols */
21> 
22> if (select user_name()) in ('cml', 'dbradt', 'djr', 'dph', 'hjd', 'rmb', 'sr', 'tc', 'tier3') and
23>    (select _Marker_Status_key from MRK_Nomen where _Nomen_key = @nomenKey) != 1 and
24>    (select _Marker_Status_key from MRK_Nomen where _Nomen_key = @nomenKey) != 3
25> begin
26> 	raiserror 99999 "You do not have permission to Broadcast symbol %1!.", @symbol
27> 	rollback transaction
28> 	return
29> end
30> 
31> /* Tier 3 users can only broadcast Pending Symbols which belong to them */
32> 
33> if (select user_name()) in ('cml', 'dbradt', 'djr', 'dph', 'hjd', 'rmb', 'sr', 'tc', 'tier3') and
34>    (select _Marker_Status_key from MRK_Nomen where _Nomen_key = @nomenKey) = 1 and
35>    (select submittedBy from MRK_Nomen where _Nomen_key = @nomenKey) != user_name()
36> begin
37> 	raiserror 99999 "You do not have permission to Broadcast symbol %1!.", @symbol
38> 	rollback transaction
39> 	return
40> end
41> 
42> if (select _Marker_Status_key from MRK_Nomen where _Nomen_key = @nomenKey) = 5
43> begin
44> 	raiserror 99999 "Symbol %1! has already been broadcast.", @symbol
45> 	rollback transaction
46> 	return
47> end
48> 
49> if (select _Marker_Status_key from MRK_Nomen where _Nomen_key = @nomenKey) = 2
50> begin
51> 	raiserror 99999 "Symbol %1! has been deleted.", @symbol
52> 	rollback transaction
53> 	return
54> end
55> 
56> if not exists 
57> 	(select _Refs_key from MRK_Nomen_Reference 
58> 		where _Nomen_key = @nomenKey and isPrimary = 1)
59> begin
60> 	raiserror 99999 "Symbol %1! has no Primary Reference.", @symbol
61> 	rollback transaction
62> 	return
63> end
64> 
65> declare @name varchar(255)
66> declare @statusKey integer
67> declare @eventKey integer
68> declare @eventReasonKey integer
69> declare @primaryRefKey integer
70> declare @markerKey integer
71> declare @accID varchar(30)
72> declare @offset float
73> 
74> /* Create new marker record in MGD */
75> 
76> select @name = n.name,
77>        @eventKey = n._Marker_Event_key,
78>        @eventReasonKey = n._Marker_EventReason_key,
79>        @primaryRefKey = r._Refs_key,
80>        @statusKey = 1
81> from MRK_Nomen n, MRK_Nomen_Reference r
82> where n._Nomen_key = @nomenKey
83> and n._Nomen_key = r._Nomen_key
84> and r.isPrimary = 1
85> 
86> select @markerKey = max(_Marker_key) + 1 from mgd_release..MRK_Marker
87> 
88> insert into mgd_release..MRK_Marker
89> (_Marker_key, _Species_key, _Marker_Type_key, _Marker_Status_key, symbol, name, chromosome)
90> select @markerKey, 1, _Marker_Type_key, @statusKey, symbol, name, chromosome
91> from MRK_Nomen
92> where _Nomen_key = @nomenKey
93> 
94> if @@error != 0
95> begin
96> 	raiserror 99999 "Could not add symbol %1! in Nomen_transferToMGD.", @symbol
97> 	rollback transaction
98> 	return
99> end
100> 
101> /* Create Offset for new marker */
102> 
103> if (select chromosome from MRK_Nomen where _Nomen_key = @nomenKey) = "UN"
104> begin
105> 	select @offset = -999.0
106> end
107> else
108> begin
109> 	select @offset = -1.0
110> end
111> 
112> insert into mgd_release..MRK_Offset values(@markerKey, 0, @offset, getdate(), getdate())
113> 
114> if @@error != 0
115> begin
116> 	raiserror 99999 "Could not add offset for symbol %1! in Nomen_transferToMGD.", @symbol
117> 	rollback transaction
118> 	return
119> end
120> 
121> /* Create History line for new marker */
122> exec mgd_release..MRK_insertHistory @markerKey, @markerKey, @primaryRefKey, @eventKey, @eventReasonKey, @name
123> 
124> if @@error != 0
125> begin
126> 	raiserror 99999 "Could not add history for symbol %1! in Nomen_transferToMGD.", @symbol
127> 	rollback transaction
128> 	return
129> end
130> 
131> /* Create Other Names for new marker */
132> 
133> declare @otherName varchar(255)
134> declare @otherRefKey integer
135> declare @otherKey integer
136> 
137> declare otherCursor cursor for
138> select name, _Refs_key
139> from MRK_Nomen_Other
140> where _Nomen_key = @nomenKey
141> for read only
142> 
143> open otherCursor
144> 
145> fetch otherCursor into @otherName, @otherRefKey
146> 
147> while (@@sqlstatus = 0)
148> begin
149> 	select @otherKey = max(_Other_key + 1) from mgd_release..MRK_Other
150> 
151> 	insert into mgd_release..MRK_Other 
152> 	(_Other_key, _Marker_key, _Refs_key, name)
153> 	values(@otherKey, @markerKey, @otherRefKey, @otherName)
154> 
155> 	if @@error != 0
156> 	begin
157> 		raiserror 99999 "Could not add other name %1! for symbol %2! in Nomen_transferToMGD.", @otherName, @symbol
158> 		rollback transaction
159> 		return
160> 	end
161> 
162> 	fetch otherCursor into @otherName, @otherRefKey
163> end
164> 
165> close otherCursor
166> deallocate cursor otherCursor
167> 
168> /* Create Related References for new marker */
169> 
170> declare @relatedRefKey integer
171> 
172> declare refCursor cursor for
173> select _Refs_key
174> from MRK_Nomen_Reference
175> where _Nomen_key = @nomenKey
176> and isPrimary = 0
177> and broadcastToMGD = 1
178> for read only
179> 
180> open refCursor
181> 
182> fetch refCursor into @relatedRefKey
183> 
184> while (@@sqlstatus = 0)
185> begin
186> 	insert into mgd_release..MRK_Reference
187> 	(_Marker_key, _Refs_key, auto)
188> 	values(@markerKey, @relatedRefKey, 0)
189> 
190> 	if @@error != 0
191> 	begin
192> 		raiserror 99999 "Could not add related reference %1! for symbol %2! in Nomen_transferToMGD."
193> 		rollback transaction
194> 		return
195> 	end
196> 
197> 	fetch refCursor into @relatedRefKey
198> end
199> 
200> close refCursor
201> deallocate cursor refCursor
202> 
203> declare @logicalDB integer
204> declare @refsKey integer
205> declare @preferred integer
206> declare @private integer
207> 
208> /* Create non-reference Accession IDs for new marker */
209> 
210> declare acc_cursor cursor for
211> select distinct a.accID, a._LogicalDB_key, a.preferred, a.private
212> from ACC_Accession a
213> where a._Object_key = @nomenKey
214> and not exists (select 1 from ACC_AccessionReference r
215> where a._Accession_key = r._Accession_key)
216> for read only
217> 
218> open acc_cursor
219> 
220> fetch acc_cursor into @accID, @logicalDB, @preferred, @private
221> 
222> while (@@sqlstatus = 0)
223> begin
224> 	exec mgd_release..ACC_insert @markerKey, @accID, @logicalDB, 'Marker', -1, @preferred, @private
225> 
226> 	if @@error != 0
227> 	begin
228> 		raiserror 99999 "Could not add accession id %1! for symbol %2! in Nomen_transferToMGD.", @accID, @symbol
229> 		rollback transaction
230> 		return
231> 	end
232> 
233> 	fetch acc_cursor into @accID, @logicalDB, @preferred, @private
234> end
235> 
236> close acc_cursor
237> deallocate cursor acc_cursor
238> 
239> /* Create Accession IDs for new marker */
240> 
241> declare acc_cursor cursor for
242> select distinct a.accID, a._LogicalDB_key, r._Refs_key, a.preferred, a.private
243> from ACC_Accession a, ACC_AccessionReference r
244> where a._Object_key = @nomenKey
245> and a._Accession_key = r._Accession_key
246> for read only
247> 
248> open acc_cursor
249> 
250> fetch acc_cursor into @accID, @logicalDB, @refsKey, @preferred, @private
251> 
252> while (@@sqlstatus = 0)
253> begin
254> 	exec mgd_release..ACC_insert @markerKey, @accID, @logicalDB, 'Marker', @refsKey, @preferred, @private
255> 
256> 	if @@error != 0
257> 	begin
258> 		raiserror 99999 "Could not add accession id %1! for symbol %2! in Nomen_transferToMGD.", @accID, @symbol
259> 		rollback transaction
260> 		return
261> 	end
262> 
263> 	fetch acc_cursor into @accID, @logicalDB, @refsKey, @preferred, @private
264> end
265> 
266> close acc_cursor
267> deallocate cursor acc_cursor
268> 
269> /* Load MRK_Label and MRK_Reference */
270> 
271> exec mgd_release..MRK_reloadLabel @markerKey
272> exec mgd_release..MRK_reloadReference @markerKey
273> 
274> /* Update Status, Broadcast date, Broadcast User */
275> 
276> update MRK_Nomen
277> set _Marker_Status_key = 5,
278>     broadcastBy = user_name(),
279>     broadcast_date = getdate()
280> where _Nomen_key = @nomenKey
281> 
282> if @@error != 0
283> begin
284> 	raiserror 99999 "Could not update Status, Broadcast Date and Broadcast By for symbol %1! in Nomen_transferToMGD.", @symbol
285> 	rollback transaction
286> 	return
287> end
288> 
289> commit transaction
290> 
1> 
2> grant execute on Nomen_transferToMGD to cml, dbradt, djr, dph, hjd, ljm, lmm, rmb, sr, tc, tier3, tier4
1> 
2> grant execute on Nomen_transferToMGD to progs
1> 
2> drop procedure Nomen_transferAlltoMGD
1> 
2> create procedure Nomen_transferAlltoMGD
3> as
4> 
5> /* Transfer all Approved Markers to MGD */
6> 
7> begin transaction
8> 
9> declare marker_cursor cursor for
10> select _Nomen_key
11> from MRK_Nomen
12> where _Marker_Status_key = 4
13> for read only
14> 
15> declare @nomenKey integer
16> 
17> open marker_cursor
18> 
19> fetch marker_cursor into @nomenKey
20> 
21> if @@sqlstatus != 0
22> begin
23> 	raiserror 99999 "There are no records to transfer to MGD."
24> 	rollback transaction
25> 	return
26> end
27> 
28> while (@@sqlstatus = 0)
29> begin
30> 	exec Nomen_transfertoMGD @nomenKey
31> 	fetch marker_cursor into @nomenKey
32> end
33> 
34> close marker_cursor
35> deallocate cursor marker_cursor
36> 
37> commit transaction
38> 
1> 
2> grant execute on Nomen_transferAllToMGD to ljm, lmm, tier4
1> 
2> grant execute on Nomen_transferAllToMGD to progs
1> 
2> drop procedure Nomen_transferEditorRefToMGD
1> 
2> create procedure Nomen_transferEditorRefToMGD
3> 	@refsKey integer
4> as
5> 
6> /* Tier 3 - Transfer all Pending Markers which contain primary reference "@refsKey" to MGD */
7> 
8> begin transaction
9> 
10> declare marker_cursor cursor for
11> select distinct n._Nomen_key
12> from MRK_Nomen n, MRK_Nomen_Reference r
13> where n._Marker_Status_key = 1
14> and n.submittedBy = user_name()
15> and n._Nomen_key = r._Nomen_key
16> and r.isPrimary = 1
17> and r._Refs_key = @refsKey
18> for read only
19> 
20> declare @nomenKey integer
21> 
22> open marker_cursor
23> 
24> fetch marker_cursor into @nomenKey
25> 
26> if @@sqlstatus != 0
27> begin
28> 	raiserror 99999 "There are no records to transfer to MGD."
29> 	rollback transaction
30> 	return
31> end
32> 
33> while (@@sqlstatus = 0)
34> begin
35> 	exec Nomen_transfertoMGD @nomenKey
36> 	fetch marker_cursor into @nomenKey
37> end
38> 
39> close marker_cursor
40> deallocate cursor marker_cursor
41> 
42> commit transaction
43> 
1> 
2> grant execute on Nomen_transferEditorRefToMGD to cml, dbradt, djr, dph, hjd, rmb, sr, tc, tier3
1> 
2> grant execute on Nomen_transferEditorRefToMGD to progs
1> 
2> drop procedure Nomen_transferCoordRefToMGD
1> 
2> create procedure Nomen_transferCoordRefToMGD
3> 	@refsKey integer
4> as
5> 
6> /* Tier 4 - Transfer all Approved Markers which contain primary reference "@refsKey" to MGD */
7> 
8> begin transaction
9> 
10> declare marker_cursor cursor for
11> select distinct n._Nomen_key
12> from MRK_Nomen n, MRK_Nomen_Reference r
13> where n._Marker_Status_key = 4
14> and n._Nomen_key = r._Nomen_key
15> and r.isPrimary = 1
16> and r._Refs_key = @refsKey
17> for read only
18> 
19> declare @nomenKey integer
20> 
21> open marker_cursor
22> 
23> fetch marker_cursor into @nomenKey
24> 
25> if @@sqlstatus != 0
26> begin
27> 	raiserror 99999 "There are no records to transfer to MGD."
28> 	rollback transaction
29> 	return
30> end
31> 
32> while (@@sqlstatus = 0)
33> begin
34> 	exec Nomen_transfertoMGD @nomenKey
35> 	fetch marker_cursor into @nomenKey
36> end
37> 
38> close marker_cursor
39> deallocate cursor marker_cursor
40> 
41> commit transaction
42> 
1> 
2> grant execute on Nomen_transferCoordRefToMGD to ljm, lmm, tier4
1> 
2> grant execute on Nomen_transferCoordRefToMGD to progs
1> 
2> checkpoint
Password: 
1> 
2> use strains_release
1> 
2> checkpoint
1> 
2> drop trigger MLP_Strain_Delete
1> 
2> create trigger MLP_Strain_Delete
3> on MLP_Strain
4> for delete
5> as
6> 
7> delete mgd_release..PRB_Strain from mgd_release..PRB_Strain, deleted
8> where mgd_release..PRB_Strain._Strain_key = deleted._Strain_key
9> 
10> delete MLP_Notes from MLP_Notes, deleted
11> where MLP_Notes._Strain_key = deleted._Strain_key
12> 
13> delete MLP_StrainTypes from MLP_StrainTypes, deleted
14> where MLP_StrainTypes._Strain_key = deleted._Strain_key
15> 
16> delete mgd_release..ACC_Accession 
17> from mgd_release..ACC_Accession a, mgd_release..ACC_MGIType m, deleted
18> where a._Object_key = deleted._Strain_key
19> and a._MGIType_key = m._MGIType_key
20> and m.name = "Strain"
21> 
1> 
2> drop trigger MLP_StrainType_Delete
1> 
2> create trigger MLP_StrainType_Delete
3> on MLP_StrainType
4> for delete
5> as
6> 
7> /* Disallow deletion if Strain Type is referenced elsewhere */
8> 
9> if exists (select * from MLP_StrainTypes, deleted
10>          where MLP_StrainTypes._StrainType_key = deleted._StrainType_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Strain Type is referenced in Strain Record(s)"
14> 	return
15> end
16>  
1> 
2> drop trigger MLP_Species_Delete
1> 
2> create trigger MLP_Species_Delete
3> on MLP_Species
4> for delete
5> as
6> 
7> /* Disallow deletion if Species is referenced elsewhere */
8> 
9> if exists (select * from MLP_Strain, deleted
10>          where MLP_Strain._Species_key = deleted._Species_key)
11> begin
12>         rollback transaction
13>         raiserror 99999 "Species is referenced in Strain Record(s)"
14> 	return
15> end
16>  
1> 
2> checkpoint
Password: 
1> 
2> use strains_release
1> 
2> checkpoint
1> 
2> drop view MLP_Strain_View
1> 
2> create view MLP_Strain_View
3> as
4> select s.*, sp.species, p.strain, p.standard, p.needsReview
5> from MLP_Strain s, MLP_Species sp, mgd_release..PRB_Strain p
6> where s._Species_key = sp._Species_key
7> and s._Strain_key = p._Strain_key
1> 
2> grant select on MLP_Strain_View to public
1> 
2> drop view MLP_StrainTypes_View
1> 
2> create view MLP_StrainTypes_View
3> as
4> select s.*, st.strainType
5> from MLP_StrainTypes s, MLP_StrainType st
6> where s._StrainType_key = st._StrainType_key
1> 
2> grant select on MLP_StrainTypes_View to public
1> 
2> checkpoint
Password: 
1> 
2> use strains_release
1> 
2> checkpoint
1> 
2> drop procedure GEN_rowcount
1>  
2> create procedure GEN_rowcount
3>   @table varchar(30)
4> as
5> 
6> select convert(char(10),rowcnt(MAX(doampg)))
7> from sysobjects o, sysindexes i
8> where o.name = @table
9> and o.id = i.id
1> 
2> grant execute on GEN_rowcount to public
1> 
2> checkpoint
Password: 
1> 
2> use strains_release
1> 
2> checkpoint
1> 
2> drop procedure MLP_mergeStrain
1>  
2> create procedure MLP_mergeStrain
3>   @oldStrainKey int,
4>   @newStrainKey int
5> as
6> 
7> /*
8>  * Update old Strain key to new Strain key
9>  * in all relevant tables which contain a Strain key.
10>  * When finished, remove the Strain record for the old
11>  * Strain key.
12> */
13> 
14> if (select count(*) from mgd_release..PRB_Allele_Strain where _Strain_key in (@oldStrainKey, @newStrainkey)
15>     group by _Allele_key having count(*) > 1) > 0
16> begin
17> 	declare @alleleKey integer
18> 	declare @probe varchar(255)
19> 	declare @jnum varchar(100)
20> 
21> 	declare allele_cursor cursor for
22> 	select distinct _Allele_key
23> 	from mgd_release..PRB_Allele_Strain
24> 	where _Strain_key in (@oldStrainKey, @newStrainkey)
25>         group by _Allele_key having count(*) > 1
26> 	for read only
27>  
28> 	open allele_cursor
29>  
30> 	fetch allele_cursor into @alleleKey
31>  
32> 	while (@@sqlstatus = 0)
33> 	begin
34> 		select @probe = p.name, @jnum = b.accID
35> 		from mgd_release..PRB_Allele a, mgd_release..PRB_RFLV v, mgd_release..PRB_Reference  r, mgd_release..PRB_Probe p, mgd_release..BIB_Acc_View b
36> 		where a._Allele_key = @alleleKey and
37> 		      a._RFLV_key = v._RFLV_key and
38> 		      v._Reference_key = r._Reference_key and
39> 		      r._Probe_key = p._Probe_key and
40> 		      r._Refs_key = b._Object_key and
41> 		      b.prefixPart = 'J:'
42> 
43> 		rollback transaction
44> 		raiserror 99999 "This merge would create a duplicate entry for Probe '%1!', %2!", @probe, @jnum
45> 		return
46> 	end
47>  
48> 	close allele_cursor
49>  
50> 	deallocate cursor allele_cursor
51> 
52> end
53> 
54> /* all Strains must have same symbols */
55> 
56> if exists (select m1.* from mgd_release..PRB_Strain_Marker m1
57>            where m1._Strain_key = @newStrainKey
58> 	   and not exists
59> 	   (select m2.* from mgd_release..PRB_Strain_Marker m2
60> 	    where m2._Strain_key = @oldStrainKey and
61> 	    m2._Marker_key = m1._Marker_key))
62> begin
63> 	rollback transaction
64> 	raiserror 99999 "Old and New Strains must have the same Marker Symbols"
65> 	return
66> end
67> 
68> if exists (select m1.* from mgd_release..PRB_Strain_Marker m1
69>            where m1._Strain_key = @oldStrainKey
70> 	   and not exists
71> 	   (select m2.* from mgd_release..PRB_Strain_Marker m2
72> 	    where m2._Strain_key = @newStrainKey and
73> 	    m2._Marker_key = m1._Marker_key))
74> begin
75> 	rollback transaction
76> 	raiserror 99999 "Old and New Strains must have the same Marker Symbols"
77> 	return
78> end
79> 
80> /* both Strains must have the same Strain Types */
81> 
82> if exists (select m1.* from MLP_StrainTypes m1
83>            where m1._Strain_key = @newStrainKey
84> 	   and not exists
85> 	   (select m2.* from MLP_StrainTypes m2
86> 	    where m2._Strain_key = @oldStrainKey and
87> 	    m2._StrainType_key = m1._StrainType_key))
88> begin
89> 	rollback transaction
90> 	raiserror 99999 "Old and New Strains must have the same Strain Types"
91> 	return
92> end
93> 
94> if exists (select m1.* from MLP_StrainTypes m1
95>            where m1._Strain_key = @oldStrainKey
96> 	   and not exists
97> 	   (select m2.* from MLP_StrainTypes m2
98> 	    where m2._Strain_key = @newStrainKey and
99> 	    m2._StrainType_key = m1._StrainType_key))
100> begin
101> 	rollback transaction
102> 	raiserror 99999 "Old and New Strains must have the same Strain Types"
103> 	return
104> end
105> 
106> /* both Strains must have the same Species value */
107> 
108> if (select _Species_key from MLP_Strain where _Strain_key = @newStrainKey) !=
109>    (select _Species_key from MLP_Strain where _Strain_key = @oldStrainKey)
110> begin
111> 	rollback transaction
112> 	raiserror 99999 "Old and New Strains must have the same Species"
113> 	return
114> end
115> 
116> /* both Strains must have the same Needs Review value */
117> 
118> if (select needsReview from mgd_release..PRB_Strain where _Strain_key = @newStrainKey) !=
119>    (select needsReview from mgd_release..PRB_Strain where _Strain_key = @oldStrainKey)
120> begin
121> 	rollback transaction
122> 	raiserror 99999 "Old and New Strains must have the same Needs Review value"
123> 	return
124> end
125> 
126> /* JAX Registry - must be equal OR use the one that exists */
127> 
128> declare @jaxRegistryNew varchar(30)
129> declare @jaxRegistryOld varchar(30)
130> 
131> select @jaxRegistryNew = NULL
132> select @jaxRegistryOld = NULL
133> 
134> if exists (select accID from mgd_release..ACC_Accession
135>            where _Object_key = @newStrainKey and _LogicalDB_Key = 22 and _MGIType_key = 10)
136> begin
137> 	select @jaxRegistryNew = accID from mgd_release..ACC_Accession
138> 	where _Object_key = @newStrainKey and _LogicalDB_Key = 22 and _MGIType_key = 10
139> end
140> 
141> if exists (select _Accession_key from mgd_release..ACC_Accession
142>            where _Object_key = @oldStrainKey and _LogicalDB_Key = 22 and _MGIType_key = 10)
143> begin
144> 	select @jaxRegistryOld = accID from mgd_release..ACC_Accession
145> 	where _Object_key = @oldStrainKey and _LogicalDB_Key = 22 and _MGIType_key = 10
146> end
147> 
148> if (@jaxRegistryNew != NULL and @jaxRegistryOld != NULL and
149>     @jaxRegistryNew != @jaxRegistryOld)
150> begin
151> 	rollback transaction
152> 	raiserror 99999 "Old and New Strains must have the same JAX Registry Number"
153> 	return
154> end
155> else if (@jaxRegistryOld != NULL)
156> begin
157>     select @jaxRegistryNew = @jaxRegistryOld
158> end
159> 
160> update mgd_release..ACC_Accession
161> set _Object_key = @newStrainKey
162> where accID = @jaxRegistryNew
163> and _LogicalDB_Key = 22
164> and _MGIType_key = 10
165> 
166> update mgd_release..ALL_Allele
167> set _Strain_key = @newStrainKey
168> where _Strain_key = @oldStrainKey
169> 
170> update mgd_release..PRB_Source
171> set _Strain_key = @newStrainKey
172> where _Strain_key = @oldStrainKey
173> 
174> update mgd_release..PRB_Allele_Strain
175> set _Strain_key = @newStrainKey
176> where _Strain_key = @oldStrainKey
177> 
178> update mgd_release..MLD_FISH
179> set _Strain_key = @newStrainKey
180> where _Strain_key = @oldStrainKey
181> 
182> update mgd_release..MLD_InSitu
183> set _Strain_key = @newStrainKey
184> where _Strain_key = @oldStrainKey
185> 
186> update mgd_release..CRS_Cross
187> set _femaleStrain_key = @newStrainKey
188> where _femaleStrain_key = @oldStrainKey
189> 
190> update mgd_release..CRS_Cross
191> set _maleStrain_key = @newStrainKey
192> where _maleStrain_key = @oldStrainKey
193> 
194> update mgd_release..CRS_Cross
195> set _StrainHO_key = @newStrainKey
196> where _StrainHO_key = @oldStrainKey
197> 
198> update mgd_release..CRS_Cross
199> set _StrainHT_key = @newStrainKey
200> where _StrainHT_key = @oldStrainKey
201> 
202> update mgd_release..GXD_Genotype
203> set _Strain_key = @newStrainKey
204> where _Strain_key = @oldStrainKey
205> 
206> update mgd_release..PRB_Strain_Marker
207> set _Strain_key = @newStrainKey
208> where _Strain_key = @oldStrainKey
209> 
210> update MLP_StrainTypes
211> set _Strain_key = @newStrainKey
212> where _Strain_key = @oldStrainKey
213> 
214> /* Delete trigger will delete records from PRB_Strain */
215> 
216> delete from MLP_Strain
217> where _Strain_key = @oldStrainKey
218> 
1> 
2> grant execute on MLP_mergeStrain to editors
1>  
2> grant execute on MLP_mergeStrain to progs
1>  
2> drop procedure MLP_mergeStandardStrain
1>  
2> create procedure MLP_mergeStandardStrain
3>   @strain varchar(255),
4>   @fromStandard int = 0,
5>   @toStandard int = 1
6> as
7>  
8> /* Given a Strain, merge all of the records into one Strain.
9>  *
10>  * Merge all Non-Standard Strains into the Standard Strain (default)
11>  * (exec PRB_mergeStandardStrain "Strain")
12>  *
13>  * OR
14>  *
15>  * Merge all Standard Strains into the Non-Standard Strain
16>  * (exec PRB_mergeStandardStrain "Strain", 1, 0)
17>  *
18> */
19> 
20> declare @newStrainKey integer
21> declare @oldStrainKey integer
22> 
23> if (select count(_Strain_key) from mgd_release..PRB_Strain
24>     where strain = @strain and standard = @toStandard) > 1
25> begin
26> 	rollback transaction
27> 	raiserror 99999 "More than one designation exists for Strain: %1!", @strain
28> 	return
29> end
30> 
31> if (select count(_Strain_key) from mgd_release..PRB_Strain
32>     where strain = @strain and standard = @toStandard) = 0
33> begin
34> 	rollback transaction
35> 	raiserror 99999 "No correct designation exists for Strain: %1!", @strain
36> 	return
37> end
38> 
39> select @newStrainKey = _Strain_key from mgd_release..PRB_Strain
40> where strain = @strain and standard = @toStandard
41> 
42> declare strain_cursor cursor for
43> select _Strain_key
44> from mgd_release..PRB_Strain
45> where strain = @strain and standard = @fromStandard
46> for read only
47>  
48> open strain_cursor
49>  
50> fetch strain_cursor into @oldStrainKey
51>  
52> while (@@sqlstatus = 0)
53> begin
54> 	exec MLP_mergeStrain @oldStrainKey, @newStrainKey
55>         fetch strain_cursor into @oldStrainKey
56> end
57>  
58> close strain_cursor
59>  
60> deallocate cursor strain_cursor
61>  
1> 
2> grant execute on MLP_mergeStandardStrain to editors
1>  
2> grant execute on MLP_mergeStandardStrain to progs
1>  
2> checkpoint
Data Migration...
LocusLink Load...
RIKEN Load...
SWISS-PROT Load...
Update MGI DB Info...
Wed Feb  7 08:53:50 EST 2001
